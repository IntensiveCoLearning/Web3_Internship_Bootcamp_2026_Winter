---
timezone: UTC+8
---

# Kevin Jiang

**GitHub ID:** doctorzero666

**Telegram:** @ZE_Monster

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
# **ERC-7962 笔记：**

## **0\. 一句话总结**

ERC-7962 的核心是：**把“资产归属”从 address 改成 keyHash（公钥哈希）**，并通过 **EIP-712 签名** 来授权转账，因此可以做到：

-   **更难把资产和某个地址绑定（隐私更强）**
    
-   **任何人都能代你发交易/付 gas（relayer sponsor）**，但无法盗用资产（没有你的签名就不能动）
    

* * *

## **1\. 为什么需要 ERC-7962**

传统 ERC-20 / ERC-721：资产归属是 address -> balance/owner

地址公开 ⇒ 交易行为与资产很容易被追踪关联。

ERC-7962：资产归属是 keyHash(bytes32) -> balance/owner

链上只看到 keyHash 的流转，不直接看到 owner address。

* * *

## **2\. 核心名词**

### **Key（公钥）**

-   用户持有一把 secp256k1 的 **未压缩公钥 key（65 bytes，以 0x04 开头）**
    
-   这把 key 对应的私钥在用户手里（签名用）
    

### **keyHash（链上身份）**

-   keyHash = keccak256(key)（bytes32）
    
-   合约用 keyHash 作为“账户标识”来存余额/NFT owner
    

### **signature（授权凭证）**

-   使用 **EIP-712 结构化签名**对“转账意图”签名
    
-   合约验证签名 ⇒ 确认你确实掌握该 key 的私钥
    

### **nonce + deadline（防重放）**

-   每笔签名包含 nonce（一次性）和 deadline（过期时间）
    
-   防止别人复制你旧签名重复花钱
    

* * *

## **3\. ERC-7962 两套接口（20 + 721）**

### **A) ERC-KeyHash721（NFT）**

-   ownerOf(tokenId) -> bytes32 keyHash
    
-   transfer(tokenId, toKeyHash, key, signature, deadline)
    
    -   用 key+signature 证明你是当前 owner（ownerKeyHash）
        
    -   把 token 转给 toKeyHash
        

### **B) ERC-KeyHash20（同质化 Token）**

它的转账像“UTXO 找零”：

-   transfer(fromKeyHash, toKeyHash, amount, key, signature, deadline, leftKeyHash)
    

含义：

-   fromKeyHash：你现在余额所在的 keyHash（旧身份）
    
-   toKeyHash：收款方 keyHash
    
-   leftKeyHash：你的“找零” keyHash（建议每次换新，提高隐私）
    
-   执行效果（概念上）：
    
    -   balance\[fromKeyHash\] 被“花掉”
        
    -   balance\[toKeyHash\] += amount
        
    -   balance\[leftKeyHash\] += (原余额 - amount)
        
    -   并且规范鼓励 leftKeyHash 不等于 from/to（鼓励换身份）
        

* * *

## **4\. 使用方式总流程（用户视角）**

> 你可以把它当成：
> 
> **“链上账户不是地址，而是 keyHash；地址只用来付 gas”**

### **Step 1：生成 key & keyHash**

-   用户本地生成一对密钥（私钥/公钥 key）
    
-   计算 keyHash = keccak256(key)
    
-   这个 keyHash 就是“你的链上身份”（类似地址，但不会直接暴露 address）
    

### **Step 2：收款（最简单）**

别人要给你转账/转 NFT：

-   你只需要把 **keyHash** 给对方
    
-   对方在合约里把资产转到你的 keyHash
    

### **Step 3：付款（需要签名）**

你要转出资产：

-   你构造“转账意图”数据（包含 toKeyHash、amount、leftKeyHash、nonce、deadline 等）
    
-   用私钥对这份结构化数据做 EIP-712 签名
    
-   把 key + signature 给 relayer 或自己广播
    

### **Step 4：relayer 代发（可选但常见）**

-   relayer 用**自己的地址**发起链上交易并付 gas
    
-   合约只看签名，不在乎交易是谁发的
    
-   relayer 不能盗币，因为没有你私钥就伪造不了 signature
    

* * *

## **5\. 开发/产品落地：需要实现的组件**

### **(1) 智能合约（ERC-7962 Token / NFT）**

合约需实现：

-   balanceOf(keyHash) / ownerOf(tokenId) -> keyHash
    
-   nonces\[keyHash\] 管理
    
-   transfer(...)：
    
    -   验证 keccak256(key) == fromKeyHash / ownerKeyHash
        
    -   验证 signature（EIP-712）
        
    -   检查 deadline 未过期
        
    -   校验 nonce 并自增
        
    -   更新余额/owner
        

### **(2) 前端/钱包侧：Key 管理 + 签名**

你要做：

-   生成/保存 key（建议支持导出/恢复）
    
-   支持“轮换 keyHash”（每次找零生成新 keyHash）
    
-   EIP-712 签名弹窗（让用户确认：给谁、多少、找零去哪里、手续费策略等）
    

### **(3) Relayer 服务（强烈建议配套）**

作用：

-   帮用户付 gas、批量提交交易、优化 UX
    
-   可做商业模式：收手续费/订阅/项目方补贴
    

安全要点：

-   relayer 只负责广播交易，不接触用户私钥
    
-   需要防滥用（rate limit / 黑名单 / 支付策略）
    

* * *

## **6\. 一个完整示例（KeyHash20）**

假设：

-   你现在 100 Token 在 fromKeyHash = H(keyA)
    
-   你要给朋友 30 Token，朋友 keyHash 是 toKeyHash = H(keyB)
    
-   你想把剩下 70 换到新身份 leftKeyHash = H(keyA2)
    

你做的事：

1.  本地构造 Transfer 数据：toKeyHash=H(keyB), amount=30, leftKeyHash=H(keyA2), nonce, deadline
    
2.  用 keyA 的私钥签名 ⇒ 得到 signature
    
3.  把 {keyA, signature} 给 relayer
    
4.  relayer 发交易上链
    
5.  合约验证通过后：
    
    -   balance\[H(keyB)\] += 30
        
    -   balance\[H(keyA2)\] += 70
        
    -   balance\[H(keyA)\] = 0
        

链上观察者看到的是 keyHash 的流转，不直接看到你的 address。

* * *

## **7\. 常见坑 & 注意事项（很重要）**

### **兼容性**

-   生态默认认 address（DEX、钱包、工具）
    
-   ERC-7962 用 keyHash ⇒ 通常需要：
    
    -   **包装器/适配器合约**
        
    -   或 dApp 自己一套 UI/查询逻辑
        

### **Gas 成本**

-   每次转账都要验签（ECDSA + EIP-712）⇒ 比传统 transfer 贵
    

### **不支持 approve（设计选择）**

-   规范倾向：每次签名授权，配合 keyHash 轮换减少关联
    
-   所以 DeFi “授权+拉取”范式很难直接复用
    

### **密钥管理风险**

-   你不再只管理一个地址，而是管理 key（甚至一堆轮换 key）
    
-   建议策略：
    
    -   用 HD 派生管理（类似钱包派生路径）
        
    -   做好备份/恢复机制
        

* * *

## **8\. 它适合什么场景**

-   **Gas 代付 onboarding**：新用户无需 ETH 就能用 dApp
    
-   **隐私要求高的转账/NFT**：减少地址关联
    
-   **批量交易/赞助型产品**：项目方补贴 gas，用户只签名
    

不太适合：

-   强依赖 ERC-20 approve/allowance 的老 DeFi 生态（除非做适配层）
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->

# **一句话先把 Gas 优化讲清**

> Gas 优化 = 用更少的计算 + 更少的存储修改，完成同一件事

在以太坊里要记住一句**生存法则**：

> 算不值钱，存才值钱

-   💸 **最贵的是：改链上存储（storage）**
    
-   😐 中等贵：写 event / log
    
-   😎 便宜：算数学、if 判断、for 循环（相对而言）
    

* * *

# **为什么 Gas 会贵？**

### **以太坊不是“你的电脑”**

-   每个操作都要 **全网所有节点重复执行**
    
-   每个 storage 写入：
    
    -   要写磁盘
        
    -   要进状态树
        
    -   要改变 stateRoot
        

所以系统必须：

> 对“消耗全网资源的行为”收钱

* * *

# **Gas 优化的 5 个底层直觉**

## **1️⃣ 少改 storage（最重要）**

> storage 一改，gas 直接起飞

### **❌ 坏例子**

```
count = count + 1;
```

如果 count 是 storage 变量 → 贵

### **✅ 好思路**

-   能放内存（memory）就别放 storage
    
-   能一次性写，就别写多次
    

* * *

## **2️⃣ 用 memory / calldata，别乱用 storage**

```
function foo(uint[] calldata arr) external {
    // calldata 只读，最便宜
}
```

**价格直觉**：

```
calldata < memory <<< storage
```

* * *

## **3️⃣ 少 for 循环 + 少在循环里改 storage**

### **❌ 非常贵的写法**

```
for (uint i = 0; i < users.length; i++) {
    balances[users[i]] += 1;
}
```

👉 每次循环都在写 storage

### **✅ 优化思路**

-   批量处理
    
-   用事件代替状态
    
-   把计算挪到链下
    

* * *

## **4️⃣ 能用事件（event）就别存状态**

**事件是写日志，不进状态树**

### **❌**

```
mapping(address => uint) public lastAction;
lastAction[msg.sender] = block.timestamp;
```

### **✅**

```
event Action(address user, uint time);
emit Action(msg.sender, block.timestamp);
```

👉 如果只是“给前端/索引器看”，**event 几乎永远更省 gas**

* * *

## **5️⃣ 避免重复读 storage（读一次存起来）**

### **❌**

```
if (user.balance > 0) {
    user.balance -= 1;
}
if (user.balance == 0) {
    ...
}
```

### **✅**

```
uint bal = user.balance;
if (bal > 0) {
    bal -= 1;
}
if (bal == 0) {
    ...
}
user.balance = bal;
```

* * *

# **真实案例 1：投票合约**

### **❌ 未优化版本**

```
mapping(address => bool) public voted;

function vote() external {
    require(!voted[msg.sender]);
    voted[msg.sender] = true;
}
```

👉 每个用户一次 storage 写

### **✅ 优化思路（Bitmap）**

```
mapping(uint256 => uint256) bitmap;

function vote(uint id) external {
    uint bucket = id / 256;
    uint offset = id % 256;
    bitmap[bucket] |= (1 << offset);
}
```

👉 **256 个布尔值 = 1 次 storage**

* * *

# **真实案例 2：空投 / 批量转账**

### **❌ on-chain 批量空投**

```
for (...) {
    token.transfer(user, amount);
}
```

👉 gas 爆炸，可能直接 out of gas

### **✅ 优化方案**

-   **Merkle Airdrop**
    
    -   链下算好 Merkle Tree
        
    -   链上只存 root
        
    -   用户自己 claim + proof
        

👉 Uniswap、Optimism、Arbitrum 都用这套

# **Gas 优化和之前学的「状态树」的关系**

记住这条：

> 每一次 storage 写 = 状态树的一次“叶子变更”

-   写得越多
    
-   状态树改得越多
    
-   gas 越贵
    

所以 gas 优化的本质就是：

> 少动状态树

# **Solidity 合约漏洞速查地图（Checklist 版）**

> 核心心法：
> 
> **攻击者不会“破坏规则”，只会利用你写的规则漏洞，让合约按对他有利的方式执行。**

* * *

## **1) 访问控制（Access Control）**

**典型问题**

-   关键函数缺少 onlyOwner / onlyRole
    
-   权限边界不清：谁能 mint / pause / upgrade / setParams
    
-   使用 tx.origin 做身份校验（会被钓鱼合约绕过）
    

**你怎么查**

-   列出所有 external/public 且会改状态的函数
    
    → 每个函数问一句：**“谁应该有权调用？”**
    
    → 检查是否有正确的权限修饰/校验
    

* * *

## **2) 重入（Reentrancy）**

**典型问题**

-   在状态还没更新前做外部调用（特别是 call{value:...} 或 token 转账）
    
-   外部合约收到钱/收到 token 时回调你，再次进入敏感函数
    

**你怎么查**

-   找所有外部调用（ETH 转账 / 合约调用 / token 调用）
    
-   检查是否满足：**Checks → Effects → Interactions**
    
-   对敏感函数加 nonReentrant
    

* * *

## **3) 数学/精度/单位错误（Math / Precision / Units）**

**典型问题**

-   整数除法精度丢失导致被薅羊毛
    
-   单位混用（wei/ether、decimals）
    
-   比例计算顺序不当（先除后乘 vs 先乘后除）
    

**你怎么查**

-   扫所有“价格/利率/兑换/份额/清算/手续费”公式
    
-   检查边界输入：0、1、最大值、极小值
    

* * *

## **4) 可预测性与可操纵输入（Randomness / Timestamp / Block vars）**

**典型问题**

-   用 block.timestamp、blockhash 做随机数
    
-   关键逻辑依赖时间戳（可被验证者小幅操纵）
    
-   依赖区块相关变量进行分配/结算
    

**你怎么查**

-   找所有使用 block 变量的地方
    
    → 判断是否影响“分钱、开奖、清算、结算、胜负”
    

* * *

## **5) 抢跑/夹子（MEV / Front-running）**

**典型问题**

-   用户先提交敏感操作，别人插队获利（swap、拍卖、mint）
    
-   滑点、deadline 设置不当导致被夹子
    

**你怎么查**

-   判断交易是否会暴露“可套利信息”
    
-   是否有滑点/期限/commit-reveal 等保护机制
    

* * *

## **6) 外部调用返回值/兼容性（Return Values / Token quirks）**

**典型问题**

-   call 没检查 success
    
-   ERC20 调用没用 SafeERC20，遇到不标准 token 可能 silent fail
    

**你怎么查**

-   所有外部调用必须明确处理返回值
    
-   ERC20 全部使用 SafeERC20
    

* * *

## **7) DoS 与 Gas 陷阱（Denial of Service / Unbounded loops）**

**典型问题**

-   遍历用户数组、遍历存款人列表：用户多了函数永远跑不完
    
-   循环里给多人转账，某个地址 revert 让全体失败
    

**你怎么查**

-   找所有 for 循环：上界是否可被用户放大？
    
-   分发场景改为 **pull 提现**（用户自己领）
    

* * *

## **8) 升级合约/代理（Upgradeable / Proxy pitfalls）**

**典型问题**

-   初始化函数忘记 initializer（可被重新初始化）
    
-   升级权限不严（可被接管）
    
-   storage layout 冲突导致状态错乱
    

**你怎么查**

-   是否使用标准代理模式（如 EIP-1967 / UUPS）
    
-   初始化是否只能执行一次
    
-   升级权限是否严格受控、是否可暂停/紧急处理
    

* * *

# **外部调用检查重点（Audit Checklist）**

> 外部调用 =
> 
> **你把执行权交给外部世界**

## **A) 顺序是否正确（最重要）**

-   ✅ **先改账（Effects）再外部调用（Interactions）**
    
-   ❌ 先外部调用再改账（重入高危）
    

* * *

## **B) 目标地址是否可信？**

把这些都当成“不可信”：

-   msg.sender（可能是合约）
    
-   用户传入的 to
    
-   可由管理员修改的地址（可能被替换）
    
-   任意 token 地址（可能不标准甚至恶意）
    

* * *

## **C) 是否检查了返回值/失败处理？**

-   ETH 转账用 call 必须检查 ok
    
-   ERC20 调用必须用 SafeERC20（避免不标准 token 问题）
    

* * *

## **D) 外部调用失败会不会导致 DoS？**

-   循环里付款：一个失败 → 全部失败（DoS）
    
-   建议：
    
    -   分发改为 **pull**（用户自己 withdraw/claim）
        
    -   或者记录失败项，分批处理
        

* * *

## **E) 是否使用了**

## **delegatecall**

## **（超级红灯）**

-   delegatecall = “借别人的代码，改我自己的存储”
    
-   检查：
    
    -   目标地址是否可控/可替换？
        
    -   是否有严格权限？
        
    -   是否为标准代理实现？
        

* * *

## **F) 是否可能触发回调钩子（隐藏重入）**

-   token/协议可能带 hooks（例如 ERC777）
    
-   即使是 token.transfer 也当作外部调用处理
    
    → 关键函数加 nonReentrant + 正确顺序
    

* * *

# **重入保护（Reentrancy Guard）要点**

## **核心作用**

-   给敏感函数加“门栓”：函数没执行完，不允许再次进入
    
-   常用：OpenZeppelin nonReentrant
    

## **记忆点**

-   **顺序（CEI）是第一道防线**
    
-   **nonReentrant 是第二道保险**
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->


# **DApp 开发流程笔记（从 0 到 1）**

## **1）先想清楚：DApp 由哪三块组成？**

**一句话：DApp = 前端 + 智能合约 + 链上/链下配套服务。**

-   **前端（UI）**：网页/APP，负责展示、按钮、表单
    
-   **合约（Solidity）**：核心业务规则（转账、mint、swap、权限、状态存储）
    
-   **配套服务（可选）**：
    
    -   索引：The Graph / 自己监听事件入库
        
    -   存储：IPFS / Arweave / 云存储
        
    -   后端：登录、风控、业务计算、缓存等（不是必须，但很多项目会有）
        

* * *

## **2）设计阶段：先画清楚“链上做什么、链下做什么”**

### **2.1 业务拆分（最关键）**

-   哪些必须上链？（需要可信执行/不可篡改/公开可验证的）
    
-   哪些放链下更合适？（成本高、频繁读写、隐私、复杂计算）
    

### **2.2 合约数据结构（storage 设计）**

-   你要存什么状态？（mapping、struct、数组）
    
-   谁能改？谁能读？
    
-   会不会需要升级（proxy）？或者先不做升级，简单起步
    

### **2.3 交互流程（用户路径）**

-   用户打开页面 → 连接钱包 → 读数据（免费）→ 写交易（付 gas）→ 等确认 → 刷新状态/展示结果
    

* * *

## **3）写合约：Solidity 开发的标准步骤**

### **3.1 写合约逻辑（核心功能）**

-   状态变量（storage）
    
-   方法：
    
    -   **view/pure**：读数据（不花 gas）
        
    -   **non-payable/payable**：写状态（要交易）
        
-   权限控制（onlyOwner / roles）
    
-   事件（event）：前端和索引用来“追踪发生了什么”
    

### **3.2 本地测试（必须做）**

-   用 Foundry / Hardhat 写单元测试
    
-   常测点：
    
    -   正常流程（happy path）
        
    -   权限错误
        
    -   边界值
        
    -   revert 是否正确
        
    -   事件是否正确发出
        

### **3.3 安全检查（最少要做这些）**

-   重入（reentrancy）
    
-   权限与可升级权力风险
    
-   外部调用顺序（CEI：先检查→改状态→再交互）
    
-   依赖预言机/外部价格要谨慎
    
-   用 OpenZeppelin 的成熟库
    

* * *

## **4）部署流程：从本地到测试网到主网**

### **4.1 本地链（开发期）**

-   Anvil / Hardhat node 跑本地链
    
-   快速迭代，随便重置
    

### **4.2 测试网（验证期）**

-   Sepolia 等
    
-   领水龙头测试币
    
-   验证：
    
    -   gas 成本是否合理
        
    -   交易确认时间
        
    -   前端交互是否稳定
        

### **4.3 主网/生产网（上线）**

-   确认环境变量、权限、多签、紧急开关
    
-   部署后做：
    
    -   合约源码验证（Etherscan verify）
        
    -   保存：合约地址、ABI、部署参数、版本号
        

* * *

## **5）前端对接：从“能连钱包”到“能写交易”**

### **5.1 连接钱包**

-   MetaMask / WalletConnect
    
-   获取：
    
    -   用户地址 address
        
    -   chainId（你在哪条链）
        
    -   provider / signer
        

### **5.2 读链（免费）**

-   调用合约的 view 函数
    
-   常见做法：页面加载 + 定时刷新 + 监听事件更新 UI
    

### **5.3 写链（付费交易）**

-   调用合约的写函数：需要 signer
    
-   前端要处理 4 个状态：
    
    1.  用户签名确认
        
    2.  交易发送成功（拿到 txHash）
        
    3.  等待区块确认（txReceipt）
        
    4.  成功/失败提示 + 刷新数据
        

### **5.4 处理“用户常见问题”**

-   切错网络、余额不足、gas 太贵、交易 pending 太久
    
-   错误信息要翻译成人话提示用户
    

* * *

## **6）链上数据展示：事件（Events）+ 索引（Indexing）**

为什么需要事件？

-   合约 storage 适合存“当前状态”，但不适合做“历史列表/行为记录”
    
-   事件是天然的“日志”
    

常见方案：

-   简单 DApp：直接用前端去拉事件（范围小还能撑）
    
-   正经产品：用 The Graph / 自建监听服务把事件写入数据库，再做查询/API
    

* * *

## **7）文件/资源存储：别把大文件直接塞链上**

-   链上存大内容很贵
    
-   常见做法：
    
    -   文件放 IPFS/Arweave/云
        
    -   链上只存 hash 或 URI（指向文件地址）
        

NFT 就是典型例子：链上是 ownership + tokenId + metadataURI

* * *

## **8）上线前的 Checklist**

-   合约测试覆盖足够（关键路径都有测）
    
-   权限/管理员地址清楚（最好多签）
    
-   是否需要暂停功能（紧急止损）
    
-   合约地址、ABI、版本、部署参数已备份
    
-   前端能处理失败/拒签/pending
    
-   事件日志完整，方便追踪
    
-   最少跑一次“从连接钱包到完成交易”的全流程演练
    

* * *

## **9）一句话总结**

DApp 开发的本质是：**用 Solidity 在链上写规则（状态机），用前端让用户签名触发交易，用事件/索引把链上行为变成可读的产品体验。**
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->



# **Uniswap V2 & V3 知识点总览**

## **0\. 一句话理解**

-   **Uniswap V2**：每个币对一个池子，流动性铺满全价格区间，靠 **恒定乘积** x·y=k 自动定价。
    
-   **Uniswap V3**：在 V2 基础上加入 **集中流动性（按价格区间做市）** + **多费率池** + **LP 仓位 NFT**，资本效率更高但管理更复杂。
    

* * *

# **Part A. Uniswap V2**

## **A1. V2 的核心概念**

-   **AMM（自动做市商）**：不用订单簿，不靠挂单撮合；用池子储备自动给价格。
    
-   **Pool/Pair（交易对池子）**：每个 token pair 对应一个 Pair 合约，池子里有两种 token 的储备 reserve0/reserve1。
    
-   **LP（Liquidity Provider）**：往池子放两种币作为库存，给交易者兑换，赚手续费；拿到 LP token 表示份额。
    

* * *

## **A2. 定价机制：恒定乘积公式**

-   不变量：
    
    $$ x \\cdot y = k $$
    
-   直觉：
    
    -   你用 token1 买 token0：token1 储备↑，token0 储备↓，为了保持乘积不变，token0 的边际价格会越来越贵 → **滑点**。
        
-   “现价”直觉（近似）：
    
    $$ price \\approx \\frac{y}{x} $$
    
    （储备比例决定价格）
    

* * *

## **A3. Swap（换币）如何计算（含手续费）**

-   V2 典型交易费 **0.30%**（进入池子，归 LP）。
    
-   常用输出公式（实际工程中最常见）：
    
    $$ amountOut = \\frac{amountIn \\cdot 997 \\cdot reserveOut}{reserveIn \\cdot 1000 + amountIn \\cdot 997} $$
    
-   关键现象：
    
    -   **滑点**：单笔越大、池子越小 → 价格影响越大
        
    -   **价格影响（Price Impact）**：你自己把池子比例推走导致成交价变差
        

* * *

## **A4. LP：加/撤流动性与 LP Token**

### **加流动性（Mint）**

-   第一次建池：LP 存入两种币，确定初始价格。
    
-   后续加池：必须按当前池子比例存入，否则会导致价格被改变；多余一侧可能被退回/浪费。
    
-   得到 **LP token**：代表你占池子的份额。
    

### **撤流动性（Burn）**

-   退回 LP token，按份额取回两种币：
    
    $$ amount0 = share \\cdot reserve0,\\quad amount1 = share \\cdot reserve1 $$
    

### **LP 收益来源**

-   交易手续费留在池子里 → 池子总储备变多 → 你按份额拿走增量
    
-   长期看（含手续费）**k 会慢慢变大**（因为手续费进入储备）
    

* * *

## **A5. 套利（Arbitrage）在 V2 的作用**

-   Uniswap 不会“主动跟着外部市场价走”，它只按储备给价。
    
-   外部市场价变化后，套利者会在 Uniswap 和外部市场之间搬砖，把池子价格推回接近市场价。
    
-   所以你看到的“价格合理”，很大程度是套利在维护。
    

* * *

## **A6. 无常损失（Impermanent Loss, IL）**

-   IL 本质：作为 LP，你的资产比例会被套利者/市场价格变化被动改变，可能跑输“单纯持币 HODL”。
    
-   直觉：
    
    -   价格涨：池子 ETH 被买走 → 你 ETH 变少、稳定币变多（被动卖出上涨资产）
        
    -   价格跌：池子 ETH 变多 → 你 ETH 变多、稳定币变少（被动买入下跌资产）
        
-   是否亏：看 **手续费收入能否覆盖 IL**。
    

* * *

## **A7. 关键组件（V2 架构）**

-   **Factory**：创建/查找 Pair（币对池地址），并保证 token 排序规则。
    
-   **Pair**：核心合约（储备、swap、mint、burn、不变量检查、累积价格）。
    
-   **Router**：用户常用入口（多跳路径、ETH/WETH 处理、amountOutMin 防滑点等）。
    

* * *

## **A8. V2 预言机：TWAP（时间加权平均价）**

-   Pair 维护 **价格累积值**（cumulative price）。
    
-   通过“两次读取累积值 + 时间差”计算一段时间的平均价（TWAP），比瞬时价更抗操纵（但非万能）。
    

* * *

## **A9. V2 的 Flash Swap（闪电交换）**

-   允许你先拿到 tokenOut，在回调里完成套利/补款，最终只要满足不变量检查即可。
    
-   类似闪电贷思路，但资金来源是池子本身。
    

* * *

# **Part B. Uniswap V3**

## **B1. V3 的三大升级**

1.  **集中流动性（Concentrated Liquidity）**：LP 可以选择价格区间提供流动性，而不是全区间。
    
2.  **多费率池（Multiple fee tiers）**：同一币对可以有 0.05% / 0.3% / 1% 等不同池子。
    
3.  **LP 仓位 NFT（Positions as NFTs）**：每个 LP 的区间不同、参数不同，份额不再同质化，因此用 NFT 表示一个仓位。
    

* * *

## **B2. 集中流动性：工作原理（直觉版）**

-   LP 选择区间 \[P\_{low}, P\_{high}\]，只在这个区间“营业”：
    
    -   **价格在区间内**：仓位是双边资产（两种币都有）并赚手续费
        
    -   **价格出区间**：仓位会逐渐变成单边（只剩一种币），且**不再赚手续费**，直到价格回到区间或你调整区间
        
-   资本效率提升：
    
    -   把资金集中到“最常交易的价格附近” → 更深流动性 → 更小滑点 → LP 更可能赚到更多有效手续费
        

* * *

## **B3. Tick（刻度）与价格移动**

-   V3 把价格轴离散化为很多 **ticks**。
    
-   池子里存在“当前激活的流动性 L”：
    
    -   只有覆盖当前价格的那些 LP 仓位才算 active
        
-   交易会推动价格在 tick 间移动：
    
    -   跨过某些 tick 时，会进入/退出一些 LP 区间边界 → active 流动性 L 变化 → 价格影响（滑点）也跟着改变
        
-   直觉：V3 更像“分段的深度墙”，不是一条光滑曲线。
    

* * *

## **B4. V3 的手续费分配**

-   **只有在你的区间内成交的交易**，你才按 active liquidity 占比拿手续费。
    
-   区间越窄：
    
    -   ✅ 在区间内的资本效率更高（同样资金赚手续费更强）
        
    -   ❌ 更容易出区间（停赚）且风险更集中（更像策略）
        

* * *

## **B5. V3 的风险与 IL（更“策略化”）**

-   V3 仍然有无常损失，并且区间越窄风险越集中。
    
-   出区间后的资产形态：
    
    -   价格涨出上界：仓位趋向 **全稳定币**（相当于一路上涨中不断卖出风险资产）
        
    -   价格跌破下界：仓位趋向 **全风险资产**（相当于一路下跌中不断买入风险资产）
        
-   所以 V3 LP 更像“主动做市/区间挂单策略”，需要管理与再平衡。
    

* * *

## **B6. 多费率池：为什么要这样设计**

-   不同币对波动不同：
    
    -   稳定币对：波动小、交易多 → 适合更低费率（更吸引交易者）
        
    -   波动大币对：LP 承担更大风险 → 需要更高费率补偿
        
-   路由器/聚合器会在不同费率池间寻找综合成本最优路径（费率 + 滑点）。
    

* * *

## **B7. V3 的组件（架构层面）**

-   **Factory**：创建不同 fee tier 的池子
    
-   **Pool**：核心（tick、active liquidity、swap、手续费累积、价格状态）
    
-   **NonfungiblePositionManager**：管理 LP 仓位 NFT（mint/increase/decrease/collect）
    
-   **SwapRouter**：路由与多跳
    
-   **Quoter**：用于估算 swap 输出（一般用于前端/离线查询）
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->




# **以太坊的交易树（Transaction Trie）和收据树（Receipt Trie）**

> 一句总览

-   状态树：**世界现在长什么样**
    
-   交易树：**这个区块里都发生了哪些交易**
    
-   收据树：**这些交易各自执行得怎么样**
    

* * *

## **一、三棵树的分工（先建立全局感）**

| 树 | 存什么 | 回答的问题 |
| --- | --- | --- |
| State Trie | 账户 / 合约状态 | “现在余额/状态是多少？” |
| Transaction Trie | 区块内交易列表 | “这笔交易在不在这个区块里？” |
| Receipt Trie | 交易执行结果 | “这笔交易执行得怎么样？产生了哪些日志？” |

⚠️ **三棵树都是 Merkle Patricia Trie（MPT）**

⚠️ **每个区块都有自己的一套 Transaction Trie + Receipt Trie**

* * *

## **二、交易树（Transaction Trie）**

### **1️⃣ 交易树是什么？**

> 交易树 = “本区块中所有交易的 Merkle Trie”

-   Key：交易在区块中的 **index（0,1,2,3…）**
    
-   Value：**交易本身（from、to、value、data、nonce、gas…）**
    

📌 注意：

交易树 **只关心“交易内容”**，

**不关心交易执行成功还是失败**

* * *

### **2️⃣ 区块里怎么用到交易树？**

在区块头（block header）中有一个字段：

```
transactionsRoot
```

它是：

-   对该区块所有交易
    
-   构建 Transaction Trie
    
-   得到的 **根哈希**
    

👉 这个 root =

**“我承诺：本区块里包含的交易列表就是这些”**

* * *

### **3️⃣ 交易树解决什么问题？**

### **✅ 证明「某笔交易在某个区块中」**

-   给你：
    
    -   区块头里的 transactionsRoot
        
    -   这笔交易的 Merkle proof
        
-   你可以验证：
    
    > “这笔交易确实属于这个区块”
    

📌 这在 **轻节点（light client）**、跨链验证里非常重要。

* * *

## **三、收据树（Receipt Trie）**

### **1️⃣ 收据树是什么？**

> 收据树 = “每笔交易执行结果的 Merkle Trie”

一笔交易执行完后，会生成一个 **receipt（收据）**，里面包括：

-   status：成功（1）/ 失败（0）
    
-   gasUsed
    
-   logs：事件日志（events）
    
-   logsBloom：Bloom Filter（日志索引用）
    

📌 **receipt 是“结果”，不是交易本身**

* * *

### **2️⃣ 收据树的 key 是什么？**

-   Key：交易在区块中的 **index**
    
-   Value：该交易的 **receipt**
    

👉 和交易树 **一一对应**

👉 第 i 笔交易 ↔ 第 i 个 receipt

* * *

### **3️⃣ 区块头里对应哪个字段？**

```
receiptsRoot
```

👉 表示：

> “我承诺：这些交易执行后的结果就是这样”

* * *

## **四、交易树 vs 收据树（最容易混的点）**

| 维度 | 交易树 | 收据树 |
| --- | --- | --- |
| 存的是 | 交易内容 | 执行结果 |
| 是否包含 logs | ❌ 不包含 | ✅ 包含 |
| 是否反映成功/失败 | ❌ 不反映 | ✅ 有 status |
| 是否影响状态树 | ❌ 不直接 | ✅ 间接（通过执行结果） |

⚠️ **状态变化 ≠ 收据内容**

状态变化体现在 **State Trie**

收据只是“执行报告”

* * *

## **五、三棵树在一次交易中的完整流程（超级重要）**

### **一笔交易发生时：**

1.  交易被打包进区块
    
    → 写入 **Transaction Trie**
    
2.  EVM 执行交易
    
    → 改变账户/合约状态
    
    → 更新 **State Trie**
    
3.  生成执行结果
    
    → 写入 **Receipt Trie**
    
4.  区块头写入三个 root：
    

```
stateRoot
transactionsRoot
receiptsRoot
```

👉 **一个区块 = 三个“承诺指纹”**

* * *

## **六、它们和 Rollup 的关系（结合你前面的问题）**

### **Rollup 在 L1 上依赖什么？**

-   **L1 状态树**：
    
    承诺 Rollup 合约中存储的 L2 root
    
-   **Receipt Trie**：
    
    -   Rollup 提交 batch 时产生事件（logs）
        
    -   索引器 / 前端靠 receipt + logs 监听状态更新
        
-   **Transaction Trie**：
    
    -   用来证明“某个 batch 提交交易确实在 L1 区块中”
        

📌 **Rollup 的状态正确性 ≠ 由交易树或收据树保证**

它们是 **“可证明存在 + 可索引”** 的基础设施。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->





# **Ethereum 状态树（State Trie）学习笔记**

## **1\. 状态树是什么**

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/doctorzero666/images/2026-01-19-1768824261071-image.png)

-   以太坊维护的是“全世界当前状态”（账户余额、nonce、合约代码、合约变量等），而不是像比特币那样只维护 UTXO。
    
-   _状态树（State Trie）_\*用来记录全体账户（EOA/合约账户）的当前状态。
    
-   技术结构：**Merkle Patricia Trie（MPT）**
    
    -   Trie：按 key（地址）组织数据
        
    -   Merkle：用哈希把整棵树“承诺”（commit），可验证
        

* * *

## **2\. 状态树里每个账户存什么**

状态树叶子节点对应一个账户（EOA 或 Contract）：

-   nonce：交易计数/合约创建计数
    
-   balance：ETH 余额
    
-   storageRoot：合约存储（变量）的根（合约才用）
    
-   codeHash：合约代码哈希（合约才用）
    

> 关键点：EOA/合约账户本质上都是状态树中的“叶子”。差异只是合约账户额外关联 code 和 storage。

* * *

## **3\. 出新区块时：状态树是“全量承诺”，但“只改动局部”**

### **区块里到底记录什么？**

-   区块头只写一个核心值：**stateRoot（状态树根哈希）**
    
-   **不会把全量状态塞进区块里**；全量状态由节点在本地数据库维护。
    

### **更新是怎么发生的？**

-   本区块交易只会影响少量账户/合约变量 → 只更新这些对应的叶子（及相关路径）。
    
-   但因为是 Merkle 结构：
    
    改动叶子 → 叶子 hash 变 → 沿路径向上重算 → 最终 root 变。
    
-   树的实现支持**结构共享（persistent / copy-on-write）**：
    
    -   看起来“生成了新树（新 root）”
        
    -   实际上大量没动的分支直接复用旧节点
        
    -   只复制/更新“变动叶子到根的那条路径”附近的节点
        

> 类比 Git：改一个文件不会复制整个仓库，只产生新的 commit（root）并复用大部分对象。

* * *

## **4\. 以太坊不止一棵树（3棵核心 Trie）**

-   **State Trie（状态树）**：全体账户/合约状态（世界当前长啥样）
    
-   **Transaction Trie**：本区块交易列表（证明某交易在该区块中）
    
-   **Receipt Trie**：交易回执/日志（事件 logs、执行结果）
    

> 我们讨论的“状态树”特指 State Trie。

* * *

## **5\. 为什么状态树重要**

-   **可验证性**：给定区块头的 stateRoot + 某账户的 proof，可以验证该账户状态属于该 root（轻节点/跨链/提款证明的基础）。
    
-   **确定性共识**：同样起始状态 + 同样交易顺序 → 必然得到同一个 stateRoot，便于全网达成一致。
    
-   **支撑智能合约状态**：合约变量由 storage（也有根 hash）管理，最终都锚定到 stateRoot。
    

* * *

# **Rollup 与状态树的关系**

## **6\. Rollup 的“roll-up”不是靠 L1 状态树“只记叶子”**

Rollup 的扩容核心：

-   **把大量交易放在 L2 执行（计算外包）**
    
-   L1 只需要保存“让它能信”的最小信息：
    
    -   **L2 state root（或相关承诺）**
        
    
    -   数据（Optimistic）或证明（ZK）
        

## **7\. Optimistic vs ZK：L1 怎么信 L2**

### **Optimistic Rollup**

-   L2 执行一批交易，算出新的 L2Root\_new
    
-   提交到 L1 合约：交易数据（通常 calldata）+ L2Root\_new
    
-   默认相信没错，但留 **challenge window**
    
    有人可提交 **fraud proof** 指出某步计算错误
    

### **ZK Rollup**

-   L2 执行交易得到 L2Root\_new
    
-   生成 zk proof：证明从 old root 按规则执行后得到 new root
    
-   L1 验证 proof 很快，通过就更新合约里记录的 root
    

> 核心点：L1 不会自己重算 L2 全部交易；L1 只验证“数据+挑战机制”或“零知识证明”。

## **8\. L1 状态树在 Rollup 里扮演的角色**

-   L1 合约把 latestL2Root 写进自己的 storage
    
    → L1 的 stateRoot 间接承诺了“当前认可的 L2 root 是多少”
    
-   用户提款时通常需要 proof：证明“提款请求/余额变化属于某个 L2 root”
    
    → 合约用记录的 L2 root 来校验 proof
    

* * *

# **回溯（reorg / rollback）怎么处理**

## **9\. L1 链回溯（reorg）时：状态树如何回到过去**

发生 reorg 时：

1.  找到两条分叉的共同祖先块（common ancestor）
    
2.  以祖先块的 stateRoot 为起点
    
3.  重新执行新分叉上的区块序列
    
4.  得到新的 head 和新的 stateRoot
    

> 本质不是“倒着撤销交易”，而是“换一条历史重新算”。

## **10\. Rollup 遇到 L1 reorg：会发生什么**

-   Rollup 提交 batch/更新 L2 root 本质是一次 L1 交易（写入合约 storage、产生事件）。
    
-   若该 L1 区块被 reorg 掉：
    
    -   这次“提交”就像没发生过（事件消失、合约状态回滚）
        
    -   sequencer/relayer 会重新提交（或重新组织 batch 再提交）
        
-   用户侧表现：
    
    -   UI 可能短暂显示不一致（索引器要跟随主链）
        
    -   提款/跨链消息可能延迟
        
    -   所以系统会强调等待 **N 个 L1 confirmations**
        

## **11\. 历史状态查询与节点类型**

-   **Archive Node**：保留完整历史状态，能直接查任意高度的账户/合约状态
    
-   **Full Node（常见）**：可能会 prune 老状态，查久远历史可能需要重建或依赖索引服务
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






# **今日记录：在 OpenSea 铸造并上架第一个 NFT（Base / ERC1155）**

## **目标**

-   用最低成本跑通 NFT 从 0 到 1 的完整流程：
    
    **创建 Collection → 创建 NFT → 铸造（mint）→ 上架（list）→ 钱包可见**
    

* * *

## **环境与工具**

-   平台：OpenSea
    
-   钱包：MetaMask
    
-   链：Base（最终选择）
    
-   标准：ERC1155
    
-   NFT 类型：图片 NFT
    

* * *

## **实际流程回顾（按时间顺序）**

### **1）创建 Collection（相当于创建“文件夹”）**

-   在 OpenSea 进入创建页面，看到提示：需要先创建/部署 Collection Contract
    
-   填写了：
    
    -   **Name**（系列名）
        
    -   **Token Symbol**（系列简称，类似股票代码/代号）
        
    -   选择链（最开始误选/默认在 Ethereum，后来考虑低成本）
        

✅ 结果：Collection 创建成功，但当时 **ITEMS=0**（还没有任何具体 NFT）

* * *

### **2）遇到的问题：无法继续制作 NFT（Polygon 网络费警告）**

-   MetaMask 弹窗显示：
    
    -   Network：Polygon
        
    -   Method：Create Clone（创建/克隆 ERC1155 合约）
        
    -   Network fee 红色提示，余额显示 **0 POL**
        
-   结论：这是链上交易，需要 gas；钱包里没有 Polygon 的 gas（POL/MATIC），导致无法执行。
    

✅ 解决思路：

-   低成本跑通流程，不用主网 → 改用 Base 或 Polygon
    
-   我主网有 ETH，但不能直接付 Polygon/Base 的 gas（需要把资产转到对应链）
    

* * *

### **3）链选择策略：从 Polygon 转到 Base**

-   目标是更省 gas、更快跑通
    
-   最终选择 **Base 链** 来铸造与上架
    

* * *

### **4）创建具体 NFT（从“文件夹”变成“文件”）**

-   在 Collection 里点击 **Create / Add item**
    
-   上传图片 + 填写基础信息（Name/Description 等）
    
-   创建成功后进入 NFT 单品页，看到关键字段：
    
    -   **Owned by You**
        
    -   **ERC1155 · BASE · Token #1**
        
    -   可以点击 **List for sale**
        

✅ 结果：证明 NFT 已经创建/铸造成功（至少 OpenSea 已识别为我持有）

* * *

### **5）上架出售（List for sale）**

-   选择 Fixed price（一口价）
    
-   设置价格：**0.01 ETH**
    
-   上架成功后页面显示：
    
    -   Listed 0.01 ETH
        
    -   可 Edit listing
        

✅ 结果：完成“铸造 → 上架”的完整闭环

* * *

### **6）钱包里看不到 NFT 的问题（最终解决）**

现象：OpenSea 显示我拥有 NFT，但 MetaMask NFT 列表里一开始看不到。

原因（高概率）：

-   Base 链 + ERC1155 在钱包里可能不会自动索引/展示，需要手动导入或等待。
    

解决：

-   在 MetaMask 的 NFT 页面使用 **Import NFT**
    
-   输入：
    
    -   Contract Address（合约地址）
        
    -   Token ID（#1）
        
-   导入后成功在钱包里看到 NFT ✅
    

* * *

## **今日关键收获（Lessons Learned）**

1.  **Collection ≠ NFT**：
    
    先创建的是系列/文件夹，只有 Add item 才是真正创建具体 NFT。
    
2.  **切网络不等于跨链**：
    
    主网 ETH 不能直接付 Polygon/Base 的 gas，需要把资产转到对应链。
    
3.  **Gas Token 很关键**：
    
    Polygon 需要 POL/MATIC，Base 需要 Base 链上的 ETH。
    
4.  **钱包不显示不代表没铸造**：
    
    OpenSea 显示 Owned by You 基本可信；钱包可能需要 Import NFT 才能看到。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->







# **Uniswap v4 学习笔记（基于官方 Contracts v4 Overview）**

## **1）Uniswap v4 一句话总结**

**v4 = 在 v3 的“集中流动性”基础上，把 AMM 变成“可插拔的模块系统（Hooks）”，并通过“单例合约 + 闪电记账”把 gas 成本打下来。**

* * *

## **2）v4 的核心目标是什么？**

可以把 v4 的目标记成 3 句话：

1.  **更灵活**：把“池子的行为”开放给开发者自定义（Hooks）。
    
2.  **更省 gas**：用 singleton（单例）架构 + flash accounting（闪电记账）减少中间转账与合约部署成本。
    
3.  **更像基础设施**：让第三方可以在“swap/加减流动性/建池”等生命周期节点插入逻辑，做出新的交易/做市玩法。
    

* * *

## **3）v4 三大关键创新**

### **A. Hooks（钩子）：把 AMM 变成“可编程的插件系统”**

**大白话**：v4 允许你在交易流程的关键节点“插一段自己的 Solidity 逻辑”，比如 swap 前/后、加流动性前/后、建池时等。Hooks 是独立部署的合约，由 v4 的 PoolManager 以一种“任何人都能触发执行”的方式去调用。

Hooks 能做什么（官方举的典型用例）：

-   限价单（Limit Orders）
    
-   自定义预言机（Custom Oracles）
    
-   自定义费率管理（Fee Management）
    
-   自动化做市/流动性管理（Automated Liquidity Management）
    

> 记忆法：
> 
> **v3 是“固定功能的交易池”**
> 
> **v4 是“带插件位的交易池”**

* * *

### **B. Dynamic Fees（动态手续费）：费率可以“随时调”**

**大白话**：v4 支持“动态费率池”，手续费可以上调/下调，而且 **协议不强行规定你怎么计算费率**——你可以用自己的策略（甚至每次 swap 都更新费率）。更新频率也可以自由设定（每次 swap / 每个区块 / 每周等）。

它打开的空间：

-   费率优化（不同波动/流动性情况不同费率）
    
-   价值再分配（比如把费用策略和激励结合）
    
-   更多研究/新机制设计
    

* * *

### **C. Singleton Design（单例架构）：所有池子都由一个合约管理**

**大白话**：v3 每个池子都是一个独立合约；v4 把所有池子的状态和操作集中到一个合约里（PoolManager.sol），这样：

-   **建池更便宜**：建池不再是“部署新合约”，而更像“在 PoolManager 里写一条状态”。
    
-   **多跳交换更省**：多跳不需要在每一步都把 token 真的转来转去。
    

* * *

## **4）Flash Accounting（闪电记账）：为什么能省 gas？**

**大白话**：在 v4 里，你可以先在 PoolManager 里做一串“会改变余额的操作”（比如多次 swap、多次加减流动性），**中间过程先记账**，最后一步才把需要的 token 转账结算。

对比 v3：

-   v3：每一步操作往往都要你自己处理 token 的转入转出（成本更高、流程更碎）。
    
-   v4：允许“最后统一结算”，更像批处理。
    

* * *

## **5）与 v4 交互：为什么官方更推荐用 Universal Router？**

官方建议：**swap 最好走 Universal Router**，而不是直接对 PoolManager 做 swap（虽然技术上能做，但更复杂、也可能更低效）。

Universal Router 的定位（大白话）：

-   一个“通用交易路由器”，能把 v2/v3/v4 的交换、拆单、ETH 包装/拆包、以及 Permit2 授权等组合成一笔交易。
    
-   它是 **无 owner、不可升级** 的合约（更偏基础设施属性）。
    

> 你可以理解为：
> 
> **PoolManager 是 v4 的“发动机”**

* * *

## **6）Subscribers（订阅者）：v4 新的 LP 扩展能力**

**大白话**：LP（头寸拥有者）可以选择“订阅”某个合约，让它接收通知（例如你增减流动性、转移头寸、取消订阅等）。

官方强调这能支持更安全的流动性挖矿/额外奖励：v3 的老做法常需要把头寸转到外部合约（风险更大），v4 用订阅通知降低了“把头寸交出去”的必要性。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->








# **今日总结：EVM 与 Gas 机制（以太坊怎么“跑代码”和“收钱”）、共识机制与生态展望（以太坊怎么更安全、更扩容、未来往哪走）**

## **1）EVM 到底是什么？**

-   **一句话**：EVM 就是以太坊的“统一执行引擎/世界状态机”——所有节点都按同一套规则执行合约，才能得到同一个结果。
    
-   它把合约行为拆成一条条最小指令（opcode），**逐条执行**，确保全网一致（共识确定性）。
    

## **2）为什么要“逐条执行 opcode”？**

教材给的核心理由可以背下来：

-   **共识确定性**：每条 opcode 语义写进规则里，节点逐条解释，才能全网状态一致。
    
-   **精确计费 + 防 DoS**：逐条执行才能给每一步定价，防无限循环/资源滥用。
    
-   **实现一致 + 安全隔离 + 审计友好**：指令集小而明确，不同客户端更容易一致；也更好追踪调试。
    

## **3）Gas 是什么？（先搞清“Gas≠钱”）**

-   **Gas 是“工作量单位”**：衡量一笔交易/一次合约调用消耗多少计算、存储等资源。
    
-   **钱用 ETH/Gwei 付**：Gas（用多少资源） × GasPrice（每单位资源多少钱）= 你最终花的钱。
    

## **4）Gwei / Wei / ETH 怎么换算？（非常实用）**

-   1 ETH = 10^18 wei
    
-   1 Gwei = 10^9 wei
    
-   所以：1 ETH = 10^9 Gwei
    
    并且 GasPrice 通常写成 **Gwei/Gas**。
    

> 21,000 gas 的转账 × 20 gwei/gas = 420,000 gwei = 0.00042 ETH。

## **5）为什么每条 opcode 都要收 gas？**

-   **一句话**：因为以太坊是开放环境+图灵完备，必须用“付费执行”把攻击变贵。
    
-   作用：让 DoS/无限循环不划算、让节点执行有激励、让昂贵资源（存储/外部调用）合理计费，并且协议还能通过调整 gas 表应对新攻击。
    

一个很形象的**厨房类比**：

-   opcode 像做菜步骤；简单翻炒便宜，开烤箱2小时很贵；想一直瞎折腾就得一直付钱，很快破产，拖不垮厨房。
    

## **6）Gas 机制像“三层防护网”（很好背）**

-   每条指令都要付费
    
-   交易/区块有 gas 上限（能消耗的资源被硬限制）
    
-   费用市场 + 销毁机制：越想挤爆网络越要烧更多 ETH
    

## **7）Out of Gas 会发生什么？（链上“失败”的精确定义）**

当交易执行中 gas 用完：

1.  **状态全部回滚（revert）**
    
2.  **已消耗的 gas 不退**
    
3.  **交易仍会进区块，但状态是失败（status=0）**
    

* * *

## **8）The Merge 到底改变了什么？**

-   **一句话（教材可背）**：The Merge 不是“换壳”，而是把安全从烧电迁移到质押，把能耗砍掉 99.95%，为扩容/分片/更健康的经济模型打基础。
    

## **9）PoS 的本质：用“押金”来换安全**

PoS 核心流程（你可以当成一条业务链路记）：

-   质押：想当验证者就把 ETH 锁进合约里当赌注
    
-   选择：协议伪随机选人提议区块（质押越多概率越大）
    
-   共识：其他验证者确认区块有效
    
-   奖励与惩罚：做对给奖励；作恶（如双签等）会被 **Slashing 罚没质押**。
    

## **10）PoS 带来的两个“巨变”：能耗 & 发行**

-   **能耗骤降约 99.95%**：从 PoW 的矿机耗电，变成 PoS 的质押安全。
    
-   **发行量显著下降**：PoW 时代年发行约 430 万枚；PoS 时代约 60–70 万枚（随质押量变化），大幅减少约 90%。
    

## **11）ETH 的“销毁机制”仍在：通缩/低通胀取决于活跃度**

-   BaseFee（EIP-1559）继续被销毁；链上越活跃销毁越多。
    
-   Merge 后出现过“净通缩”（销毁>发行）的阶段；但 Dencun 让 L2 更便宜后，主网负载变化、销毁减少，整体在低通胀和轻微通缩之间摆动。
    

## **12）路线图与升级：以太坊在往“Rollup-centric”走**

教材给了升级节点和方向（你抓住主线就行）：

-   Shanghai/Capella：释放质押提款，提高参与意愿
    
-   Dencun：引入 EIP-4844 blob，Rollup 数据走 blob，L2 成本下降，主网更像 DA 层
    
-   Pectra：继续推进账户能力、验证者架构、EOF/L2 演进等
    

## **13）分片、Danksharding、Verkle：分别解决什么？**

教材有“一句话总结 + 对比表”（非常适合记 Notion）：

-   **分片 Sharding**：把“要处理/存的东西”拆小，缓解所有节点都干所有活。
    
-   **Danksharding（数据分片）**：把“给 Rollup 用的数据空间”做大做便宜，专注解决 DA 和 L2 成本。
    
-   **Verkle 树**：换更高级的状态树结构，缩小证明体积，为无状态客户端铺路，让跑节点更轻。
    

并且教材解释了“为什么分片思路会演化”：

-   早期想做 **状态分片**（把整条链拆成多片并行处理，提升吞吐、降低节点负担），但跨分片一致性很复杂；Rollup 崛起后，以太坊更偏向 **Rollup-centric**：分片更像是给 Rollup 提供数据空间，而不是 L1 直接处理所有扩容。
    

## **14）企业为什么更愿意支持以太坊？**

教材总结了三类理由：

-   **智能合约自动化/无需信任**：减少中介、降成本提效率
    
-   **安全与透明**：去中心化安全 + 公共账本透明（对审计/合规/信任重要）
    
-   **生态和开发者社区**：DeFi、NFT、Web3 游戏等最成熟活跃
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->









# **今日学习总结：账户类型与结构（EOA vs 合约账户）、智能合约理论基础（合约怎么工作、怎么交互、怎么更安全）**

## **1）以太坊里只有两种账户**

### **EOA（外部账户）**

-   **一句话**：EOA = 你用**私钥**直接控制的钱包账户
    
-   能做什么：
    
    -   ✅ 主动发起交易（转账 / 调合约）
        
    -   ✅ 持有 ETH / 代币
        
-   不能做什么：
    
    -   ❌ 自己不带代码，不会自动执行逻辑
        
-   **谁掌握私钥，谁就掌握这个账户的一切**
    

### **合约账户（Contract Account）**

-   **一句话**：合约账户 = 一段**代码 + 持久化状态**，住在一个地址里
    
-   通过“部署合约”创建出来
    
-   自己不能“主动发起交易”，只能被外部交易触发后执行代码
    

* * *

## **2）合约账户怎么创建？（CREATE / CREATE2）**

合约账户不是“注册来的”，而是“部署产生的”。

-   **CREATE（传统）**：合约地址由 **创建者地址 + nonce** 等信息推出来
    
-   **CREATE2**：合约地址由 **创建者地址 + salt + init\_code** 推出来
    
    -   好处：你能提前“算出来未来合约地址”（更可预测）
        

> 记忆法：

> CREATE = “按顺序生孩子（nonce）”

> CREATE2 = “按指定名字生孩子（salt）”

* * *

## **3）为什么以太坊地址都以 0x 开头？**

-   **0x 是十六进制的标记**（告诉你：后面是一串 hex）
    
-   **它不是地址本体的一部分**（链上真实值是 160bit）
    

* * *

## **4）EOA vs 合约账户：控制方式对比（核心差异）**

| 对比点 | EOA | 合约账户 |
| --- | --- | --- |
| 控制权 | 私钥控制 | 代码规则控制 |
| 能否主动发交易 | ✅ 能 | ❌ 不能（只能被触发） |
| 是否有代码逻辑 | ❌ 没有 | ✅ 有（bytecode） |
| 典型例子 | MetaMask 地址 | ERC20 合约、Uniswap 合约 |

* * *

## **5）谁能“主动发起交易”？**

-   **只有 EOA 能主动发交易**
    
-   合约账户只能：
    
    -   被 EOA 交易调用后执行
        
    -   或者被别的合约在执行过程中“内部调用”（message call）
        

* * *

## **6）合约账户的余额和“状态”存在哪里？**

合约账户除了余额，还有“状态数据”：

-   余额（ETH）
    
-   存储（storage）：比如 ERC20 的 balanceOf 映射、NFT 的 ownership 映射
    
-   代码（bytecode）
    

> 大白话：合约账户像一个“带数据库的小程序”。钱只是其中一个字段。

* * *

## **7）EOA 和合约如何互相调用？**

-   **EOA → 合约**：通过一笔交易触发（最常见）
    
-   **合约 → 合约**：在执行过程中内部调用
    
-   **合约不能自己突然发起一笔链上交易**（它没有私钥）
    

* * *

## **8）MetaMask 在管理什么？**

-   MetaMask 管理的是 **EOA**（私钥/助记词派生出来的一堆地址）
    
-   一套助记词可以生成多个地址（HD 钱包的思路）
    

* * *

## **9）ERC20 / ERC721 代币和合约账户的关系**

-   **代币本身就是合约**（在一个合约地址里）
    
-   “你有多少代币”不是写在你钱包里，而是写在**代币合约的 storage** 里
    
-   “转代币”本质是：你调用代币合约，让它改 storage 里的记录
    

> 记忆法：

> ETH 余额在“账户”里

> Token 余额在“合约的账本（storage）”里

* * *

## **10）合约部署后为什么“不可篡改”？那升级怎么办？**

-   合约一旦部署，代码默认不可改（immutable by default）
    
-   真要升级，一般靠：
    
    -   **代理合约（Proxy）**：地址不变，背后逻辑合约可换
        
-   合约销毁（SELFDESTRUCT）属于旧时代思路，现在已不推荐当“升级/回滚”手段（安全模型和规则已变化）
    

* * *

## **11）智能合约是什么？**

-   **一句话**：智能合约 = 链上的“自动执行程序合同”
    
-   本质是：**代码（functions）+ 数据（state）** 固定在一个地址上
    
-   触发方式：必须靠交易或调用触发执行
    

* * *

## **12）Solidity 为啥能写合约？（它的特点）**

你可以把 Solidity 理解成：**“给 EVM 写程序的语言”**，特点是：

-   面向合约、面向状态（特别强调 storage / memory）
    
-   强类型、支持继承/接口/库
    
-   很多设计都在为 “gas 成本” 服务（比如数据位置、打包变量等）
    

* * *

## **13）合约编译会产生什么？（人类和链交互靠它）**

编译后最关键的两个东西：

### **Bytecode（字节码）**

-   真正部署到链上的“机器指令”
    
-   EVM 执行它来跑合约逻辑
    

### **ABI（接口说明书）**

-   一份 JSON，描述合约有哪些函数/事件、参数类型是什么
    
-   **前端/脚本/钱包要靠 ABI 才知道怎么调用合约**
    

> 大白话：

> bytecode 是“机器本体”

> ABI 是“机器说明书 + 按钮功能表”

* * *

## **14）部署合约：地址和 ABI 怎么拿到？**

部署流程大概是：

1.  写 Solidity
    
2.  编译 → 得到 bytecode + ABI
    
3.  发部署交易（包含 init code）
    
4.  链上生成合约地址
    
5.  用 ABI 在前端/脚本里与合约交互
    

* * *

## **15）合约部署成本怎么算？为什么写法会影响 gas？**

-   gas 不只是“调用一次多少钱”，还包括：
    
    -   **部署成本**（把 bytecode 上链很贵）
        
    -   **运行成本**（执行指令）
        
    -   **存储成本**（写 storage 特别贵）
        

> 直觉规则：

> 写 storage ＞ 读 storage ＞ 计算

> 所以合约优化常常围绕“少写 storage”。

* * *

## **16）常见安全漏洞 & 防范（复习重点）**

高频坑（先记“套路”就够用）：

-   **权限控制问题**：谁能改关键参数/提现吗？
    
-   **重入攻击（Reentrancy）**：外部调用导致反复进入
    
-   **预言机/价格操控**：用错误价格套利（特别是 DeFi）
    
-   **前置交易/抢跑（MEV）**：你交易公开在 mempool 里会被插队
    
-   **随机数不随机**：链上“看起来随机”的东西可能可预测
    
-   **升级/管理员私钥风险**：能升级=能改规则，也可能被盗用
    

常见防范思路：

-   最小权限、关键操作多签/延时
    
-   “先改状态再转账”的写法（Checks-Effects-Interactions）
    
-   用成熟库（如 OpenZeppelin），再加测试/审计
    

* * *

## **17）部署工具：Remix vs Hardhat（你今天应该形成的认识）**

-   **Remix**：适合入门、快速试验、手动部署
    
-   **Hardhat**：适合工程化开发（脚本部署、测试、网络管理、验证）
    

* * *

## **18）合约部署后的公开性与可审计性**

-   合约地址、交易、状态、事件日志基本都能被公开查到
    
-   **“链上没有真正的秘密”**：不要把私密信息硬写进合约
    
-   公开性带来：
    
    -   ✅ 透明、可验证
        
    -   ❌ 更容易被盯上（攻击者也能读你的逻辑）
        

* * *

## **19）合约逻辑修改与升级模式（为什么要升级？也为什么危险？）**

-   想升级：修 bug、加功能、改参数
    
-   但升级本身是一种“权力”，会带来信任问题
    
-   常见升级路线：**Proxy（透明代理 / UUPS 等）**
    
-   需要理解的核心权衡：
    
    -   **可升级 = 更灵活，但更依赖“管理员可信”**
        
    -   **不可升级 = 更可信，但 bug 就很难救**
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->










## **今日学习总结：Web3 合规 & 网络安全**

## **_两条终身安全法则（最重要）_**

1.  **零信任**：默认“对方可能是骗你的”。
    
2.  **持续验证**：你愿意相信之前，必须能验证你怀疑的点（并养成习惯）。
    

### **1）我今天学的“合规”到底在管什么？**

**一句话：合规就是在回答——这套加密业务会不会被用来洗钱/诈骗/违规卖金融产品，以及出了事谁负责。**

合规通常分成 4 块（可以当成“监管四件套”）：

1.  **反洗钱/反恐融资（AML/CTF）**
    
    -   重点：**KYC（认识你的客户）**、交易监控、可疑交易报告、黑名单/制裁筛查。
        
    -   在澳洲，如果你是做“法币↔加密货币兑换”的业务，一般要 **向 AUSTRAC 注册**，不注册提供服务是违法的。
        
2.  **“Travel Rule”（转账随行规则）**
    
    -   大白话：当你帮用户转币时，需要把“转出方/接收方”的必要信息跟着交易走，增加透明度。
        
    -   这是 FATF 的一套全球标准方向，各国会逐步落地。
        
3.  **牌照/经营边界（到底算不算金融服务？）**
    
    -   大白话：提供的功能如果很像“交易所/托管/借贷/理财”，监管会更关注：是不是需要许可、你怎么保护客户资产、怎么处理投诉。
        
4.  **信息披露与消费者保护**
    
    -   大白话：不能乱宣传、不能“暗示保本”、要把风险说清楚。
        
    -   比如欧盟 MiCA 就是典型趋势：要求更统一的市场规则、披露和监管框架（不同地区规则不同，但大方向是“更规范”）。
        

* * *

### **2）今天学的“网络安全”到底在保什么？**

**一句话：Web3 安全的目标是——不让人把你的钱偷走/把你的合约玩坏/把你的系统搞瘫。**

Web3 安全分三层，你可以这样记：

### **A. 钱包与私钥安全（个人层）**

-   私钥/助记词=银行卡密码+印章
    
-   常见风险：钓鱼网站、假钱包插件、假空投签名、恶意授权（Approve）、SIM 换卡等
    
-   核心原则：**“助记词永不外泄；签名前先看清楚你在授权什么”**
    

### **B. 智能合约安全（代码层）**

-   合约一旦上线很难改，漏洞就是“永久后门”
    
-   常见漏洞类型可用 OWASP 的安全标准/Top10 来做检查清单（比如权限控制、逻辑错误、重入、预言机操纵等）。
    

### **C. 协议与运营安全（系统层）**

-   组件包括：前端、RPC、合约、跨链桥、预言机、后台、权限多签
    
-   常见事故：跨链桥被打、预言机被操纵、管理员私钥泄露、前端被篡改诱导签名
    

* * *

## **3）把“合规”和“安全”放在一起：学到的行业真相**

可以用这句来总结今天的核心认知：

> 合规解决“能不能做、怎么做才不违法”；安全解决“做了之后会不会被偷、会不会崩”。

> 两者目标一致：
> 
> **降低系统性风险，让产品能长期活下去。**

* * *

## **4）复习用的“速记框架”（以后看项目就按这张表扫一遍）**

### **合规快速扫 6 问**

1.  这个产品是 **托管/交易/借贷/理财/支付** 哪一类？
    
2.  有没有 **KYC/AML**？用户资金来源/去向能不能解释？
    
3.  有没有制裁/黑名单筛查？有没有异常交易监控？
    
4.  跨平台转账是否涉及 **Travel Rule** 义务？
    
5.  用户资产怎么隔离/保管？出事怎么申诉？
    
6.  宣传是不是会被理解成“保本/收益承诺”？
    

### **安全快速扫 6 问**

1.  私钥/管理员权限怎么管？单点还是多签？
    
2.  合约是否审计？关键函数是否有权限控制与限制？
    
3.  预言机数据来源是否可信？会不会被操纵？
    
4.  是否有紧急暂停/熔断机制？升级怎么做？
    
5.  前端/RPC 是否可能被劫持？用户如何验证？
    
6.  出现事故的响应流程：监控→告警→止损→公告→复盘
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->











# **今日学习总结（Layer2 / DAO / 节点通信 / 全节点&轻节点&归档节点）**

## **1）Layer2 到底想解决什么？**

**一句话：让以太坊“更便宜、更快”，但尽量不牺牲“安全性/去中心化”。**

你可以把以太坊主网（L1）理解成：

-   **最高法院 + 最安全的总账本**
    
-   但它“处理能力有限”，所以贵、慢。
    

Layer2 的核心思路几乎都长这样：

1.  先把资产从 L1 “存入”到一个合约（桥/存款合约）
    
2.  大量交易在 L2 上处理（更快更便宜）
    
3.  L2 定期把“结果/证明/数据”交回 L1，让 L1 负责最终裁决
    

* * *

## **2）Layer2 为啥会不断演化？（演化的主线）**

可以用一条线记住这段历史：

**省钱省事（把活挪走）** → **但会出现“我怎么确定你没作恶/数据没丢？”**

于是 L2 的演化基本都在围绕两件事打补丁：

### **A. 正确性：你有没有作弊？**

-   早期：靠“双方签名/退出机制/挑战期”
    
-   后来：靠“证明”（欺诈证明 or 有效性证明）
    

### **B. 数据可用性（DA）：数据是不是大家都拿得到？**

-   如果 L2 不把交易数据公开，别人就没法验证/退出
    
-   所以现在大家很强调：数据到底是放 L1（更安全但贵），还是放链下（便宜但要信人）
    

> 所以会看到：从 Channels / Plasma → 逐渐走向 Rollups（把数据放回 L1）。

> 因为“正确性 + 数据可用性”这两件事，Rollup 更容易给出强保证。

* * *

## **3）Layer2 有哪几大类？各自的问题是什么？**

### **（1）状态通道 State Channels（最早一代）**

**大白话：先把钱锁到合约里，然后你们俩私下疯狂对账，最后再把最终结果上链。**

**优点**

-   超快、超便宜（链上只管开局和结算）
    

**致命问题**

-   **不适合“很多陌生人自由交易”的场景**：通常需要参与方提前建立通道
    
-   **在线要求高**：你得随时能监控/响应（不然对方可能提交旧状态）
    
-   更像“支付/游戏对战结算”，不太像“开放式 DeFi 世界”
    

**为什么会被后续方案替代？**

因为 DeFi/NFT 这种是“任何人随时进来交易”，通道不够开放。

* * *

### **（2）Plasma（试图做“子链”，但退出太麻烦）**

**大白话：搞一条挂在以太坊上的子链，子链高频跑；一旦出事大家可以退回主链。**

**优点**

-   理论吞吐高、L1 压力小
    

**主要问题（经典坑）**

-   **退出/挑战机制很复杂**（“退出游戏”很折腾）
    
-   **数据可用性风险**：如果子链不公开数据，你可能连“证明自己有钱”都拿不出
    
-   对通用智能合约支持也不如 Rollup 路线顺滑
    

**为什么后来 Rollup 更火？**

因为 Plasma 为了省链上数据，反而让“退出安全性/可用性”变得很难搞。

* * *

### **（3）侧链 Sidechains（经常被当 L2 讲，但安全性逻辑不同）**

**大白话：这是一条“自己当家”的链，用自己的共识/验证者，不是完全靠以太坊保安全。**

**优点**

-   很便宜、很灵活、想怎么改规则都行
    

**关键问题**

-   **安全性不继承以太坊**：你得信它自己的验证者/共识系统
    
-   所以严格说它更像“独立链 + 桥”，不如 Rollup 那种“挂靠以太坊安全”
    

**适合什么？**

-   对极致便宜/高吞吐更敏感、且能接受额外信任假设的应用
    

* * *

### **（4）Rollups（主流路线）：把“数据”发回 L1，让安全更硬**

**大白话：交易在链下算，但“账本证据（数据/证明）”要交回 L1，这样大家都能验证。**

Rollup 之所以成为主流，核心是：

-   **正确性**：要么可挑战（Optimistic），要么直接给证明（ZK）
    
-   **数据可用性**：交易数据放 L1，别人永远能拿到数据并验证/退出
    

* * *

**4.1）Optimistic Rollup（“先相信你是对的，有人不服再告你”）**

-   默认认为 L2 提交的结果是对的（Optimistic）
    
-   给一个**挑战期**，任何人都可以提交欺诈证明来反驳
    

**优点**

-   更容易兼容以太坊生态（特别是 EVM 兼容）
    
-   工程落地早、生态成熟
    

**主要问题**

-   **提现慢**：因为要等挑战期过去（常见是一周左右量级）
    
-   运行上经常依赖排序器（sequencer）等组件，存在“中心化程度/抗审查”方面的讨论（后续靠去中心化排序器等方案演进）
    

* * *

**4.2）ZK Rollup（“我直接给你数学证明：我算得没错”）**

**机制大白话**

-   L2 批量执行交易后，生成一个\*\*有效性证明（validity proof）\*\*交给 L1
    
-   L1 验证这个证明通过，就认可这批交易结果
    

**优点**

-   **最终确认更快**（不需要等挑战期那种长等待的逻辑）
    
-   理论上安全性更“数学化”
    
-   有机会做隐私（某些 ZK 系统可扩展到隐私状态）
    

**主要问题**

-   **工程复杂、证明系统成本高**（生成证明需要较强工程/算力，开发门槛高）
    
-   通用 EVM 兼容在早期更难（现在在快速推进，但你只要记住：更难做、但潜力更大）
    

* * *

### **（5）Validium / Volition（更便宜更快，但要“额外信任”）**

这类系统的核心是：**计算正确性用 ZK 证明保，但“交易数据不放 L1”，放链下。**

这样费用更低、吞吐更高，但引入数据可用性的信任假设。

### **Validium**

-   **数据放链下**（比如 DAC 数据可用性委员会保存/签名）
    
-   风险：如果数据提供方不配合，你可能很难自己重建状态/顺利退出
    

### **Volition**

-   **让用户自己选**：这笔交易的数据放 L1（更安全更贵）还是放链下（更便宜）
    

* * *

-   **最安全（强保证）**：Rollup（数据上 L1）
    
-   **最便宜（强性能）**：Validium（数据链下，但要信数据可用性）
    
-   **最适合固定参与者**：State Channels（适合支付/对战结算）
    
-   **折中的早期路线**：Plasma（退出机制复杂、逐渐被 rollup 路线替代）
    
-   **“独立链 + 桥”**：Sidechains（不继承以太坊同等安全）
    

* * *

## **4）DAO：它是“公司”还是“群聊”？**

-   **一句话：DAO 是“用智能合约 + 投票规则”运行的组织。**
    
-   传统公司靠：老板拍板、合同、银行账户、人工执行。
    
-   DAO 靠：链上规则写死（合约）、资金在金库（Treasury）、决策用投票（Governance）。
    

**DAO 通常怎么运作：**

1.  提案（Proposal）：有人提出“要不要做某事”
    
2.  讨论（论坛/Discord）
    
3.  投票（用治理代币或会员资格投票）
    
4.  执行（通过后由合约自动执行，或多签执行）
    

**优缺点大白话：**

-   ✅ 透明：钱去哪了、谁投了啥票，链上都能查
    
-   ✅ 抗单点：不依赖一个人/一个公司
    
-   ❌ 慢：投票周期长
    
-   ❌ 容易被“鲸鱼”影响：代币多的人话语权更大（除非有特殊设计）
    

* * *

## **5）以太坊节点之间怎么“交流”？**

-   **一句话：节点之间靠 P2P（点对点）网络“互相八卦”，同步交易和区块。**
    
-   没有一个“中央服务器”发通知，而是节点彼此连起来形成网。
    

**它们主要传播两类东西：**

-   **交易（Transactions）**：比如你转账、mint NFT 这种“请求”
    
-   **区块/区块头（Blocks/Headers）**：打包后的最终结果
    

**传播方式可以想成：**

-   有人听到新消息（新交易/新区块）
    
-   就发给自己的邻居节点
    
-   邻居再发给更多节点
    
-   很快全网都知道了（像朋友圈转发）
    

**节点同步的基本流程：**

1.  先同步区块头/链的骨架（知道“最新到哪了”）
    
2.  再补齐区块内容、交易等细节
    
3.  最后本地验证：每一步都符合规则才算数
    

* * *

## **6）全节点 / 轻节点 / 归档节点：三者区别（最重要）**

可以把区块链理解成“账本 + 规则”，不同节点保存账本的深浅不一样。

### **A. 全节点（Full Node）**

-   **一句话：保存区块数据，能独立验证规则，是“自给自足的普通裁判”。**
    
-   会自己验证每个区块、每笔交易是否合规。
    
-   一般会保存“必要的数据”，但**不保存所有历史状态的每个版本**。
    

适合：想更安全、更独立地使用链上数据的人（开发者/高级用户）

### **B. 轻节点（Light Node / Light Client）**

-   **一句话：只保存“摘要”（区块头），像“看新闻标题的人”。**
    
-   不下载完整区块数据，主要靠区块头 + 证明来确认“事情大概率是真的”。
    
-   好处：省空间、省带宽，适合手机钱包等轻量场景。
    
-   代价：需要依赖别人提供数据和证明（但仍比完全信任中心化服务器强）。
    

适合：手机钱包、资源有限设备

### **C. 归档节点（Archive Node）**

-   **一句话：保存“从古到今每一刻的完整状态”，像“全历史录像馆”。**
    
-   不仅有区块数据，还能查询“任意历史时刻某个地址的状态”（余额、合约状态）。
    
-   成本最高：存储巨大、维护更重。
    

适合：区块浏览器、数据分析平台、研究/审计、需要历史状态查询的服务

* * *

-   **轻节点：只看“标题”（区块头）**
    
-   **全节点：看“全文”（区块+验证）**
    
-   **归档节点：还保存“所有历史版本的全文+录像回放”**
    

* * *
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->












# **今日学习总结（以太坊 / DeFi / Uniswap / Compound / NFT）**

### **1）以太坊基础原理：它到底是什么？**

-   **以太坊 = 一台全世界共同维护的“公共电脑”**
    
    大家都运行同一套规则，所以你在上面做的事情（转账、交易、发 NFT）都会被记录在链上，任何人都能验证。
    
-   **账户有两种：**
    
    -   **EOA（外部账户）**：用钱包（比如 MetaMask）控制的地址，能发起交易。
        
    -   **合约账户**：智能合约的地址，只能被交易触发后按代码执行。
        
-   **Gas（手续费）是“让机器干活的电费”**
    
    每次操作（转账、调用合约、mint NFT）都要消耗计算资源，所以要付 gas。网络越忙，gas 越贵。
    

* * *

### **2）DeFi：去中心化金融是怎么回事？**

-   **DeFi = 把传统金融的“借贷/交易/理财”搬到链上**
    
-   今天接触的两类 DeFi：
    
    -   **去中心化交易（DEX）**：代表是 Uniswap（换币）
        
    -   **借贷协议（Lending）**：代表是 Compound（存币赚利息、抵押借币）
        

* * *

### **3）Uniswap：不用“买卖双方撮合”，也能交易**

-   传统交易所像“菜市场撮合”：有人挂买单、有人挂卖单，匹配成交。
    
-   **Uniswap 像“自动售货机”**：你把一种币塞进去，机器按规则吐出另一种币。
    
-   它的核心是 **AMM（自动做市商）+ 流动性池（Liquidity Pool）**：
    
    -   池子里放着两种币（比如 ETH/USDC）
        
    -   价格由池子里两种币的比例决定
        
-   **一个重要概念：滑点（Slippage）**
    
    -   换得越多，池子比例被“推得越高”，价格就越不划算
        
    -   所以“大额兑换”通常滑点更明显
        

* * *

### **4）Compound：存币、借币怎么自动化的？**

-   **Compound = 链上“借贷市场”**
    
-   两种最常见动作：
    
    -   **Supply（存入）**：把币存进去，赚利息（利息来自借款人）
        
    -   **Borrow（借出）**：抵押资产，借出另一种资产
        
-   **关键逻辑：超额抵押**
    
    -   你想借钱，得先押一笔更值钱的资产
        
    -   如果抵押物价格跌太多，会触发 **清算（Liquidation）**（系统强制卖掉你的抵押物来还债）
        

* * *

### **5）NFT：它和“普通代币”最大的区别**

-   **NFT = 独一无二的链上“所有权凭证”**
    
-   大白话对比：
    
    -   **ERC-20 代币**：每个都一样
        
    -   **NFT（ERC-721 / ERC-1155）**：每个都不一样（像身份证编号/门票编号）
        
-   NFT 本质不一定是“图片”，更像：
    
    -   一条链上记录：谁拥有它
        
    -   +（可选）指向图片/文件的链接（很多存在 IPFS/中心化服务器上）
        

* * *

### **6）实操记录：我今天在链上真正做了什么**

-   ✅ **领取 SepoliaETH 测试币（Faucet）**
    
    ![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/doctorzero666/images/2026-01-12-1768221565468-image.png)
    
    用测试网模拟真实操作：不用真钱，但流程和主网很像。
    
-   ✅ **第一次转账（测试网转账）**
    
    体验了交易的关键要素：地址、金额、gas、等待确认。
    
-   ✅ **第一次做 NFT（Mint）**
    
    ![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/doctorzero666/images/2026-01-12-1768221538545-image.png)

* * *

## **我今天最大的收获：**

我把 Web3 从“概念”变成了“亲手做过一次”：

**我知道以太坊怎么记账（gas/交易/合约），也知道 DeFi 两大应用（换币 Uniswap、借贷 Compound），并且我在测试网完成了领币、转账、mint NFT 的完整闭环。**
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
