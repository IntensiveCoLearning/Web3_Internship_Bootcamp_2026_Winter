---
timezone: UTC+8
---

# yanzhuchen96-creator

**GitHub ID:** yanzhuchen96-creator

**Telegram:** @cydot0906

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
## 学习solidity推荐路线

1.  读官方文档 + 做例子：
    

-   从 Solidity 官方文档的 “Introduction to Smart Contracts” 和 “Solidity by Example” 开始。
    
-   用 Remix 这种网页 IDE 写第一个合约（HelloWorld，存／读变量， 转账，事件触发）。
    

2.  做交互式教程：
    

-   用 CryptoZombies、Solidity by Example 的小项目练手，感受 storage / memory、gas、事件、modifier 等细节。
    

3.  学习工具／测试／部署：
    

-   在本地装 Hardhat（适合脚本部署、多网络管理）或 Foundry（适合写大量单测、fuzzing、主网 fork 研究协议）
    
-   学会写单元测试（require 失败、revert、边界条件），**这一步对以后搞 DeFi / NFT 协议非常关键**。
    

4.  安全／最佳实践：
    

-   学习常见漏洞：重入、整数溢出／下溢、访问控制错误、price oracle 操纵、flash-loan 攻击等。
    
-   用 Slither、Mythril 之类的工具做静态分析，配合 Foundry/Hardhat 测试，把显而易见的坑先扫一遍。
    

5.  做一个小项目：
    

-   写一个简单 ERC-20 代币、投票合约，或者小型 DeFi 玩具协议，上 testnet 或某条 L2（如 Sepolia / Arbitrum Sepolia / Base 测试网）部署一遍，完整走完：编译 → 部署 → 前端调用 → 调试的闭环。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

# 1.15 学习笔记

今天在学校上了一天学，没有进行阅读，不过听了“AI及其基础概念”的分享会，以下是整理的笔记。

这次分享的主线就是从聊天机器人到“打工人”AI的演变。AI 正在从“高级复读机的聊天机器人”进化成“能自己干活、自己收钱的打工人”，而要让这种 agentic AI 真正落地，必须解决三个基础设施问题：**有记忆、有工具、有身份和钱包**。Web3 提供了 AI 身份、声誉和原生微支付的底层协议，SpoonOS 则把这些协议封装成开发框架，让普通开发者几天内就能搭出有 Web3 能力的 AI 智能体。

一个完整的 AI 智能体由三部分组成：**LLM** 是“脑子”，负责理解意图和制定计划；**私有知识库与向量数据库**是“记忆”，通过数据采集、embedding 与相似度检索让 AI 从金鱼记忆升级为大象记忆；**工具调用与 MCP** 是“手脚”，通过函数调用执行发邮件、查库、跑代码、调第三方 API 等操作，形成“思考-行动-观察”的闭环，让 AI 从回答问题进化为长期运行的智能体。

在 Web2 的架构下，AI 的局限在于：

-   服务端无法分辨请求是人还是 AI、是哪个公司或哪个 agent，导致身份欺诈风险高，AI agent 实际上是“能力很强的黑户”。
    
-   绝大多数 AI 日志存本地服务器，可被修改、删除或伪造，监管难以相信现有日志，责任追溯存在巨大漏洞。
    
-   随着 AI 大量调用 API、购买数据、支付算力，传统信用卡和订阅制在 KYC、微支付颗粒度、结算速度等方面都无法支撑“每秒成千上万笔 0.001 美元级交易”的机器经济需求。
    

Web3 能给 AI 带来两样关键东西：一张**不可伪造的链上身份证**和一个**可编程的钱包账户**。 区块链的去中心化、不可篡改和可编程特性，恰好匹配 AI agent 在身份验证、行为记录和支付结算上的需求。Rick 把他们的架构拆成三层：底层是交易层，用的是 X402 协议，把支付能力直接嵌入 HTTP；中间是身份层，用的是 ERC8004 标准，为 AI 提供唯一链上身份和声誉系统；顶层是应用层，即 SpoonOS，封装前两层能力为简单 API，让开发者不必自己管理私钥和写签名逻辑。整体目标是让 AI agent 像“合法公民”一样在链上参与经济活动，而不是继续做“黑户打工人”。

X402 以 HTTP 402 为基础，把支付能力直接嵌入 HTTP 流程：服务端用 402 响应返回收款地址、金额、代币和链信息，客户端用钱包完成链上交易或签署付款承诺，再携带支付证明获取真实服务。支付证明可通过链上查交易或验证签名承诺来确认，同时结合支付通道和批量结算降低 gas，使按 token 计费、按次付费的 API 成为现实，把互联网从广告/订阅扩展到面向 agent-agent 的精细按需付费模式。​

ERC8004 基于 ERC721，为每个 AI agent 铸造唯一 NFT 身份，元数据中记录 agent 类型、能力声明、运行模型哈希和 owner 地址，便于验证和权限编程。配套的声誉系统用 0–100 分为单维评分，通过“只有与 agent 有真实链上交易的钱包才可评价”“评价需付 gas”“评分上链不可篡改+时间衰减权重”等机制，增加刷分成本并兼顾改过机会，同时预留 TEE 与 ZKML 接口用于证明模型在可信环境中执行而不泄露内部细节。

在此基础上，SpoonOS 的角色是“AI × Web3 的操作系统/框架”，目标是让普通开发者不懂 solidity、不自己管理私钥，也能快速做出可上链、有钱包、有声誉、有支付能力的智能体。四层架构包括：输入层（采集链上数据、文档并做 RAG）、核心层（统一 LLM 接口、多智能体编排引擎、记忆管理器和工具调用器）、协议层（集成 ERC8004 和 X402、钱包托管和链上证明）、输出层（DeFi 连接器和跨链桥），并通过“私钥永不离开安全环境”的设计降低密钥泄露风险。

基于 SpoonOS，可以快速开发 DeFi 交易/套利智能体、数据市场 agent（按量卖数据/API）、代码协作助手（代处理 issue/PR）以及未来的“智能体网络”和“AI 网络游戏”等复杂生态。实践上，量化策略的上限主要取决于人本身的策略水平，AI 提供的是自动化执行和编排能力；建议先用小额资金验证 AI 是否按预期策略行动并能稳定盈利，再逐步放大规模，以降低策略错误或实现偏差带来的损失。

## Q&A

### AI 量化是否一定要单独链上账户？

小规模自用时，可以直接托管自己钱包即可；但如果要做成公开可募资的量化“基金型机器人”，则需要链上身份和可验证记录来建立信任，否则别人无法确认策略真实性、也无法追责。

### Web3 的 TPS 是否真比 Web2 高？

相比跨境电汇等传统体系（手续繁琐且受合规和架构瓶颈限制），多链高 TPS 区块链更适合机器经济那种高频、跨区域、24 小时运行的微支付结算，只是这个比较对象更偏向传统金融基础设施，而不是单一中心化支付巨头。

### 其他讨论

声誉系统目前是针对“agent 而不是开发者”的单一维度评分，所以确实存在开发者“废号重开”的问题；协议还比较早期，未来会探索更复杂的多维度声誉和防女巫机制。对于 DeFi 场景下的策略 agent，核心天花板仍然在人的策略质量上，AI 主要负责自动化执行和编排：如果人本身不懂交易，只想“让 AI 帮忙写一个稳赚策略”，大概率会亏钱，建议先用少量资金小规模实测，再逐步放大。

## 总结

大模型升级为 agentic AI 后，开始“替人干活、替人花钱”，传统 Web2 与金融基础设施在身份、审计和微支付上都无法支撑即将到来的“机器经济”；Web3 通过 ERC8004 和 X402 等协议，为 AI agent 提供链上护照和原生微支付能力，再配合像 SpoonOS 这样的框架，把复杂的链上操作（身份、声誉、钱包、支付、审计）封装起来，从而构建一个“AI 作为经济主体”的新基础设施，让未来的经济活动由数以亿计的 AI agent 在链上以可验证方式持续运转。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->



# 1.14 学习笔记

# 021学习以太坊第三章重点

## EOA VS 合约账户（类比银行卡 VS 自动售货机）

| 维度 | EOA | 合约账户 |
| --- | --- | --- |
| 控制主体 | 私钥持有者（人 / 程序）​ | 合约代码逻辑本身​ |
| 是否有私钥 | 有（私钥 → 公钥 → 地址）​ | 无，不能签名​ |
| 是否能签名 | 能，对交易签名​ | 不能，所有调用都由外部交易触发​ |
| 发起交易 | 可以主动发起交易​ | 不能主动发起，只能被消息调用（internal call）​ |
| 创建成本与方式 | 生成 EOA 只是本地生成一对 key pair，不需要上链、不花 gas。 | 部署合约账户必须发一笔 “创建合约交易”，把 bytecode 写入链上，需要支付不少 gas。 |
| 状态 | 只有余额和随机 nonce​ | 余额 + 代码 + 存储（状态树）​ |

**可以通过 RPC 方法 eth\_getCode(address) 判断某地址是否为合约账户：如果返回的代码非空，就说明有智能合约存在，是合约账户；否则为 EOA。**

## CREATE VS CREATE2

| 维度 | CREATE | CREATE2 |
| --- | --- | --- |
| 地址是否可预测 | 依赖部署者 nonce，部署前不好精确算地址（要模拟或推演 nonce）。 | 由 部署者地址 + salt + init_code 决定，部署前就能精确算出地址。 |
| 跟什么有关 | 跟“当前第几次部署/发交易”的 nonce 强绑定，顺序变地址就变。 | 跟 sender、salt、init_code 强绑定，和 nonce、部署顺序无关。 |
| 典型用途 | 普通合约部署，一般随手 new 一个合约就用它。 | 需要“先知道地址再部署”的场景：合约工厂、预先授权、钱包预创建等。 |
| 是否能“先占坑后部署” | 基本不行，地址前期不好引用。 | 可以先算出未来地址，提前写进别的合约或权限里，再真正部署。 |
| 地址复用可能性 | 通常视为 “一次性地址”，销毁后也很少复用同址。 | 在旧合约被销毁后，可用同一 sender+salt+init_code 再部署回同一个地址（要非常谨慎）。 |

## 0x是什么？为什么要用0x？必须写吗？

0x相当于 “货币符号”，用来告诉人和程序：后面这一串是十六进制数字。用0x的好处是，一眼能看出是**地址 / hex**，而不是什么别的东西，避免和其它内容混淆，这使得在文档或者代码里查找都更加方便。从 “数学意义” 上看，0x并不算地址的一部分，所以写不写都行，都能识别，但出于能 **“让人和程序一眼识别”** 的目的，推荐带上0x。

## 账户抽象的通俗解释

用一套机制（如 ERC-4337，EIP-7702），让**合约钱包**可以像普通账户那样发起操作，还能自己写规则（怎么验证、怎么付费、怎么玩安全），从而大幅改造 “账户能力”，而不只是“EOA 私钥签交易”这一种模式。

真正 “发交易”的还是 EOA，合约自己不能直接把交易丢进区块链，只能在交易内部继续调用别的合约。账户抽象做的事是搭一层 “中间系统”，对用户来说就像 “这个合约账户在主动发交易、主动操作”。​

EIP-7702 把“EOA 能不能执行合约逻辑”这件事，放进了协议层，用一 种可授权、可撤销、带 nonce 防重放的新交易类型来做；钱包（包括 MetaMask）可以在此基础上继续构建更上层的智能账户体验。

## 在codehash中，为什么要存哈希而不是直接把code塞进账户对象？

在账户里放一整段合约代码很占空间，状态树会变得又大又难同步。代码实际单独存储，账户里只存 codeHash 作为 “指针 + 防篡改承诺”。通过 eth\_getCode(address) 可以根据 codeHash 拿回真实字节码。

## EOA 与合约账户的互相调用机制

外部交易由 EOA 发起，合约间调用被称为 internal transactions / message calls，由 EVM 执行引擎在同一条交易上下文中完成。

## 代币与合约账户的关系

代币储存在合约账户的storage中，转账时，EOA向合约账户发起一笔交易，调用转账函数，合约代码在执行过程中更新双方的余额等存储项，这个过程在EVM里执行。**EOA 地址本身并不存放 ERC-20 / ERC-721 代币对象**，它只在代币合约的映射里作为一行 key 出现。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->















# 1.13 学习笔记

## **节点和客户端的关系以及客户端间的协同配合**

客户端是软件实现，节点是跑着软件（客户端）的“电脑”。有验证者在的节点就是一个“验证节点”。

-   执行客户端就像法院里的书记员 + 案卷系统，负责接收材料、执行具体流程、更新“案卷状态”。**EVM + 状态 + RPC**，相当于“世界计算机”的 CPU + 内存 + 本地数据库 + RPC 网关。
    
-   共识客户端就像法官，根据书记员提供的案卷（执行结果），做出“这是不是合法区块、最终选哪条链”的裁决。**PoS + Beacon + Finality**
    

**上述两项通过Engine API连接**

-   以太坊节点 = 一台电脑 + 两个必备客户端 + （可选）一个验证者客户端
    

**对于开发者来说需要记住的内容：**

调用 eth\_\* / 部署合约 / 查状态找的是 执行客户端（EVM + JSON-RPC）；质押 32 ETH 做验证者 / 关心 attestation、finality、slashing是共识客户端 + 验证者客户端的工作。

**为什么要拆两块？**

为了模块化、易维护、多客户端实现、独立升级，以及更清晰的安全边界： 执行层可以专心把 EVM 和状态做到极致性能，共识层可以独立演进 PoS、PBS 等协议设计。

-   执行客户端负责“算结果、管状态”，共识客户端负责“选哪条结果被全网认可”，两者通过 Engine API 三大动作 newPayload / forkchoiceUpdated / getPayload 互相配合。
    

## 以太坊节点的“社交流程”

先找到人（UDP + Kademlia） → 再拉上加密专线（TCP + RLPx/devp2p） → 最后靠八卦（gossip）把消息传满全网（Gossip + 请求/响应）

## 全节点、轻节点、归档节点的区别

| 类型 | 存储什么数据 | 资源消耗 | 典型用途 | 信任 / 安全属性 |
| --- | --- | --- | --- | --- |
| 全节点 | 全部区块 + 最近若干块的完整状态（老状态会被修剪） | 中等（数百 GB 级磁盘 + 稳定带宽） | 自托管 RPC 节点、参与网络、做验证者的基础 | 自己验证所有交易和区 块，最信任最抗审查 |
| 归档节点 | 全节点数据 + 从创世到现在的所有历史状态快照 | 极高（TB 级磁盘） | 区块浏览器、链上分析、历史调试与回测、节点服务商 | 同全节点，但还能随时 回答“任意高度的任意 状态” |
| 轻节点 | 区块头 + 必要的轻客户端数据，不存完整区块和状态 | 很低（适合手机 / 嵌入式） | 轻钱包、浏览器插件、跨链桥验证、 IoT 设备 | 通过状态根 + Merkle 证明验证数据，安全性 接近全节点，但数据依 赖全节点提供 |

**轻节点不参与共识，不能做验证者**

## RPC节点（服务商）通俗解释

就像一个客服中心，它内部连接数据库或后台系统，查出余额／交易 状态后告诉你答案。 你不需要知道客服后台系统内部结构，也不需要自己去部署整个数据库与服务器；只要有客服电话号码（RPC endpoint）和合适的询问方式（RPC 方法名 + 参数），就能得到你想要的信息。

**更好的方式：**

-   作为普通开发者，自己跑**全节点**，可以独立完成所有事情，更加独立隐私，更高的去中心化程度；同时选择一个“不是头部垄断”的客户端，这实际上就是在非常直接地增强以太坊的弹性和去中心化。此外，还能拥有\*\*“治理话语权”\*\*，拥有升级与分叉的选择权。
    
-   作为**需要大量历史查询 / 调试 / 审计的机构**，自己维护一套**归档节点**。
    

## 节点同步

| 模式 | 核心特点 | 优点 | 缺点 | 适合谁 |
| --- | --- | --- | --- | --- |
| Full 同步 | 从创世块开始，按顺序把所有历史交易都执行一遍。 | 数据最完整，安全性最高，可完全独立验证全链历史。 | 同步时间最长，占用磁盘和带宽最大。 | 交易所、基础设施服务商、对安全和完整历史要求极高的节点。​ |
| Snap 同步 | 从比较新的检查点块开始，同步一份“状态快照”，再从那之后正常追块。 | 同步速度很快，是 Geth 默认模式，资源占用比 Full 小很多。 | 最早那一段历史状态不是本地一点点算出来的，而是基于快照信任网络多数节点。 | 想跑“正常全节点”，但又不想等太久、硬盘没那么豪华的开发者和个人玩家。​ |
| Light 同步 | 只保存区块头，需要具体数据时再向全节点“按需查询”。 | 启动飞快，占用磁盘和带宽极小，非常轻量。 | 依赖外部全节点提供数据，不能离线完整验证全网状态。 | 手机钱包、浏览器插件钱包等，只需查自己相关数据的客户端。 |

## 助记词和私钥的关系

助记词是钱包，私钥是钱包里的夹层。助记词可以推出很多私钥，私钥推不出助记词。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->




































## 今日学习目标（周一 1.12）

1.  **读完 Web3 实习手册**[**「入门导读」**](https://web3intern.xyz/zh/blockchain-basic/)**部分，并写出自己的理解**
    

-   用 2–3 句话回答「什么是区块链、它解决了什么问题」。
    

区块链是一个由很多节点共同维护的**去中心化**账本，按时间顺序把交易打包成区块，串成链，并且记录一旦写入就很难被篡改。它主要解决的是在不完全信任对方、没有单一中心的情况下，大家还能对同一份账本达成一致。

-   列出自己觉得最重要的 3 个概念​。
    

Layer 2（对技术岗十分重要）| Gas （所有链上操作都要付费）| EVM（以太坊“核心引擎”）

**Web3 不等于 Web3.0 ！**

2.  **完成 021 学习以太坊第 1 章的第一次通读**
    

-   知道以太坊大概是干什么的、和比特币的核心区别（不需要记细节）。
    

以太坊更像是一台大家共享的“世界计算机”，能够通过执行智能合约来实现很多功能，有更完整的区块链生态；而比特币作为“数字黄金”，主要在金融相关的领域使用（例如储值和投资），在支付以外的应用生态（DeFi、NFT、游戏等）上，相比以太坊要少得多。

3.  **阅读拓展 & 辅助材料（optional)**
    

-   [Day 1: A Developer’s Guide to Building on Ethereum](https://www.youtube.com/watch?v=zuJ-elbo88E&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=1) - Intro
    
-   [Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)
    
-   [Uniswap V2 学习官方文档](https://docs.uniswap.org/contracts/v2/overview?utm_source=chatgpt.com)
    

4.  **Web3 行业全局介绍分享会重点**
    

-   竞争情况：热门岗位平均一个职位收到450份简历，初级人才过剩，精英极度短缺。70%的面试会考察AI工具使用能力和链上交互记录。
    
-   薪酬梯队：
    

第一梯队：智能合约开发和合规法务，senior月薪可破10万

第二梯队：研究员和核心产品

第三梯队：运营和增长，初级8000-1.5万，但做好增长的奖金和token分成可能超过开发

-   **如何求职：**
    

**进入Web3的三条主要路径**

1.  从Web2迁移：带着能力和资源从传统互联网转型，特别欢迎有海外工作经验、英文好、能独立交付项目的人才
    
2.  生态嵌入：在DAO里接任务、在开源社区贡献代码、写研究报告，积累贡献后项目方会主动联系
    
3.  建立链上声誉：在Twitter/Farcaster持续输出深度内容、参加Space活动，公域流量池是最好的社交简历
    

**对自己来说，短期更适合的路径可能是：1. 在开源社区贡献代码；2. 在Twitter持续输出深度内容。**

**打造链上简历很重要！！！**

**技术岗：**

1.  掌握Solidity（最基础）
    
2.  了解新语言如Rust、Move、Cairo、Funk
    
3.  具备安全意识和系统设计能力
    
4.  理解DeFi机制
    

**当前短期目标：学会Solidity和Rust**
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
