---
timezone: UTC+8
---

# yanzhuchen96-creator

**GitHub ID:** yanzhuchen96-creator

**Telegram:** @cydot0906

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->
## EOA VS 合约账户（类比银行卡 VS 自动售货机）

| 维度 | EOA | 合约账户 |
| --- | --- | --- |
| 控制主体 | 私钥持有者（人 / 程序）​ | 合约代码逻辑本身​ |
| 是否有私钥 | 有（私钥 → 公钥 → 地址）​ | 无，不能签名​ |
| 是否能签名 | 能，对交易签名​ | 不能，所有调用都由外部交易触发​ |
| 发起交易 | 可以主动发起交易​ | 不能主动发起，只能被消息调用（internal call）​ |
| 创建成本与方式 | 生成 EOA 只是本地生成一对 key pair，不需要上链、不花 gas。 | 部署合约账户必须发一笔 “创建合约交易”，把 bytecode 写入链上，需要支付不少 gas。 |
| 状态 | 只有余额和随机 nonce​ | 余额 + 代码 + 存储（状态树）​ |

**可以通过 RPC 方法 eth\_getCode(address) 判断某地址是否为合约账户：如果返回的代码非空，就说明有智能合约存在，是合约账户；否则为 EOA。**

## CREATE VS CREATE2

| 维度 | CREATE | CREATE2 |
| --- | --- | --- |
| 地址是否可预测 | 依赖部署者 nonce，部署前不好精确算地址（要模拟或推演 nonce）。 | 由 部署者地址 + salt + init_code 决定，部署前就能精确算出地址。 |
| 跟什么有关 | 跟“当前第几次部署/发交易”的 nonce 强绑定，顺序变地址就变。 | 跟 sender、salt、init_code 强绑定，和 nonce、部署顺序无关。 |
| 典型用途 | 普通合约部署，一般随手 new 一个合约就用它。 | 需要“先知道地址再部署”的场景：合约工厂、预先授权、钱包预创建等。 |
| 是否能“先占坑后部署” | 基本不行，地址前期不好引用。 | 可以先算出未来地址，提前写进别的合约或权限里，再真正部署。 |
| 地址复用可能性 | 通常视为 “一次性地址”，销毁后也很少复用同址。 | 在旧合约被销毁后，可用同一 sender+salt+init_code 再部署回同一个地址（要非常谨慎）。 |

## 0x是什么？为什么要用0x？必须写吗？

0x相当于 “货币符号”，用来告诉人和程序：后面这一串是十六进制数字。用0x的好处是，一眼能看出是**地址 / hex**，而不是什么别的东西，避免和其它内容混淆，这使得在文档或者代码里查找都更加方便。从 “数学意义” 上看，0x并不算地址的一部分，所以写不写都行，都能识别，但出于能 **“让人和程序一眼识别”** 的目的，推荐带上0x。

## 账户抽象的通俗解释

用一套机制（如 ERC-4337，EIP-7702），让**合约钱包**可以像普通账户那样发起操作，还能自己写规则（怎么验证、怎么付费、怎么玩安全），从而大幅改造 “账户能力”，而不只是“EOA 私钥签交易”这一种模式。

真正 “发交易”的还是 EOA，合约自己不能直接把交易丢进区块链，只能在交易内部继续调用别的合约。账户抽象做的事是搭一层 “中间系统”，对用户来说就像 “这个合约账户在主动发交易、主动操作”。​

## 在codehash中，为什么要存哈希而不是直接把code塞进账户对象？

在账户里放一整段合约代码很占空间，状态树会变得又大又难同步。代码实际单独存储，账户里只存 codeHash 作为 “指针 + 防篡改承诺”。通过 eth\_getCode(address) 可以根据 codeHash 拿回真实字节码。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->










# 1.13 学习笔记

## **节点和客户端的关系以及客户端间的协同配合**

客户端是软件实现，节点是跑着软件（客户端）的“电脑”。有验证者在的节点就是一个“验证节点”。

-   执行客户端就像法院里的书记员 + 案卷系统，负责接收材料、执行具体流程、更新“案卷状态”。**EVM + 状态 + RPC**，相当于“世界计算机”的 CPU + 内存 + 本地数据库 + RPC 网关。
    
-   共识客户端就像法官，根据书记员提供的案卷（执行结果），做出“这是不是合法区块、最终选哪条链”的裁决。**PoS + Beacon + Finality**
    

**上述两项通过Engine API连接**

-   以太坊节点 = 一台电脑 + 两个必备客户端 + （可选）一个验证者客户端
    

**对于开发者来说需要记住的内容：**

调用 eth\_\* / 部署合约 / 查状态找的是 执行客户端（EVM + JSON-RPC）；质押 32 ETH 做验证者 / 关心 attestation、finality、slashing是共识客户端 + 验证者客户端的工作。

**为什么要拆两块？**

为了模块化、易维护、多客户端实现、独立升级，以及更清晰的安全边界： 执行层可以专心把 EVM 和状态做到极致性能，共识层可以独立演进 PoS、PBS 等协议设计。

-   执行客户端负责“算结果、管状态”，共识客户端负责“选哪条结果被全网认可”，两者通过 Engine API 三大动作 newPayload / forkchoiceUpdated / getPayload 互相配合。
    

## 以太坊节点的“社交流程”

先找到人（UDP + Kademlia） → 再拉上加密专线（TCP + RLPx/devp2p） → 最后靠八卦（gossip）把消息传满全网（Gossip + 请求/响应）

## 全节点、轻节点、归档节点的区别

| 类型 | 存储什么数据 | 资源消耗 | 典型用途 | 信任 / 安全属性 |
| --- | --- | --- | --- | --- |
| 全节点 | 全部区块 + 最近若干块的完整状态（老状态会被修剪） | 中等（数百 GB 级磁盘 + 稳定带宽） | 自托管 RPC 节点、参与网络、做验证者的基础 | 自己验证所有交易和区 块，最信任最抗审查 |
| 归档节点 | 全节点数据 + 从创世到现在的所有历史状态快照 | 极高（TB 级磁盘） | 区块浏览器、链上分析、历史调试与回测、节点服务商 | 同全节点，但还能随时 回答“任意高度的任意 状态” |
| 轻节点 | 区块头 + 必要的轻客户端数据，不存完整区块和状态 | 很低（适合手机 / 嵌入式） | 轻钱包、浏览器插件、跨链桥验证、 IoT 设备 | 通过状态根 + Merkle 证明验证数据，安全性 接近全节点，但数据依 赖全节点提供 |

**轻节点不参与共识，不能做验证者**

## RPC节点（服务商）通俗解释

就像一个客服中心，它内部连接数据库或后台系统，查出余额／交易 状态后告诉你答案。 你不需要知道客服后台系统内部结构，也不需要自己去部署整个数据库与服务器；只要有客服电话号码（RPC endpoint）和合适的询问方式（RPC 方法名 + 参数），就能得到你想要的信息。

**更好的方式：**

-   作为普通开发者，自己跑**全节点**，可以独立完成所有事情，更加独立隐私，更高的去中心化程度；同时选择一个“不是头部垄断”的客户端，这实际上就是在非常直接地增强以太坊的弹性和去中心化。此外，还能拥有\*\*“治理话语权”\*\*，拥有升级与分叉的选择权。
    
-   作为**需要大量历史查询 / 调试 / 审计的机构**，自己维护一套**归档节点**。
    

## 节点同步

| 模式 | 核心特点 | 优点 | 缺点 | 适合谁 |
| --- | --- | --- | --- | --- |
| Full 同步 | 从创世块开始，按顺序把所有历史交易都执行一遍。 | 数据最完整，安全性最高，可完全独立验证全链历史。 | 同步时间最长，占用磁盘和带宽最大。 | 交易所、基础设施服务商、对安全和完整历史要求极高的节点。​ |
| Snap 同步 | 从比较新的检查点块开始，同步一份“状态快照”，再从那之后正常追块。 | 同步速度很快，是 Geth 默认模式，资源占用比 Full 小很多。 | 最早那一段历史状态不是本地一点点算出来的，而是基于快照信任网络多数节点。 | 想跑“正常全节点”，但又不想等太久、硬盘没那么豪华的开发者和个人玩家。​ |
| Light 同步 | 只保存区块头，需要具体数据时再向全节点“按需查询”。 | 启动飞快，占用磁盘和带宽极小，非常轻量。 | 依赖外部全节点提供数据，不能离线完整验证全网状态。 | 手机钱包、浏览器插件钱包等，只需查自己相关数据的客户端。 |

## 助记词和私钥的关系

助记词是钱包，私钥是钱包里的夹层。助记词可以推出很多私钥，私钥推不出助记词。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->































## 今日学习目标（周一 1.12）

1.  **读完 Web3 实习手册**[**「入门导读」**](https://web3intern.xyz/zh/blockchain-basic/)**部分，并写出自己的理解**
    

-   用 2–3 句话回答「什么是区块链、它解决了什么问题」。
    

区块链是一个由很多节点共同维护的**去中心化**账本，按时间顺序把交易打包成区块，串成链，并且记录一旦写入就很难被篡改。它主要解决的是在不完全信任对方、没有单一中心的情况下，大家还能对同一份账本达成一致。

-   列出自己觉得最重要的 3 个概念​。
    

Layer 2（对技术岗十分重要）| Gas （所有链上操作都要付费）| EVM（以太坊“核心引擎”）

**Web3 不等于 Web3.0 ！**

2.  **完成 021 学习以太坊第 1 章的第一次通读**
    

-   知道以太坊大概是干什么的、和比特币的核心区别（不需要记细节）。
    

以太坊更像是一台大家共享的“世界计算机”，能够通过执行智能合约来实现很多功能，有更完整的区块链生态；而比特币作为“数字黄金”，主要在金融相关的领域使用（例如储值和投资），在支付以外的应用生态（DeFi、NFT、游戏等）上，相比以太坊要少得多。

3.  **阅读拓展 & 辅助材料（optional)**
    

-   [Day 1: A Developer’s Guide to Building on Ethereum](https://www.youtube.com/watch?v=zuJ-elbo88E&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=1) - Intro
    
-   [Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)
    
-   [Uniswap V2 学习官方文档](https://docs.uniswap.org/contracts/v2/overview?utm_source=chatgpt.com)
    

4.  **Web3 行业全局介绍分享会重点**
    

-   竞争情况：热门岗位平均一个职位收到450份简历，初级人才过剩，精英极度短缺。70%的面试会考察AI工具使用能力和链上交互记录。
    
-   薪酬梯队：
    

第一梯队：智能合约开发和合规法务，senior月薪可破10万

第二梯队：研究员和核心产品

第三梯队：运营和增长，初级8000-1.5万，但做好增长的奖金和token分成可能超过开发

-   **如何求职：**
    

**进入Web3的三条主要路径**

1.  从Web2迁移：带着能力和资源从传统互联网转型，特别欢迎有海外工作经验、英文好、能独立交付项目的人才
    
2.  生态嵌入：在DAO里接任务、在开源社区贡献代码、写研究报告，积累贡献后项目方会主动联系
    
3.  建立链上声誉：在Twitter/Farcaster持续输出深度内容、参加Space活动，公域流量池是最好的社交简历
    

**对自己来说，短期更适合的路径可能是：1. 在开源社区贡献代码；2. 在Twitter持续输出深度内容。**

**打造链上简历很重要！！！**

**技术岗：**

1.  掌握Solidity（最基础）
    
2.  了解新语言如Rust、Move、Cairo、Funk
    
3.  具备安全意识和系统设计能力
    
4.  理解DeFi机制
    

**当前短期目标：学会Solidity和Rust**
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
