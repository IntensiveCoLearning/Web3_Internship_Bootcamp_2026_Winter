---
timezone: UTC+8
---

# wuqi030624

**GitHub ID:** wuqi030624

**Telegram:** @wuqi030624

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
# Hardhat 学习笔记：本地节点交互教程

## 一、Hardhat 概述

Hardhat 是一个基于 JavaScript/TypeScript 的以太坊开发环境，被称为"工程正规军"的标配工具。相比 Foundry 的命令行风格，Hardhat 更像是一个完整的工程化解决方案，特别适合有前端开发经验的开发者。

**核心优势：**

-   使用 JavaScript/TypeScript 编写脚本和测试
    
-   对前端开发者极其友好
    
-   测试代码与前端代码风格一致，便于全栈开发
    
-   丰富的插件生态系统
    

* * *

## 二、核心概念

### 1\. Hardhat Network

本地开发链，相当于一个私有的测试服务器（类似 Foundry 的 Anvil），提供20个预置账户供测试使用。

### 2\. Scripts（脚本）

自动化执行脚本，用 JavaScript 编写，用于自动化部署合约、执行批量操作等。

### 3\. Console（控制台）

交互式 JavaScript 环境，可以实时与已部署的合约进行交互，调试和测试功能。

* * *

## 三、环境准备

### 前置条件

确保已安装 Node.js，验证方法：

bash

```bash
node -v
```

输出版本号即表示安装成功。

* * *

## 四、项目初始化流程

### 步骤 1：创建项目目录并安装依赖

bash

```bash
mkdir my_hardhat_project
cd my_hardhat_project
npm init -y
npm install --save-dev hardhat
```

### 步骤 2：初始化 Hardhat 项目

bash

```bash
npx hardhat init
```

**重要提示：** 使用键盘上下键选择 "Create a JavaScript project"，然后一路确认。

* * *

## 五、启动本地节点

在终端（窗口1）执行：

bash

```bash
npx hardhat node
```

**启动成功标志：**

-   显示 20 个测试账户（Account #0 ~ #19）
    
-   显示 `Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/`
    

**注意：** 此窗口需保持开启状态，不要关闭。

* * *

## 六、智能合约开发

### 示例合约：Counter.sol

在 `contracts/` 目录下创建 `Counter.sol`：

solidity

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract Counter {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }
}
```

### 编译合约

在窗口2执行：

bash

```bash
npx hardhat compile
```

成功标志：输出 `Compiled 1 Solidity file`

* * *

## 七、部署脚本编写

### 创建部署脚本

在 `scripts/` 目录下新建 `deploy.js`：

javascript

```javascript
const hre = require("hardhat");

async function main() {
    // 1. 获取合约工厂（获取合约的部署模板）
    const Counter = await hre.ethers.getContractFactory("Counter");
    
    // 2. 开始部署
    const counter = await Counter.deploy();
    
    // 3. 等待部署完成
    await counter.waitForDeployment();
    
    // 4. 打印部署地址
    console.log("合约已部署到:", await counter.getAddress());
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
```

### 执行部署

bash

```bash
npx hardhat run scripts/deploy.js --network localhost
```

**关键参数说明：**

-   `--network localhost`：指定部署到本地运行的 Hardhat Network，而非内存中临时执行
    

**部署成功后：** 记录输出的合约地址（如 `0x5FbDB2315678afecb367f032d93F642f64180aa3`）

* * *

## 八、Console 交互操作

### 进入控制台

bash

```bash
npx hardhat console --network localhost
```

进入后会显示 `>` 提示符。

### 连接已部署的合约

javascript

```javascript
const counter = await ethers.getContractAt("Counter", "0x5FbDB2315678afecb367f032d93F642f64180aa3")
```

（将地址替换为实际部署地址）

### 读取状态（Call 操作）

javascript

```javascript
await counter.number()
```

输出：`0n`（`n` 表示 BigInt 大整数类型）

### 修改状态（Send 操作）

javascript

```javascript
await counter.setNumber(99)
```

执行后会返回交易信息（hash, gasPrice 等），同时窗口1的节点会显示交易日志。

### 验证修改结果

javascript

```javascript
await counter.number()
```

输出：`99n`

### 退出控制台

按两次 `Ctrl + C`

* * *

## 九、`await` 关键字说明

在 Console 中频繁使用的 `await` 关键字用于等待异步操作完成。由于区块链操作（读取、写入）都是异步的，需要使用 `await` 等待结果返回。

* * *

## 十、常见报错及解决方案

| 报错信息 | 原因分析 | 解决方案 |
| --- | --- | --- |
| HH100: Network localhost doesn't exist | 命令中缺少 --network localhost 参数，或配置文件问题 | 检查命令拼写，确保参数正确 |
| connect ECONNREFUSED 127.0.0.1:8545 | 本地节点未启动 | 在窗口1执行 npx hardhat node 启动节点 |
| ReferenceError: ethers is not defined | 未通过正确方式进入控制台，或插件未安装 | 使用 npx hardhat console 进入控制台 |

* * *

## 十一、Hardhat vs Foundry 选型建议

| 维度 | Hardhat | Foundry |
| --- | --- | --- |
| 语言 | JavaScript/TypeScript | Solidity |
| 适合人群 | 前端开发者、全栈开发者 | 纯合约开发者 |
| 特点 | 工程化、插件丰富、前端友好 | 极速、命令行风格、黑客感 |
| 学习曲线 | 需要 JS 基础 | 命令更直接，原理更清晰 |
| 应用场景 | 全栈 DApp 开发、前端交互 | 纯合约开发、高效测试 |

**推荐学习路径：** 先用 Foundry 理解区块链交互原理（命令直接，无需复杂脚本），再用 Hardhat 学习与前端对接的工程实践。

* * *

## 十二、核心命令速查表

| 功能 | 命令 |
| --- | --- |
| 初始化项目 | npx hardhat init |
| 启动本地节点 | npx hardhat node |
| 编译合约 | npx hardhat compile |
| 执行脚本（本地网络） | npx hardhat run scripts/deploy.js --network localhost |
| 进入控制台 | npx hardhat console --network localhost |

* * *

## 十三、总结

Hardhat 通过 JavaScript 脚本和交互式控制台，提供了一套完整的以太坊开发工作流。其"双窗口实战"模式（一个窗口运行节点，一个窗口执行操作）是本地开发的标准范式。掌握 Hardhat 对于构建完整的 DApp（包含前端交互）至关重要。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->

# Foundry 学习笔记

## 1\. 概述

Foundry 是一套用于以太坊应用开发的命令行工具集，能够帮助开发者在本地环境中创建区块链网络、编写智能合约、部署以及与链上数据进行交互。相比于图形化界面，Foundry 提供了一种更接近底层交互原理（类似 RPG 游戏中的命令行控制）的开发体验。

## 2\. 核心组件

在 Foundry 的开发流程中，三个主要工具扮演了不同的角色：

-   **Anvil (铁砧 - 本地节点/服务器)**
    
    -   **作用**：在本地电脑上启动一条测试用的区块链。
        
    -   **性质**：它是交互的基础环境。Anvil 运行时，本地链存在；关闭后，链上数据（世界状态）消失。
        
-   **Forge (锻造 - 开发工具)**
    
    -   **作用**：用于项目的初始化、合约编写、编译以及部署。
        
    -   **类比**：造物主工具，负责创造智能合约并将其放置到 Anvil 提供的世界中。
        
-   **Cast (施法 - 交互工具)**
    
    -   **作用**：用于与已部署的智能合约进行互动，包括查询状态和执行交易。
        
    -   **类比**：游戏手柄，用于操作合约（如读取数据、修改数据）。
        

## 3\. 环境搭建与初始化

### 3.1 安装 Foundry

在 macOS 或 Linux 终端中执行以下步骤：

1.  **下载安装脚本**：
    
    Bash
    
    ```
    curl -L https://foundry.paradigm.xyz | bash
    ```
    
2.  **更新环境变量**：根据提示运行 `source ~/.zshrc` 或重启终端。
    
3.  **安装二进制文件**：运行 `foundryup` 下载 `forge`, `cast`, `anvil` 等核心组件。
    
4.  **验证安装**：运行 `forge --version` 检查是否成功。
    

### 3.2 项目初始化

-   **创建新项目**：
    
    Bash
    
    ```
    forge init my_first_dapp
    cd my_first_dapp
    ```
    
-   **目录结构**：
    
    -   `src/`：存放智能合约源文件（默认包含 `Counter.sol`）。
        
    -   `test/`：存放测试文件。
        
    -   `script/`：存放部署脚本。
        

## 4\. 实战交互流程

本流程以默认的计数器合约（`Counter.sol`）为例，演示从启动链到修改数据的完整过程。需开启两个终端窗口。

### 第一步：启动本地节点 (Terminal 1)

-   **命令**：输入 `anvil` 启动。
    
-   **关键信息**：启动后会显示一组测试用的账户和私钥。
    
    -   **注意**：需复制 `Private Keys` 下的第一行私钥（`0xac09...` 开头），这是拥有无限测试代币的管理员账户，用于后续部署和支付 Gas 费。
        
-   **状态**：保持该窗口运行，不要关闭。
    

### 第二步：部署合约 (Terminal 2)

在项目根目录（如 `my_first_web3`）下执行部署操作。

-   **命令**：
    
    Bash
    
    ```
    forge create src/Counter.sol:Counter \
      --rpc-url http://127.0.0.1:8545 \
      --private-key <你的私钥> \
      --broadcast
    ```
    
-   **参数说明**：
    
    -   `--rpc-url`：指定连接的本地节点地址。
        
    -   `--private-key`：用于签名的私钥（来自 Anvil）。
        
    -   `--broadcast`：广播交易上链。
        
-   **结果**：部署成功后，终端会返回 `Deployed to: 0x...`。此 **合约地址** 需复制保存，用于后续交互。
    

### 第三步：合约交互 (Terminal 2)

使用 `cast` 工具对合约进行“读”和“写”操作。

1\. 读取数据 (Call)

-   **操作**：查询合约当前的计数值。
    
-   **特点**：免费操作，不需要消耗 Gas，不需要私钥签名。
    
-   **命令**：
    
    Bash
    
    ```
    cast call <合约地址> "number()" --rpc-url http://127.0.0.1:8545 | cast --to-dec
    ```
    
-   **技巧**：默认返回值为 16 进制，管道符后接 `cast --to-dec` 可将其转换为十进制以便阅读。
    

2\. 修改数据 (Send)

-   **操作**：调用 `setNumber` 函数将计数值修改为 666。
    
-   **特点**：付费操作，改变了链上状态，需要消耗 Gas，必须提供私钥进行签名。
    
-   **命令**：
    
    Bash
    
    ```
    cast send <合约地址> "setNumber(uint256)" 666 \
      --rpc-url http://127.0.0.1:8545 \
      --private-key <你的私钥>
    ```
    
-   **现象**：执行后，运行 `anvil` 的第一个窗口会滚动日志，表明交易已被打包处理。
    

3\. 验证结果

再次运行读取命令（Call），确认返回值已变为 `666`，证明状态修改成功。

## 5\. 常见问题排查 (Troubleshooting)

-   **Error: Connection refused**
    
    -   **原因**：本地节点未启动或已关闭。
        
    -   **解法**：检查第一个终端窗口是否正在运行 `anvil`。
        
-   **Error: Contract not found**
    
    -   **原因**：当前路径错误。
        
    -   **解法**：使用 `ls` 检查当前目录下是否存在 `foundry.toml` 配置文件，确保在项目根目录操作。
        
-   **Error: Bad key**
    
    -   **原因**：私钥格式错误。
        
    -   **解法**：确保复制的私钥是完整的，且以 `0x` 开头。
        

## 6\. 学习总结与原理映射

通过命令行操作 Foundry，实际上是在模拟真实的以太坊交互过程：

-   **Anvil** 对应 **以太坊主网/测试网**。
    
-   **Cast Send** 对应 **钱包（如 MetaMask）中的“确认交易”**（涉及签名和 Gas 费）。
    
-   **Cast Call** 对应 **DApp 前端的数据展示**（只读请求）。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->


### Remix IDE ：以太坊智能合约开发基础

1\. 工具概述

[**Remix IDE**](https://www.google.com/search?q=https://remix.ethereum.org/) 是以太坊官方推荐的基于浏览器的集成开发环境（IDE）。

-   **核心优势**：无需本地环境配置（Zero-setup），打开浏览器即可编写、编译、部署和调试 Solidity 智能合约。
    
-   **适用场景**：快速原型开发、教学演示、轻量级合约测试。
    

* * *

2\. 核心界面架构

Remix 的工作区主要由以下三个核心面板组成（位于左侧工具栏）：

-   **File Explorers (文件管理器)** !\[📂\]
    
    -   用于管理项目文件结构。支持创建文件 (`.sol`)、文件夹以及导入本地或 GitHub 代码。
        
-   **Solidity Compiler (编译器)** !\[🔌\]
    
    -   负责将人类可读的 Solidity 代码转换为机器可执行的字节码 (Bytecode)。
        
    -   **关键设置**：
        
        -   `Compiler Version`：需选择大于等于代码中 `pragma` 声明的版本。
            
        -   `Auto compile`：建议勾选，可实时检查语法错误。
            
-   **Deploy & Run Transactions (部署与交互)** !\[🚀\]
    
    -   负责将编译好的合约部署到区块链网络（或模拟环境），并提供交互界面调用合约函数。
        

* * *

3\. 标准开发全流程 (Lifecycle)

开发一个智能合约通常包含以下四个标准步骤：

步骤 I：创建 (Create)

在文件管理器中新建 Solidity 源文件，例如命名为 Storage.sol。

步骤 II：编写 (Code)

输入智能合约代码。以下为标准存储合约示例 (SimpleStorage)：

Solidity

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleStorage {
    // 状态变量：存储在链上，修改需要消耗 Gas
    uint256 public myNumber;

    // 写入函数 (Setter)：修改状态变量
    function store(uint256 _num) public {
        myNumber = _num;
    }

    // 读取函数 (Getter)：读取状态变量，View 类型不消耗 Gas
    function retrieve() public view returns (uint256) {
        return myNumber;
    }
}
```

步骤 III：编译 (Compile)

进入编译器面板，点击 Compile Storage.sol。

-   **成功标志**：图标显示绿色对钩。
    
-   **失败处理**：查看控制台报错信息并修正语法错误。
    

步骤 IV：部署与调试 (Deploy & Interact)

进入部署面板进行配置：

1.  **Environment (环境选择)**：
    
    -   `Remix VM (Cancun/London)`：浏览器内存中的模拟区块链，速度快，使用虚拟 ETH，适合测试逻辑。
        
    -   `Injected Provider - MetaMask`：连接浏览器钱包，用于部署到公共测试网 (如 Sepolia) 或主网。
        
2.  **Account (账户)**：Remix VM 默认提供多个预充值 100 ETH 的测试账户，可用于模拟不同用户行为。
    
3.  **Deploy (动作)**：点击部署按钮。
    
4.  **Deployed Contracts (交互)**：部署成功后，下方会出现合约实例。展开后可调用函数：
    
    -   `store`：输入参数，发起交易（写入数据）。
        
    -   `retrieve`：点击按钮，直接返回结果（读取数据）。
        

* * *

4\. 函数交互与 Gas 机制（颜色代码解析）

Remix 按钮的颜色直观反映了以太坊的计费与执行逻辑：

| 按钮颜色 | 对应操作类型 | Solidity 关键字 | Gas 费用 | 确认时间 |
| 蓝色 | 读取 (Read) | view / pure | 免费 | 瞬间返回 (本地执行) |
| 橙色 | 写入 (Write) | 无 (Transaction) | 付费 | 需等待区块打包 |
| 红色 | 支付 (Payable) | payable | 付费 + 转账 | 需等待区块打包 |

* * *

5\. 常见问题与解决方案 (Troubleshooting)

-   **代码丢失风险**：
    
    -   **现象**：刷新浏览器缓存后代码消失。
        
    -   **方案**：Remix 默认存储在浏览器本地存储中。重要代码务必**本地备份**，或使用 Remixd 连接本地文件系统。
        
-   **部署按钮不可用 (灰色)**：
    
    -   **原因**：通常是因为代码未编译或编译包含致命错误（红色报错）。
        
    -   **方案**：返回编译器面板修复所有红色错误，确保编译成功。
        
-   **多账户测试逻辑**：
    
    -   区块链数据是公开透明的。使用 Account A 写入的数据，切换到 Account B 依然可以读取 (`retrieve`)，这验证了链上数据的**公共可见性**。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->



# Solidity 高级特性与工程实践

## 1\. Gas 优化策略 (Gas Optimization)

在以太坊上，计算和存储都需要消耗 Gas。合约开发不仅要实现功能，还需极度关注成本优化。

-   **存储优化 (Storage Optimization)** `[00:51:53]`
    
    -   **原理**：链上存储（Storage）是 EVM 中最昂贵的操作。初始化一个非零存储槽大约消耗 20,000 Gas，修改存储值大约消耗 5,000 Gas。
        
    -   **策略**：
        
        -   尽量减少对状态变量（State Variables）的读写。
            
        -   在函数内部运算时，优先使用内存（Memory）变量或栈变量，计算完成后再统一写入 Storage，避免频繁操作 Storage。
            
        -   对于不需要链上逻辑读取的历史记录，优先使用 **Event (事件)** 进行存储，而非写入状态变量。
            
-   **算术运算优化 (**`unchecked` **代码块)** `[00:52:41]`
    
    -   **背景**：Solidity 0.8.0 之后内置了溢出检查（Overflow/Underflow Check），这虽然增加了安全性，但也带来了额外的 Gas 开销。
        
    -   **优化**：当你确定某段数学运算绝对不会溢出时（例如：循环变量 `i++` 或 肯定的减法逻辑），可以使用 `unchecked { ... }` 代码块包裹。这会跳过安全检查，直接执行底层指令，从而节省 Gas。
        
-   **错误处理优化 (**`revert` **vs** `require`**)** `[00:54:10]`
    
    -   **Custom Errors**：相比于使用 `require(condition, "Long error message string")`，使用自定义错误类型配合 `revert CustomError()` 更节省 Gas。因为存储和返回长字符串需要较高的成本。
        

## 2\. 智能合约架构与安全模式

-   **修饰器 (Modifiers) 的高级用法** `[01:02:02]`
    
    -   **作用**：用于提取通用的校验逻辑（如权限控制、状态检查），提高代码复用性和可读性。
        
    -   **机制**：修饰器中的 `_;` 符号代表被修饰函数的函数体执行位置。
        
    -   **示例**：`onlyOwner` 修饰器确保只有合约拥有者能调用关键函数（如 `mint`）。这避免了在每个函数中重复编写 `require(msg.sender == owner)`。
        
-   **重入攻击防护 (Reentrancy Guard)** `[01:06:58]`
    
    -   **风险**：当合约在更新自身状态前调用外部合约（如转账 ETH）时，攻击者可能利用回调机制递归调用原函数，导致资产被盗。
        
    -   **防御**：
        
        -   **检查-生效-交互 (Checks-Effects-Interactions)** 模式：先更新状态变量，再进行外部调用。
            
        -   **重入锁 (ReentrancyGuard)**：使用 OpenZeppelin 的 `nonReentrant` 修饰器锁定函数调用栈。
            

## 3\. 可升级合约原理 (Upgradeable Contracts)

由于区块链的不可篡改性，合约一旦部署无法修改。为了支持业务迭代和 Bug 修复，需要使用代理模式。

-   **代理模式 (Proxy Pattern)** `[01:26:12]`
    
    -   **架构分离**：将合约拆分为 **代理合约 (Proxy Contract)** 和 **逻辑合约 (Logic/Implementation Contract)**。
        
        -   **Proxy Contract**：负责存储所有状态数据（Storage），并提供对外地址。
            
        -   **Logic Contract**：仅包含业务逻辑代码，不存储真实状态。
            
    -   **核心机制：**`delegatecall` `[01:28:15]`
        
        -   当用户调用 Proxy 合约时，Proxy 使用 `delegatecall` 调用 Logic 合约。
            
        -   **关键特性**：代码在 Logic 合约中执行，但**上下文（Context）**（如 `msg.sender`, `msg.value`）和**数据存储（Storage）** 均停留在 Proxy 合约中。
            
    -   **升级方式**：只需部署新的 Logic 合约，并更新 Proxy 指向的逻辑合约地址即可，原有数据保留在 Proxy 中不变。
        
-   **注意事项**：
    
    -   **存储布局 (Storage Layout)**：升级时必须保证存储槽位的顺序和类型兼容，否则会导致数据错乱（Storage Collision）。
        

## 4\. 工程化最佳实践

-   **不要重复造轮子 (Don't Reinvent the Wheel)** `[01:23:46]`
    
    -   **OpenZeppelin 库**：对于 ERC20、ERC721、权限控制（Ownable）等标准功能，强烈建议继承 OpenZeppelin 的代码库。这些代码经过了严格的社区审查和专业审计，安全性远高于手写代码。
        
    -   **开发方式**：通过 `import "@openzeppelin/contracts/..."` 并使用 `is` 关键字继承。
        
-   **ABI 编码与解码 (ABI Encode/Decode)** `[01:08:31]`
    
    -   **ABI (Application Binary Interface)**：是链下程序（前端/脚本）与链上合约交互的桥梁。
        
    -   **Encode**：将函数调用和参数转换为 EVM 可执行的字节码（Bytecode）。
        
    -   **Decode**：将链上返回的字节码解析为可读数据。
        

## 5\. 代币标准扩展

-   **多重标准共存**：
    
    -   **ERC20**：同质化代币（如 USDT, UNI）。
        
    -   **ERC721**：非同质化代币（NFT）。
        
    -   **ERC1155**：半同质化代币，在一个合约中同时支持 FT 和 NFT。
        
-   **接口与实现**：ERC 标准只规定了“接口”（必须有哪些函数），具体的内部实现逻辑（如何存储、是否有特殊限制）由开发者自定义。只要接口一致，就能被钱包和交易所识别 `[01:19:56]`。
    

* * *

**总结**： 初学者在掌握 Solidity 基础语法后，应重点阅读 **OpenZeppelin** 的源码（特别是 `ERC20.sol` 和 `Ownable.sol`），并尝试理解 **EVM 的存储槽机制** 和 `delegatecall` 的工作原理，这是从“写代码”进阶到“架构设计”的关键门槛。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->




# Solidity 学习笔记：核心架构与语法概览

## 1\. 语言综述

Solidity 是一门**面向对象、静态类型**的高级编程语言，专为实现智能合约而设计。

-   **运行环境**：编译为字节码（Bytecode），运行在以太坊虚拟机（EVM）上。
    
-   **核心约束**：
    
    -   **Gas 机制**：每一行代码的执行都需要消耗算力资源（Gas），这要求代码逻辑必须极度精简和优化。
        
    -   **原子性**：函数调用是原子的。如果执行过程中抛出异常（Revert），所有状态更改都会回滚，如同交易从未发生。
        
    -   **不可篡改性**：合约一旦部署，字节码不可修改（除非采用 Proxy 代理模式）。
        

## 2\. 合约结构解析

一个标准的 Solidity 文件（`.sol`）通常包含以下组件。以下代码展示了一个基础的资金管理模型。

Solidity

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0; // 版本指令

// contract 关键字类似于面向对象语言中的 class
contract Vault {
    // --- 状态变量 (State Variables) ---
    // 永久存储在链上 (Storage)，修改它们极其消耗 Gas
    address public owner; 
    uint256 public balance; 

    // --- 事件 (Events) ---
    // 用于向前端或外部监听器抛出日志，不消耗状态存储空间
    event Deposit(address indexed sender, uint256 amount);

    // --- 构造函数 ---
    // 仅在部署时执行一次
    constructor() {
        owner = msg.sender; // msg.sender 代表当前调用者
    }

    // --- 修饰器 (Modifiers) ---
    // 用于封装通用的前置检查逻辑
    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _; // 下划线代表继续执行函数主体
    }

    // --- 功能函数 ---
    // payable 关键字：允许该函数接收 ETH
    function deposit() external payable {
        // 累加余额逻辑（注：address(this).balance 自动更新，此处仅作逻辑演示）
        balance += msg.value; 
        emit Deposit(msg.sender, msg.value);
    }

    // external: 仅允许从合约外部调用，比 public 略省 Gas
    function withdraw() external onlyOwner {
        uint256 amount = address(this).balance;
        // 交互逻辑：将合约余额转给调用者
        payable(msg.sender).transfer(amount);
    }
}
```

## 3\. 关键概念详解

### 3.1 内存布局 (Data Location)

这是 Solidity 与常规后端开发最大的区别。必须明确指定引用类型（数组、结构体、字符串）的数据存储位置。

| 关键字 | 存储位置 | 生命周期 | 成本 (Gas) | 适用场景 |
| storage | 区块链状态树 | 永久保存 | 极高 | 状态变量（默认），需要跨函数保存的数据 |
| memory | 内存 | 函数执行完即销毁 | 中等 | 临时变量，函数内部的计算逻辑 |
| calldata | 调用数据区 | 只读，随函数调用存在 | 最低 | 外部函数的输入参数（External Function Arguments） |

### 3.2 函数可见性 (Visibility)

决定了函数能否被内部或外部访问。

-   `public`: 内部、外部均可调用（自动生成 Getter 函数）。
    
-   `private`: 仅当前合约内部可见（继承的合约不可见）。
    
-   `internal`: 当前合约及继承的子合约可见（类似于 Java 的 protected）。
    
-   `external`: 仅外部可调用（内部调用需使用 `this.f()`）。
    

### 3.3 状态可变性 (State Mutability)

用于告知 EVM 该函数是否会修改链上数据。

-   `view`: **只读**。读取状态变量但不修改。不消耗 Gas（如果是外部调用）。
    
-   `pure`: **纯函数**。既不读取也不修改状态变量（通常用于数学计算）。
    
-   **无标记** (默认): 允许读取和修改状态。
    

### 3.4 错误处理 (Error Handling)

Solidity 不使用 try-catch 处理逻辑错误，而是通过状态回滚机制。

-   `require(condition, message)`: 最常用。用于验证输入或前置条件。若失败，**退回剩余 Gas** 并回滚。
    
-   `revert(message)`: 类似于 require，用于复杂的逻辑判断分支中主动触发回滚。
    
-   `assert(condition)`: 用于检查“绝不应该发生”的内部错误（如不变量检查）。若失败，**消耗所有 Gas**（Panic）。
    

## 4\. 常用数据结构

### Mapping (映射)

Solidity 中最常用的存储结构，类似于哈希表，但**无法遍历**（除非辅助存储 Key 列表）。

Solidity

```
// 定义：从 地址 映射到 余额
mapping(address => uint256) public balances;

// 访问与赋值
balances[msg.sender] = 100;
uint256 myBalance = balances[msg.sender];
```

### Struct (结构体)

用于定义复杂数据类型。

Solidity

```
struct User {
    uint256 id;
    bool isActive;
}
```

## 5\. 开发注意事项（与 JS 的思维转换）

1.  **没有浮点数**：Solidity 不支持 `float` 或 `double`。所有货币金额通常以最小单位（Wei）计算（1 ETH = $10^{18}$ Wei）。前端展示时需手动转换精度。
    
2.  **溢出保护**：Solidity 0.8.0+ 内置了数学溢出检查（Overflow/Underflow），无需再引入 SafeMath 库。
    
3.  **安全性优先**：
    
    -   **重入攻击 (Reentrancy)**: 攻击者在合约转账时回调合约函数。
        
    -   **防御范式**: Checks-Effects-Interactions（检查-生效-交互）。即先修改本合约的状态（如扣除余额），最后再发送 ETH。
        

* * *

后续计划：

在 Remix IDE 中创建一个新的 .sol 文件，尝试手写一个 Mapping 结构，实现“记录每个用户最后一次操作时间”的逻辑，以加深对 msg.sender 和 block.timestamp 的理解。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->





### 以太坊中文周会

### **会议总结**

这是一场关于以太坊技术发展与Web3的周度社区会议。会议涵盖了区块链快讯、技术提案讨论以及稳定币支付应用等多元主题。参会者分享了以太坊最新开发进展、技术优化方案及行业趋势分析，同时介绍了社区学习计划和相关活动信息。

**1、区块链快讯分享**

-   2026年以太坊将聚焦自主权和去信任，计划使用ZKEVM和BL简化节点运行，推出Helios验证RPC，并开发社会恢复钱包和时间锁功能。
    
-   2025年加密货币盗窃案损失达40.4亿美元，同比增长34.2%，其中诈骗损失增长64%。
    
-   以太坊上周平均每天新增32.7万个钱包，非空钱包总数达1.729亿。
    
-   上周SDE会议拒绝了七个提议的EIP，但将7954纳入考量范围，该提案旨在将countryside从24KB提升到32KB。
    
-   BNB升级后区块生产速度提升40%，最终确认时间降至1秒，降低了高波动市场中的滑点风险。
    

**2、新EIP提案介绍**

-   EIP778旨在防止开发者通过非零到零的操作突破gas limit限制。
    
-   EIP新增的opcode可返回当前区块的slot number，方便开发者跟踪区块时间。
    
-   EIP8024改善了开发者体验，允许更深的栈操作。
    

**3、稳定币在全球支付中的作用**

-   传统跨国支付手续费高达8%，且需3-5个工作日结算，而稳定币支付手续费仅0.1%-0.4%，秒级结算。
    
-   稳定币支付可绕过中间商，降低成本60%-80%，并支持实时追踪和审计。
    
-   企业可通过试点逐步推广稳定币支付，优先选择摩擦高的业务场景。
    

**4、Base和Sequence混合方案**

-   提出结合Base和Sequence的优点，Base提供同步可组合能力，Sequence提供低延迟。
    
-   通过slot ending block提示L1构建区块，实现低延迟和同步组合。
    

**5、DS改进方向**

-   提出使用rites coding替代固定码率编码，减少计算和存储开销。
    
-   rites coding抽样次数少，带宽需求低，适合以太坊的二维数据采样。
    

**6、MegaEase开源项目**

-   小型可验证的Trie数据结构将验证层数据从20GB降至1GB，提升计算速度十几倍。
    
-   Validator方案允许验证者无需完整状态数据库，降低硬件要求。
    
-   MegaEVM支持512KB合约代码，远超以太坊的24KB限制。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






本周完成了手册“入门导读”、“行业知识”及“前辈访谈”三个核心模块的学习。整体来看，这周的学习不仅仅是概念的扫盲，更是一次对 Web3 行业从底层技术叙事到上层人才需求的全景式梳理。

**一、 底层逻辑与行业叙事** 通过入门章节的学习，对行业的认知从碎片化的“加密货币”概念上升到了\*\*“去中心化协作”\*\*的系统层面。

-   **技术叙事：** 明确了以太坊不仅是资产层，更是“世界计算机”这一核心定位。理解了智能合约（Smart Contract）如何通过“Code is Law”在无须信任的环境下自动执行协议，这是 Web3 应用（DApp）区别于传统互联网应用的关键范式。
    
-   **组织变革：** 深入理解了 DAO（去中心化自治组织）的运作机制。它改变了传统的公司制生产关系，强调分布式办公、公开透明治理与社区共建。这种“分布式账本”技术对信任机制的重构，是理解所有 Web3 赛道（DeFi, NFT, Layer2）的基石。
    

**二、 岗位生态与核心技能** 在行业知识板块，重点梳理了 Web3 的人才画像与技能树，打破了“只有程序员才能入行”的误区。

-   **“Community First” 运营逻辑：** 区别于 Web2 的流量思维，Web3 的运营核心在于**共识构建**。社区不仅是用户集合，更是项目的护城河。掌握 Discord 运营、治理提案撰写以及从 0 到 1 建立社区文化，是运营岗位的核心竞争力。
    
-   **安全与合规红线：** “黑暗森林”法则不仅是比喻，更是实操中的生存底线。学习了关于私钥管理、防范钓鱼攻击以及不同地区的合规政策。在去中心化环境中，个人资产安全和业务合规性是开展任何工作的前置条件。
    

**三、 职业路径与实战方法论** 通过梳理行业前辈的访谈实录，总结出了一套可复用的职业切入方法论。

-   **从“做题家”到“链上实干家”：** 无论是技术还是非技术背景，核心竞争力来源于 **On-chain Action**（链上交互）。通过实际参与 DeFi 协议交互、贡献开源代码或参与 DAO 治理积累的“链上履历”，比传统简历更具说服力。
    
-   **跨界与转型：** 行业目前正处于从基础设施向应用层爆发的过渡期，对具备 Web2 成熟经验（如增长、产品体验优化）同时又能快速习得 Web3 原生语境的“双栖人才”有巨大需求。保持 Curiosity（好奇心）并快速迭代认知，是应对行业高波动性的唯一解法。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->







# Viem 学习笔记

## 一、Viem 简介

### 1.1 什么是 Viem？

Viem 是一个用于以太坊的 TypeScript 接口库，提供了与以太坊区块链交互的低级无状态原语。它是 ethers.js 和 web3.js 的现代替代品，专注于**可靠性、效率和出色的开发者体验**。

### 1.2 核心优势

Viem 解决了现有以太坊库在四个关键领域的不足：

-   **开发者体验**：自动类型安全和推断、完善的文档、可组合的API
    
-   **稳定性**：针对分叉的以太坊网络运行测试套件、完整的测试覆盖率
    
-   **包体积**：可摇树的轻量级模块
    
-   **性能**：优化的编码/解析、仅在必要时执行异步任务
    

### 1.3 安装

bash

```bash
# npm
npm i viem

# pnpm
pnpm i viem

# bun
bun i viem
```

* * *

## 二、客户端 (Clients)

Viem 中的客户端类似于 ethers.js 中的 Provider，提供对一组特定操作(Actions)的访问。

### 2.1 客户端类型

Viem 有三种类型的客户端：

| 客户端类型 | 用途 | 示例操作 |
| --- | --- | --- |
| Public Client | 访问公共操作 | getBlockNumber, getBalance |
| Wallet Client | 访问钱包操作 | sendTransaction, signMessage |
| Test Client | 访问测试操作 | mine, impersonate |

### 2.2 Public Client（公共客户端）

Public Client 是与"公共" JSON-RPC API 方法交互的接口，用于检索区块号、交易、读取智能合约等。

typescript

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const publicClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

// 使用公共操作
const blockNumber = await publicClient.getBlockNumber()
```

**重要配置选项**：

typescript

```typescript
const publicClient = createPublicClient({
  chain: mainnet,
  transport: http('https://eth-mainnet.g.alchemy.com/v2/<apiKey>'),
  
  // Multicall 批量优化
  batch: {
    multicall: true,        // 启用 eth_call 聚合
    // multicall: {
    //   batchSize: 512,     // 每批最大字节数
    //   wait: 16,           // 批量等待时间(ms)
    // }
  },
  
  // 缓存时间
  cacheTime: 10_000,        // 10秒
  
  // 轮询间隔
  pollingInterval: 4_000,   // 4秒（默认）
})
```

### 2.3 Wallet Client（钱包客户端）

Wallet Client 用于与以太坊账户交互，提供发送交易、签名消息等能力。

**使用 JSON-RPC 账户（浏览器钱包）**：

typescript

```typescript
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

// 创建客户端
const client = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})

// 获取账户地址
const [address] = await client.getAddresses()
// 或请求授权
const [address] = await client.requestAddresses()

// 发送交易
const hash = await client.sendTransaction({
  account: address,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('0.001')
})
```

**使用本地账户（私钥）**：

typescript

```typescript
import { createWalletClient, http, parseEther } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

// 从私钥创建账户
const account = privateKeyToAccount('0x...')

const client = createWalletClient({
  account,  // 可以将账户提升到客户端
  chain: mainnet,
  transport: http()
})

const hash = await client.sendTransaction({
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('0.001')
})
```

**扩展公共操作**：

typescript

```typescript
import { createWalletClient, http, publicActions } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'

const account = privateKeyToAccount('0x...')

// 使用 extend 扩展公共操作
const client = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
}).extend(publicActions)

// 现在可以同时使用公共操作和钱包操作
const { request } = await client.simulateContract({ ... })
const hash = await client.writeContract(request)
```

* * *

## 三、传输层 (Transports)

Transport 是客户端的中间层，负责执行出站请求（如 RPC 请求）。

### 3.1 HTTP Transport

typescript

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http('https://eth-mainnet.g.alchemy.com/v2/<apiKey>')
})
```

**支持批量 JSON-RPC**：

typescript

```typescript
const transport = http('https://...', {
  batch: true,  // 启用批量请求
  // batch: {
  //   batchSize: 1000,  // 每批最大请求数
  //   wait: 16,         // 等待时间(ms)
  // }
})

// 批量请求示例
const [blockNumber, balance, ensName] = await Promise.all([
  client.getBlockNumber(),
  client.getBalance({ address: '0x...' }),
  client.getEnsName({ address: '0x...' }),
])
```

**配置选项**：

typescript

```typescript
const transport = http('https://...', {
  fetchOptions: {
    headers: { 'Authorization': 'Bearer ...' }
  },
  retryCount: 5,      // 重试次数
  retryDelay: 150,    // 重试延迟(ms)
  timeout: 10_000,    // 超时时间(ms)
})
```

### 3.2 WebSocket Transport

typescript

```typescript
import { createPublicClient, webSocket } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: webSocket('wss://eth-mainnet.g.alchemy.com/v2/<apiKey>')
})
```

**配置选项**：

typescript

```typescript
const transport = webSocket('wss://...', {
  keepAlive: {
    interval: 1_000  // 心跳间隔
  },
  reconnect: {
    attempts: 5,     // 最大重连次数
    delay: 2_000,    // 重连延迟(ms)
  }
})
```

### 3.3 Custom Transport（自定义传输）

typescript

```typescript
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'

// 使用浏览器钱包
const client = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!)
})
```

### 3.4 Fallback Transport（回退传输）

typescript

```typescript
import { createPublicClient, http, fallback } from 'viem'
import { mainnet } from 'viem/chains'

const alchemy = http('https://eth-mainnet.g.alchemy.com/v2/<apiKey>')
const infura = http('https://mainnet.infura.io/v3/<apiKey>')

const client = createPublicClient({
  chain: mainnet,
  transport: fallback([alchemy, infura])
})
```

* * *

## 四、链配置 (Chains)

### 4.1 使用内置链

typescript

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet, polygon, optimism, arbitrum, base, zora } from 'viem/chains'

const client = createPublicClient({
  chain: polygon,
  transport: http()
})
```

### 4.2 自定义链

typescript

```typescript
import { defineChain } from 'viem'

export const myChain = defineChain({
  id: 7777777,
  name: 'My Chain',
  nativeCurrency: {
    decimals: 18,
    name: 'Ether',
    symbol: 'ETH',
  },
  rpcUrls: {
    default: {
      http: ['https://rpc.mychain.com'],
      webSocket: ['wss://rpc.mychain.com'],
    },
  },
  blockExplorers: {
    default: { name: 'Explorer', url: 'https://explorer.mychain.com' },
  },
  contracts: {
    multicall3: {
      address: '0xcA11bde05977b3631167028862bE2a173976CA11',
      blockCreated: 5882,
    },
  },
})
```

* * *

## 五、账户 (Accounts)

### 5.1 本地账户类型

-   **Private Key Account**：私钥账户
    
-   **Mnemonic Account**：助记词账户
    
-   **Hierarchical Deterministic (HD) Account**：分层确定性账户
    

### 5.2 创建私钥账户

typescript

```typescript
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')
```

### 5.3 JSON-RPC 账户

通过浏览器钱包（如 MetaMask）提供：

typescript

```typescript
const [address] = await window.ethereum.request({
  method: 'eth_requestAccounts'
})
```

* * *

## 六、公共操作 (Public Actions)

Public Actions 与公共以太坊 RPC 方法一一对应，不需要特殊权限。

### 6.1 账户相关

**获取余额**：

typescript

```typescript
import { formatEther } from 'viem'

const balance = await publicClient.getBalance({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
})

const balanceInEther = formatEther(balance)  // "6.942"
```

**获取交易计数（nonce）**：

typescript

```typescript
const count = await publicClient.getTransactionCount({
  address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
})
```

### 6.2 区块相关

**获取区块号**：

typescript

```typescript
const blockNumber = await publicClient.getBlockNumber()
```

**获取区块信息**：

typescript

```typescript
const block = await publicClient.getBlock({
  blockNumber: 69420n
})
```

**监听新区块**：

typescript

```typescript
const unwatch = publicClient.watchBlockNumber({
  onBlockNumber: (blockNumber) => console.log(blockNumber)
})

// 停止监听
unwatch()
```

### 6.3 Gas 相关

**估算 Gas**：

typescript

```typescript
const gas = await publicClient.estimateGas({
  account: '0x...',
  to: '0x...',
  value: parseEther('0.1')
})
```

**获取 Gas 价格**：

typescript

```typescript
const gasPrice = await publicClient.getGasPrice()
```

**获取费用估算**：

typescript

```typescript
const fees = await publicClient.estimateFeesPerGas()
// { maxFeePerGas, maxPriorityFeePerGas }
```

### 6.4 日志/事件

**获取日志**：

typescript

```typescript
import { parseAbiItem } from 'viem'

const logs = await publicClient.getLogs({
  address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 value)'),
  args: {
    from: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
    to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac'
  },
  fromBlock: 16330000n,
  toBlock: 16330050n
})
```

* * *

## 七、钱包操作 (Wallet Actions)

### 7.1 发送交易

typescript

```typescript
import { parseEther } from 'viem'

const hash = await walletClient.sendTransaction({
  account,
  to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
  value: parseEther('1')
})
```

**完整参数**：

typescript

```typescript
const hash = await walletClient.sendTransaction({
  account,
  to: '0x...',
  value: parseEther('1'),
  
  // 可选参数
  gas: 21000n,
  gasPrice: parseGwei('20'),           // Legacy 交易
  maxFeePerGas: parseGwei('20'),       // EIP-1559 交易
  maxPriorityFeePerGas: parseGwei('2'),
  nonce: 69,
  data: '0x...',
  chain: mainnet,
})
```

### 7.2 签名消息

typescript

```typescript
const signature = await walletClient.signMessage({
  account,
  message: 'hello world',
})

// 签名原始数据
const signature = await walletClient.signMessage({
  account,
  message: { raw: '0x68656c6c6f20776f726c64' },
})
```

### 7.3 签名类型化数据（EIP-712）

typescript

```typescript
const signature = await walletClient.signTypedData({
  account,
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: { name: 'Cow', wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826' },
    to: { name: 'Bob', wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB' },
    contents: 'Hello, Bob!',
  },
})
```

* * *

## 八、合约交互

### 8.1 读取合约 (readContract)

typescript

```typescript
const data = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'totalSupply',
})

// 带参数
const balance = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'balanceOf',
  args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC']
})
```

### 8.2 模拟合约 (simulateContract)

模拟写入操作，检查是否会成功：

typescript

```typescript
const { result, request } = await publicClient.simulateContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  args: [69420],
  account,
})

// 如果模拟成功，执行实际写入
const hash = await walletClient.writeContract(request)
```

### 8.3 写入合约 (writeContract)

typescript

```typescript
// 推荐：先模拟再写入
const { request } = await publicClient.simulateContract({
  account,
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
})
const hash = await walletClient.writeContract(request)

// 或直接写入（不推荐）
const hash = await walletClient.writeContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  functionName: 'mint',
  account,
})
```

### 8.4 监听合约事件

typescript

```typescript
const unwatch = publicClient.watchContractEvent({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  eventName: 'Transfer',
  args: {
    from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b'
  },
  onLogs: logs => console.log(logs)
})

// 停止监听
unwatch()
```

### 8.5 合约实例 (getContract)

使用 `getContract` 创建合约实例，简化重复操作：

typescript

```typescript
import { getContract } from 'viem'

const contract = getContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: wagmiAbi,
  client: { public: publicClient, wallet: walletClient }
})

// 读取
const balance = await contract.read.balanceOf([address])

// 写入
const hash = await contract.write.mint([69420])

// 获取事件
const logs = await contract.getEvents.Transfer()

// 监听事件
const unwatch = contract.watchEvent.Transfer({
  onLogs: logs => console.log(logs)
})
```
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->








参加**Web3 实习计划（冬季）第一周例会**

## Ethers.js v6

### 1\. 概述与安装

Ethers.js 是一个完整且紧凑的 JavaScript 库，用于与以太坊区块链及其生态系统进行交互。常用于创建 DApps、钱包等。

安装方式：

````bash
npm install ethers
```

导入方式：
```javascript
// 导入所有
import { ethers } from "ethers";
// 按需导入
import { BrowserProvider, parseUnits } from "ethers";
```

### 2. 核心概念

**Provider（提供者）**：只读连接到区块链，用于查询状态（余额、区块、交易等）

**Signer（签名者）**：封装账户交互操作，需要私钥来签署交易

**Transaction（交易）**：状态更改操作，需要支付 Gas 费用

**Contract（合约）**：部署在区块链上的程序

**Receipt（收据）**：交易被打包后的确认信息

### 3. 连接以太坊

```javascript
// MetaMask 连接
if (window.ethereum == null) {
    provider = ethers.getDefaultProvider()
} else {
    provider = new ethers.BrowserProvider(window.ethereum)
    signer = await provider.getSigner();
}

// JSON-RPC 连接
provider = new ethers.JsonRpcProvider(url)
```

### 4. 单位转换

```javascript
parseEther("1.0")           // 字符串转 wei
parseUnits("4.5", "gwei")   // 转换为 gwei
formatEther(wei)            // wei 转 ether 字符串
formatUnits(value, "gwei")  // 格式化显示
```

### 5. 区块链查询

```javascript
await provider.getBlockNumber()        // 当前区块号
await provider.getBalance("addr")      // 账户余额
await provider.getTransactionCount()   // 交易数量
```

### 6. 发送交易

```javascript
tx = await signer.sendTransaction({
    to: "ethers.eth",
    value: parseEther("1.0")
});
receipt = await tx.wait();
```

### 7. 合约交互

```javascript
// 创建合约实例
contract = new Contract(address, abi, provider/signer)

// 只读调用
await contract.balanceOf(addr)

// 写入调用
tx = await contract.transfer(to, amount)
await tx.wait()

// 静态调用模拟
await contract.transfer.staticCall(to, amount)
```

### 8. 事件监听

```javascript
// 实时监听
contract.on("Transfer", (from, to, amount, event) => {...})

// 历史查询
events = await contract.queryFilter(filter, -100)
```

### 9. 钱包管理

```javascript
const wallet = new Wallet('0x...')           // 私钥
const randomWallet = Wallet.createRandom()    // 随机
const hdWallet = Wallet.fromPhrase("...")     // 助记词
```

---

## 第二部分：Viem 学习笔记

### 1. 概述与特点

Viem 是 TypeScript 优先的以太坊接口，特点：
- 自动类型安全和推断
- 可 tree-shaking 的轻量模块
- 原生 BigInt 支持
- 函数式/可组合 API

安装：
```bash
npm i viem
```

### 2. Client 类型

**Public Client**：只读操作
```typescript
const client = createPublicClient({
    chain: mainnet,
    transport: http(),
})
```

**Wallet Client**：签名操作
```typescript
// 浏览器钱包
const client = createWalletClient({
    chain: mainnet,
    transport: custom(window.ethereum!)
})

// 本地账户
const account = privateKeyToAccount('0x...')
const client = createWalletClient({
    account,
    chain: mainnet,
    transport: http()
})
```

### 3. Transport 类型

```typescript
http('https://...')           // HTTP
webSocket('wss://...')        // WebSocket
custom(window.ethereum)       // 浏览器扩展
fallback([http(), http()])    // 回退
```

### 4. Account 类型

```typescript
// JSON-RPC 账户（浏览器钱包签名）
const [address] = await client.getAddresses()

// 本地账户
privateKeyToAccount('0x...')
mnemonicToAccount('abandon...')
```

### 5. Public Actions

```typescript
// 获取余额
const balance = await publicClient.getBalance({ address })
formatEther(balance)

// 获取区块
const block = await publicClient.getBlock()
```

### 6. Wallet Actions

```typescript
// 发送交易
const hash = await walletClient.sendTransaction({
    account,
    to: '0x...',
    value: parseEther('1')
})

// 签名消息
const signature = await walletClient.signMessage({
    account,
    message: 'hello'
})
```

### 7. 合约交互

```typescript
// 读取
const data = await publicClient.readContract({
    address, abi, functionName: 'balanceOf',
    args: [userAddress]
})

// 写入（推荐先模拟）
const { request } = await publicClient.simulateContract({
    account, address, abi, functionName: 'mint',
})
const hash = await walletClient.writeContract(request)
```

### 8. 合约实例

```typescript
const contract = getContract({
    address, abi, client: publicClient,
})
await contract.read.totalSupply()
await contract.read.balanceOf([addr])
```

### 9. 事件处理

```typescript
// 监听
const unwatch = publicClient.watchContractEvent({
    address, abi, eventName: 'Transfer',
    onLogs: logs => {...}
})
unwatch()  // 停止

// 查询历史
const logs = await publicClient.getContractEvents({...})
```

### 10. 高级特性

```typescript
// Multicall 批量调用
const client = createPublicClient({
    batch: { multicall: true },
    ...
})

// 扩展 Client
const client = createWalletClient({...})
    .extend(publicActions)
```

---

## 第三部分：Ethers.js vs Viem 对比

| 特性 | Ethers.js | Viem |
|------|-----------|------|
| 语言 | JS/TS | TypeScript 优先 |
| API 风格 | 面向对象 | 函数式 |
| 类型安全 | 基础 | 深度集成 |
| Bundle | 较大 | Tree-shakable |
| BigNumber | 内置类 | 原生 BigInt |

**核心概念映射**：
- Provider → PublicClient
- Signer → WalletClient + Account
- Wallet → privateKeyToAccount 等
- Contract → getContract 或直接 Actions

**选择建议**：
- 新项目、重视类型安全、bundle 敏感 → Viem
- 已有代码库、团队熟悉 OOP → Ethers.js
````
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->










参加AI及其基础概念分享会，了解ai与web3结合的技术可能、落地场景和潜在困难。

### 智能合约开发

### 一、 DApp 架构与开发流程

-   **DApp 架构核心组件**：
    
    1.  **前端 (UI)**：使用 React/Vue 等框架，不直接连区块链，而是通过 RPC 节点或钱包（Provider）交互。
        
    2.  **智能合约**：部署在区块链上的业务逻辑（通常用 Solidity 编写）。
        
    3.  **数据检索器 (Indexer)**：监听链上事件（Event），将数据存入传统数据库供前端快速查询。
        
    4.  **去中心化存储**：使用 IPFS 或 Arweave 存储图片、文档等非结构化数据。
        
-   **开发全流程**：需求分析 → 智能合约开发（编写、测试、审计） → 检索器开发 → 前端开发（集成钱包、展示数据） → 交互集成（Viem/Ethers.js） → 部署上线。
    

### 二、 开发环境搭建

-   **基础工具**：Node.js (推荐 nvm 管理), Git, Yarn/NPM。
    
-   **开发框架**：
    
    -   **Foundry**：Rust 编写，速度极快，包含 Forge (构建/测试)、Anvil (本地节点)、Cast (交互工具)。
        
    -   **Hardhat**：主流 JS/TS 框架，生态丰富，插件多。
        
-   **辅助工具**：[Remix IDE](https://remix.ethereum.org/) (网页版，适合快速测试)、MetaMask (开发钱包)、OpenZeppelin (标准合约库)。
    

### 三、 RPC 节点服务

-   **RPC 作用**：连接前端与区块链的桥梁，负责读取数据、发送交易、监听事件。
    
-   **JSON-RPC 协议**：以太坊标准通信格式，常用方法如 `eth_getBalance`, `eth_sendTransaction`。
    
-   **服务商选择**：
    
    -   **Alchemy/QuickNode**：企业级，稳定，适合生产环境。
        
    -   **Infura**：老牌服务商。
        
    -   **Public Node**：免费但有限制，适合测试。
        
-   **最佳实践**：保护 API Key（后端存储或环境变量）、实现错误重试机制、配置多节点备份、注意速率限制。
    

### 四、 Solidity 编程基础

-   **基础语法**：
    
    -   **类型**：`uint`, `bool`, `address`, `mapping`, `struct`, `event` 等。
        
    -   **可见性**：`public` (任何地方), `external` (仅外部), `internal` (继承+内部), `private` (仅当前合约)。
        
    -   **状态修饰**：`view` (只读), `pure` (纯计算), `payable` (可接收 ETH)。
        
-   **合约结构**：包含状态变量、构造函数 (`constructor`)、功能函数、修饰符 (`modifier`)、事件 (`event`)。
    
-   **开发范式**：状态机模式、事件驱动编程、模块化设计（继承与接口）。
    

### 五、 安全实践 (重点)

-   **重入攻击 (Reentrancy)**：
    
    -   _原理_：恶意合约在回调中重复调用未更新状态的函数。
        
    -   _防护_：使用“检查-生效-交互” (CEI) 模式，或使用 `ReentrancyGuard` 修饰符。
        
-   **访问控制**：关键函数必须加权限，如 `onlyOwner`。
    
-   **整数溢出**：Solidity 0.8+ 版本已内置检查，无需额外使用 SafeMath。
    
-   **其他风险**：预言机操纵（需用 Chainlink）、三明治攻击/抢跑。
    

### 六、 部署与实战

-   **实战项目**：链上留言板（存留言、查记录）。
    
-   **以太坊技术**：
    
    -   **账户**：EOA（私钥控制） vs 合约账户（代码控制）。
        
    -   **Gas**：执行指令的费用，防止死循环。
        
    -   **交易生命周期**：签名 → 广播 → 打包 → 执行 → 确认。
        
-   **部署流程**：
    
    1.  **测试网**：使用 Sepolia 或 Holesky，通过水龙头领取测试币。
        
    2.  **工具**：Remix 配合 MetaMask (Injected Provider) 进行部署。
        
    3.  **验证**：在 [Etherscan](https://sepolia.etherscan.io/) 上查看交易哈希、验证合约代码、交互测试。
        

### 七、 前端整合

-   **技术栈**：推荐使用 **Viem** 或 **Wagmi** (替代较老的 Web3.js/Ethers.js)。
    
-   **核心交互**：
    
    -   **连接钱包**：请求用户授权 `eth_requestAccounts`。
        
    -   **读操作**：`contract.read.functionName()`，免费。
        
    -   **写操作**：`contract.write.functionName()`，需签名并支付 Gas。
        

### 八、 高阶内容

-   **Gas 优化**：减少 Storage 写入（最贵），使用内存缓存，变量压缩，循环优化。
    
-   **审计**：工具扫描 (Slither) + 动态测试 (Fuzzing) + 人工审计。
    
-   **协作规范**：Git Flow 分支管理，PR 代码审查，Issue 追踪。
    
-   **Layer 2**：了解 Optimistic Rollup (Arbitrum/Optimism) 和 ZK Rollup (Starknet/zkSync)。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->











1.参加web3安全分享会，了解常见的针对web3的攻击和对应的防范手段。

2.参加web3合规分享会，了解法律对项目方和从业者的合规要求和如何避免法律风险。

3.学习web3实习手册“以太坊概览”。

这篇关于 [以太坊概览](https://web3intern.xyz/zh/overview-of-ethereum/) 的文章详细介绍了以太坊的定义、发展历程、技术架构及核心机制。

### 1\. 核心定义与定位

-   **什么是以太坊？**
    
    -   被称为“区块链 2.0”，不仅是加密货币（ETH），更是一个支持 [智能合约](https://web3intern.xyz/zh/overview-of-ethereum/#%E4%B8%80-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E4%BB%8B%E7%BB%8D) 的“全球共享计算机”。
        
    -   由 Vitalik Buterin 提出，旨在提供一个去中心化的应用平台（Dapps），支持 DeFi、NFT、DAO 等生态。
        
-   **核心目标：** 成为全球范围内的“世界计算机”，利用代码自动执行规则，无需依赖中心化机构。
    

### 2\. [Ethereum 与 Bitcoin 的差异](https://web3intern.xyz/zh/overview-of-ethereum/#%E4%BA%8C%E3%80%81ethereum-%E4%B8%8E-bitcoin-%E7%9A%84%E5%B7%AE%E5%BC%82)

| 特性 | Bitcoin (区块链 1.0) | Ethereum (区块链 2.0) |
| --- | --- | --- |
| 定位 | 去中心化数字货币（数字黄金） | 去中心化计算平台 |
| 编程能力 | 有限脚本，仅处理简单交易 | 图灵完备（如 Solidity），支持复杂智能合约 |
| 共识机制 | PoW（工作量证明），高能耗 | PoS（权益证明），更环保、高效 |
| 区块时间 | 约 10 分钟 | 约 12 秒 |
| 经济模型 | 总量固定（2100万） | 供应灵活，存在通缩机制（EIP-1559） |

### 3\. [演进路线与升级](https://web3intern.xyz/zh/overview-of-ethereum/#%E4%B8%89-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%BC%94%E8%BF%9B)

以太坊的发展是一个不断升级的过程，重点在于从高能耗转向高效能，以及通过分层技术解决扩展性问题。

-   **从 PoW 到 PoS (The Merge)**
    
    -   **背景：** 早期以太坊使用 [PoW 机制](https://web3intern.xyz/zh/overview-of-ethereum/#_1-%E4%BB%A5%E5%A4%AA%E5%9D%8A-1-0-pow-%E9%98%B6%E6%AE%B5)，面临高能耗和低 TPS（每秒交易数）的问题。
        
    -   **The Merge (合并)：** 2022年9月，以太坊主网（执行层）与信标链（共识层）合并，正式转向 [PoS 机制](https://web3intern.xyz/zh/overview-of-ethereum/#pos-%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3)。
        
    -   **成果：** 能耗降低 99.95%，引入质押机制（32 ETH 成为验证者），增强了经济安全性。
        
-   [**未来升级路线图**](https://web3intern.xyz/zh/overview-of-ethereum/#_3-%E6%9C%AA%E6%9D%A5%E5%8D%87%E7%BA%A7%E8%B7%AF%E7%BA%BF%E5%9B%BE)
    
    -   **EIP-4844 (坎昆升级)：** 引入“Blob 交易”，大幅降低 Layer 2 (L2) 提交数据的成本，是 L2 降费的关键。
        
    -   **分片技术 (Sharding)：** 专注于数据分片，配合 L2 提升网络吞吐量。
        
    -   **ZK-Rollup：** 利用零知识证明实现批量验证，提升速度与安全性。
        

### 4\. [以太坊生态架构](https://web3intern.xyz/zh/overview-of-ethereum/#%E5%9B%9B%E3%80%81%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%94%9F%E6%80%81%E6%A6%82%E8%A7%88-l1%E3%80%81l2%E3%80%81sidechains-%E7%AD%89)

以太坊通过分层架构来平衡安全性与扩展性：

-   **Layer 1 (L1 主网)：** 负责最终的安全性、共识和数据可用性。核心组件包括 EVM 和账户系统。
    
-   **Layer 2 (L2 扩展层)：** 如 Rollup（Optimistic 和 ZK），负责在链下批量处理交易，然后将结果打包回 L1，从而降低 Gas 费并提高速度。
    
-   **侧链 (Sidechains)：** 独立运行的区块链，通过桥接与主网交互。
    

### 5\. [核心运行机制](https://web3intern.xyz/zh/overview-of-ethereum/#%E5%85%AD%E3%80%81%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-%E4%BB%8E%E8%B4%A6%E6%88%B7%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E5%AE%8C%E6%95%B4%E9%93%BE%E8%B7%AF)

理解以太坊运作的三个关键支柱：

-   [**账户系统**](https://web3intern.xyz/zh/overview-of-ethereum/#_1-%E8%B4%A6%E6%88%B7%E7%B3%BB%E7%BB%9F-%E4%BD%A0%E7%9A%84%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD)
    
    -   **外部账户 (EOA)：** 由私钥控制（如个人钱包），有公钥和私钥，可主动发起交易。
        
    -   **合约账户 (CA)：** 由代码控制（如智能合约），无私钥，只能被动响应交易。
        
-   [**Gas 模型**](https://web3intern.xyz/zh/overview-of-ethereum/#_2-gas-%E6%A8%A1%E5%9E%8B-%E4%BA%A4%E6%98%93%E7%9A%84%E7%87%83%E6%96%99%E8%B4%B9)
    
    -   **定义：** 交易的“燃料费”，防止网络资源被滥用。
        
    -   **计算公式：** `Gas Limit` (愿意消耗的最大量) × `Gas Price` (单价)。
        
    -   **EIP-1559 改革：** 费用分为 **基础费用** (Base Fee，直接销毁，导致通缩) + **小费** (Tip，给验证者)。
        
-   [**以太坊虚拟机 (EVM)**](https://web3intern.xyz/zh/overview-of-ethereum/#_3-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-evm-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E)
    
    -   以太坊的“大脑”，是一个图灵完备的虚拟执行环境。
        
    -   所有节点运行相同的代码，确保全网状态一致且可信。
        

### 6\. [文化与价值观](https://web3intern.xyz/zh/overview-of-ethereum/#%E4%BA%94%E3%80%81%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%96%87%E5%8C%96%E4%B8%8E%E4%BB%B7%E5%80%BC%E8%A7%82)

以太坊不仅是技术，还承载了 **密码朋克 (Cypherpunk)** 精神：

-   **去中心化与抗审查：** 无单一控制者，代码即法律。
    
-   **开源与无需许可：** 任何人都可以开发和使用。
    
-   **公共物品导向：** 注重生态整体利益与可持续发展。
    

这篇 [以太坊概览](https://web3intern.xyz/zh/overview-of-ethereum/) 将以太坊比作一个由 [EOA (钱包)](https://web3intern.xyz/zh/overview-of-ethereum/#_2-%E7%9B%B8%E4%BC%BC%E7%B1%BB%E6%AF%94) 发起指令、支付 [Gas (燃料)](https://web3intern.xyz/zh/overview-of-ethereum/#_2-%E7%9B%B8%E4%BC%BC%E7%B1%BB%E6%AF%94)、驱动全球共享的 [EVM (计算机)](https://web3intern.xyz/zh/overview-of-ethereum/#_2-%E7%9B%B8%E4%BC%BC%E7%B1%BB%E6%AF%94) 来执行 [CA (智能保险箱/合约)](https://web3intern.xyz/zh/overview-of-ethereum/#_2-%E7%9B%B8%E4%BC%BC%E7%B1%BB%E6%AF%94) 的系统。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->












## **区块链工作原理与Web3核心特性讲解**

### 钱包、私钥与地址生成

-   私钥是管理资产的重要凭证，需要妥善保管，不能遗忘或泄露给他人
    
-   助记词（12或24个单词）可以生成无限个私钥，便于记忆和管理
    
-   地址生成流程：助记词 → 私钥 → 公钥 → 钱包地址（取公钥后20位，加上0x前缀）
    
-   私钥与公钥的关系是单向的：私钥可以生成公钥，但公钥无法反推私钥
    
-   私钥丢失或泄露后无法找回，只能更换钱包，因为区块链只认签名
    

### 私钥安全注意事项

-   私钥和助记词不能截图或发送给任何人
    
-   复制时要小心，避免整段复制，可以分段输入以防监控
    
-   任何人都可以创建私钥，创建后立即拥有账户和资产控制权，无需他人授权
    
-   私钥与公钥是一对一关系，通过加密算法生成
    

### 交易与数字签名

-   区块链交易（Transaction/TX）包含转账信息、gas费用、nonce等数据
    
-   Nonce（交易序号）用于防止交易被重放攻击，每个地址的交易都会加1
    
-   交易通过私钥生成数字签名，签名后广播到区块链网络
    
-   数字签名验证过程：接收者收到原始消息、发送地址和签名后，通过密码学算法反推验证签名者身份
    

### Gas费用机制

-   Gas费是维持网络运行的经济驱动力，支付给节点提供者作为维护网络的奖励
    
-   Gas费 = Gas价格 × Gas使用量
    
-   Gas价格类似油价，会根据网络拥堵程度波动；Gas使用量取决于操作复杂度
    
-   操作越复杂（如执行智能合约）消耗的Gas越多，费用越高
    
-   网络拥堵时，Gas价格上涨，用户支付更高费用可以优先打包交易
    

### 区块链网络运行流程

-   交易生命周期：钱包签名 → 通过RPC发送到网络 → 进入交易池排队 → 验证者选择并打包 → 通过共识机制加入区块链
    
-   以太坊每12秒产生一个区块
    
-   交易在交易池中排队，Gas费高的交易优先被打包
    
-   演示了实时区块链动画，展示交易排队和打包过程
    

### 区块结构与最终确定性

-   每个区块包含大量交易信息、验证者投票等数据
    
-   当前以太坊有约32,948个验证者，每个验证者质押32个ETH进行投票验证
    
-   区块通过父哈希（parent hash）连接形成链，修改一个区块需要修改其后所有区块
    
-   新区块初始状态为"unfinalized"（未最终确定），需要等待约12-13分钟才能达到"finalized"状态
    
-   最终确定性确保交易不会被修改，比特币需要等待约10分钟
    

### 共识机制

-   PoW（工作量证明）：通过解决难题获得奖励，计算资源越多越有优势，比特币使用此机制
    
-   PoS（权益证明）：通过质押代币成为验证者，随机选择验证者进行验证并获得奖励，作恶会被罚没质押，以太坊目前使用此机制
    

### RPC节点与去中心化风险

-   钱包不直接连接区块链网络，而是通过RPC节点或节点集群转发交易
    
-   RPC是中心化风险点：服务可能拒绝提供服务、拦截签名或执行其他操作
    
-   用户可以在Chain List查看和添加不同的RPC服务器，选择延迟低、稳定性好、隐私保护强的RPC
    
-   以太坊基金会正在研究去中心化RPC项目
    

### 智能合约

-   智能合约本质是可以在区块链上执行的代码
    
-   代码上传到区块链后，调用时会在虚拟机中运行，执行结果写入区块链或改变状态
    
-   演示了My First NFT合约，展示了合约地址、Mint逻辑（每个地址只能mint一次）和交易历史
    
-   智能合约的社会学意义："代码即法律"，规则可通过代码验证，所有人都可以查看规则和执行历史
    
-   智能合约部署后难以修改，所有规则公开可验证，降低信任成本
    
-   减少中介和摩擦：将对人、机构、政府、法律的信任转化为对代码、共识和审计的信任
    
-   Mint NFT演示显示智能合约操作比简单转账更复杂，Gas费更高
    

### 区块链协议升级（EIP）

-   以太坊通过EIP（以太坊改进提案）标准升级网络功能
    
-   升级流程：论坛讨论 → 形成初步EIP → 具体开发 → 社区审查 → 最终确定 → 客户端升级
    
-   最新升级是Fusaka升级，所有升级细节公开可见
    
-   整个升级过程是社区驱动的，不是某个人或公司单独决定，需要反复讨论
    

### 客户端软件与网络健康

-   以太坊节点软件分为执行客户端和共识客户端
    
-   客户端多样性降低单点故障风险：如果某个客户端出现bug，其他客户端仍可正常运行
    
-   当前主流客户端包括Geth（占比49%）等多种不同语言编写的软件
    
-   验证者（Validator）约97,000个，每个验证者质押32 ETH作为保证金
    
-   验证者越多，网络越安全，因为恶意行为更容易被发现和惩罚
    
-   全网节点约13,700台服务器，主要分布在美国、德国和中国
    
-   节点分布越分散，网络越安全和去中心化
    

### Web3核心特性

-   **去中心化**：钱包创建无需KYC或身份验证，任何人都可以使用
    
-   **抗审查**：节点分布全球，即使某个钱包服务停止，用户可以切换到其他钱包，只要拥有私钥
    
-   **开源透明**：客户端代码开源，交易记录公开可验证，需要审计以保证安全
    
-   **隐私保护**：所有人可以看到交易记录，但不知道地址属于谁，除非主动公开
    
-   **隐私技术演进**：通过零知识证明（ZK）、隐私链等技术不断改进隐私保护
    
-   **无需许可**：不需要任何人批准即可读取和操作区块链网络
    

### 跨学科视角

-   Web3是跨学科领域，涉及技术、社会学、经济学和密码学
    
-   **治理与共识**：匿名去中心化网络中的决策机制
    
-   **经济学设计**：Gas费的燃烧或奖励机制，质押惩罚机制，确保网络安全和可持续性
    
-   **密码学基础**：签名、哈希、零知识证明等，加密算法失败可能导致灾难性后果
    
-   **技术原理总结**：通过私钥签名证明身份 → 共识网络确保可信 → 智能合约执行
    

### Web3的社会意义与挑战

-   Web3是权力再分配，实现数字资产和权力自主控制
    
-   用户可以控制自己的钱包和资产，无需许可即可使用，交易不可审查
    
-   所有交易和信息公开可信，难以伪造，可以移除中介直接交易
    

### 未来需要思考的问题

-   如何提高安全性并降低私钥管理的复杂度？
    
-   在没有中心化机构和政府的情况下，如何维护和资助公共基础设施？资金应该如何分配？
    
-   抗审查特性对黑客和黑市同样有利，如何判定和管理有害信息？不同标准下如何保护各方利益？
    
-   在去中心化协作中，如何在不了解对方的情况下实现公平可信的分配和持续合作？
    

### 关于这些结尾问题的思考

* * *

### 1\. 安全性与易用性的平衡：如何降低私钥管理复杂度？

**核心痛点：** 会议中提到“私钥丢失无法找回”且“不能泄露”，这种单点故障（Single Point of Failure）是阻碍大规模采用的主要门槛。

**解决方案方向：**

-   账户抽象（Account Abstraction, AA）：
    
    这是以太坊社区正在推进的重要方向（如ERC-4337）。它将外部拥有账户（EOA，即传统私钥控制的钱包）升级为智能合约钱包。
    
    -   **社交恢复（Social Recovery）：** 你可以设定5个信任的朋友或设备作为“监护人”。当你丢失私钥时，只要其中3个监护人批准，即可重置访问权限，而无需记住复杂的助记词。
        
    -   **可编程安全：** 设置每日转账限额、白名单地址等，即使私钥被盗，黑客也无法一次性转走所有资产。
        
-   多方计算（MPC）钱包：
    
    私钥不再完整地存储在一个地方，而是被分割成多个碎片（Shards），分散存储在用户设备、服务商服务器和备份云中。交易时需多方协作签名，单一碎片泄露不会导致资产丢失。
    
-   **硬件与生物识别集成：** 利用手机的安全芯片（Secure Enclave）存储私钥，通过FaceID或指纹签名，让Web3体验接近Web2的银行App。
    

* * *

### 2\. 公共基础设施的维护：在去中心化下如何分配资金？

**核心痛点：** 笔记提到Gas费主要支付给验证者（节点），但开发客户端软件、编写EIP标准、维护开源库的开发者（公共物品提供者）往往缺乏直接的激励模型，也就是“公地悲剧”。

**解决方案方向：**

-   二次方融资（Quadratic Funding）：
    
    这是一种通过数学算法分配资金的方式（如Gitcoin）。它不仅仅看资金总额，更看重捐赠人数。
    
    > **原理：** 1000人每人捐1元权重大于1人捐1000元。这确保了资金分配给社区共识最强、最广泛需要的项目，而非被“巨鲸”资本左右。
    
-   DAO国库与协议收入分配：
    
    许多协议（如Uniswap, ENS）都有DAO国库。社区通过提案投票，将部分协议手续费或治理代币分配给核心贡献者和生态开发者。
    
-   追溯性公共物品募资（RetroPGF）：
    
    先由开发者自费做出成果，证明其对网络的价值，然后社区投票给予事后奖励。这种机制鼓励了具有长远价值的开发工作，而非仅仅为了炒作。
    

* * *

### 3\. 抗审查的双刃剑：如何平衡自由与有害信息管理？

**核心痛点：** 会议强调了“抗审查”和“无需许可”是Web3的核心特性，但这同时也为黑客、洗钱提供了避风港。

**解决方案方向：**

-   **分层监管模型（协议层中立，应用层合规）：**
    
    -   **协议层（底层）：** 区块链网络本身（如以太坊节点）应保持像互联网TCP/IP协议一样的绝对中立，只负责打包和验证数据，不进行道德判断。
        
    -   **应用层（前端/RPC）：** 钱包界面、交易所和前端应用可以根据当地法律法规，屏蔽黑客地址或过滤有害内容。用户如果不满，可以直接调用底层合约，但这提高了作恶的门槛。
        
-   隐私与合规技术的结合（ZK-Compliance）：
    
    利用\*\*零知识证明（Zero-Knowledge Proofs）\*\*技术，用户可以在不通过KYC（不泄露具体身份）的情况下，证明自己“不在黑名单上”或“资金来源合法”。
    
    > 这实现了在保护隐私的同时，将非法资金拒之门外。
    
-   **社区驱动的策展（Curation）：** 通过代币激励的去中心化审核员网络，标记有害信息，让前端自行选择接入哪种“黑名单列表”，而非由单一中心化机构强行删除。
    

* * *

### 4\. 无信任协作：如何在陌生人之间实现公平分配？

**核心痛点：** 会议中提到“代码即法律”，在没有法律合同和法院强制执行的情况下，如何确保跨国界、跨身份的陌生人能持续合作并公平分钱？

**解决方案方向：**

-   智能合约自动分账（Payment Splitter）：
    
    将协作规则写入不可篡改的代码中。
    
    -   _例子：_ 咱们合作发行一个NFT系列，合约设定你拿30%，我拿70%。每当有一笔销售发生，资金会在区块链上自动路由到各自钱包，无需人工财务结算，消除了“事后赖账”的信任成本。
        
-   链上声誉系统（Soulbound Tokens, SBT）：
    
    SBT是一种不可转让的代币，代表你的身份、技能或贡献历史。
    
    -   在陌生人协作前，我可以通过查看你的SBT（如“以太坊核心开发者”、“Gitcoin捐赠者”、“DAO活跃投票者”）来快速建立信任基准，而不是依赖你的LinkedIn简历（后者可能造假）。
        
-   DAO治理与争议解决（Kleros等）：
    
    如果是复杂的非代码纠纷（如“设计稿质量不达标”），可以引入去中心化仲裁法庭。随机选取的陪审员根据证据投票裁决，结果由智能合约执行，确保流程透明公正。
    

* * *

### 总结

这些问题的答案核心在于将**社会契约（Social Contract）** 转化为 **数学契约（Mathematical Contract）**。

-   **私钥问题**通过密码学升级（MPC/ZK）解决。
    
-   **资金问题**通过算法机制设计（二次方融资）解决。
    
-   **监管问题**通过分层架构和零知识证明解决。
    
-   **协作问题**通过智能合约的确定性执行解决。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->













# 区块链基础概念

**1\. 区块链的核心定义与特性**

-   **定义**：区块链是一个去中心化的分布式账本，由包含交易信息的“区块”按时间顺序串联而成。
    
-   **主要特性**：
    
    -   **不可篡改**：每个区块都包含上一个区块的摘要（哈希），修改历史记录需要修改后续所有区块。
        
    -   **公开透明且匿名**：所有人可查看账本记录，但交易者身份通过钱包地址匿名。
        
    -   **去中心化**：数据存储在全球众多节点上，没有单一控制方，即使部分节点被篡改也无法影响整体网络（除非超过51%）。
        

**2\. 区块链的运行与激励**

-   **核心组成**：由去中心化网络（节点）和维持网络运行的代币激励（如比特币、Gas费）组成。
    
-   **运行流程**：交易发起 -> 广播 -> 节点验证 -> 矿工打包（挖矿） -> 链接上链 -> 奖励发放。
    

**3\. 三种区块链类型的对比**

-   [**公链**](https://web3intern.xyz/zh/blockchain-basic/#_1-%E5%85%AC%E9%93%BE-public-blockchain-%E5%85%AC%E5%85%B1%E5%85%AC%E5%9B%AD) (Public Blockchain)：完全开放，任何人可自由加入成为节点，数据全公开（比喻：公共公园）。
    
-   [**联盟链**](https://web3intern.xyz/zh/blockchain-basic/#_2-%E8%81%94%E7%9B%9F%E9%93%BE-consortium-blockchain-%E5%A4%9A%E5%85%AC%E5%8F%B8%E8%81%94%E5%90%88%E7%9A%84%E8%91%A3%E4%BA%8B%E4%BC%9A) (Consortium Blockchain)：需邀请或审批，由多个机构共同管理，数据半公开（比喻：多公司董事会）。
    
-   [**私链**](https://web3intern.xyz/zh/blockchain-basic/#_3-%E7%A7%81%E9%93%BE-private-blockchain-%E7%A7%81%E4%BA%BA%E4%BF%B1%E4%B9%90%E9%83%A8) (Private Blockchain)：由单一组织严格控制权限，数据仅内部可见（比喻：私人俱乐部）。
    

**4\. Web3、Web 3.0 与 Web2 的区别**

-   **Web2 (当前互联网)**：平台控制数据，用户仅是内容生产者（如微信、抖音）。
    
-   [**Web 3.0 (语义网)**](https://web3intern.xyz/zh/blockchain-basic/#_2-web-3-0-%E8%AF%AD%E4%B9%89%E7%BD%91)：侧重于数据的语义化和机器可读性，不一定涉及区块链。
    
-   [**Web3 (去中心化互联网)**](https://web3intern.xyz/zh/blockchain-basic/#_3-web3-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%92%E8%81%94%E7%BD%91)：基于区块链，用户真正拥有数据和数字资产的主权（如 MetaMask、Uniswap）。
    

**5\. 去中心化的优势与挑战**

-   **优势**：最小化信任成本、抗审查、高弹性、用户自主掌握资产。
    
-   **挑战**：扩展性瓶颈（交易速度慢）、安全与治理难题、用户体验门槛高、法律合规风险。
    

## **1\. 以太坊中文周会**

### **区块链快讯分享**

-   OPPNB完成主网硬分差，减少区块时间以提高吞吐量。
    
-   OP提议用super chat收入的50%回购OP，执行12个月，过去12个月收入5868个以太坊，一半用于回购。
    
-   Vitalic发文讨论去中心化稳定币，需解决价格指数、预言机设计和质押收益竞争问题。
    
-   RP窗Ltwo活跃，引入新定价模型，提高最低基础费，支持原生签名。
    
-   stark net在1月5日宕机18分钟，因执行层和证明层状态不一致。
    

### **2025年市场预测与看法**

-   类比互联网2001年，26年可能进入胜者为王时代，利用现有基础设施整合。
    
-   以太坊L1协议发展快，但应用少；比特币面临量子计算挑战，表现或不如黄金。
    
-   企业链如temple和circle的链可能表现不佳，robin hood链类似base。
    
-   25以太坊和sana创历史新高，但市场未感受到牛市氛围，参与者多为三年以上老用户。
    
-   25年热门赛道预测市场和hyper liquid合约市场，预测市场可能两倍增长。
    

### **25年回顾与26年展望**

-   稳定币增长超50%，USDT占大头，usdc占20%，合规稳定币数量翻番。
    
-   26年预测比特币7万5到14万，传统金融代币化提速，稳定币进入真实消费领域。
    
-   26年风险包括宏观流动性逆转、监管收紧、安全事件和defi信用危机。
    
-   25年web3上半场靠链上价格上涨推动，下半场转向合规和传统金融合作。
    
-   去中心化交易所占比增加，衍生品从5%到12%，现货从10%到20%。
    

## 2\. Web3 行业全局介绍 & 岗位概览

Web3 的核心逻辑是通过去中心化技术将**协议的所有权**和**价值**归还给用户。目前行业主要分为四个层级：

| 层级 | 核心内容 | 代表性技术/项目 |
| --- | --- | --- |
| 底层基础设施 (L0/L1) | 行业“地基”，解决安全、去中心化和可扩展性。 | Ethereum, Solana, Polkadot, Move 系 (Sui/Aptos) |
| 扩容与互操作 (L2/Middle) | 解决交易速度和跨链沟通，让 Web3 像 Web2 一样快。 | Arbitrum, Optimism, ZK-Rollups, LayerZero |
| 中间件与开发者工具 | 提供数据存储、预言机、索引等服务。 | Chainlink, The Graph, IPFS/Filecoin |
| 应用层 (DApps) | 直接面向用户的产品。 | DeFi (金融), GameFi (游戏), SocialFi (社交), RWA (现实资产) |

### 26 年三大行业趋势：

1.  **AI + Web3 深度融合：** 去中心化算力网络、AI 代理 (Agents) 自主链上交易成为常态。
    
2.  **合规化与机构化：** 随着 RWA (代币化国债/股票) 的普及，传统金融机构 (TradFi) 大规模入场。
    
3.  **用户体验革命：** 账户抽象 (AA) 技术普及，用户不再需要管理复杂的私钥，助记词时代逐渐终结。
    

### 1\. 技术类岗位

-   **智能合约工程师 (Smart Contract Dev):** \* **职责：** 编写、测试和部署链上逻辑。
    
    -   **技能：** Solidity (以太坊系), Rust (Solana/Near), Move (Sui)。
        
-   **安全审计师 (Security Auditor):** \* **职责：** 寻找代码漏洞，预防黑客攻击（Web3 最昂贵的岗位之一）。
    
    -   **工具：** Slither, Echidna, Foundry。
        
-   **全栈/后端开发者:** \* **职责：** 处理 DApp 的前端交互和索引层数据。
    
    -   **技能：** React, Node.js, ethers.js, GraphQL。
        

### 2\. 产品与设计类

-   **Web3 产品经理:** 需要深谙“代币经济学 (Tokenomics)”，设计激励模型。
    
-   **UX 交互设计师:** 挑战在于如何隐藏区块链的复杂性（如 Gas 费、签名确认），让非加密用户也能无缝使用。
    

### 3\. 运营与市场类 (社区是灵魂)

-   **社区经理 (Community Manager):** 活跃在 Discord, Telegram, Twitter (X)，不仅是客服，更是生态建设者。
    
-   **增长/增长黑客 (Growth):** 负责协议的 TVL (总锁仓量) 或活跃用户增长，常涉及空投 (Airdrop) 策略。
    
-   **KOL 关系/商务拓展 (BD):** 建立跨项目合作，推动生态联盟。
    

### 4\. 新兴垂直岗位

-   **代币经济学专家 (Tokenomics Designer):** 设计代币的供应、消耗和长期治理模型。
    
-   **合规与法律顾问:** 协助项目在不同司法管辖区内合法运营。
    
-   **链上数据分析师:** 使用 **Dune Analytics** 或 **Nansen** 洞察用户行为和资金流向。
    

* * *

## 三、 Web3 的“职业潜规则”

1.  **英语是硬通货：** 大多数优质项目是国际化的，Discord 和 Twitter 是信息中心。
    
2.  **学历背景淡化，链上简历 (On-chain CV) 强化：** 你在 GitHub 的代码贡献或在 DAO 里的参与治理记录，比一张名校毕业证更管用。
    
3.  **极速进化：** 行业一周，人间一年。需要极强的自我驱动能力和面对资产波动的心理承受力。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
