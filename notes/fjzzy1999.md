---
timezone: UTC+0
---

# fjzzy1999

**GitHub ID:** fjzzy1999

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
复习day5视频

1\. scaffold-eth 工具链：革命性的迭代循环

scaffold-eth 提供了一种比传统 Hardhat 测试驱动开发更直观、更具“触感”的开发模式。

• 核心组件与工作流：

◦ 安装与启动： 通过 Git 克隆仓库，依次执行 yarn install（安装依赖）、yarn chain（启动本地 Hardhat 节点）、yarn start（启动前端 UI）和 yarn deploy（部署合约）。

◦ 热加载迭代： 开发者修改 Solidity 代码后只需执行部署脚本，前端 UI 会自动同步合约函数，允许开发者直接通过 UI 进行交互测试。

• Burner Wallets（临时钱包）：

◦ 系统自动为浏览器本地生成测试地址，无需 MetaMask 弹出确认即可快速发起交易。

◦ 通过内置的 Faucet（水龙头）可快速获取测试代币，极大简化了多角色、多地址的对抗性测试。

2\. Solidity 核心概念与实战重温

2.1 基础原语与全局单位

• 变量类型： 涵盖布尔值（bool）、无符号整数（uint256/uint8）、地址（address）等。

• 全局变量： 重点提及了 block.timestamp（区块时间戳）、msg.sender（消息发送者）、msg.value（附带的以太坊金额）以及 tx.origin（交易原始发起者）。

2.2 复杂结构与事件机制

• 映射（Mapping）： 用于存储键值对（如地址对应的余额）。其局限性在于无法直接遍历，但在存储资产数据时具有高效性。

• 事件（Events）： 链上存储成本昂贵，事件提供了一种低成本的日志记录方式，用于驱动前端 UI 的状态更新和历史记录展示。

2.3 构造函数与部署优化

• 构造函数（Constructor）： 仅在合约部署时运行一次，常用于设置初始管理员（Boss/Owner）。

• Immutable 变量： 对于部署后不再改变的变量（如管理员地址），使用 immutable 可节省 Gas。

3\. 高级开发模式：继承与 OpenZeppelin

为了提高安全性并减少冗余代码，建议开发者继承经过审计的标准库。

• Ownable 模式应用：

◦ 通过继承 OpenZeppelin 的 Ownable 合约，开发者可以立即获得 onlyOwner 修改器。

◦ 部署技巧： 默认情况下，部署者是合约所有者。为将权限转交给前端测试地址，可在部署脚本中调用 transferOwnership，或者在合约构造函数中直接设置。

• Gas 效率对比： | 操作方式 | Gas 消耗特征 | 复杂度 | | :--- | :--- | :--- | | 部署后二次交易转移所有权 | 较高（多一次交易开销） | 低 | | 构造函数内直接设置 | 较低（单次交易完成） | 中 |

4\. 合约间交互与地址溯源

理解合约如何相互通信是构建去中心化应用的关键。

• 接口与引用： 通过 import 现有合约或定义接口，一个合约可以调用另一个合约的函数（如 Bank 合约的 deposit/withdraw）。

• 身份识别差异：

◦ msg.sender： 指向当前直接调用合约的实体（可能是用户，也可能是另一个中间合约）。

◦ tx.origin： 始终指向最初发起交易的外部账户（EOA）。

• 安全限制实例： 利用 require(tx.origin == msg.sender) 可以强制要求调用者必须是个人钱包，从而阻止通过合约进行的自动化攻击。

5\. 安全深度解析：重入攻击（Reentrancy）

视频通过实战演示了一个经典的重入攻击案例，揭示了逻辑顺序不当导致的灾难性后果。

5.1 攻击原理

1\. 易感合约逻辑： 先向用户发送资金（外部调用），再将用户的余额清零（状态更新）。

2\. 攻击者手段： 创建一个恶意中间合约，在其 receive 函数中再次调用合约的提现函数。

3\. 漏洞触发： 由于余额清零发生在资金发送之后，攻击合约可以在余额被清零前反复“重入”提现函数，从而耗尽受害合约的所有资金。

5.2 核心修复方案：检查-效果-交互模式 (Checks-Effects-Interactions)

为防御此类攻击，开发者必须遵循严格的操作顺序：

1\. 检查（Checks）： 确认调用者余额足够。

2\. 效果（Effects）： 先将调用者的余额更新（如清零）。

3\. 交互（Interactions）： 后执行外部转账调用。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->

学习day4视频

开发 Web3 应用的最佳路径是建立快速反馈循环。这种被称为“修补”的方法包含以下步骤：

• 编写代码：从简单的原始数据类型和计数器逻辑开始。

• 即时部署：将合约部署到本地环境或测试网。

• 交互测试：通过前端 UI 或脚本“拨弄”合约，验证其行为是否符合预期。

• 持续重复：根据反馈修改代码并再次迭代。

开发工具链对比

根据不同的开发需求，报告提到了几种主流工具：

• Scaffold-eth：最适合快速迭代和修补，能根据合约自动生成前端界面，让开发者直观看到逻辑变化。

• Remix：基于浏览器的 IDE，无需安装环境，适合快速实验和部署简单合约，但功能相对受限。

• Hardhat：行业标准的本地开发环境，适合编写底层的自动化测试脚本和复杂的部署流程。

• Foundry：基于 Rust 开发的新兴工具，运行速度极快，适合追求性能的开发者。

Solidity 语言核心要素

版本控制与安全

• Pragma 声明：pragma solidity 规定了编译器版本。

• 版本分水岭：在 0.8.0 版本之前，开发者必须使用 SafeMath 库来防止数值溢出（Overflow）和下溢（Underflow）。0.8.0 及以上版本已在语言层面内置了这些检查。

状态变量与存储

• 存储（Storage）：合约中的状态变量（类属性）存储在区块链上，由数千台机器共同维护。

• 成本意识：由于存储是永久且冗余的，在链上存储数据的成本非常昂贵，应尽可能保持数据结构精简。

可见性与权限

• 可见性标识：包括 public、private、internal 和 external。

• 公共性质声明：在公共区块链上，即使变量标记为 private，其数据依然对所有人透明可见。private 仅限制了合约间的访问权限，而非数据的隐私性。

函数类型

• View 函数：仅读取状态而不修改，对客户端而言是免费调用的。

• Pure 函数：既不读取也不修改状态，纯粹基于输入参数进行计算。

• 写入函数：涉及状态修改，必须作为交易打包进区块，需要消耗 Gas。

逻辑控制与安全性

核心关键字

• require 语句：Solidity 中最强大的关键字之一。它用于设定规则，若条件不满足，整个交易将回滚（Revert），撤销所有更改并返回错误消息。

• constructor：仅在合约部署时运行一次，用于初始化状态（如设置初始供应量或管理员地址）。

访问控制与修饰符 (Modifiers)

• 代码复用：修饰符（如 onlyOwner）允许将常见的权限检查逻辑抽象出来。

• 执行流程：修饰符先运行检查逻辑，通过特定符号 \_ 将控制权交还给被修饰的函数体。这种方式提高了代码的可读性和可测试性。

数据结构

• 映射 (Mapping)：类似于哈希表或字典，通过键（如地址）存取值（如余额）。其优点是空间效率高，缺点是无法遍历。

• 数组 (Array) 与结构体 (Struct)：用于存储更复杂、可迭代的数据集合，但操作成本高于映射。

高级特性与经济激励

全局变量

• msg.sender：调用当前函数的地址，是权限控制的基础。

• msg.value：随交易发送的以太币数量（以 Wei 为单位）。

• block.timestamp：当前区块的时间戳。

以太币处理

• Payable 关键字：只有标记为 payable 的函数或地址才能接收以太币。

• receive() 函数：使合约能够接收直接发送到其地址的以太币。

• 发送建议：虽然有 .send 和 .transfer 方法，但由于 Gas 限制问题，社区目前推荐使用底层 .call{value: ...}("") 方法。

事件 (Events)

• 离链日志：事件允许合约在执行过程中发射信号。虽然合约无法读取彼此的事件，但前端应用可以利用事件来追踪合约的历史行为（如交易记录）。

• 成本效益：使用事件进行数据存储比使用状态变量（存储在 Struct 中）更便宜，适合存储不需要被其他合约读取的信息。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->


学习部分day3视频

1\. 运行本地以太坊节点 (Geth)

动机：去中心化与性能

在 Web3 开发的初期，开发者通常会通过 Infura 等第三方 RPC 服务来与以太坊区块链进行交互。虽然这种方式便捷，但它引入了中心化依赖。运行自己的节点是实现更高程度去中心化和性能的关键一步。

• **去中心化参与**：运行一个节点意味着直接参与到点对点网络中，成为网络的一部分，从而增强整个网络的去中心化和弹性。正如 Austin Griffith 所说：“是什么让它越来越去中心化？是更多的人在家里运行这些节点。”

• **性能提升**：与依赖有速率限制的 API 服务相比，查询本地节点的速度要快得多。实践证明，本地节点接收新区块的速度甚至可能超过 Infura。

• **高级访问权限**：拥有自己的节点可以访问 Infura 等服务通常不提供的功能，例如直接查看内存池（mempool）中待处理的交易。

客户端多样性

以太坊网络依赖于多种由不同团队开发的客户端软件。这种“客户端多样性”对于网络健康至关重要。

“当我们运行一个无人控制的巨大去中心化网络时，我们担心如果每个人都运行完全相同的客户端，而该客户端存在软件缺陷，整个网络就可能出现问题。因此，‘客户端多样性’这个短语就是为了让我们有很多人运行不同版本的软件，它们基本做同样的事情，以防某个软件出现问题时，网络仍能保持运行。” - Austin Griffith

主要的执行层客户端包括 Geth (Go Ethereum) 和 Nethermind 等。

2\. Hardhat：本地开发与编排

当开发重点从与现有网络交互转向创建和测试新的智能合约时，Hardhat 成为了核心工具。它提供了一个完全在本地运行的、模拟以太坊环境的开发网络。

Hardhat 的核心功能

Hardhat 不仅仅是一个本地区块链，它是一个全面的“编排软件”：

• 本地开发网络：启动一个即时的、零成本的本地以太坊网络，用于部署和测试。

• 编译：将 Solidity 源代码编译成以太坊虚拟机（EVM）可执行的字节码（bytecode）和应用二进制接口（ABI）。

• 部署：提供脚本化工具，将编译后的合约部署到本地网络、测试网或主网。

• 测试：集成了 Mocha、Chai 等测试框架，可以编写自动化的单元测试和集成测试。

• 调试：支持在 Solidity 代码中使用 console.log，并将输出打印到终端，极大地简化了调试过程。

Hardhat 是当前业界事实上的标准，其他替代工具包括老牌的 Truffle 和新兴的、用 Rust 编写的 Foundry。

建立 Hardhat 环境

通过 npx hardhat 命令可以快速初始化一个示例项目。该命令会创建标准化的项目结构，包括：

• contracts/：存放 Solidity 源代码。

• scripts/：存放部署和交互脚本。

• test/：存放自动化测试脚本。

• hardhat.config.js：项目的核心配置文件。

同时，它会安装必要的依赖，如 hardhat-ethers（扩展了 ethers.js 库，提供了与 Hardhat 集成的便捷函数）和 waffle（测试工具库）。

Hardhat 节点的关键特性与警告

运行 npx hardhat node 会启动一个本地开发网络，它具有以下特性：

• JSON-RPC 端点：在 [http://127.0.0.1:8545/](http://127.0.0.1:8545/) 提供服务，可供钱包或脚本连接。

• 创世区块：网络从区块 0 开始，是一个全新的、干净的区块链。

• 预置账户：自动创建 20 个确定性的账户，并为每个账户预充值 10,000 ETH，方便开发和测试。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->



1.学习了Day 2: Reading and Writing to Contracts with Ethers.js

1\. 核心基础设施：工具类与环境配置

为了提高开发效率并确保代码可复用，建立一个工具文件（如 utils.js）至关重要。

1.1 Provider 与 Signer 的职能

• Provider（提供者）： 连接区块链节点的只读接口。脚本通过它获取区块高度、查询余额或解析 ENS 名称。

• Signer（签名者）： 拥有私钥的实体，能够签署交易。Signer 通常需要连接到一个 Provider 才能将签署后的交易广播到网络。

• 链 ID（Chain ID）： 不同网络（如 Mainnet 为 1，Rinkeby 为 4）之间通过链 ID 区分，但在代码逻辑层面，由于 EVM 兼容性，交互方式基本一致。

1.2 安全协议 (OpSec)

• 助记词管理： 严禁在代码中硬编码私钥。应使用本地生成的助记词文件或环境变量。

• 环境变量： 使用 dotenv 库加载 .env 文件，并确保该文件已被列入 .gitignore。

• 隔离原则： 建议为每个项目生成独立的助记词，并仅存入足以支付测试气费（Gas）的资金，避免因开发环境泄露导致生产资金受损。

2\. 智能合约交互流程

2.1 读取合约数据 (Read Operation)

读取操作是免费且“脱链”的（不改变状态）。

• 必需元素： 合约地址、ABI（或其特定片段）、Provider。

• 示例： 脚本通过调用 mintPrice() 获取 NFT 合约的铸造价格。由于以太坊处理大数（BigNumber），通常需要使用 ethers.utils.formatEther 将 Wei 转换为可读的 ETH 数值。

2.2 写入合约数据 (Write Operation)

写入操作会改变区块链状态，需要支付 Gas 费。

• 必需元素： 合约地址、ABI、Signer（已连接 Provider）。

• Payable 函数： 某些函数（如 mint）被标记为 payable，意味着在调用时必须附带 value（原生代币）。

• 金额转换： 在发送交易前，需使用 ethers.utils.parseEther("0.01") 将常用数值转换为合约可识别的 Wei 格式。

3\. 技术深挖：交易剖析与 Call Data

3.1 什么是 Call Data？

当脚本与合约交互时，它并非直接“戳”应用，而是构建了一笔包含 data 字段的交易。

• 函数选择器（Function Selector）： 合约通过 data 字段的前 4 个字节来识别用户想调用的函数。这 4 个字节是函数签名（如 mint()）的 Keccak-256 哈希值的前 4 位。

• 参数编码： 函数参数会被编码并追加在选择器之后。

3.2 手工构造原始交易

研讨中展示了不依赖合约实例（Contract Instance），仅通过 signer.sendTransaction 手动填充 to、value 和 data 字段来调用合约的方法。这种方式揭示了 Web3 交互的本质。

4\. 交易管理：Nonce 与 Gas 调优

4.1 Nonce 的作用

Nonce 确保交易按顺序执行且防止重放攻击。如果 Nonce 4 的交易卡住，Nonce 5 的交易将无法被打包。

4.2 交易加速 (Speed Up)

通过发送一笔 Nonce 相同 但 Gas Price 更高 的新交易，可以覆盖掉内存池（Mempool）中正在等待的旧交易。这一逻辑在脚本中可以通过硬编码 gasPrice 和 nonce 字段来实现，模拟了 Metamask 中的“加速”功能。

5\. 实践案例：主网 DAI 代币转账

通过脚本在以太坊主网上向 sanford.eth 发送 5 美元的 DAI。

• ENS 解析： 使用 provider.resolveName("sanford.eth") 动态获取目标地址，而非硬编码。

• ERC-20 交互：

1\. 获取 DAI 的合约地址和 ABI。

2\. 调用合约的 balanceOf 函数检查余额。

3\. 调用 transfer(to, amount) 函数进行转账。

• 观察视角： 与发送 ETH 不同，代币转账在 Etherscan 上体现为“ERC-20 Token Transfers”中的内部合约状态变更，而非原生的 Value 转移。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->




学习视频Day 1: Scripting and Smart Contracts! Providers, Signers, and Wallets

1\. 开发环境与基础设置

在进行 Web3 脚本编写前，必须构建稳健的本地开发环境。

1.1 环境要求

• Node.js 版本管理： 建议使用 n 或 nvm 管理 Node 版本（推荐版本为 Node 14 或 16）。

• 模块系统： 推荐在 package.json 中设置 "type": "module" 以启用 ES6 导入语法（import），这不仅与前端 React 开发保持一致，还允许在主线程中使用顶层 await。

• 依赖库：

    ◦ ethers.js：与以太坊交互的核心辅助库。

    ◦ dotenv：用于管理敏感的环境变量（如 API 密钥和私钥），防止其被上传至 GitHub。

1.2 安全实践

• .gitignore 设置： 必须忽略 node\_modules 和 .env 文件。

• 环境变量： 私钥应存储在 .env 中，并通过 process.env 调用，而不是硬编码在脚本里。

2\. 提供者 (Provider) 深度解析

Provider 是连接区块链的只读门户，它不持有私钥，仅用于查询链上状态。

2.1 Provider 的角色

Provider 类似于 Web2 中的 API 接口（如 Firebase）。它允许脚本向区块链请求数据，例如查询区块高度或账户余额。

2.2 连接方式

• 公共/第三方服务： 如 Infura 或 Alchemy。这些服务提供负载均衡的节点集群，适合生产环境。

• 默认提供者： ethers.getDefaultProvider() 适用于测试，但在高频请求下会失效。

• 本地节点： 运行自己的以太坊节点（如 Nethermind 或 Geth）可以提供最快的响应速度和更高的隐私性，无需信任第三方公司。

2.3 核心功能演示

• 获取区块高度： provider.getBlockNumber() 用于确认连接状态及同步进度。

• ENS 解析：

    ◦ resolveName：将 ENS 域名（如 atg.eth）解析为以太坊地址。

    ◦ lookupAddress：将地址反向解析为 ENS 域名。

◦ 注意： ENS 解析通常需要在以太坊主网（Mainnet）Provider 上运行，即使交易发生在测试网。

3\. 签名者 (Signer) 与钱包 (Wallet)

Signer 是 Provider 的子集，具备本地加密签名功能，能够发送改变区块链状态的交易。

3.1 钱包的生成与派生

• 随机生成： ethers.Wallet.createRandom() 可生成全新的助记词和私钥。

• 助记词派生： 演示了如何通过循环路径（Path）从同一组助记词派生出多个不同的账户地址，这与 MetaMask 的多账户功能逻辑一致。

• 私钥导入： 可以通过私钥直接实例化钱包对象。注意：私钥前的 0x 前缀在某些库处理中可能导致错误，需仔细调试。

3.2 离线签名

Signer 可以在不连接互联网的情况下签名消息（signMessage）。这在 Web3 身份验证中非常强大，允许用户证明其所有权而无需支付 Gas 费。

4\. 交易发送实战流程

在测试网（如 Rinkeby）上发送交易的完整逻辑如下：

1\. 连接 Provider： 确定脚本指向的目标网络。

2\. 实例化 Signer： 将私钥钱包连接至 Provider（wallet.connect(provider)）。

3\. 准备交易对象： 定义接收者地址（to）和金额（value）。

4\. 发送交易：

    ◦ 调用 sendTransaction。

    ◦ 第一步等待： 交易进入内存池（Mempool），此时可以获取交易哈希（Hash）。

    ◦ 第二步等待（tx.wait()）： 等待交易被矿工打包进区块（Mined/Confirmed）。

5.1 关键陷阱

在编写交互脚本时，如果 to 字段为空且包含数据，以太坊会将其视为合约创建交易。演示中由于 ENS 解析返回 null 而导致意外创建了一个空合约。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->





复习了021学习以太坊的第三章内容

**1\. 以太坊的两大账户类型**

以太坊网络中只有两种账户，它们在“世界状态”中都由四个字段构成（Nonce, Balance, StorageRoot, CodeHash），但控制方式截然不同：

**外部拥有账户 (EOA)：**

控制方式：由私钥直接控制，用户持有私钥即可控制账户资产和行为。

特点：没有代码（CodeHash为空），没有内部存储（StorageRoot为空）。

功能：它是交易的发起点，能够主动发起转账或调用合约，需要支付Gas。

**合约账户 (Contract Account)：**

控制方式：由部署在链上的\*\*代码（EVM字节码）\*\*逻辑控制，没有私钥。

特点：拥有代码和独立的存储空间（Storage），可以持久化保存数据（如代币余额、NFT归属）。

功能：不能主动发起交易，只能被EOA或其他合约调用后被动执行逻辑。

**2\. 交易发起与账户抽象**

唯一发起者：在当前协议规则下，链上每一笔交易的起点必须是EOA（由私钥签名）。合约无法凭空通过“意念”发起交易。

账户抽象 (ERC-4337)：虽然合约不能直接发起交易，但通过ERC-4337标准，用户可以签署“意图（UserOperation）”，由捆绑器（Bundler，一个EOA）代为上链。这让合约钱包（智能账户）拥有了类似EOA的主动性体验，但底层物理定律未变。

**3\. 合约的创建与地址生成**

合约账户是通过“创建合约交易”诞生的，其地址生成有两种规则：

CREATE：地址由 发布者地址 + Nonce 决定。这意味着同一个账户按顺序部署的合约地址是确定的。

CREATE2：地址由 发布者地址 + Salt + 合约代码哈希 决定。这允许在合约真正部署之前就能预测其地址，常用于钱包工厂或跨链统一部署。

**4\. 代币的本质：记账表**

用户持有的ERC-20代币或NFT，并不存放于用户的EOA账户中。

存储位置：代币是记录在代币合约的Storage。

记账方式：合约内部维护一个映射表（如 mapping(address => uint256)），记录了“某地址拥有多少余额”。

转账本质：转账代币并非资产移动，而是调用代币合约，修改其内部账本上的两个数字（A减，B加）。

**5\. 合约的不可篡改与“销毁”新规**

代码不可变：合约一旦部署，其代码逻辑默认无法修改。如果需要升级，通常使用代理模式（Proxy Pattern），即通过一个固定地址的代理合约将调用转发给可替换的逻辑合约。

SELFDESTRUCT 的变更：在Dencun升级（EIP-6780）后，SELFDESTRUCT 操作码的行为发生了重大变化。它不再能随意清除旧合约的代码和存储，仅在合约创建的同一笔交易中调用才有效。这意味着依赖“自毁再重建”的升级模式已基本失效。

**6\. 安全与管理**

私钥管理：助记词（SRP）是派生所有私钥的种子，MetaMask等钱包只在本地保存加密后的私钥，不上传服务器。拥有助记词即拥有控制权。

地址格式：以太坊地址是公钥哈希的后20字节，0x 前缀是编程界表示十六进制的惯例，并非地址数据本身。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->






复习021学习以太坊

1\. 节点架构：执行层与共识层的分离

自“合并（The Merge）”以后，一个完整的以太坊节点不再是单一软件，而是由两个核心客户端配合运行：

执行客户端 (Execution Client, EL)：负责处理交易、运行 EVM（以太坊虚拟机）、维护世界状态（账户余额、合约存储）以及提供 RPC 接口。常见的实现有 Geth, Nethermind, Besu 等。

共识客户端 (Consensus Client, CL)：负责 PoS 共识逻辑，包括信标链维护、区块提议与投票（Attestation）、以及最终性确认。常见的实现有 Lighthouse, Prysm, Teku 等。

Engine API：这是两者之间的“专线电话”，用于传递区块骨架和执行结果。共识客户端指挥执行客户端验证区块或打包交易。

2\. 节点类型与区别

根据存储数据量和功能的不同，节点主要分为三类：

全节点 (Full Node)：保存所有区块头和区块体，验证所有新交易，但会对陈旧的历史状态进行裁剪（Pruning）。它是网络的安全基石，能够独立验证链的合法性。

归档节点 (Archive Node)：在全节点基础上，保存从创世区块至今的所有历史状态快照。它类似“时间机器”，能瞬间查询任意历史时刻的余额或合约状态，适合区块浏览器、审计和数据分析使用，但存储成本极高（TB级别）。

轻节点 (Light Node)：只保存区块头，不存完整交易和状态。它依赖全节点获取数据，通过 Merkle 证明进行验证，适合手机等资源受限设备。

3\. 网络通信机制

以太坊节点之间的“社交”分为三个阶段：

发现 (Discovery)：基于 UDP 协议和 Kademlia 算法（DHT），通过引导节点（Bootnodes）找到并认识新的邻居节点。

连接 (Connection)：基于 TCP 协议建立加密通道（RLPx），在此通道上复用多种子协议传输数据。

传播 (Gossip)：使用 Gossip（八卦）协议传播新交易和新区块。节点随机传给几个邻居，邻居再扩散，实现全网秒级同步。对于历史数据的补全，则使用点对点的“请求-响应”模式。

4\. 同步模式 (Sync Modes)

节点加入网络时需要下载数据，主要有三种模式：

Snap Sync (快照同步)：推荐模式。先下载区块头，再并发下载最新的“状态快照”，最后补齐近期数据。速度快，安全性高。

Full Sync (全同步)：从创世块开始重新执行每一笔交易，极其耗时，通常用于审计或极高安全需求。

Light Sync (轻同步)：只下载区块头，不构建状态树，无法参与共识，仅做轻量级验证。

5\. 运行节点的意义

对于开发者或机构，运行自己的全节点（而不是依赖 Infura 等公共 RPC）有以下核心价值：

隐私与抗审查：不暴露 IP 和交易意图给第三方服务商。

去信任验证：坚守“Don’t trust, verify”原则，独立验证每一笔交易的正确性。

基础设施韧性：在云服务宕机或被限流时，自有节点能保证业务不中断。

6\. 数据分析与工具扩展

RPC 接口：节点通过 JSON-RPC 接口（如 eth\_getBalance）对外提供服务，这是钱包和 dApp 与链交互的窗口。

不跑节点的分析方法：如果不想维护硬件，可以使用 Dune (SQL分析)、BigQuery (公共数据集) 或 Etherscan API 来获取链上数据。

7\. 网络现状与去中心化

目前以太坊主网约有近 100 万个活跃验证者。

去中心化的保障来自于：多客户端实现（防止单一软件 bug 导致全网瘫痪）、地理分布以及云与自建节点的混合部署。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->







1\. 学习视频Day 5: Stuck Transactions, Gas Limits, Multisigs, L2s, Lending...

Gas 机制的核心：交易并非简单的价值流动，而是对智能合约状态的调整；Gas 限制（Limit）防止程序陷入死循环，而最高费用（Max Fee）则是竞价块空间的关键。

Nonce 与交易管理：Nonce 是防止重放攻击的关键序列号，也是解决交易“卡死”的核心。通过手动调整 Nonce 或提高 Gas 费用，可以实现交易的加速或取消。

L2 的价值主张：以太坊二层网络（如 Optimism）在保留 L1 安全性的同时，显著降低了费用并实现了近乎实时的交易确认。

安全进阶：相比助记词，多重签名钱包（Multisig）通过多方签名验证提供了更高级别的资产保护和恢复机制。

矿工池（Mempool）竞价

区块空间是有限的。矿工会优先选择 Mempool 中出价最高的交易。如果设置的 Max Fee 过低（如在 Gas 均价为 30 Gwei 时设置 10 Gwei），交易将处于“浮动”状态，直至网络闲暇或手动加速。

多重签名钱包由智能合约驱动，而非单一助记词。

M-of-N 验证：例如设置 4 个持有者，需要其中 2 人签名才能执行交易。

容错性：如果一个私钥丢失或泄露，剩余持有者可以协同追回资金并更换持有者。

在 Aave 等协议中，用户可以质押抵押品（如 ETH）借出另一种资产。

清算风险：如果抵押品价值下降导致贷款担保不足，资产会被清算。

循环杠杆：这种机制可用于做空或放大杠杆，但对开发者而言，参与此类“投机游戏”具有极高风险。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->








**1.学习**[**Day 4: NFTs!!! ERC20 vs ERC721, IPFS, Metadata**](https://www.youtube.com/watch?v=NOdrEpnoCiM&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=4)

NFT（Non-Fungible Tokens）是构建在区块链上的数字资产，其核心价值源于以下几个方面：

**Digital Scarcity：**艺术家可以通过智能合约限制代币的总供应量（例如 10,000 个）。一旦合约部署，即便原作者也无法超越该限制，从而创造了技术层面的稀缺性。

**On-chain Provenance:** 区块链记录了从铸造（Minting）到历次转手的所有权路径。市场可以以此辨别原始艺术品与“仿制品”，因为后者无法伪造原始艺术家的合约签名。

**Permissionless Environment：**NFT 是一个无许可的环境，任何人都可以部署任何内容。这虽然促进了创新，但也导致了市场中存在大量劣质内容，用户需具备辨别能力。

**身份与库存的随行性：**在 Web3 中，用户的身份（如 ENS 域名）和资产库存（NFT）不属于特定平台，而是跟随用户的钱包在不同服务（如 OpenSea、Zapper、Rarible）之间漫游。

**NFT 正在向功能化发展：**

Token Gating： 持有特定 NFT 才能进入聊天室或参加会议。

治理与投票：NFT 可作为参与 DAO（去中心化自治组织）投票的凭证。

流动性凭证：在 Uniswap 等协议中，用户的流动性头寸被铸造成 NFT，代表对底层储备的所有权。

Royalties： 创作者可以在合约中直接编程版税规则（如二次销售额的 10% 自动分配给原作者），从而剔除传统中介，最大化创作者收益。

**2\. 参加AI分享会**

**ERC-8004 智能体链上护照**

**SpoonOS架构**
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->









**1.学习**[**Day 3: ENS, DEX, Identity, Inventory, Sybil**](https://www.youtube.com/watch?v=wYSMNdIRoII&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=3)

**1.1 Web3 身份的自主性与可迁移性:** 用户对 Web3 身份拥有完全的控制权。借由 ENS（以太坊域名服务），可以将复杂的十六进制地址（如 0xae9...）转化为好记的名称（如 sanfordstout.eth）。这个身份不从属于特定的平台，而是随着用户的钱包在各个 Web3 应用间流转，保持了跨平台的一致性。

**1.2 身份与资产清单（Inventory）的深度耦合:** 在 Web3 中，身份与数字资产是高度集成的。无论是 ETH、Dai 还是作为 NFT 的域名，都直接挂钩在链上身份中。当用户接入 Uniswap 或 Zapper 等应用时，系统能自动识别其名下的资产状况，这种资产数据的互通性带来了极为流畅的体验。

**1.3 由智能合约承载的后端服务:** ENS 和 Uniswap 等核心服务的底层逻辑并非运行在传统数据库上，而是由部署在链上的智能合约驱动。这虽然确保了服务的抗审查和无需信任的特性，但也引入了特有的交互成本，例如需要支付 Gas 费以及经历多步交易确认。

**1.4 稳定币在提升交互体验中的角色:** 加密货币（如 ETH）的价格波动过于频繁，限制了其在日常场景中的使用。而像 Dai 这样的稳定币，通过超额抵押、铸造与销毁等经济模型与美元挂钩，为 Web3 生态提供了一个可靠的价值尺度，是链上价值交换和储存的基础。

**1.5 女巫攻击（Sybil Attack）的潜在威胁:** Web3 面临的一个核心挑战是身份创建成本极低。由于可以轻易生成类似 "Sanford Stout" 的虚假身份，这给基于“一人一票”的去中心化治理以及公平的代币分发带来了风险。目前行业主要通过分析链上行为轨迹来识别账户的真实度，但这依然是一个尚未攻克的难题。

**2 参加了安全分享会**

**3\. 参加了合规分享会:**

**合同与薪酬风险**

**1\. 签约主体风险：**

纯境外主体签约：若合同方仅为境外实体，一旦产生劳动纠纷，在国内通过法律途径维权的难度和成本极高。

国内主体签约（含第三方派遣）：虽然劳动关系相对明确，受国内法保护，但如果签约公司涉及违法业务，员工容易面临被牵连的法律风险。

**2\. 薪资支付方式：**

虚拟货币发放薪资的隐患：

法律合规性：我国劳动法规定工资必须以人民币形式支付。

司法判例：已有相关仲裁结果显示，虚拟币支付的工资不被法律认可，法院通常会判决公司必须以人民币形式补足。

**风险规避建议**

**1\. 入职前的尽职调查：**

核实公司牌照的真实性、业务经营范围以及主要用户群体。

亲自测试产品的注册流程，确认其是否对特定地区进行了合规限制。

**2\. 严审合同条款：**

必须在合同中明确签约实体、薪资的具体构成以及发生争议时的解决机制。

**3\. 业务层面的隔离：**

优先考虑那些完全不向大陆用户提供服务的项目。

尽量规避核心业务涉及高杠杆合约、期权等高法律风险的板块。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->










**1.复习了Web3实习手册入门导读部分和021学习以太坊第一章**

### **1.1区块链在解决什么问题**

区块链本质上是一种账本，用来记录交易。  
难点不在于怎么记账，而在于在没有中心机构的情况下，谁来负责往账本上加新的一页，以及大家如何对“哪一页是最新的”达成一致。

### **1.2 PoW 和 PoS 是怎么选记账者的**

PoW（工作量证明）中，负责记账的是矿工。  
矿工通过不断计算哈希来竞争出块权。  
系统会把出块速度控制在一个固定区间，比如比特币大约 10 分钟一个区块。  
算力越高，挖到区块的概率越大，但不能让区块出得更快。

PoW 的算力消耗并不是为了“算出结果本身”，而是为了制造一种真实、不可伪造、不可回收的成本，从而防止作恶。

PoS（权益证明）中，负责记账的是验证者。  
验证者需要先质押一定数量的代币，系统再按规则随机选人出块。  
验证者如果正常工作可以获得奖励，如果作恶或离线则会被惩罚甚至罚没质押。

PoS 把安全成本从链下的电力，转移到了链上的资产。

### **1.3 矿工、验证者和智能合约的关系**

PoW 中的矿工和 PoS 中的验证者，本质角色是一样的，都是负责出块和延长区块链的节点。

智能合约并不是记账的人，也不会主动执行。  
智能合约只是一些写在链上的规则和状态，只有在交易调用时，才会被节点执行。

可以理解为：  
验证者或矿工在“干活”，  
智能合约只负责“规定钱怎么算、规则怎么执行”。

### **1.4 区块链账本和智能合约记账的关系**

区块链只有一个账本，记录的是全局状态。  
这个状态里既包括普通账户余额，也包括合约状态，还包括验证者的质押和奖惩信息。

智能合约并不是单独记一本账，而是规定某一部分状态在什么条件下如何变化。  
最终所有变化，都会被写进同一条区块链账本中。

### **1.5 Gas 是什么**

Gas 是对计算和存储资源的计量单位，不是钱。  
用户真正支付的是 ETH。

一笔交易实际支付的手续费，等于消耗的 Gas 数量乘以 Gas 单价。

在 EIP-1559 之后，以太坊的 Gas 费分成两部分。  
基础费由系统自动计算并直接销毁。  
小费支付给出块的验证者，用来激励其优先打包交易。

### **1.6 dApp 是什么**

dApp 是建立在区块链上的应用。  
它通常包括一个前端界面和一组智能合约。

用户在 dApp 上的操作，会被转化成交易。  
交易调用智能合约。  
验证者执行交易和合约，并把结果写入区块。

dApp 本身不出块，也不参与共识，只是一个使用区块链的应用入口。

### **1.7L1、L2 和 Rollup 的关系**

L1 是主链，负责共识和最终裁决。  
谁出块、哪条链是正确的，都是由 L1 决定的。

L2 是建立在 L1 之上的扩展方案，目的是提高速度、降低成本。  
Rollup 是目前最主流的 L2 形式。

Rollup 把交易执行放在链下进行，只把必要的数据和结果提交给 L1，从而继承 L1 的安全性。

### **1.8 Blob 是什么，为什么和 L1 有关**

Blob 是以太坊在 Dencun 升级中引入的一种数据形式，主要是给 Rollup 使用的。

虽然 Blob 的数据是 L2 的交易数据，但它是发布在 L1 上的，由 L1 的共识机制来保证数据可用性。

Blob 的特点是不会进入 L1 的长期状态，只会临时保存一段时间，之后可以被清理。  
这样既保证了 Rollup 的安全，又不会拖累 L1 的存储和状态大小。

**2.学习了**[Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)

**12 位助记词（Mnemonic）是资产的“主密钥”**，必须绝对保密并离线备份，一旦丢失或泄露，资金将永远无法找回。

**私钥**：本质上是一个巨大的随机数。它是签署所有交易的凭证，必须绝对保密。

**地址**：由私钥通过单向加密算法派生而来，可以安全地分享给他人以接收资金。

**非托管钱包 (Non-Custodial)**：如MetaMask。用户完全控制自己的私钥和助记词。

**优点**：资产的完全所有权和控制权。

**缺点**：用户对安全负全部责任。

**核心理念**：“Not your keys, not your coins.”

**托管钱包/交易所 (Custodial)**：如Coinbase。平台为用户保管私钥。

**优点**：用户体验更简单，可以找回密码，有客服支持。

**缺点**：用户不真正拥有资产，而是依赖平台的信用。平台可能被黑客攻击（如Mt. Gox事件）、倒闭或冻结用户资产。

**3\. 创建了 MetaMask / Rabby 钱包，领取 Sepolia 测试币并转账给同学**

**4\. 参加了分享会 记录了以下问题**

![64bc4099668a11d5ef2ab2462dbd1e7d.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/fjzzy1999/images/2026-01-13-1768330550189-64bc4099668a11d5ef2ab2462dbd1e7d.png)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->











**1.学习了web3实习手册入门导读部分：**

1.1笔记中的结构图让我对区块链的架构有了更为形象的理解。

区块链特性：不可篡改，公开透明、匿名，快速交易，去中心化。

第一次对公链、联盟链、私链之间的区别有了直观的认识。

**区分了Web3.0与Web3的概念**（自己曾将两者的概念混在了一起）

1.2以太坊概览部分，只看手册感觉有些抽象，对一些概念如信标链的理解不是很到位，明天结合**021 学习以太坊**进行进一步的消化。

1.3学习了行业赛道部分，以前不了解DAO的含义。该部分帮我补足了这一点。

DAO（Decentralized Autonomous Organization，去中心化自治组织），不依赖传统的公司架构，而是通过智能合约和社区投票来做决策。

1.4 Web3工作方式部分昨天已经学过。

**2.观看了视频：Day 1: A Developer's Guide to Building on Ethereum - Intro**

视频概括了为期四周的学习路径：从第一周通过使用钱包、DEX 和 NFT 成为“超级用户”，到后续学习脚本编写（Ethers.js、Hardhat），并最终通过实战构建各种去中心化应用（如质押应用、代币供应商）。

我学到了智能合约的核心价值在于让互不信任的交易双方（例如 Alice 和 Bob）仅需信任代码规则即可完成协作，而无需中介。

此外，Web3 开发与传统开发不同，它强调设计激励机制来让网络参与者自发维护系统（而非依赖中心化的定时任务），且智能合约一旦部署上链，就成为了不可停止且不可篡改的规则。

**3\. 参加了以太坊中文周会**

该部分笔记参考了群里同学的总结（说实话我没听懂多少 只能说重在参与....回头慢慢补..）：

以太坊推进Fusaka

opBNB完成Fourier主网硬分叉

Polymarket结算争议升级

Optimism提案

Upbit黑客洗币

1/9Truebit(TRU)旧合约定价漏洞遭利用

**4\. 参加了行业全局及岗位概览分享会：**

老师分享的该部分对我启发很大：

![44edaff99cf27d00695aa27cbebfa097.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/fjzzy1999/images/2026-01-12-1768237401275-44edaff99cf27d00695aa27cbebfa097.png)![0d6f935d5722f46d72f6a86bb472986d.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/fjzzy1999/images/2026-01-12-1768237413019-0d6f935d5722f46d72f6a86bb472986d.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
