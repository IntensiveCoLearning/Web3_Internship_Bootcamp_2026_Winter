---
timezone: UTC+8
---

# 0xSevenK

**GitHub ID:** andOneBasketball

**Telegram:** @HaroldKKK

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
# 📒 共学营 Day 5 学习笔记

今天我继续让 ChatGPT 模拟面试官，针对 **Uniswap V2 的高级机制** 进行了面试式问答训练。重点关注 **流动性添加规则、AMM 定价以及 Pair 合约的状态同步机制**。通过答题 + 讲解，我对协议设计与安全逻辑有了更深入的理解。

* * *

## 1️⃣ 面试题三：池子已存在时如何添加流动性？比例不一致会发生什么？

### 问题回顾

当交易对池子已经存在时，用户再次添加流动性，需要按照什么比例存入两种 Token？如果用户提供的数量比例不一致，会发生什么？Router 和 Pair 各自负责什么逻辑？

### 核心点

-   必须按照当前池子储备比例添加：`amountA / amountB = reserveA / reserveB`
    
-   Router 会计算最优投入量，以数量较小的一侧为准，多余的 Token 会退回给用户
    
-   Pair 合约只根据实际转入数量铸造 LP Token：
    
    ```
    liquidity = min(amountA * totalSupply / reserveA, amountB * totalSupply / reserveB)
    ```
    
-   Router 负责比例计算和退币，Pair 只负责铸币
    

### 学习收获

-   理解 Router 与 Pair 的职责边界
    
-   明白比例不对不会报错，而是自动按最小量匹配，多余 Token 会退回
    

* * *

## 2️⃣ 面试题四：Uniswap V2 的价格是如何计算和维持的？

### 问题回顾

Uniswap V2 中价格是如何计算的？`x * y = k` 在合约中是如何被保证的？

### 核心点

-   AMM 采用常数乘积模型 `x * y = k`
    
-   价格由储备比例决定：
    
    ```
    priceA = reserveB / reserveA
    priceB = reserveA / reserveB
    ```
    
-   交易时扣除 0.3% 手续费：`dx' = dx * 997 / 1000`
    
-   输出数量公式：`dy = y * dx' / (x + dx')`
    
-   手续费留在池子里，每次交易后 k 实际增加，这部分增长就是 LP 收益来源
    

### 学习收获

-   理解公式背后的逻辑，不仅仅是记公式
    
-   掌握交易与 LP 收益的关系
    

* * *

## 3️⃣ 面试题五：为什么需要 skim() 和 sync()？

### 问题回顾

UniswapV2Pair 合约中存在 `skim()` 和 `sync()` 函数，但在 Router 中并不会调用，它们是做什么用的？有没有安全风险？

### 核心点

-   `reserve` 是内部记账值，`balance` 是链上真实余额，两者可能不一致
    
-   `skim()`: 把多出来但未计入 reserve 的 Token 转走，用于回收误转资金或套利修正
    
-   `sync()`: 用真实余额更新 reserve，用于项目方注资或纠偏价格
    
-   安全提示：如果 transfer 与 sync 分开两笔交易，中间可能被别人调用 skim 抢走资金
    
-   正确做法：通过管理合约在同一笔交易内原子执行 transfer + sync
    

### 学习收获

-   理解 Pair 的记账机制与链上状态的差异
    
-   认识到原子性在 DeFi 中的重要性
    
-   掌握异常纠偏和资金安全的操作思路
    

* * *

## 4️⃣ 今日总结

-   理解了 Router 与 Pair 的职责分工
    
-   熟悉 AMM 定价与手续费对 LP 收益的作用
    
-   理解 reserve 与真实余额差异可能带来的安全问题
    
-   掌握原子操作在池子注资和纠偏中的重要性
    

今天的面试练习让我对 Uniswap V2 的核心机制和安全边界有了更深入的理解，也为后续学习 Flash Swap 和套利机制打下了基础。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

# 📒 共学营 Day 4 学习笔记

今天我让 ChatGPT 来模拟面试官，针对 **Uniswap V2** 对我进行了一轮面试式提问，通过答题 + 讲解的方式复盘了协议的核心设计，收获还是挺大的，主要集中在 **协议合约结构** 和 **LP Token 机制** 两个问题上。

* * *

## ✅ 面试题一：Uniswap V2 的核心合约有哪些？各自职责是什么？

### 🧩 合约分层结构

Uniswap V2 的合约整体分为 **Core（协议核心层）** 和 **Periphery（外围交互层）** 两部分。

### 🔹 Core 层

-   **UniswapV2Factory**
    
    -   负责创建和管理所有交易对（Pair）
        
    -   通过 `createPair(tokenA, tokenB)` 使用 `CREATE2` 部署 Pair
        
    -   保证任意代币对只会存在一个池子
        
-   **UniswapV2Pair**
    
    -   真正持有资金池资产的合约
        
    -   内部实现 `mint / burn / swap / sync / skim`
        
    -   所有交易和流动性变化都发生在 Pair 中
        
-   **UniswapV2ERC20**
    
    -   Pair 继承的 ERC20 实现
        
    -   用于实现 LP Token
        
    -   支持 `permit`（EIP-2612），方便无 gas 授权
        

### 🔹 Periphery 层

-   **UniswapV2Router02**
    
    -   面向用户的统一交互入口
        
    -   提供添加/移除流动性接口
        
    -   封装多跳 swap 路径
        
    -   处理 ETH 与 WETH 的转换逻辑
        

📌 总结：Router 只负责调度和路径计算，**不托管资产**，真正的资产始终在 Pair 合约中。

* * *

## ✅ 面试题二：LP Token 有什么作用？数量是如何计算的？

### 🎯 LP Token 的作用

-   LP Token 是流动性提供者在池子中的**份额凭证**
    
-   代表持有者在池中拥有的资产比例
    
-   可通过 `burn()` 随时赎回对应比例的两种代币
    
-   本身是 ERC20，可转让、可组合进其他 DeFi 协议
    

* * *

### 📐 LP Token 的计算方式

1️⃣ 第一次添加流动性（初始化池子）

```
liquidity = sqrt(amountA * amountB) - MINIMUM_LIQUIDITY
```

-   `MINIMUM_LIQUIDITY = 1000` 会被永久锁定
    
-   用于防止池子被完全抽空以及除零等边界问题
    

* * *

2️⃣ 后续添加流动性（池子已存在）

```
liquidity = min(
  amountA * totalSupply / reserveA,
  amountB * totalSupply / reserveB
)
```

-   按资产在池子中的**占比**计算 LP Token
    
-   取 `min` 是为了保持当前价格比例不被破坏
    
-   多余的一侧资产会被退回给用户
    

* * *

### 🧠 核心理解

> 后续加池不是按投入的绝对数量算，而是按能提供多少“等比例流动性份额”来算。

* * *

今天通过面试式复盘的方式，把 Uniswap V2 的基础结构和 LP 机制又系统过了一遍，也发现一些以前只是记结论、但没认真推过公式的地方，后面打算继续往 swap 过程和价格累计机制方向深入。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->


# 📝 Uniswap V2 学习记录（实习第 3 天）

今天主要复习了 Uniswap V2 的整体架构与核心交易机制，加深了对 AMM 型 DEX 工作原理的理解。

## 一、整体架构

Uniswap V2 主要由三部分组成：

-   **Factory**：负责创建交易对 Pair，并记录 token 对应的 Pair 地址
    
-   **Pair**：真正存资金并执行 AMM 逻辑的合约，每个 Pair 管理一对 Token
    
-   **Router**：用户交互入口，负责路径计算、转账和调用 Pair
    

三者职责清晰：Factory 管创建，Pair 管资金和定价，Router 管用户体验。

* * *

## 二、定价机制（AMM）

核心公式是恒定乘积：

> x · y = k

交易时会收取 0.3% 手续费，实际参与定价的是：

> amountIn × 0.997

交易会改变池子中两种资产比例，因此产生**滑点**。

* * *

## 三、流动性与 LP

-   添加流动性会获得 **LP Token**，代表池子份额
    
-   移除流动性时销毁 LP Token，按比例取回两种资产
    
-   手续费不会直接分发，而是体现在池子余额增长中
    

* * *

## 四、Router01 与 Router02 的区别

Router01 假设：

> 转进 Pair 的数量 = 用户实际输入数量

但很多代币存在转账扣税机制，导致 Pair 实际收到更少 token，从而 swap 失败。

Router02 新增了：

-   `SupportingFeeOnTransferTokens` 系列函数
    
-   通过 **读取 Pair 实际余额变化** 来计算真实输入量
    

因此 Router02 能兼容扣税币，现在主流 DEX 基本都使用 Router02。

* * *

## 五、设计特点

-   Pair 使用 CREATE2 部署，地址可预测
    
-   价格计算逻辑集中在 Library，链上链下结果一致
    
-   合约拆分清晰，便于二次开发和组合创新
    

* * *

## 六、个人理解

Uniswap V2 的核心在于：

-   Pair 极度稳定，几乎不改动
    
-   创新主要发生在 Router 和外围激励机制
    
-   非常适合作为 DEX 二开和 GameFi 资产交易的基础模块
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



# 📒 共学营 Day 2 学习笔记｜以太坊的去中心化是如何被“工程化”的

今天在《021 学习以太坊》中了解到一个非常震撼的事实：  
**以太坊是一个拥有百万级验证者参与的全球公链系统。**  
如此规模的分布式节点还能保持同步与安全，本身就是一项极其复杂的系统工程。

更让我佩服的是：  
以太坊不仅在机制上追求去中心化，**在实现方式上也主动对抗单点风险**，比如通过多客户端来摊平单一实现 Bug 带来的系统性风险。  
这意味着更高的研发成本和维护复杂度，但也换来了更强的系统韧性。

逐步理解后发现：  
👉 **以太坊的去中心化并不是单一机制的结果，而是多层设计叠加形成的整体系统工程。**

* * *

## 🧩 一、共识层：经济博弈保障的安全性

-   采用 **PoS + Gasper 共识机制**
    
    -   出块权与投票权分离
        
    -   由百万级验证者共同参与确认区块
        
-   引入强约束机制：
    
    -   **Slashing**：对明确作恶行为直接罚没质押本金
        
    -   **Inactivity Leak**：对长期不在线节点持续削减权重
        
-   本质是：
    
    > 用可惩罚的经济成本，替代算力博弈来保障安全性与最终性
    

* * *

## 🌐 二、网络层：真正无中心的 P2P 结构

-   全球成千上万节点通过 **P2P 网络直接连接**
    
-   没有中心服务器或调度节点
    
-   多种节点角色共同参与：
    
    -   全节点
        
    -   轻节点
        
    -   质押验证节点
        
-   网络本身具备：
    
    -   去中心发现
        
    -   多路径传播
        
    -   抗局部网络故障能力
        

* * *

## 🛠️ 三、实现层：多客户端战略对抗系统性风险

-   同一协议由多个团队、多个语言实现：
    
    -   Geth、Nethermind、Besu、Erigon（执行层）
        
    -   Prysm、Lighthouse、Teku、Nimbus（共识层）
        
-   官方长期刻意维持客户端占比的健康分布
    
-   目标不是效率最大化，而是：
    
    > 防止“一个 Bug 干翻整个网络”的灾难级风险
    

这是非常少见的工程取舍，本质是在用研发复杂度换系统安全边界。

* * *

## 🚀 四、扩容路径：Rollup 中心化执行，L1 专注共识与数据

-   扩展策略不是堆大 L1，而是：
    
    -   把执行和应用创新推向 **大量 L2 Rollup**
        
    -   L1 专注三件事：
        
        -   共识
            
        -   数据可用性
            
        -   去中心化安全
            
-   形成结构分工：
    
    -   L2 = 性能与应用实验场
        
    -   L1 = 安全与最终性锚点
        

这是一条明确的 **模块化区块链路线**。

* * *

## 🏛️ 五、治理层：社会共识优先于代币投票

-   没有形式化链上治理系统
    
-   协议升级依赖：
    
    -   公开讨论
        
    -   EIP 流程
        
    -   社区协调与客户端同步升级
        
-   避免：
    
    > 简单等同「代币持有量 = 治理权」
    

本质是承认：  
**区块链最终仍然是社会系统，而不仅是代码系统。**

* * *

## ✍️ 总结感受

以太坊的去中心化不是靠某个“神奇机制”实现的，而是：

> 在共识、网络、实现、扩容、治理多个层面同时做出工程取舍，  
> 用复杂度换取系统级安全与韧性。

这是一种非常“反商业直觉”、但极其工程理性的设计路线，  
也让我第一次真正理解了：

> 公链不是一个产品，而是一整套长期演化的社会—技术系统。

![Snipaste_2026-01-13_17-04-03.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/andOneBasketball/images/2026-01-13-1768295056827-Snipaste_2026-01-13_17-04-03.png)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->




> **Web3 实习计划 · Day 1 学习记录**

今天是 Web3 实习计划的第一天。昨晚通过线上 Zoom 会议认识了不少在 Web3 行业持续深耕、真正做实事的伙伴，对接下来的学习节奏和方向也更有信心了。

截至目前，我已经基本通读完《Web3 实习手册》的核心内容。结合自己以往的积累，目前已经具备使用 **Hardhat 与 Foundry 进行 Solidity 合约开发与测试** 的实战经验，对常规合约开发流程较为熟悉。

在接下来的训练营阶段，我希望进一步 **向交易系统与协议底层深入**，以 **DEX 与 CEX 的核心功能模块** 为切入点，系统性研究成熟开源项目的实现方式，例如：

-   CEX 方向：订单簿与撮合引擎（如 `i25959341/orderbook`）
    
-   DEX 方向：Uniswap V2 / V3 / V4 的合约架构、流动性机制与路由设计
    

通过源码级别的阅读、调试和复现，将学习成果逐步沉淀为：

-   可复用的技术总结
    
-   可展示的 Demo 项目
    
-   以及可写入简历的工程经验
    

技术栈规划上，短期仍以 **Golang + Solidity** 为主，重点加强：

-   撮合引擎与交易系统后端能力（Go）
    
-   协议与链上业务逻辑理解（Solidity）
    

中期目标是逐步补齐 **Next.js + Web3 前端交互** 能力，形成从合约 → 后端 → 前端的完整闭环开发能力。

长期希望能在 Web3 行业中找到与自身技术背景和兴趣高度匹配的 **Remote 开发岗位**，持续参与有真实业务价值的项目建设。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
