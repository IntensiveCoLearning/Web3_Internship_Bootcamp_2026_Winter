---
timezone: UTC+8
---

# Lynn000811

**GitHub ID:** Lynn000811

**Telegram:** @FourDrachma

## Self-introduction

哲学系学生探索Web3

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
一、继续在补CS知识

目前自己想了一些类比

计算机的Input Data 对应以太坊的 Calldata。在以太坊上，这些随交易发送过来的、只读的、不可修改的原始参数（比如 buy(cat\_id=101)），就是 Calldata。它就像是我写给计算机的一张只读便条，告诉它我要干什么。

其次是 CPU，对应以太坊的 EVM。我的笔记本靠 AMD / Apple M4 chip 来处理逻辑运算，而在以太坊那里则是靠 EVM。EVM 是一个不仅存在于物理实体（作为节点的计算机里），还同时存在于所有节点共识中的"虚拟 CPU"。在传统计算机里，Claude Code 帮我写的 Python 代码最终会被编译成一串串二进制的机器码，即 0 和 1，那是只有硅基芯片才能听懂的电流通断指令。而在以太坊的世界里，我的 Solidity 代码同样会被编译成 EVM Bytecode，每一小段 Opcode 都对应着一个微小的动作——比如 PUSH、ADD、STORE。

接着是 RAM，对应以太坊的 Memory。这是一种临时的存储空间。当 EVM 在计算"这只猫是否符合要求"的过程中，它需要暂存一些中间变量（比如先把 score 读进来放在手边），这些数据就放在 Memory 里。一旦这笔交易（计算）结束，这里的数据就会被瞬间抹去，就像电脑关机后内存被清空一样。

最后，也是最关键的 Hard Drive，对应以太坊的 Storage。这是 Web3 最昂贵的地方。在我的电脑里，保存一个文件到硬盘里是不用花一分钱的（或许要消耗些许电费）。但是，以太坊上写入 Storage 意味着我要永久地改变这个"世界计算机"的状态，这不仅仅是修改一个数字，而是要在全球成千上万个节点的账本上同步刻下这笔记录。正因为它是永久存储且占用全球共识的资源，所以修改 Storage 的 Gas 费极高。

PS：Stack 怎么放？好像还没找到特别合适的对应关系。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->

一、今天在继续补CS基础知识：

今天学习了逻辑门部分。梳理了一下从抽象的逻辑公式到物理电路的过程。

首先我有一个用自然语言表达的我的想法，例如，我想要一只公猫，已绝育的，白色或褐色都可以；或者一只母猫，已绝育的，除了白色任何颜色都可以；或者只要是黑猫也可以

其次我利用逻辑符号将自然语言中的表达转化为了布尔代数里的表达式

(N\*((M\*(W+T))+(F\*(1-W))))+B

(N AND ((M AND (W OR T)) OR (F AND (NOT W))))) OR B

然后我发现，对于店员任意给我的一只猫，我可以根据表达式来判断其是否符合我的结果，对于每一个判断项来说，我规定，若符合，则输出1，若不符合则输出0；由此带入表达式，若最后计算结果为1则猫满足我的选择要求，若为0则不满足我的选择要求。

接下来我发现，在这个计算过程中，AND和OR的计算过程可以被放到由继电器组成的电路中来完成，AND对应AND gate, OR对应 OR gate, NOT对应inverter；因此我其实可以根据表达式来制作一个电路来帮助我完成计算，或者说是将计算的过程直观地展现在了电路当中！ 这是一个从思维中的逻辑演算到物理世界中的电子流通的形象化过程，是香农的天才一跃！ 由此我们得到了一个ASIC（专用集成电路）。 这个电路只能被我们用来按照我的那个特定逻辑来选猫。

在某种意义上，智能合约可不可以被看作是在通用 CPU 上模拟运行的一颗逻辑被固定的虚拟 ASIC？而gas费也就是为了让“电子”跑通这个虚拟的逻辑电路的各种逻辑门，即solidity构建出的逻辑判断式，所支付的电费了（当然还有构建全网共识的最重要的这个目的）。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->


一、今天在继续补CS基础知识：

布尔代数

   布尔代数与传统代数最大的不同在于，传统代数处理数字，**而布尔代数处理类，即集合**。

   在布尔代数中，以字母表示的操作数代表集合；

   而算子**+**代表两个集合的**并集**；**\***（即✖）代表两个集合的**交集**

以猫为例，

M代表公猫的集合，F代表母猫的集合；

B代表黑猫的集合，W代表白猫的集合，T代表褐色猫的集合，O代表不在B、W、T集合中的其它颜色的猫的集合；

N代表已绝育的猫的集合；U代表未绝育的猫的集合

                 可以得出以下这些表达式：

                                   M+F=1         在布尔代数中1代表全集

                                   1-M=F          在布尔代数中1与减号连用代表在全集中排除某元素

                                   F\*M=0         在布尔代数中0代表空集

                                   1\*F=F

                                   0\*F=F

                                   1+F=1

                                   F\*(1-F)=0         这个公式为矛盾律的公式

                                   F\*F=F

在布尔代数中有以下的法则

i.               加法和乘法的交换律（与传统代数相同）

A+B=B+A 

A\*B=B\*A

ii.              加法和乘法的结合律（与传统代数相同）

A+(B+C)=(A+B)+C

A\*(B\*C)=(A\*B)\*C

iii.             乘法的加法分配率（与传统代数相同）

A\*(B+C)=(A\*B)+(A\*C)

     Iv.           加法的乘法分配律（布尔代数独有的法则）

                      A+(B\*C)= (A+B)\*(A+C)

3、布尔代数可以被用来表达逻辑命题

 例如一下这个三段论            P是人的集合；M是会死的事物的集合；S是苏格拉底的集合

                       所有人都是会死的            P\*M=P

                       苏格拉底是人                     S\*P=S

                      苏格拉底是会死的                S\*(P\*M)=S

                                                                             根据结合律可得(S\*P)\*M=S

                                                                                   S\*M=S

同时还可以用布尔代数来把对于猫的选择符号化

规则：

在布尔代数中，以字母表示的操作数代表集合；

 而算子**+**代表两个集合的**并集**；**\***（即✖）代表两个集合的**交集**

M代表公猫的集合，F代表母猫的集合；

B代表黑猫的集合，W代表白猫的集合，T代表褐色猫的集合，O代表不在B、W、T集合中的其它颜色的猫的集合；

N代表已绝育的猫的集合；U代表未绝育的猫的集合

现在：我想要一只公猫，已绝育的，白色或褐色都可以；或者一只母猫，已绝育的，除了白色任何颜色都可以；或者只要是黑猫也可以

这个命题可被符号化为：

             一只公猫，已绝育的，白色或褐色都可以: M\*N\*W+ M\*N\*T=M\*N\*(W+T)

             一只母猫，已绝育的，除了白色任何颜色都可以: F\*N\*(1-W)

             黑猫：B

       我想要的猫：M\*N\*(W+T)+ F\*N\*(1-W)+B

4、对于布尔代数的进一步符号化

      原先：算子**+**代表两个集合的**并集**；**\***（即✖）代表两个集合的**交集**；1-代表从全集中去掉某些元素

     现在：     OR代表并集；AND代表交集；NOT代表1-

   我想要的猫：

       M AND N AND (W OR T)                   M  _N_ (W + T)                

           OR                                                                     +

       F AND N AND (NOT W)                       F \* N + (1-W)

          OR                                                                      +

            B                                                                        B

这个表达式可以被用来检验我去一个宠物店，店员给我的猫是否符合我的要求

接下来可以引入数字0与1，当满足某一个要求的时候，YES，输出1（全集）；当不满足某一个要求的时候，NO，输出0（空集）

接下来还要给OR(+) 与AND(\*)分别的计算表

| OR/+ | 0 | 1 |
| 0 | 0 | 1 |
| 1 | 1 | 1 |

| AND/* | 0 | 1 |
| 0 | 0 | 0 |
| 1 | 0 | 1 |

现在店员给我一只未绝育蓝色公猫U\*O\*M       U AND O AND M

   我想要的猫：                                                                                                            店员给的猫

       M AND N AND (W OR T)                   M  _N_ (W + T)                      1\*0\*(0+0)=0

           OR                                                                     +                                               +

       F AND N AND (NOT W)                       F _N + (1-W)                         0_0+(1-0)=0

          OR                                                                      +                                                +

            B                                                                        B                                              0

                                                                                                                 最终计算结果为0，不满足我的要求
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->



一、继续在精读Mastering Ethereum

二、在快速恶补CS基础知识，希望能快速进入编程的语境吧
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->




一、继续在精读Mastering Ethereum

二、补了很多CS的基础知识

I、harvard architecture vs von neumann architecture

首先需要了解一个最简模型

计算机：一个会执行特定步骤的机器

程序：规定计算机执行步骤的顺序以及执行步骤的规则（指令集合）

数据：执行步骤时的原材料、中间结果、最终产物（数值、字符、图像…）

这里需要注意，程序和数据本质上都是由0或1组成的一串字节序列，只不过某些字节序列可被CPU当作是程序；而另一些字节序列被CPU当作是数据

接下来可引入哈佛架构和冯诺伊曼架构的区别

i.harvard architecture

在哈佛架构中，程序和数据被分别存放在两套不同的储存器中，CPU通常有分别的取指通道和取数据通道。

ii.von neumann architecture

在冯诺伊曼架构中，程序和数据被存放在同一套储存器中，CPU的取指通道和取数据通道是同一个，所以有可能出现程序/指令和数据同时抢同一个通道的情况。

II、Kitchen Analogy

Computer: Kitchen

```
    i.  program: recipe

    ii. data: ingredients

    iii. Hard Drive/ SSD: Pantry or Fridge

      Store the data in a long-term. When the power is off, the data remain there.

      However, data cannot be directly processed in the hard drive. Just like we can not chop vegetables inside the pantry or fridge, they must be sent to the countertop, the RAM.

   iv. RAM(Random Access Memory): Countertop

     Store the data when the power in on. When the power is off, everything in the RAM will be wiped off. To do any work, the data must be grabbed from the Hard Drive and stored in the RAM for the future processing conducted by CPU.

     RAM is like the countertop, when the Chef wants to cook, the Chef need to take the ingredients from the pantry/ fridge to the countertop. Furthermore, when he finishes the process, everything will be thrown away.

   v. CPU(Central Processing Unit): The only Masterchef

   Process the data in the RAM. The CPU is fast, but one core can only do one thing at the same time. 

   vi. GPU(Graphics Processing Unit): brigade of 5,000 junior interns

     GPU can do many things at the same time. It is like you tell these 5,000 junior interns to chop carrot at the same time.

   vii. ROM: morning checklist

   vii. Mother Board: Hallways of the kitchen

   The data is passed form one part to the other through the mother board.
```

[**II.Ethereum: A General-Purpose Blockchain**](https://masteringethereum.xyz/chapter_1.html#ethereum-a-general-purpose-blockchain)

i. 以太坊是一个State Machine

现在的状态（State S\_t） + 一个动作（Transaction T） = 新的状态（State S\_\[t+1\]）

也即是说每一个状态都是完全确定的，以你才可以在Etherscan上查询交易结果。（如果状态是流变的，那根本无法获得确定的查询结果）

ii. 在以太坊中数据以Key-Value Store / Tuple 键值对储存的方式存储

key 对应value

例如：

Key：A的地址➡️Value balance 0.1ETH

```
                                     nounce

                                     codehash

                                    storageRoot
```

iii. 以太坊与冯·诺伊曼架构计算机的对比

1）CPU就是EVM 负责根据程序/指令处理数据

```
这里有一个注意点，与传统的那种有物理实体的硅片CPU不同，EVM相当于是一个全部节点模拟出来的“CPU”（并不是每个节点分享一点算力出来的结合结果，而是所有节点同时重复同样的计算），根据智能合约里的编写好的规则来验证calldata，验证交易合法后，将内容写入到链上。
```

2）RAM就是solidity 中的memory：临时储存，不会上链，所以gas费便宜

3）Hard Drive就是solidity中的 storage：永久储存，会上链，所以gas费昂贵，因为要占据全网节点的储存空间（数据要被大家存到硬盘里）

4）Input data就是Calldata

例如我想把0.1ETH转给B,这个交易动作就会生成一大串代码，这大串代码就会给交给EVM验证合法性

5）程序或指令/即规则就是smart contract

```
智能合约里写好的交易逻辑
```

补充内容：

iv.冯诺伊曼式的ethereum vs 哈佛式的solana

在ethereum中，因为冯诺伊曼式的架构,程序和帐户的数据本身是被放在一起的。

其次，交易A交易B按先后顺序进来，但是因为Ethereum是一个state machine，即新交易带来的新的数据输入将产生一个新的全局状态，因此EVM将会首先处理交易A进而生成一个新的全局状态；然后在处理交易B生成一个新的全局状态。

但是solana那里，程序和帐户的数据是被分开的，如果两部交易处理的是不同的帐户数据，那就可以并行。

v. ethereum的account模型以及bitcoin的UTXO模型

ethereum：

在ethereum那里，有一个全局的ledger，记录了每一个account的eth balance，balance的数字可以根据任意转账金额而修改。

因此转帐实际上是在这个大账本上记录account的余额变化。

Alice 和Bob的转帐都需要对大账本进行修改，因此需要排序处理，无法并行处理。

bitcoin:

但是bitcoin那里，btc是以UTXO（unspent transaction output）的形式存在的。

假设我有4btc，我要转给我朋友1btc，实际上发生的事情是，原先的4btc被花掉了（spent）；然后两个不同的output被创造出来：

1btc被重新铸造出来给到了我的朋友

另外3btc被重新铸造出来给到了我

vi.以太坊的gas机制

停机问题：

1936年，艾伦·图灵（Alan Turing）提出了一个逻辑命题： **是否存在一个通用的算法，可以判断任意一个程序在任意输入下，是会最终停止（得出结果），还是会无限循环下去？** 结果是不存在这样的算法，因此无法让程序自我判断停止。

也即是说，对于ethereum这种图灵完备的系统，如果没有一个规定运算上限的机制，只要有人写一个死循环代码，EVM会一直跑下去，正因如此才有了gas机制，限定运算的上限。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->





在阅读Mastering Ethereum: 2nd Edition
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






一、今天学习尝试了vibe coding

利用cursor和claude code编了一个呈现BTC,ETH价格的网页：[https://lynn000811.github.io/Vibe-coding-test/](https://lynn000811.github.io/Vibe-coding-test/)

学会了这个模式：

1、先想一个idea，和gpt或gemini讨论一下，给一个大纲。

2、让gpt或gemini先给一个出发点的prompt，发给claude

3、让claude边写代码边完善产品

二、在学习IPFS的原理
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->







一、零知识证明

ZKP  zero knowledge proofs

prover向validator/verifier证明一个statement是正确的，而无需透露该陈述是正确的之外的其它信息。

1、直观展示zkp的一个思想实验：

Jean-Jacques Quisquater的Ali Baba’s Cave

**场景**：有一个环形的洞穴，入口是分叉路（A路和B路），洞穴深处有一道**魔法门**，只有知道咒语（私钥）的人才能打开门通过。

**角色**：Peggy（证明者，声称知道咒语）和 Victor（验证者，想验证Peggy知道咒语，但Peggy不想告诉他咒语是什么）。

**过程**：

  i.Victor 站在洞外，Peggy 随机走进 A 路或 B 路（Victor 看不见）。

  ii. Victor 走到分叉口，随机喊出一个出口：“从 B 路出来！”

  **iii. 如果 Peggy 真的知道咒语**：无论她在 A 还是 B，她都能通过魔法门（如果需要在另一侧的话）从 B 出来。    **iv. 如果 Peggy 在撒谎**：她有 50% 的几率正好站在 B 路，能混过去；但如果她在 A 路且不知道咒语，她就出不来了。

  v.**重复验证**：如果重复这个过程 20 次，Peggy 每次都成功按要求出来的概率是 $1 - (1/2)^{20}$，几乎接近 100%。

2、zk-SNARK  是零知识证明的一种具体实现形式

| 缩写 | 全称 (英文) | 含义 |
| zk | Zero-Knowledge | 零知识：验证者只知道结果是对的，不知道输入数据。 |
| S | Succinct | 简洁性：生成的证明文件非常小（几百字节），且验证速度非常快（毫秒级）。这对于区块链极其重要，因为链上资源昂贵。 |
| N | Non-Interactive | 非交互式：不需要像阿里巴巴洞穴那样重复喊话 20 次。证明者把证据打包成一个只有几百字节的“包”，发给验证者，验证者看一眼就能确认真假。 |
| AR | Argument | 论证：在计算复杂度理论中，它指的是“在计算能力有限的情况下是成立的”。它不是数学上绝对的 Proof（证明），而是密码学上的 Argument（论证），但在现实算力下几乎不可伪造。 |
| K | of Knowledge | 知识：证明者确实掌握了那个“秘密信息”（比如私钥），而不仅仅是证明某个陈述为真。 |

zk-SNARK的两大应用场景：

  i.隐私（Zcash）：

    在BTC主网上转账的时候，其实所有人都能看到转账的具体明细，以及发出钱包与接受钱包的余额。

    但是利用zk-SNARK，例如Zcash就可以实现完全不泄漏转账双方的任何信息、钱包余额…等隐私信息，矿工只需验证关于交易的那个零知识证明。

  ii.扩容（zk rollup）：

     在L2上把交易打包汇集到一个state root上，每个state root都包含一个零知识证明，证明打包结果是正确执行该批次交易后的正确结果。stete root和该零知识证明被通过rollup 智能合约上传到L1，L1仅需验证这个零知识证明，节约算力。

计划阅读：**Vitalik Buterin 的博客系列《Quadratic Arithmetic Programs: from Zero to Hero》**

二、基于Ethereum生态的DeFi全览

| 层级 | 子类型 | 核心机制与逻辑 | 行业代表协议 | 备注 | 风险主轴 |
| L0: 基础设施与数据 | 预言机(Oracles) | 中间件：将链下数据（价格、天气等）去信任化传输到链上智能合约。 | Chainlink, Pyth | 技术点：解决封闭系统的输入问题。 | 1、数据正确性与延迟（错误报价/延迟更新）； 2、依赖集中化（少数节点/数据源）； 3、操纵攻击（薄流动性市场/喂价/闪电贷）。 |
|   | 跨链桥 / 互操作性(Bridges) | 信息传递：锁定一条链资产，在另一条链铸造映射资产；或跨链传递消息。 | LayerZero, Wormhole, Stargate | 风险点：代码最复杂，黑客攻击重灾区。类比 TCP/IP 的路由层。 | 1、信任假设/验证机制（轻客户端/多签/预言机）2、合约复杂度（攻击面大）；3、消息伪造/重放； 4、桥接资产脱锚。 |
|   | MEV 基础设施(MEV & Order Flow) | 博弈层：围绕交易排序/传播/区块构建提取价值（黑暗森林）。 | Flashbots | 职业点：偏底层网络传播、区块构建、博弈论与工程化。 | 1、中心化趋势（少数 builder/relay）；2、审查与合规压力（OFAC/过滤）； 3、博弈外溢（普通用户被夹/被抢跑）。 |
| L1: 核心金融原语 | DEX (AMM)(Automated Market Maker) | 恒定乘积等公式 ($x*y=k$)：用算法替代传统做市商，无需订单簿。 | Uniswap, Curve (稳定币), Pancake | 基石：DeFi 的基石。 | 1、无常损失 (IL)； 2、滑点/深度不足（大额交易成本）； 3、价格操纵（配合闪电贷）； 4、预言机依赖（AMM 价格被用作喂价）。 |
|   | DEX (订单簿)(Order Book) | 撮合引擎：买卖单排队撮合；更接近 CEX 微观结构。 | dYdX, Vertex | 性能：通常需要高性能链（Solana / L2）支持。 | 1、链性能/拥塞风险（撮合延迟）； 2、清算风控（杠杆连锁）；3、做市集中化（流动性依赖少数做市商）。 |
|   | 交易聚合 / Intent / RFQ(Execution & Aggregation) | 求解器模式：把“意图”交给 Solvers，拆单跨池找最优价格，或 batch auction 降低 MEV 损耗。 | 1inch, Matcha(0x), CoW Protocol | 关键差异：CoW 属于 intent + solver + batch auction 的执行范式（区别于 L0 的 MEV plumbing）。 | 1、求解器中心化（少数 solver 垄断）；2、路由依赖与失败（成交不确定/回退）； 3、OFA/订单流博弈（激励扭曲）。 |
|   | 借贷协议(Lending) | 超额抵押：抵押 100 借 80；通过清算保证偿付能力。 | Aave, Compound | 逻辑：DeFi“货币市场”，资金利用率较低但安全。 | 1、清算瀑布（价格急跌）；2、预言机风险（误喂价触发清算）； 3、利率跳变/挤兑（流动性枯竭）。 |
|   | CDP / 铸币引擎(CDP & Minting Engine) | 抵押铸造：抵押进仓→生成稳定币债务；偿还回收/销毁；用清算+参数治理维持偿付。 | MakerDAO (DAI), Liquity (LUSD) | 抓手：链上“发钞机 / 资产负债表引擎”。 | 1、脱锚风险（抵押不足/市场恐慌）； 2、治理风险（参数被误设/被劫持）； 3、抵押品相关性（一同下跌）。 |
|   | 固定利率 / 期限借贷(Fixed-Rate / Term) | 期限化：把借贷期限化+利率锁定；更像 TradFi 的期限结构与债券逻辑。 | Notional | 职业点：利率曲线/期限结构/对冲会更像传统利率市场。 | 1、期限错配（短借长贷）；2、流动性折价（到期前退出成本）； 3、利率曲线定价错误（模型/参数）。 |
| L2: 资产与收益 | LSD / LST(Liquid Staking) | 资产封装：将质押 ETH 变成可流通凭证（stETH 等），释放流动性。 | Lido, Rocket Pool | 必须懂：以太坊生态“近似无风险利率”基准。 | 1、罚没/节点风险 (slashing)；2、LST 脱锚（流动性/恐慌）； 3、集中化风险（质押集中影响共识）。 |
|   | Restaking (再质押)(Restaking) | 共享安全：把质押 ETH 二次质押给 AVS 等服务，赚多重收益。 | EigenLayer, Puffer | 热点：提高资金效率，但叠加风险。 | 1、重叠风险/传染（AVS 出事牵连）； 2、罚没规则复杂（误罚/漏洞）； 3、收益与风险不对称（补贴期结束）。 |
|   | 收益聚合器(Yield Aggregators) | 自动复利：在不同协议间搬砖/复投，自动找更高收益。 | Yearn, Beefy | 工具：俗称“机枪池”。 | 1、策略与合约风险叠加（跨多个协议）； 2、权限/治理风险（策略可被替换）； 3、收益幻觉（补贴驱动不可持续）。 |
|   | 流动性管理 (ALM)(Liquidity Management) | 策略金库：面向 Uniswap v3 等集中流动性，自动调仓/再平衡/复投。 | Arrakis (及同类) | 更像：“策略做市 / 风控参数化”。 | 1、再平衡损耗（频繁调仓成本）； 2、策略失效（波动结构变化）； 3、LP 风险（更像做市风险而非单纯存款）。 |
|   | 稳定币 (资产形态)(Stablecoins) | 挂钩机制：法币映射 / 债务抵押 / 合成对冲，维持 1:1 锚定。 | USDT, DAI, USDe | 观察：DAI/LUSD 的“引擎”见 L1 CDP；USDe 是合成对冲。 | 1、脱锚（流动性/信心）； 2、对手方风险（法币托管/银行）； 3、对冲失效（合成型遇极端行情）； 4、监管风险（冻结/合规）。 |
|   | 保险 / 风险覆盖(Insurance) | 风险对冲：把合约风险/黑客风险打包成 cover；为机构提供风险预算工具。 | Nexus Mutual | 定位：DeFi 的“安全边际”，常见于机构尽调。 | 1、尾部风险定价难（黑天鹅）； 2、资本不足（大额赔付）；3、治理/索赔争议（是否赔付）。 |
|   | BTCFi(Bitcoin DeFi) | 释放流动性：在二层或通过质押/再质押产生收益。 | Babylon, Merlin | 相关性：让冷钱包 BTC 也能“生息”。 | 1、桥接/托管风险（BTC 进入其他系统）； 2、共识/安全假设变化（新协议）； 3、流动性与退出风险（回到 BTC 主链）。 |
| L3: 衍生品与进阶 | 永续合约(Perpetuals) | 资金费率：多空互付，使价格锚定现货附近。 | GMX, Hyperliquid | 特点：手续费常更“真实”，也更接近交易所业务。 | 1、清算连锁（高杠杆）； 2、预言机/标记价格（操纵触发）； 3、做市池风险（LP 承担对手盘）。 |
|   | 利率 / 本息分离(Yield Trading) | 时间价值：拆分为本金代币 (PT) 与收益代币 (YT) 分别交易。 | Pendle | 特点：把“现在价值”与“未来收益”剥离。 | 1、利率曲线风险（再定价）；2、流动性风险（长尾期限）；3、组合复杂度（用户误用）。 |
|   | 期权 / 合成资产(Options / Synths) | 对冲/追踪：波动率交易；或追踪现实资产价格。 | Lyra, Synthetix (SNX) | 机制：合成资产强依赖预言机与抵押机制。 | 1、尾部风险（卖方爆仓）；2、预言机与抵押不足（脱锚/穿仓）； 3、监管压力（证券化/合规）。 |
|   | 链上资管 / 指数(Structured Products) | 封装：把资产篮子/策略封装成可交易代币；把期权策略等“产品化”。 | Index Coop, Set, Ribbon | 定位：“基金产品经理 + 策略包装”。 | 1、复杂产品误导（风险披露不足）； 2、策略黑箱（参数/权限）；3、流动性与赎回折价。 |
| L4: 边缘与实验 | RWA(Real World Assets) | 资产上链：美债/票据/房地产等上链，连接 TradFi 与 DeFi。 | Ondo, MakerDAO (RWA) | 趋势：合规资金入口；收益多来自美债。 | 1、法律可执行性（链上≠链下）； 2、托管/破产隔离（SPV/银行）； 3、监管与牌照（合规成本）。 |
|   | 预测市场(Prediction) | 信息发现：对事件结果下注，聚合群体信息。 | Polymarket | 社会学：真金白银的“信息聚合器”。 | 1、监管风险（博彩/衍生品界定）； 2、操纵与流动性（小市场易被带节奏）； 3、预言机/仲裁争议（结果判定）。 |
|   | 隐私 / 零知识(Privacy / ZK) | 数据遮蔽：证明我符合条件，但不暴露身份/余额等。 | Tornado Cash, Aztec | 矛盾：技术重要但监管阻力巨大。 | 1、合规高压（制裁/追踪）；2、可用性与成本（证明成本）； 3、匿名集大小（隐私强度）。 |
|   | 流支付(Streaming) | 连续性：按秒结算，资金如水流。 | Sablier | 概念：改变货币支付的“离散”时间属性。 | 1、权限/撤销逻辑（雇主/合约控制）； 2、稳定币依赖（支付币脱锚）； 3、合约漏洞（资金持续流出）。 |
|   | 无抵押信贷(Unsecured Credit) | 信用借贷：基于链下信用/白名单/机构尽调借贷。 | Maple, Goldfinch | 难点：身份确认与违约执行。 | 1、信用违约（坏账）； 2、身份与女巫攻击 (Sybil)；3、法律追偿（链下执行成本）。 |

三、预言机

1、预言机的作用：

预言机Oracle被用来向链上的智能合约提供链下数据的输入

2、为什么需要预言机：

i、链上共识达成优先：节点不能在共识执行中直接请求外部 API，否则难以保证结果一致；

ii、安全与责任隔离：数据采集/清洗/聚合应由专门网络承担；

iii、成本与扩展：链上更新贵，需要在更新频率与成本之间权衡。

三、预言机服务提供商：

1、Chainlink

2、Pyth

....

四、Chainlink的运作流程：

1、数据源Data Source：现实世界中多个机构提供某一数据

2、节点运营商Node Operator:链下诸多服务器（节点）监听着数据源

3、聚合Aggregation：

i.为了防止不诚实节点，Chainlink引入了DON(Decentralized Oracle Network)的机制

ii.例如N个节点分别从不同的数据源监听着ETH的价格，并上报结果

iii.通过特殊设计的机制，例如取中位数，去除异常值，例如过高或或低的结果，最终生成共识数据结果

4、结果push上主链：将共识数据结果通过智能合约上传主链

5、数据获取：需要获取相关数据的智能合约直接可在主链上获取pushed的数据

五、Pyth的运作流程：

1、权威机构或第一方数据提供者直接是Pyth的节点（例如获取ETH的价格时，多个CEX就直接事节点）

2、节点上传数据，数据被打包上Pythnet（一个基于Solana技术的链），并签名

3、通过\[\[跨链桥\]\]服务在用户需要时将签名后的数据分发到别的链

4、目标链上的用户/APP需获取数据

5、获取数据方付费，Pythnet上关于此数据的数据包被跨链桥到目标链上；获取数据方的行动与需要的数据被整合在一起

六、Chainlink与Pyth运作的不同模式

1、Chainlink的push模式：

i.无论是否有人需要该数据，数据均上主链

ii.隔一段时间才更新最新数据

优点：去中心化；适合持续需要某数据的情况

缺点：成本与更新频率有关；更新的速度

2、Pyth的pull模式

i.用户有需要时再去拉取数据

ii.Pyth节点的权威机构实时更新数据

优点：快、便宜

缺点：依赖中心化机构
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->








一、完成了对URL范式的总结，明天搞IPFS

I.基础概念

   TCP/IP模型：**Transmission Control Protocol/Internet Protocol**（传输控制协议/网际协议）

    分四层：

        i.应用层：规定程序之间如何沟通，规定处理数据的协议

                       HTTP/HTTPS协议:一种传输协议，规定浏览器和服务器沟通的规则（request and response； header and body； html and resources； status code）

                       DNS协议

                       URL

                        DHCP协议

                        …

        ii.传输层：规定通过应用层处理过后的数据的发送方式；同时给数据贴上其将前往的的端口位置；至此数据被处理为数据段（被切分）

                       TCP协议：确保数据段按顺序、完整地送到；比较慢

                        UDP协议：比较快地处理数据段，但可能不完整

                        端口

                         …

        iii.网络层：帮助数据找到要去的地方，负责寻址和路由；至此数据被处理为数据包（被打包）

                       IP(IPV4/IPV6)：把数据包发到对应的IP地址(IP地址；子网掩码；路由)

                        ICMP：确认能不能送到（比如ping命令会发一个探测包到对应的ip地址，之后可以看到一来一回用了多久，即延迟；比如traceroute命令，可以看到沿途经过的路由器节点）

                       …

        iv.网络接口层：负责把数据转为各种介质的信号（光信号/无线电波），通过物理媒介将信号发出；至此数据被处理为数据帧（头尾加了特殊标记，确保信号可被网卡识别）

                       wifi协议

                       ARP：把IP翻译为MAC

                       MAC地址

                        硬件设备

                        …

II、URL范式（去哪里拿想要的数据？）：**Uniform Resource Locator 统一资源定位符**

例子：获取一张网站上的图片

  0）、能上网

  DHCP 自动分配网络参数的服务 给我分配了4个东西：

   I. IP地址：互联网上设备接收数据包的地址

   ii. 子网掩码：判断地址是否是局域网内的地址还是局域网外的地址

   iii. 默认网关：访问外网时的第一出口，若在局域网内可直接互相访问【一般默认网关是某台附近的路由器】

   Iv. DNS服务器：负责把域名（[例如www.baidu.com](http://例如www.baidu.com)）解析为域名所对应ip地址

还有一个MAC，是设备制造时每个设备所拥有的唯一身份识别码,设备厂商在制造设备芯片时就已经提前烧录好了这个码在芯片上。

补充概念：

     局域网：小范围的内部网络，需要通过网关才能访问外网

     外网/公网/互联网：连接全世界的网络

     路由器：负责把数据包往正确的方向发的设备

    1）、输入网址并解析IP

    我在浏览器中输入域名domain name，即方便人类记忆的网站名字

   电脑将想办法把domain name解析为ip，有四个顺序：

         首先是查询浏览器cache

          其次是查询OS Cache

          然后是查询电脑的hosts文件

          最后是发送解析请求给DNS服务器，DNS（domain name system）服务器负责将我输入的域名解析（即翻译）为ip地址

     2）、知晓IP后传输数据包

   基础概念： 

  i.数据包：数据包包含两类信息：类似信封的来源IP以及目标IP；类似信纸，即真正内容的数据。  因为数据较大，一般会被拆分成多个小包来发送。

  ii.路由routing：决定数据下一步往哪里走：

  iii.路由器：负责把数据包往正确的方向发的设备

  iv.跳hop：每经过一个路由器就是一跳

  v.IP与MAC的差异：前者可能会有变换，但是后者完全不会有变换（一机一码）

    我的电脑首先通过本机IP以及子网掩码做判断，看目标IP是否与本机在统一局域网内。

    若yes,则直接通过局域网把数据包发给目标方；若no,则把数据包发到默认网关那里。

    若不在局域网内，数据包需要被发到默认网关那里，而这一步电脑通过ARP查询到默认网关的网卡的MAC地址，用来唯一定位发送方，即默认网关的网卡。

    默认网关接收到数据包，以目标IP为导向进行下一跳，将数据包发送至另外的路由：

    例：宿舍路由器➡️校园网路由➡️学校出口路由➡️运营商路由➡️城市路由➡️….百度机房路由➡️百度服务器

      3）、建立连接

     基础概念：

   i.端口port：虚拟通信端点。把每个ip比做一个大楼，端口就是里面每个不同的房间。 不同端口提供不同的服务。

   ii.TCP:一种传输协议，确保数据包按顺序、完整地送到

               在TCP内建立连接：双方建立持续的通信通道

   iii.HTTP:一种传输协议，是明文通信，没有加密

   iv:HTTPS:一种传输协议，HTTP+TLS加密

    TCP的三次握手（双方确认数据可以传输）：

                 第一次握手：我告知对方我想建立连接  SYN

                 第二次握手：对方回复收到，并同时确认对方也想和我建立连接 SYN+ACK

                 第三次握手：经前两次确认后，开始建立连接传输数据ACK

     HTTPS通过443端口进行的TLS握手，握手中发生的四个事情（加密传输信息）：

                 1：我与对方服务器商定所使用的加密算法 

                 2：服务器出示证书Certificate（域名的身份证）

                 3：浏览器验证证书，证明访问的域名确实是某个正式域名，而不是假域名

                  4:生成对话密钥session key，通过这个密钥处理数据

        4）、正式请求网页

      基础概念：

   i.request：浏览器对服务器发送对于某个东西的请求（例如想要某张png图片/网页的html）

  ii.response：服务器响应，即回应，“这是你要求的xx”或“没有/无权限/出错”

  iii. Status code：服务器响应时代表结果的数字，如404（找不到）

  iv. URL path：域名（[https://www.baidu.com/）、路径（https://www.baidu.com/后的【img/flexible/logo.png】）都可用URL的方式来表达](https://www.baidu.com/）、路径（https://www.baidu.com/后的【img/flexible/logo.png】）都可用URL的方式来表达)

  v. Header and body:HTTP信息的两个组成部分

              header:说明信息（浏览器类型、是否有cookie【网站放在浏览器里的身份凭证，用来记录登录状态】）

               body:真正的内容

   Vi. HTML：网页的骨架，HTML将告诉浏览器什么地方放标题、文本、图片、脚本…

    vii. Resources：  具体呈现的资源，例如上述提到的标题、文本、图片、脚本

           浏览器发出request要求获取网页html

           服务器回应response，给关于网页html文本的HTTP信息：（由status code+header+body【html内容】组成）

            浏览器解析HTML，发现需要加载其它resources来呈现网页（图片+脚本…）

        5）、下载图片：

          基础概念：

     i. MIME TYPE:服务器会在response里告诉浏览器，给过来的是什么东西，通过一个字段来表达，例如image/png

          浏览器看到html里写某个位置是一张图片

          浏览器发送http信息的request申请获取该图片

         服务器返回http信息的response

              Status code

             +header: content type为png 告诉浏览器这个文件是一个png文件

              +body：关于该图片的二进制数据

          浏览器接受http信息的response，把关于该图片的二进制数据按照png格式的规则转码，并将图片呈现在显示屏上。同时将图片存入cache缓存（把下载的东西暂存起来，下次使用更方便）

         通过浏览器下载图片，图片就以二进制数据被写入了硬盘，成为了一个.png格式的文件

结论：若NFT的图片是被存在这种中心化的服务器上的，那么仍然达不到想要的那种唯一性及不可篡改性。因为服务器管理员完全可以更改那个URL path下png文件的内容。

二、以太坊L2

  I. rollup

交易不用在以太坊主链上执行，而是在layer2上执行完，把交易信息处理完打包经过rollup智能合约上传主链

交易以及交易的打包在layer2层面进行

i. L2产生一个新的状态承诺state commitment,即一个state root,一个merkle tree的根节点

 ii.接下来这个state root将被与zk rollup的有效性证明/ optimistic rollup的可挑战承诺一起被提交到L1的rollup合约里，最终由L1确认。

由此可以区分出两种不同的rollup方式

 Zk rollup/ optimistic rollup

三、optimistim rollup:    Optimism/Arbitrum

范式：fraud proof

1、optimism

    i.乐观假设：假设rollup上L1的state root是正确的，但同时预设在挑战期内可被证明是错误的

     ii.DTD：留下了dispute time delay的机制，即有一个挑战期。在挑战期内质押了token的挑战者可以向智能合约提交某批次计算错误的证明。

    iii.惩罚：若挑战者是正确的，则rollup者质押的资产归挑战者所有；若挑战者虚假挑战，则挑战者失去资产，归rollup者所有。总之，错误方失去质押资产

   iv.最终确认：无挑战则在L1finalize；有挑战且证明提交结果无效，则需重新提交正确的state root

       在次情况下，那个对应的错误proposal\_n=root\_x将被视为invalid，其后所有串联的proposal将不会被finalize

   痛点：

     i.挑战期长，交易被最终固定下来的时间长，用户体验差

      ii. 需要有足够的挑战者来验证rollup区块的合法性并及时在DTD期内提交欺诈证明

     iii.验证欺诈的计算放到L1，耗费gas

2、arbitrum

     L2上的多轮交互式欺诈证明+L1上的一步式

        i. asserter在H0➡️Hn的哈希链上做二分切分，challenger找错误处…..直至找到某个Hi➡️H（i+1）的错误处

         ii.定位到的特定的Hi➡️H（i+1）的错误处被交给l1上的智能合约验证

      优点：

   i. 把尽可能多的计算工作放到L2本身来进行，不用像optimism那样把整个块在L1上重新计算。

    ii.大部分计算工作在L2完成了，因此gas used消耗低，由此有空间用以组合其它类型的智能合约，允许更复杂的计算逻辑

四、zk rollup

待继续...
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->









一、看完了

[**Day 3: ENS, DEX, Identity, Inventory, Sybil**](https://www.youtube.com/watch?v=wYSMNdIRoII&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=3)

[**Day 4: NFTs!!! ERC20 vs ERC721, IPFS, Metadata**](https://www.youtube.com/watch?v=NOdrEpnoCiM&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=4)

[**Day 5: Stuck Transactions, Gas Limits, Multisigs, L2s, Lending...**](https://www.youtube.com/watch?v=11QTT6BK5j0&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=5)

二、仔细阅读了区块链黑暗森林自救手册

开始使用了1Password这款密码管理软件，很好用

了解到了硬件钱包可以用来做多签中的一个签名者，有意思

三、在学习NFT的时候遇到了IPFS这种协议，目前在梳理传统的URL模式和IPFS机制的不同的运作模式
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->










一、回顾了昨天关于mint NFT机制的部分

回顾时突然有了一个idea，mint机制（为我的艺术创作品赋予其在链上可被查询到的唯一身份标识）其实和德国哲学家瓦尔特·本雅明提到的一个概念“艺术作品的灵韵（aura）”有着非常深刻的关联，mint机制似乎可以被看作是艺术作品灵韵化的一个过程/机制。

  
本雅明认为在一个技术复制的时代，艺术作品的灵韵将不复存在，但是现在看来人们似乎找到了一个用技术手段而不是时间-空间手段为艺术作品灵韵化的机制。

  
对这个话题NFT-AURA相关的文章进行了一个初步的整理汇总，发现已经有一些人关注到了这一可能的思考路径。最近几天还在学习基础知识，之后将会抽时间把这个思路写成文发到x上。

二、仔细做完了[Unphishable](https://unphishable.io/) 钓鱼攻防挑战的两个章节，感觉可能的坑真是异常的多

养成了详细看签名内容、仔细核对地址的习惯

三、通过Uniswap的 V2机制对DEFI有了一个直观的了解，不得不感叹，恒定乘积公式真是太“美”了

I、Uniswap的特点

开创了automated market maker，AMM机制，通过恒定乘积公式实现代币定价，用户在liquidity pool中存入代币成为liquidity provider赚取手续费。

优点：不再采用CEX的订单簿模式（买卖对手方挂单成交），而是通过事先编好的智能合约来直接执行交换逻辑

II. 恒定乘积公式 k=x\*y解释（无手续费的情况）

K常数=x(该流动性池中代币A的数量)\*y（该流动性池中代币B的数量）

例如：流动性池1中有

     1,000,000=100（100个A代币）\*10,000（10,000个B代币）

                            此时直觉上的看到的汇率1A=100B

假设目前不收取手续费，一位用户意图存入50个A代币换取B代币

     新恒定乘积公式

      1,000,000=150A\*nB➡️       n=6,666.66666…

       用户通过存入50个A代币换取了10,000-6,666.7 = 3333.3个B代币

                             实际得到的汇率1A=66.666B

实际上用A换到的B没有一开始直觉上看到的汇率所能换得的那样多！此处我遭遇了一个现象，即我下单前期望的价格和实际下单后真正成交的价格之间有差值。而这个差值百分比化即可得到滑点，实际成交价格相对于期望价格的偏离程度，slippage=P期望-P实际/P期望\*100%

定位滑点产生的原因：在总流动性不变的liquidity pool中AMM是通过两种资产之间的相对储备量来确定瞬时价格的。即若lp中A变多，B就变少，每一单位A所能够换到的B的数量就一定会减少，由此A相对于B变得便宜，而B相对于A变得昂贵。                                 

III.Liquidity provider收取 0.3%手续费的情况，即实际情况   

例如：流动性池1中有

     1,000,000=100（100个A代币）\*10,000（10,000个B代币）

目前liquidity provider将收取0.3%的手续费，一位用户意图存入50个A代币换取B代币

        用户有效A代币投入数量计算：50\*（1-0.3%）=50\*0.997 = 49.85A

          新恒定乘积公式

            1,000,000=149.85A\*6673.34B

         用户通过存入50个A代币换取了10,000B-6673.34B = 3326.66个B代币

                          实际的到的汇率1A=66.533B

    因为手续费归liquidity poll，故此lp将有一个新的恒定乘积公式

                  150A\*(10,000B-3326.66B) = 1,001,001

           k反而比之前变大了！因为0.3%的手续费留在了池子里！但这部分增量并不参与未来的交换，而是留在池底作为最后对于liquidity provider赎回流动性时的奖励。

**IV. 无常损失 (Impermanent Loss) 推导**

**核心定义：** 无常损失是指“你在流动性池子里的资产价值”与“如果你直接把币拿在手里不存入池子（HODL）的资产价值”之间的差额。

**为什么叫“无常”？** 只要价格回到你最初存入时的价格，这个损失就会消失；但如果价格回不去，你取出来的时候，这个损失就变成“永久”的了。

**1\. 设定初始状态 (Initial State)**

假设为了计算方便，忽略手续费（单纯看价格波动带来的数学影响）。

-   **市场价格：** 1 ETH = 100 DAI
    
-   **你存入资金：** 1 ETH + 100 DAI
    
-   **你的总资产价值：** $200
    
-   **池子状态：** x=1 (ETH), y=100 (DAI)
    
-   **恒定乘积 k：** k = 1ETH \* 100DAI = 100
    

**2\. 价格发生剧烈波动 (Price Change)**

假设 ETH 暴涨，外部市场价格变成了 **1 ETH = 400 DAI**（翻了4倍）。

这个时候，套利者会疯狂进场搬砖，他们会不断从池子里买走便宜的 ETH，直到池子里的价格跟外部市场持平（即 1:400）。

我们需要计算池子达到平衡时，资产变成了多少。

-   **新的价格公式：** y / x = 400
    
-   **恒定乘积公式：** x \* y = 100
    

通过解这个方程组：

1.  y = 400x
    
2.  x \*(400x) = 100 ➡️400x^2 = 100 ➡️x^2 = 0.25
    
3.  **新数量 x (ETH)：** 0.5
    
4.  **新数量 y (DAI)：** 200
    

原本有 1 个 ETH，现在只剩下 0.5 个了。因为价格涨了，人们把 ETH 买走了，留下了更多的 DAI。

**3\. 算账：做 LP 亏了多少？ (Comparison)**

现在我们来对比两种情况的资产总价值（以 DAI 计价）：

**情况 A：如果当初没有做 LP，只是拿着币躺平 (HODL)**

-   你手里的币：1 ETH + 100 DAI
    
-   按照现价 (ETH=400) 计算：1 \*400 + 100 = 500DAI
    

**情况 B：你做了 LP，现在的资产价值**

-   池子里的币：0.5 ETH + 200 DAI
    
-   按照现价 (ETH=400) 计算：0.5 \*400 + 200 = 200 + 200 = 400 DAI
    

**结果对比：**

-   躺平价值：$500
    
-   做 LP 价值：$400
    
-   **无常损失：** $500 - 400 = 100  DAI
    

**结论：** 尽管总资产从 $200 涨到了 $400，**是赚了钱的**，但如果不做 LP，能赚到 $500。**这少赚的 $100，就是无常损失。**

**4\. 为什么会这样？ (The Logic)**

在 AMM（自动做市商）机制里，LP本质上是在“被动地执行逆势交易”：

-   当 ETH **上涨**时，你一直在**卖出** ETH（越涨越卖），换回价值波动小的 DAI。
    
-   当 ETH **下跌**时，你一直在**买入** ETH（越跌越买），手里的 DAI 越来越少。
    

**一句话总结无常损失：**

失去了暴涨资产的潜在涨幅（因为被卖飞了），或者接盘了暴跌资产的库存（因为接飞刀了）。

**5.盈亏平衡点**

**LP 真正的利润 = 手续费收入 - 无常损失**

-   如果 k 值增长（手续费积累）的速度，跑赢了价格偏离带来的损失，那就是赚的。
    
-   如果币价单边暴涨或暴跌，手续费通常跑不赢无常损失，这时候做 LP 反而不如直接持币。
    

四、安全大法：不点、不装、不签、不转！

五、找工作注意事项

1、背调公司牌照获取情况

2、了解是否有大陆展业情况？

3、了解工作内容与合约、期权板块的关联度

4、劳动合同签约主体：海外主体/国内主体的利弊了解

5、 薪资出金风险
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->











一、通过银行体系来类比以太坊的基础设施（修改了一下昨天的旧笔记的内容，把dApp加入进来了）：

1.  **区块链 (Blockchain):**
    
    -   \= **银行的中央大账本**。
        
    -   _作用：_ 负责存数据，记录每个人有多少钱，保证账本不被篡改。
        
2.  **EVM (以太坊虚拟机-Ethereum Virtual Machine):**
    
    -   \= **银行的操作系统/后台系统**。
        
    -   _作用：_ 提供智能合约得以运行的环境。
        
3.  **dApp(decentralized app):**
    
    -   \= **自动柜员机 (ATM) / 柜台窗口**
        
    -   _作用：_ 做交互，连接链上的智能合约（后端）和链下的客户端页面（前端）
        
4.  **智能合约 (Smart Contract):**
    
    -   \= **制定具体的业务规则**
        
    -   _作用：_ 具体的业务规则（如：“IF A 存入 100，THEN余额 +100”）。
        
5.  **钱包 (Wallet):**
    
    -   \= **银行卡 + 密码 (私钥)**。
        
    -   _作用：_ **身份证明**。它不存钱，它只是证明“我是这个账户的主人，我有权动用这笔钱”。
        

二、MINT了第一个NFT图片、并在[sepolia.etherscan.io](http://sepolia.etherscan.io)上查到了交易记录

三、在gemini的引导下执行了以下几个操作：

1、去到了Sepolia Etherscan上查了0x3d0172a432A1E861Df1434E44F815D32E9bed5cC合约地址

2、打开了contract细节页面

3、找到了tokenURI,在tokenID输入了我的NFT的ID 273，得到一大串代码：data:application/json;base64,eyJuYW1lIjogIk1GTkZUICMyNzMiLCJkZXNjcmlwdGlvbiI6ICJNeUZpcnN0TkZUIGlzIGEgbm9uLXByb2ZpdCBpbnN0cnVjdGlvbmFsIHByb2plY3QgZm9yIFdlYjMgbmV3Ymllcy4gR2V0IGEgRlJFRSBORlQgd2hpbGUgbGVhcm5pbmcgYWJvdXQgV2ViMywgdW5kZXJseWluZyB2YWx1ZXMgb2YgTkZULCBhbmQgc2VjdXJpdHkgcHJpbmNpcGxlcy4iLCJpbWFnZSI6ICJodHRwczovL2Nkbi5teWZpcnN0LmlvL25mdC9uZnQtMTc2ODI4NjkxNDgwNi5wbmciLCJhdHRyaWJ1dGVzIjogW119

4、GEMINI让我去BASE64DECODE解码出JSON文本（metadata）：

{"name": "MFNFT #273","description": "MyFirstNFT is a non-profit instructional project for Web3 newbies. Get a FREE NFT while learning about Web3, underlying values of NFT, and security principles.","image": "[https://cdn.myfirst.io/nft/nft-1768286914806.png","attributes](https://cdn.myfirst.io/nft/nft-1768286914806.png","attributes)": \[\]}

5、通过访问[https://cdn.myfirst.io/nft/nft-1768286914806.png](https://cdn.myfirst.io/nft/nft-1768286914806.png) 看到了我生成的NFT图片！！！！！！！！！！！！！！！！

四、使用GEMINI梳理了一下MINT过程中发生的事情（还没完全消化）

**第一阶段：意图的确认（The Authorization）**

**—— 私钥的签名**

一切始于你在网页上点击那个“Mint”按钮的瞬间。

1.  **构建交易（Raw Transaction）：**
    
    -   网页前端（DApp）向你的钱包（MetaMask）发送请求：“请准备一笔交易，目标是合约地址 0x3d01...，附带数据是‘调用 Mint 函数’。”
        
2.  **数学签名（The Signature）：**
    
    -   MetaMask 弹出窗口，显示 Gas 费。当你点击“确认”时，你的**私钥**在后台对这笔交易数据进行了 **ECDSA 运算**。
        
    -   **结果：** 生成了一个数字签名 (r, s, v)。这个签名证明了：“是**我**（持有该公钥的人）授权了这次操作，且内容未被篡改。”
        
3.  **广播（Broadcast）：**
    
    -   这笔带签名的交易被发送到以太坊网络的内存池（Mempool），等待矿工/验证者打包。
        

**第二阶段：事实的刻写（The Execution）**

**—— 智能合约的运行**

这是“无中生有”发生的时刻。验证者将你的交易打包进区块（Block #10033260）。

1.  **状态变更（State Change）：**
    
    -   以太坊虚拟机（EVM）找到目标合约，开始执行代码。
        
    -   **扣费：** 从你的余额里扣除 Gas 费（给验证者）。
        
    -   **铸造函数：** 执行 \_mint(你的地址, TokenID)。
        
2.  **写入账本（The Ledger Update）：**
    
    -   合约在区块链的内部存储里修改了一个巨大的映射表（Mapping）：  
          
        Mapping\[273\] = 0x6993...（你的地址）  
        
    -   同时，触发 Transfer 事件：记录代币从 **零地址 (0x0000...)** 转移到了 **你的地址**。
        
    -   **此刻，Token ID #273 正式诞生。** 它在数学上属于你了。
        

**第三阶段：意义的链接（The Association）**

**—— 指涉链条的建立**

有了 ID，但这只是一个空壳数字。它代表什么？这时候“索引”机制开始工作。

1.  **查询 URI（Pointer）：**
    
    -   合约中有一个 tokenURI 函数。
        
    -   当有人（或平台）问：“ID #273 是什么？”时，合约返回了 **Base64 编码字符**（或者是 IPFS 链接）。
        
2.  **解码元数据（Metadata）：**
    
    -   浏览器/平台拿到这串字符，进行解码，还原出 **JSON 文本**：
        
        -   **Name:** "MFNFT #273"（赋予它名字）
            
        -   **Description:** "Web3 教育项目..."（赋予它叙事）
            
        -   **Image:** "[https://cdn..."（赋予它视觉入口）](https://cdn..."（赋予它视觉入口）)
            

**第四阶段：表象的呈现（The Representation）**

**—— 最终的视觉化**

这是你在 OpenSea 或钱包里看到图片的那一步。

1.  **顺藤摸瓜：**
    
    -   OpenSea 的服务器读取 JSON 中的 image 字段。
        
    -   它发现地址是 [https://cdn.myfirst.io/...。](https://cdn.myfirst.io/...。)
        
2.  **提取实体：**
    
    -   服务器向那个中心化 CDN 发起 HTTP 请求。
        
    -   CDN 返回那张 .png 图片文件。
        
3.  **显形：**
    
    -   图片最终显示在你的屏幕上。
        

**总结：一条完整的“指涉链”**

如果用一句话概括 Mint 的全流程，那就是：

**私钥签名授权** ➡️ **支付 Gas** ➡️ **链上生成唯一 Token ID** ➡️ **ID 指向 Metadata (JSON)**➡️ **Metadata 指向图片文件。**
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->












## 第一部分：范式转变

### 1\. Web 的代际演变

主线是关于**用户与数据信息/资产之关系**的演变：

-   **Web 1 (Read-Only | 只读):**
    
    -   _核心逻辑：_ 平台单向静态罗列内容，用户被动接收。
        
    -   _形态：_ 静态网页、门户网站 (Yahoo)。
        
    -   _用户角色：_ 主要是**信息消费者**。
        
-   **Web 2 (Read-Write | 读+写):**
    
    -   _核心逻辑：_ 用户创造内容，平台分发。
        
    -   _形态：_ 社交媒体 (Twitter, Facebook)、博客…
        
    -   _用户角色_：**信息制造者**
        
    -   _痛点：_ 平台**中心化垄断**。用户无数据主权，数据归平台所有，同时用户面临审查与封号风险。
        
-   **Web 3 (Read-Write-Own | 读+写+拥有):**
    
    -   _核心逻辑：_ **去中心化与所有权**。通过区块链技术，让用户真正拥有自己的数据和数字资产。
        
    -   _形态：_ 链上应用 (DApps)、数字钱包、NFT…
        
    -   _关键：_ 免审查、不可篡改、无需许可。
        

### 2\. 概念辨析：Web3 vs Web 3.0

-   **Web3 (Crypto/Blockchain):**
    
    -   指**区块链网络**。
        
    -   核心是**资产与信任**。解决的是“价值传输”和“去中心化协作”的问题。
        
-   **Web 3.0 (Semantic Web | 语义网):**
    
    -   指**机器可理解的网络**。
        
    -   核心是**数据结构化与推理**。给互联网加一层机器能读懂的“语义结构网络”。
        
    -   例子：比如以前搜索“哈姆雷特”更偏向关键词检索；而在语义网/知识图谱的框架下，“哈姆雷特”会被识别为一个实体（作品或人物等），并被放进一张“实体—关系”的网络里：它与其它概念，如“莎士比亚”（作者）；“戏剧”（genere）；“人物”（作品里的人名所指向的那个角色）等有明确关系。这样搜索引擎不只匹配词，而是能基于这些关系做更准确的理解、联想与推理。
        

## 第二部分：关键概念

### 1\. 密码学：区块链的安全底座

-   **非对称加密 (Asymmetric Cryptography):**
    
    -   **机制：** 公钥密码学。
        
    -   **核心逻辑：** 个人掌控私钥。交易进行时，必须**用私钥签名**，交易才能完成。
        
    -   **关系：** \* 私钥 = 资产控制权（不能泄漏）
        
        -   公钥 = 链上地址（可公开）
            
-   **哈希函数 (Hash Function):**
    
    -   **定义：** 将**任意长度**的 Input 转换为 **16进制、定长256位** 的 Digest 。
        
    -   **三大特性：**
        
        1.  **单向性：** 无法通过 Digest 反推 Input。
            
        2.  **抗碰撞性：** 不同的 Input 产生的 Digest 完全不同。（侧重**防伪造**，保证每个Input产生的Digest都是唯一的）
            
        3.  **雪崩效应：** Input即使改动一点点，Digest将完全不同。（侧重**防推导**，无法通过Digest来推测新旧Input是否相似）
            

### 2\. 区块链结构、区块链的运作步骤、去中心化节点网络与防篡改机制

-   **区块链基本结构（区块+链）：**
    
    -   **区块 (Block):** 一个区块包含**有限的**交易信息、**上一个区块的摘要 (Previous Hash)**、时间戳等。
        
    -   **链 (Chain):** 按时间先后顺序将旧-新区块连接。
        
    -   **成块上链**：成块：把有限的新交易信息打包为一个新的区块；上链：将新打包的区块通过链链接上之前的旧区块
        
-   **区块链运作步骤：**
    
    -   **用户链上操作**：转帐、调用智能合约等
        
    -   **交易广播**：用户链上操作被广播到去中心化的节点网络中的各个节点
        
    -   **节点验证**：矿工节点验证操作的合法性（例如余额是否足够；签名是否正确）
        
    -   **验证交易打包成块**
        
    -   **新区块上链**
        
    -   **奖励发放**：对完成打包区块并上链的矿工发放代币奖励
        
-   **去中心化节点网络：**
    
    -   **定义:** 区块链不是运行在某一台中心服务器（如阿里云、腾讯云）上，而是运行在全球成千上万台独立的计算机（即**节点**）上。
        
    -   **分布式账本 (Distributed Ledger)**： 网络中的每个“全节点”都完整下载并保存了一份一模一样的区块链账本。
        
        ```
               验证：节点会独立验证每一笔交易和每一个新区块是否合法（比如检查区块内对应交易信息的交易签名、余额）。 
        
               冗余安全：即使损失1000个节点，只要还有其他节点在线，数据就不会全部丢失，网络依然正常运转。
        ```
        
-   **双重防篡改防线:**
    
    -   **第一道：难以修改的链**
        
        -   _原理：_ 区块通过链组成一个环环相扣的链表（…A-B-C-D-E）。如果攻击者妄图篡改历史区块 B，B 的哈希值就会改变，导致包含B的哈希值的区块 C 失效，进而导致 D 失效……因此攻击者需要重新计算B及B之后所有的区块的新的哈希值（…A-B’-C’-D’-E’），同时还需要计算将要上链的新区块的哈希值（…A-B’-C’-D’-E’-F-G）
            
        -   _结论：_ **篡改历史 = 重算并重写从被修改的历史区块及之后所有被连接的区块**。
            
    -   **第二道：共识**
        
        -   _原理：_ 比特币网络只承认工作量最大（最长）的那条链【**最长链原则 (Longest Chain Rule)**】。攻击者想要篡改成功，不仅要重写历史（…A-B’-C’-D’-E’），还要让自己的“伪造链”增长速度超过全网其他诚实节点的总和。（伪造链：…A-B’-C’-D’-E’-F-G vs 诚实链：…A-B’-C’-D’-E’-F；伪造链成功）
            
        -   _阈值：_ **51% 攻击**。除非掌握全网 51% 以上算力，否则攻击者永远追不上诚实链。
            

### 3\. 比特币 vs 以太坊

这是关于“记账”与“计算”的区别：

|   | 比特币 (Bitcoin) | 以太坊 (Ethereum) |
| --- | --- | --- |
| 诞生时间 | 2008年 (白皮书) | 2013年 (白皮书) / 2015年 (创世) |
| 核心定位 | 去中心化电子记账系统 是一个安全的ledger | 去中心化世界计算机 是一个可以执行复杂程序的计算机 |
| 计算能力 | 非图灵完备 (Non-Turing Complete) | 图灵完备 (Turing Complete) |
|   | 故意设计为不支持复杂逻辑(如循环)，只做简单记账，保证安全。 | 支持复杂逻辑开发，因此诞生了 DeFi, NFT, DAO。 |
|   |   |   |
| 系统环境 | 简单脚本 | EVM (以太坊虚拟机) |
|   |   | 相当于区块链的OS或沙盒，运行智能合约。 |
| 共识机制 | PoW (工作量证明) | PoW ➡️ 2022年转为 PoS (权益证明) |
| 痛点解决 | 用去中心化的方式实现了点对点（peer-to-peer）价值传输 | 解决了比特币无法运行复杂应用的问题 |
| 特点 | 功能单一 | Gas 费机制的引入 |
|   |   | 为了防止恶意程序写死循环堵塞网络，每一步计算都需要付费。 |

### 4\. 区块链类别

| 区块链类型 | 加入方式自由度 | 数据可见性 | 管理模式 | 适合场景 |
| --- | --- | --- | --- | --- |
| 公链 | 高：任何人可自由加入 | 高：所有人可见 | 去中心化（加入成员投票） | 加密货币、公共存证 |
| 联盟链 | 中：需联盟成员邀请/审批 | 中：仅联盟成员可见 | 多中心化（联盟成员决策） | 供应链、金融协作 |
| 私链 | 低：私链所有者审批 | 低：仅内部成员可见 | 中心化（拥有者为中心） | 企业内部管理、审计 |

### 5、知识点大串联

通过银行体系来类比 Web3 的基础设施：

1.  **区块链 (Blockchain):**
    
    -   \= **银行的中央大账本**。
        
    -   _作用：_ 负责存数据，记录每个人有多少钱，保证账本不被篡改。
        
2.  **EVM (以太坊虚拟机-Ethereum Virtual Machine):**
    
    -   \= **银行的操作系统/后台系统**。 / **手机的OS**
        
    -   _作用：_ 负责处理业务逻辑，计算余额变化。
        
3.  **智能合约 (Smart Contract):**
    
    -   \= **自动柜员机 (ATM) / 自动转账协议**。 / **手机OS上跑的APP**
        
    -   _作用：_ 具体的业务规则（如：“IF A 存入 100，THEN余额 +100”）。
        
4.  **钱包 (Wallet):**
    
    -   \= **银行卡 + 密码 (私钥)**。
        
    -   _作用：_ **身份证明**。它不存钱，它只是证明我是这个账户的主人，我有权动用这笔钱。
        

补充：智能合约的作用

### 重构信任

**场景：** 陌生人 A 向 陌生人 B 购买物品。

-   **传统痛点：**
    
    -   如果在 Web2，A 怕先付款 B 不发货；B 怕先发货 A 不付款。
        
    -   **旧解决方案：** 通过中心化双方都共同信任的节点做担保\*\*，**即找一个**Trusted Third Party\*\*做Escrow，钱先给中介，发货后再放款。
        
-   **Web3 解决方案：**
    
    -   **智能合约成为 Automated Escrow**
        
    -   **原理：** 规则被写死在代码里（例如：IF收到60ETH，则自动发放某NFT给 B）。
        
    -   **结果：** A 和 B **不需要信任对方，也不需要信任任何中心化的节点**，只需要信任**代码逻辑。**
        

## 第三部份：链上操作实战

## 一、创建 MetaMask /钱包

> 理论对应：非托管账户管理 (Non-custodial Account Management) 理解“私钥即资产”：通过助记词直接控制账户，而非依赖银行或支付宝等中介。

**1\. 钱包的本质**

-   **非存储容器：** 钱包并不真正“存”钱，它更像是一个**区块链浏览器**。它只是读取链上数据，显示某个账户下有多少 ETH；在进行交易时通过签名认证放行。
    

**2\. 核心凭证：公钥与私钥**

-   **公钥 (Public Key):** 即**地址**。类似银行卡号，发送或接收资产时提供给对方。
    
-   **私钥 (Private Key):** 控制钱包的关键。转账时需要用到私钥对交易进行**签名授权**。
    
-   **助记词 (Seed Phrase):** 私钥的“人类可读版”。因为私钥是一长串随机字符难记忆，算法将其转换为 12/24 个英文单词。
    

## 二、通过Faucets领取 Sepolia 测试币

> 理论对应：区块链网络环境 (Network Environments) 区分主网 (Mainnet) 和测试网 (Testnet) 的隔离性。

**1\. 领水实测记录**

-   ❌ **Alchemy / Infura / Quicknode:** 全部失败。
    
    -   \_ALchemy两次报错：\_1、 ETH余额不足；2、通过OKX入金ETH后仍然缺乏transaction history。
        
    -   Infura报错：缺乏transaction history。
        
    -   Quicknode：需要PoH Proof of Humanity？？？【还不清楚】
        
    -   _定位原因：_ 钱包只入金过，没有在Ethereum主网上进行过转帐交易，Nonce=0，可能被判定为机器人。
        
-   ✅ **PoW Faucet (**[**pk910.de**](http://pk910.de)**):** 成功。
    
    -   _机制：_ 通过网页计算哈希值（付出少量算力）来换取测试币。
        

**2\. 领水失败机制定位：防女巫攻击 (Sybil Resistance)**

-   **隐喻来源：** 1973年小说《Sybil》，女主拥有多重人格。
    
-   **Web3 含义：** 防止一个个体在网络中伪装成 N 个身份。
    
-   **典型案例：** 项目方发空投（每人1000刀），黑客用脚本生成 3000 个钱包地址冒充 3000 人去薅羊毛。
    

**3\. 关键概念辨析：Nonce**

-   **定义：**
    
    -   全称 _Number used ONCE_。
        
    -   在以太坊中，指由发送地址发起的一个**交易计数器**。
        
    -   **特性：** 从 0 开始，单调递增，不可跳跃（必须按顺序执行）。
        
-   **两大核心功能：**
    
    1.  **防重放攻击 :** 确保**每笔交易是唯一的**。交易上链后 Nonce 失效，黑客若再次广播相同交易，节点会因 Nonce 重复而拒绝，防止资产重复扣除。
        
    2.  **确定执行顺序 :** 只有当 Nonce `n` 确认后，网络才会处理 `n+1`。
        

## **三、发送测试币与 Gas 机制**

> **理论对应：交易生命周期 (Transaction Lifecycle)** 理解一笔交易从签名、广播、打包到上链确认的全过程。

**1\. 核心公式**

-   Transaction Fee (总花费) = Gas Price (油价)\*Gas Used (耗油量)
    

**2\. 概念拆解表**

| 核心概念 | 生活化比喻 | 决定因素 | 单位 |
| --- | --- | --- | --- |
| Gas Price | 每升油多少钱 | 市场供需 | Gwei |
| (油价) | (滴滴打车的价格) | 每个区块空间有限，当前想要把交易记录成块上链的人多 ➡️网络拥堵 ➡️ 人们提高给矿工的Priority Fee产生竞价现象，导致油价上涨。 | 1 ETH = $10^9$ Gwei |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
| Gas Used | 路程多远/路况多难 | 代码复杂度 (Complexity) | Gas |
| (耗油量) | (车子的行驶里程) | • 普通转账 (21,000 Gas): 简单。 |   |
|   |   | • 在Uniswap里把ETH换成USDT: 查汇率+扣款+改账本 (150,000+ Gas): 复杂。 |   |
|   |   |   |   |
|   |   |   |   |
| Transaction Fee | 最后支付总金额 | Gas Price✖️ Gas Used | ETH |
| (总路费) |   |   |   |

**3\. 其它概念**

-   **Gas Limit (油箱上限):**
    
    -   _定义：_ 授权该笔交易**最多**可以消耗多少 Gas,即该笔交易的Gas used的上限。
        
    -   _作用：_ 防止合约死循环烧光余额。
        
    -   _风险：_ 若 Limit < Used（油箱 < 路程），导致 **Out of Gas**。**结果：交易失败，但手续费不退**（矿工已消耗电力工时）。
        
-   `Gas Price` = `Base Fee` (基础费，**被销毁???\[为什么要销毁还没搞懂\]**) + `Priority Fee` (我想优先让我的交易记录成块上链而支付给矿工的费用，**给矿工**)。
    
-   **Max Fee Per Gas:**
    
    -   Fee Per Gas=Gas Price=Base Fee+Priority Fee=Transaction Fee/ Gas Used
        
    -   设定愿意支付的 Gas Price **上限**。
        
    -   若 设定的Max Fee Per Gas< 当前市场价，没有矿工愿意打包，交易 **Pending**。
        

4.  关键概念区分：Max Fee Per Gas vs Gas Limit
    

| 场景 | 核心原因 | 导致的结果 | 资金损失情况 |
| --- | --- | --- | --- |
| 场景一： | 市场因素： | Pending (排队/挂起) | 0 损失 |
| Max Fee 设低了 | 我出价太低，矿工嫌钱少，先去打包别人的交易了。 | 卡在内存池，既不成功也不失败。 | 钱还在兜里，可取消或加价 (Speed Up)。 |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |
| 场景二： | 技术因素： | Fail / Reverted (失败) | 亏损 Gas 费 |
| Gas Limit 设低了 | 要处理的交易太复杂了，我给的额度花完了还没处理完我的交易。 | 交易上链，但被标记失败。 | 支付了矿工辛苦费，但最终事没办成。 |
|   |   |   |   |
|   |   |   |   |
|   |   |   |   |

## 四、交易查询

> 理论对应：链上数据透明性 (On-chain Transparency) 学习使用区块浏览器读取不可篡改的账本数据。

-   **工具：** Etherscan
    
-   **操作：** 输入交易哈希 (Tx Hash) 或钱包地址，查询交易状态、Block Confirmations以及消耗的 Gas 等等详情。
    

10026530指的是我的交易信息被放到了第10026530个区块里

83 Block Confirmations指的是我的交易信息所在的这个区块后面已经有83个新区块上链了
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
