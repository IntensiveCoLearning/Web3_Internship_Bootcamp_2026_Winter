---
timezone: UTC+8
---

# Lemonadeccc

**GitHub ID:** Lemonadeccc

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->
![bf8297ca-dc9f-49f1-a73d-c431c4e98582.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Lemonadeccc/images/2026-01-22-1769088771107-bf8297ca-dc9f-49f1-a73d-c431c4e98582.png)
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->

## 一、智能合约的概念与功能

### 1智能合约是什么

-   本质：部署在链上的 **“代码（functions）+ 持久状态（state）”**
    
-   运行方式：通过交易触发执行，驻留在某个合约地址上
    
-   核心特征：**IFTTT（如果…那么…）** + **按代码确定执行**
    
-   默认不可变：合约部署后字节码通常不可直接修改（immutable by default）
    
-   需要升级时的现实做法：**代理（Proxy）/ UUPS** 等“地址不变、逻辑可换”的方案（状态留在代理，逻辑在实现合约）
    

> 重要更新点：近年的协议升级中，`SELFDESTRUCT` 的“删除代码/状态”能力被显著限制，**不再推荐依赖 selfdestruct 做升级/回滚**。

### 2概念来源

-   Nick Szabo 在 90 年代提出“智能合约”概念：用密码学与自动化，减少对受信任中介依赖
    
-   以太坊把它落地为公链上的执行引擎，支撑 DeFi / NFT / DAO 等
    

### 3传统合约的信任问题（为什么需要智能合约）

-   传统合约痛点：即使条件满足，也要相信对方会履约
    
-   引入中介（托管人/仲裁人）虽能缓解，但又引入：
    
    -   中介失职/舞弊/被收买
        
    -   中介跑路风险
        

### 4智能合约能做什么（价值点清单）

-   **自动售货机模型**：条件满足就执行；不满足就 revert（不发生状态变更）
    
-   **无需中介、无需等待**：规则写死在链上，满足条件自动结算（如时间锁账户、付完款自动转移所有权 NFT 等）
    
-   **确定性**：同样链上环境 + 同样输入 → 同样输出（节点必须一致才能共识）
    
-   **公开可审计**：部署、调用、事件日志、资产转移全在链上可查
    
-   **隐私：假名制而非匿名**
    
    -   地址不强制绑定实名，但链上行为可追踪
        
    -   结合链下数据（如交易所 KYC）可能被关联到真实身份
        
    -   真隐私通常需要额外方案（混币/隐私池/ZK 等）
        
-   **条款可见可审查**：源码验证后可在浏览器直接读/用工具审计；但前提是你看得懂或信任审计/社区共识
    
-   **你能写的逻辑基本都能上链**（受状态机与 Gas 约束）：代币、DeFi、NFT、DAO、访问控制、自动清算机器人、ZK 验证逻辑等
    

* * *

## 二、Solidity 语言特性与优势

### 1为什么是 Solidity

-   **原生契合 EVM**：编译为 EVM 字节码，能直接处理 storage/gas/event 等链上资源
    
-   **语法相对友好**：融合 JS/C++/Python 风格；支持静态类型、继承、库、事件、修饰符等
    
-   **生态最强**：大量框架、库、审计经验沉淀；EVM 链广泛兼容（Polygon/BSC/Avalanche/Arbitrum/Optimism/Base 等）
    

### 2工具生态关键词

-   Remix（浏览器 IDE，入门/小 demo）
    
-   Hardhat（工程化开发、脚本部署、多网络、fork、调试）
    
-   Foundry（速度快，Solidity 原生测试，fuzz/invariant 强）
    
-   OpenZeppelin Contracts（标准合约库：ERC20/721/1155、权限、治理等）
    

### 3推荐学习路线

1.  区块链基础概念（交易、节点、合约等）
    
2.  读官方文档 + Remix 写第一个合约（存取变量/转账/事件）
    
3.  交互式练习（CryptoZombies / Solidity by Example）
    
4.  学工具链（Hardhat/Foundry）+ 学写测试（revert、边界条件）
    
5.  学安全与最佳实践（重入、权限、预言机、flash loan 等）+ 静态分析（Slither/Mythril）
    

### 4安全与成熟度要点

-   Solidity 0.8+ 默认整数溢出检查（溢出自动 revert），显著减少经典溢出漏洞
    
-   工具/审计生态完善：Slither、Mythril、Echidna、Foundry fuzz/invariant、审计公司与竞赛审计等
    

-   **Solidity 之所以成为默认答案：EVM 原生 + 生态最强 + 标准/工具成熟 + 多链兼容 + 安全经验最多。**
    

* * *

## 三、合约编译会产生什么（编译产物）

### 1字节码（Bytecode）

-   **Creation Bytecode**：部署时执行（含构造逻辑），负责把运行时代码写入链上
    
-   **Runtime Bytecode**：部署后存在合约地址上的“真正运行代码”
    
-   常见补充：运行时代码末尾会附带 **metadata 哈希（CBOR 编码）**，用于源码验证/检索
    

### 2ABI（应用二进制接口）

-   JSON 格式：描述可调用函数/事件/参数/返回值等
    
-   作用：
    
    -   链下程序（前端/脚本/钱包/其他合约）知道怎么调用你
        
    -   负责调用数据的编码/解码
        

### 3Metadata JSON

-   记录编译器版本与配置、源码引用、ABI、NatSpec 等
    
-   浏览器/验证服务（Etherscan/Sourcify）依赖它做源码验证与生成交互界面
    

### 4）调试/审计相关输出

-   AST（抽象语法树）
    
-   Source Map（字节码指令 ↔ 源码位置）
    
-   Assembly / Yul IR（中间表示与底层可读表示，用于优化/审计/理解执行）
    

* * *

## 四、部署合约后你会拿到什么（地址与 ABI）

-   部署后获得：
    
    -   **合约地址（Contract Address）**
        
    -   **部署交易哈希（tx hash）**
        
-   ABI 不需要等部署后才有：**ABI 是编译时生成的**
    
-   主流流程：
    
    1.  本地编译得 bytecode + ABI + metadata
        
    2.  部署上链得 address + tx hash
        
    3.  去 Etherscan/Sourcify 做源码验证 → 浏览器展示 Read/Write 面板与 ABI
        

* * *

## 五、部署成本（Gas）怎么核算

### 1Gas Used：钱花在哪里

部署交易的 Gas 通常由：

-   基础交易成本：**21,000 gas**
    
-   CREATE 创建合约开销：约 **32,000 gas**
    
-   Code deposit：写入 runtime bytecode，约 **200 gas/字节**
    
-   构造函数执行：逻辑越复杂越贵
    
-   Storage 初始化：首次写入 0→非0 很贵，约 **20,000 gas/槽**
    

> 结论：**字节码越大、构造逻辑越复杂、初始化写入越多 → 部署越贵**

### 2EIP-1559 后的费用模型

-   **Total Fee = GasUsed × (Base Fee + Priority Fee)**
    
-   参数理解：
    
    -   Base Fee：协议随拥堵调整，并被销毁（burn）
        
    -   Priority Fee：给验证者的小费（tip）
        
    -   交易里常设：
        
        -   maxFeePerGas（愿付的上限）
            
        -   maxPriorityFeePerGas（小费上限）
            

### 3L1 vs L2

-   L1：最安全也最贵
    
-   L2（Rollup）：费用通常低一个数量级；近年的升级引入 blob 数据后，L2 的 L1 数据成本显著下降，部署与交互更便宜
    

### 4实战控制成本 checklist

-   本地/测试网先部署，看 gasUsed
    
-   上线前看实时 gas（BaseFee/建议 tip）
    
-   优化：减少字节码、减少构造期写 storage、合理开 optimizer
    
-   能在 L2 跑就优先 L2
    

* * *

## 六、常见安全漏洞与防护

### 1重入（Reentrancy）

-   风险：外部调用在状态更新前发生 → 可反复回调提款
    
-   防护：
    
    -   **CEI（Checks→Effects→Interactions）**
        
    -   **ReentrancyGuard / nonReentrant**
        
    -   **Pull Payment**（改“我打给你”为“你来领”）
        

### 2发送 ETH 的坑：transfer/send 不可靠

-   固定 2300 gas 津贴在一些升级后更容易失败 → DoS/卡钱
    
-   防护：用 `call{value: amount}("")` 并检查返回值；优先 Pull Payment
    

### 3整数溢出

-   0.8+ 默认检查溢出并 revert
    
-   `unchecked` 仅在证明安全时用，并写足测试与注释
    

### 4访问控制错误 / tx.origin 滥用

-   防护：Ownable/AccessControl；关键操作上多签 + Timelock；鉴权只用 msg.sender
    

### 5外部调用不可信 / ERC20 返回值不规范

-   防护：检查 success 与返回数据；ERC20 用 **SafeERC20** 兼容“非标准代币”
    

### 6预言机操控 / 闪电贷联动

-   防护：多源预言机（如 Chainlink）、TWAP、滑点/阈值保护、延迟执行或多阶段确认
    

### 7DoS 与 Gas 攻击

-   风险：无上限循环、循环里外部调用、依赖固定 gas
    
-   防护：分页/拆分交易、避免循环主动打款、设计失败策略（跳过/记录）
    

### 8业务逻辑缺陷（最难但最致命）

-   防护：边界测试 + fuzz + invariant；高价值协议做审计/形式化验证
    

### 9随机数不安全

-   风险：用区块属性做随机数可被操控
    
-   防护：Chainlink VRF 或 commit-reveal
    

### 10可升级合约风险 & delegatecall 风险

-   风险：存储布局错位、未初始化、升级权限滥用、delegatecall 到不受信目标
    
-   防护：
    
    -   用 OpenZeppelin upgradeable 模板与插件做 layout check
        
    -   initializer/reinitializer + `_disableInitializers()`
        
    -   升级权限交给 **多签 + 时间锁**，并配审计流程
        
    -   delegatecall 目标白名单，严禁用户可控
        

### 11授权（approve）竞态

-   防护：increase/decreaseAllowance；或 approve(0)→approve(new)；支持 permit 更好
    

### 12工具与流程

-   静态分析：Slither、Mythril…
    
-   Fuzz/不变式：Echidna、Foundry（forge）
    
-   审计：传统审计 + 竞赛审计（Code4rena/Sherlock）+ Bug Bounty
    

* * *

## 七、部署/开发工具怎么选（场景匹配）

-   **Remix**：入门、课堂 demo、小 PoC、快速调试
    
-   **Hardhat**：中大型工程、团队协作、脚本化部署、插件丰富、JS/TS 工作流
    
-   **Foundry**：极致测试/性能、fuzz/invariant、命令行工作流、主网 fork 研究
    
-   **Truffle + Ganache**：存量项目/老生态还在用，新项目更多迁移到 Hardhat/Foundry
    
-   **Tenderly**：高级调试、交易回放、监控告警、虚拟测试网（作为增强层）
    

* * *

## 八、部署后的公开性与可审计性

-   字节码公开：任何人可查合约 bytecode
    
-   交易历史公开：调用、资金转移、事件日志全部可追踪
    
-   状态“半公开”：public 变量直接读；private/internal 只是接口不可见，链上数据仍明文可被推导读取
    
-   可审计方式：
    
    -   源码验证（Etherscan/Polygonscan）与去中心化验证（Sourcify）
        
    -   人工审计 + 自动化工具 + 社区赏金
        

* * *

## 九、合约逻辑修改与升级模式（核心结论：不能直接改，只能“绕着改”）

### 1最直接：重新部署新合约

-   适合：无状态/状态少/可迁移
    
-   缺点：地址变更、迁移成本高
    

### 2行业主流：Proxy 代理升级

-   目标：**地址 + 状态固定**，逻辑可替换
    
-   结构：Proxy 存储状态并 delegatecall 到 Implementation
    
-   形态：
    
    -   Transparent Proxy：管理入口与用户调用隔离
        
    -   UUPS：升级逻辑在实现合约里，更轻更省 gas
        
-   最佳实践：不要手写，直接用 OpenZeppelin Upgrades；升级权限交给多签+时间锁
    

### 3更重型：模块化 / Diamond（EIP-2535）

-   多 Facet 挂接、按 selector 路由，适合“协议城市级”复杂系统
    
-   代价：实现与审计复杂度高
    

### 4不再推荐的旧套路

-   依赖 SELFDESTRUCT + CREATE2 “原地换壳”的升级方式：在新规则下已不可靠/不推荐
    

### 5怎么选

-   Demo：重部署
    
-   有资金长期运营：Proxy（Transparent/UUPS）+ 多签 + Timelock
    
-   超大型模块：Diamond/模块化（额外审计投入）
    
-   永远不要：指望 selfdestruct 兜底、随手写 proxy、不做存储布局检查
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->


### **智能合约开发核心总结**

**一、核心理念：Dapp 架构与开发**

智能合约开发不仅仅是编写合约代码，而是构建一个完整的**去中心化应用**。

1.  **核心架构**：
    
    -   **前端 (UI)**：用户界面，使用 React/Vue 等框架构建。通过 **钱包**（如 MetaMask）或 **RPC 节点** 与区块链交互，**不直接连接链**。
        
    -   **智能合约**：应用逻辑的核心，部署在区块链上，使用 Solidity 等语言编写。
        
    -   **数据检索器**：**关键组件**。监听并索引链上合约事件（如 `Transfer`），将数据存储到传统数据库（如 PostgreSQL），供前端高效查询复杂数据（如“某地址拥有的所有NFT”）。
        
    -   **去中心化存储**：用于存储图片、文件等大容量数据（如 IPFS, Arweave），保证数据的持久性和抗审查性。
        
2.  **标准开发流程**：
    
    1.  **需求分析与规划**：明确功能、选择区块链平台、设计UX。
        
    2.  **智能合约开发**：编写、测试（单元测试）、审计（安全至关重要）、优化（Gas）。
        
    3.  **检索器开发**：确定所需数据模型，使用框架（如 Ponder, Subgraph）编写索引逻辑，并部署运维。
        
    4.  **前端开发**：构建UI，集成钱包，使用库（**推荐 Viem/Wagmi**）与合约交互。
        
    5.  **部署与上线**：将合约部署到测试网（如 Sepolia）进行最终验证，然后部署到主网。
        

**二、开发环境与基础设施**

1.  **本地开发链**：
    
    -   **Foundry**：Rust实现，速度极快。包含 `forge`（构建测试）、`anvil`（本地节点）、`cast`（链交互工具）。适合追求性能和现代工具链的开发者。
        
    -   **Hardhat**：基于 JavaScript/TypeScript，插件生态丰富。**对于新手和大多数项目推荐使用 Hardhat**。
        
2.  **RPC 节点服务**：
    
    -   **作用**：前端与区块链网络交互的桥梁，用于查询数据、发送交易。
        
    -   **服务商选择**：
        
        -   **开发/测试**：Public Node、Infura免费额度。
            
        -   **生产环境**：**Alchemy**（稳定、文档好）、**QuickNode**（高性能、低延迟）。
            
    -   **最佳实践**：
        
        -   **保护API Key**：使用环境变量，切勿提交至代码仓库。
            
        -   **多节点备份**：配置多个RPC提供商，实现故障转移。
            
        -   **错误处理与重试**：网络请求需有重试机制。
            
        -   **开发时优先使用本地节点**（如 `anvil` 或 `npx hardhat node`），速度快且无限制。
            

**三、Solidity 智能合约编程精要**

1.  **基础结构**：
    
    -   `pragma solidity ^0.8.0;` 声明编译器版本。
        
    -   **状态变量**：永久存储在链上的数据。
        
    -   **函数**：包含可见性（`public`, `private`, `internal`, `external`）、状态可变性（`view`, `pure`, `payable`）。
        
    -   **修饰符 (Modifier)**：用于函数执行前的检查（如权限控制 `onlyOwner`）。
        
    -   **事件 (Event)**：使用 `emit` 触发，用于记录链上日志，是检索器的主要数据源。
        
    -   **继承与接口**：支持代码复用和多态。
        
2.  **安全实践（重中之重）**：
    
    -   **重入攻击**：
        
        -   **漏洞**：恶意合约在收到 ETH 后，在回调函数中再次调用提款函数。
            
        -   **防护**：遵循 **检查-生效-交互 (Checks-Effects-Interactions)** 模式，或使用 OpenZeppelin 的 `ReentrancyGuard` 修饰符。
            
    -   **访问控制**：
        
        -   **漏洞**：管理函数未设限，任何人可调用。
            
        -   **防护**：使用 `Ownable` 合约的 `onlyOwner` 修饰符，或更细粒度的 `AccessControl`。
            
    -   **整数溢出**：
        
        -   **防护**：Solidity 0.8.0 及以上版本默认进行溢出检查。对于老版本或特殊场景，使用 `unchecked` 块需极度谨慎。
            

**四、实战全流程：从编码到用户交互**

1.  **编写合约**：在 Remix IDE 或本地用 Hardhat/Foundry 编写 Solidity 代码。
    
2.  **编译与本地测试**：在 Remix 或通过 `forge test` / `npx hardhat test` 进行测试。
    
3.  **部署到测试网**：
    
    -   配置 Hardhat/Foundry 连接 Sepolia RPC。
        
    -   运行部署脚本，将合约上链。
        
    -   在 **Etherscan (Sepolia)** 上验证合约并查看交易详情。
        
4.  **前端集成**：
    
    -   创建网页
        
    -   **连接钱包**：调用 `window.ethereum.request({ method: ‘eth_requestAccounts’ })`。
        
    -   **实例化合约**：使用 **Viem** ，结合合约 ABI 和地址。
        
    -   **调用合约**：
        
        -   **读取 (**`call`**)**：免费，如查询留言。
            
        -   **写入 (**`send`**)**：需支付 Gas，弹出钱包确认，如发布新留言。
            

**五、成为高阶开发者**

1.  **Gas 优化**：直接关系到用户体验和成本。核心是减少昂贵的存储操作 (`SSTORE`)，善用内存和 `calldata`，优化循环和数据结构。
    
2.  **全面的安全审计**：
    
    -   **工具扫描**：使用 **Slither**（静态分析）、**MythX** 进行自动化检查。
        
    -   **人工审计**：对于持有大量资金的项目，必须聘请专业审计机构（如 OpenZeppelin, ConsenSys Diligence）进行人工代码审查。
        
3.  **专业的开发协作**：
    
    -   使用 **Git** 进行版本控制，采用功能分支工作流。
        
    -   规范 **Commit Message** 和 **Pull Request** 流程。
        
    -   建立 **Code Review** 制度，重点关注逻辑正确性、安全性和 Gas 效率。
        
4.  **探索 Layer 2 扩容**：
    
    -   **Optimistic Rollups**（如 **Arbitrum, Base**）：兼容 EVM，开发体验平滑，但提款有挑战期。
        
    -   **ZK Rollups**（如 **zkSync, Starknet**）：安全性更高，提款快，但生态和工具链略有不同。
        
    -   未来开发需根据项目需求选择合适的主网或 L2。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->



021第三章账户类型

## **1.账户基础：两种类型**

以太坊只有两种账户，其根本区别在于 **控制权归属**：

-   **EOA**：由**私钥**直接控制。像“人+银行卡”，能主动发起交易。
    
-   **合约账户**：由**部署的代码**控制。像“写死规则的自动售货机”，只能被调用后按逻辑执行。
    

| 属性 | EOA | 合约账户 |
| --- | --- | --- |
| 控制主体 | 私钥持有者 | 智能合约代码 |
| 私钥 | 有 | 无 |
| 代码(Code) | 空 | 有EVM字节码 |
| 存储(Storage) | 无 | 有状态存储 |
| 发起交易 | 能主动发起 | 不能，只能响应调用 |

## **2.账户创建与地址计算**

### **1\. 创建方式**

-   **EOA**：本地生成密钥对，**无需上链、不花Gas**。
    
-   **合约账户**：通过一笔**创建合约的交易**部署，需支付Gas将代码永久写入链上。
    

### **2\. 地址计算规则**

-   **CREATE**：`地址 = keccak256(RLP([创建者地址, 创建者nonce]))` 的后20字节。
    
    -   地址**不可提前精确预测**（除非知道nonce）。
        
-   **CREATE2**：`地址 = keccak256(0xff + 创建者地址 + salt + keccak256(init_code))` 的后20字节。
    
    -   地址**可提前精确计算**。
        
    -   核心价值：**可预测地址**、跨链部署一致性，用于工厂合约、代理模式等。
        

## **三、 账户状态（世界状态中的四元组）**

无论EOA或合约账户，在状态树中均由四个字段表示：

1.  **nonce**:
    
    -   EOA：已发送的交易数量。
        
    -   合约账户：已创建的子合约数量。
        
2.  **balance**: 账户持有的ETH余额（单位：wei）。
    
3.  **storageRoot**: 存储树的根哈希。
    
    -   EOA：固定空值。
        
    -   合约账户：存储所有状态变量。
        
4.  **codeHash**: 账户代码的哈希值。
    
    -   EOA：空代码的哈希。
        
    -   合约账户：运行时字节码的哈希。
        

**关键理解**：合约账户既能持有ETH，又能通过存储树维护复杂状态（如代币余额）。

## **四、 调用机制：谁可以发起交易？**

-   **唯一主动发起者**：**EOA**。
    
    -   合约账户**不能**主动发起顶层交易。
        
    -   所有链上交易的起点，必须是一个由私钥签名的EOA。
        
-   **调用链条**:
    
    1.  **EOA → 合约账户**：通过**外部交易**触发。
        
    2.  **合约账户 → 合约账户**：通过`call`/`delegatecall`/`staticcall`等**内部消息调用**，消耗原交易的Gas。
        
    3.  **合约账户 → EOA**：可在执行中转账，但仍是内部调用的一部分。
        

## **五、 账户抽象与未来演进**

-   **ERC-4337 (账户抽象)**：
    
    -   让**智能合约钱包**具备类似EOA的用户体验（批量操作、代付Gas等）。
        
    -   底层逻辑：用户提交`UserOperation` → Bundler用其EOA打包成交易 → 调用`EntryPoint`合约执行。
        
    -   **本质未变**：最终上链的交易仍由EOA（Bundler）签名发起。
        
-   **EIP-7702 (Pectra升级)**：
    
    -   允许EOA在单笔交易期间**临时授权**一段合约代码来控制自己。
        
    -   旨在协议层为智能账户提供更优支持，**不改变**“合约不能凭空发起交易”的根基。
        

## **六、 钱包实践：MetaMask如何管理EOA**

1.  **核心秘密**：**助记词**，遵循BIP-39/BIP-44标准。
    
    -   本地加密存储，**绝不**上传服务器。
        
    -   泄露助记词 = 失去所有资产控制权。
        
2.  **交易流程**：dApp请求 → 钱包弹窗展示详情 → 用户确认 → **本地私钥签名** → 通过RPC广播交易。
    
3.  **支持智能账户**：MetaMask已集成ERC-4337，用户可在“普通EOA”和“智能账户”间切换。
    

## **七、 代币的本质**

ERC-20/ERC-721等代币**并非独立资产**，而是**智能合约账户内的记账系统**。

-   “拥有代币” = 在代币合约的`storage`映射中，有对应你地址的一条记录。
    
-   “转账代币” = **调用代币合约**的`transfer`函数，**更新合约内部的存储映射**。
    

## **八、 合约的不可变性与“销毁”**

1.  **代码不可更改**：合约一旦部署，其字节码默认**不可修改**。
    
2.  **SELFDESTRUCT的现状**（EIP-6780后）：
    
    -   **已弱化**：在非创建交易中调用，**仅转走余额，不再删除代码和存储**。
        
    -   依赖`SELFDESTRUCT`的“变形合约”模式已基本失效。
        
3.  **主流升级方案**：**代理合约模式**。
    
    -   保持代理合约地址不变，通过更换逻辑合约地址来实现升级。
        

## **九、 关键零散知识点**

-   **地址以**`0x`**开头**：仅是十六进制表示的编程惯例，便于识别，非协议强制。
    
-   **多签钱包**：本质是一个需要多个签名才能执行的**智能合约**，如Gnosis Safe。
    
-   **时间锁**：将敏感操作延迟执行的智能合约，为社区提供反应时间，广泛用于治理升级。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->




### **021第二章**

**一、节点与客户端**

-   **节点（Node）**：任何一台运行以太坊客户端软件并连接到网络的计算机。
    
-   **客户端（Client）**：对以太坊协议的具体软件实现（如Geth, Lighthouse）。
    
-   **关系**：客户端是软件，节点是运行该软件的机器实例。
    

**二、The Merge后的新架构：三大件**

一个完整的以太坊节点由两个必备客户端组成，如需出块则增加第三个：

1.  **执行客户端（EL）**
    
    -   **职责**：处理交易、执行智能合约（EVM）、维护当前状态数据库、提供 `eth_*` JSON-RPC接口。
        
    -   **常见实现**：Geth, Nethermind, Besu, Erigon, Reth。
        
2.  **共识客户端（CL）**
    
    -   **职责**：运行权益证明（PoS）共识，维护信标链，选择区块提议者，处理验证者投票，决定最终链头。
        
    -   **常见实现**：Lighthouse, Prysm, Teku, Nimbus, Lodestar。
        
3.  **验证者客户端（Validator）**
    
    -   **职责**：管理验证者密钥，在轮到时提议区块，并对看到的区块进行投票（attestation）。
        

**三、协同核心：Engine API**

-   执行客户端（EL）和共识客户端（CL）之间的专用JSON-RPC通信接口。
    
-   共识客户端通过它让执行客户端“执行交易并生成结果”（`engine_getPayload`），或“验证他人区块的执行结果”（`engine_newPayload`）。这是两者协作的“内线电话”。
    

**四、节点间的连接与通信**

1.  **发现**：基于UDP和Kademlia算法，通过引导节点找到并建立邻居列表。
    
2.  **连接**：建立加密的TCP连接（RLPx/devp2p协议），并在其上复用多种子协议。
    
3.  **传播**：
    
    -   **Gossip协议**随机将新交易/区块转发给部分邻居，实现快速、去中心化的全网扩散。
        
    -   **请求-响应**：用于按需拉取缺失的历史数据。
        

**五、节点类型对比**

| 类型 | 存储内容 | 资源消耗 | 主要用途 | 信任模型 |
| --- | --- | --- | --- | --- |
| 全节点 | 所有区块 + 最近~128个区块的完整状态（旧状态被修剪） | 中等（~500GB-1TB SSD） | 自托管RPC、验证交易、作为验证者基础 | 完全自我验证，最去中心化 |
| 归档节点 | 全节点数据 + 从创世至今所有历史状态快照 | 极高（2TB-12TB+ SSD） | 区块浏览器、链上深度分析、历史审计 | 同全节点，且能即时查询任意历史状态 |
| 轻节点 | 只存区块头，不存完整区块和状态 | 极低（MB级） | 手机钱包、浏览器插件、资源受限设备 | 依赖全节点提供数据，但可通过Merkle证明验证 |

**图书馆类比**：

-   **全节点**：大型图书馆，有所有书目（区块），但只将最新版本的书（状态）放在阅览室。
    
-   **归档节点**：国家档案馆，保存每一本书的每一个历史版本。
    
-   **轻节点**：移动电子目录机，只存索引（区块头），借书时向图书馆索取并核对。
    

**六、运行自有全节点必要性**

1.  **隐私**：避免将你的交易查询、钱包地址和IP暴露给公共RPC提供商。
    
2.  **安全与主权**：遵循“Don‘t trust, verify”原则，独立验证所有交易和状态，不依赖第三方。
    
3.  **抗审查与可用性**：避免因公共RPC服务限流、宕机或政策影响你的dApp。
    
4.  **支持去中心化**：增加网络韧性，并通过选择非主导客户端（客户端多样性）降低单点故障风险。
    

**七、归档节点优势**

-   **即时历史查询**：无需重放交易，即可瞬间回答“在区块 #X 时，某地址/合约的状态是什么？”这类问题。
    
-   **数据查询的“时间机器”**：是区块链浏览器、深度数据分析、审计和策略回测的基础设施。
    
-   **代价**：存储成本巨大（TB级别），同步时间漫长。
    

**八、节点同步模式**

-   **快照同步（Snap Sync）**：推荐模式。先下载区块链，再获取一个近期的状态快照，最后进行状态愈合。速度最快（数小时至数天）。
    
-   **全同步（Full Sync）**：从创世块开始重放所有交易，严格验证。速度慢，但验证最完整。
    
-   **归档同步（Archive Sync）**：在全同步基础上不修剪任何历史状态，用于搭建归档节点。\`
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->





安全合规相关

只装官方软件、面试不轻信他人多渠道确认、不提供提供任何隐私

空投相关不轻易授权

平台插件只在官网下载、开启防火墙、浏览器插件权限管理

使用密码管理器为每个平台独立设置强密码

转账审计仔细地址

助记词只能离线保存、不上传发给任何人

定期检查钱包授权

然后web3合规直播部分

在文本、合同、协议、白皮书等法律文件上做到形式合法合规，使用符合监管的术语和表述

在业务模式、资金流向、用户交互等实际运营中规避法律风险，不做公开融资行为

入职前要详细调查、合同审查、业务隔离

安全方面做到不点、不签、不装、不转
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->






以太坊是一个去中心化、开源并且具备智能合约功能的公共区块链平台。EVM是一个图灵完备的虚拟机，能够执行智能合约代码，可以运行各类程序和应用。

以太坊具有几个特点：1smart contract 2dapp 3tokens 4PoS 5gas 6Proto-Danksharding与Dencun 7

gas费动荡原因：1网络拥堵 2全球用户活动时间差 3交互复杂程度

dapp核心技术特征：1去中心化 2确定性 3图灵完备 4隔离性

021上以太坊中心化实现机制中的部分不理解，查询后的内容如下

MEV与PBS（应对市场力量的集中化压力）

核心问题：最大可提取价值（MEV）会促使验证者专业化、中心化，以获取更高利润。

解决方案（PBS）：

-   职责分离：将“构建区块”（排序交易以获取MEV）和“提议区块”（最终确认区块）的角色分开。
    
-   构建者市场竞争：专业构建者之间为让自己的区块被选中而竞标，验证者只需选择收益最高的有效区块。
    
-   目的：防止验证者因追逐MEV而自然走向中心化，将排序权分散到一个竞争性市场中。当前的MEV-Boost是过渡方案，目标是最终通过协议升级（ePBS）将其内化。
    

今日学习的021学习以太坊部分内容和昨天的实习手册相重合
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->







区块链由多个区块组成，共同维护不可篡改的记录数据。

特点：不可篡改、公开透明、快速交易

BTC拥有区块链特性的同时具备货币属性，可以通过随机生成钱包地址进行交易。

区块链根据访问权限与治理模式，大致可分为三类：公链、联盟链、私链

去中心化的优势：信任最小化、抗审查与高弹性、用户自主管理、开放创新生态

Ethereum是通过ETH提供去中心化的EVM来处理点对点合约的。

ETH与BTC的差异

| 维度 | 比特币（Bitcoin） | 以太坊（Ethereum） |
| --- | --- | --- |
| 目标与定位 | 去中心化的数字货币，强调安全、稳定和稀缺性（总量 2100 万枚） | 去中心化平台，支持智能合约和 Dapps，定位为“区块链 2.0” |
| 编程能力 | 脚本语言有限，仅支持简单的交易验证逻辑 | 图灵完备的编程语言（如 Solidity），可开发复杂智能合约 |
| 共识机制 | 工作量证明（PoW），矿工通过算力竞争记账权 | 从 PoW 转向权益证明（PoS），通过 The Merge 实现能源效率优化 |
| 交易速度 | 每 10 分钟生成一个区块，交易确认较慢 | 区块时间约 12 秒，交易确认更快，适合高频应用 |
| 经济模型 | 总量固定，强调抗通胀属性 | 供应灵活，通过 EIP-1559 等机制可能呈现通缩趋势 |

以太坊历史：Pow -> The Merge -> PoS

1.  **The Merge（2022 年完成）**：从高能耗 PoW → 低能耗 PoS
    
2.  **EIP-4844（2024 年完成）**：让 L2 更便宜，普通人用得起
    
3.  **数据分片（2025-2026 年）**：进一步降低 L2 成本，提升整体扩展性
    

以太坊的生态系统由多层架构组成，包括 L1（主网）、L2（二层扩展解决方案）、侧链（Sidechains）

以太坊生态：应用层(defi/nft/wallet/dao)、协议层(共识层客户端、执行层客户端、核心协议)、扩展层(Layer2Rollups/侧链/状态通道)

gas是为了激励验证者以及防止资源滥用的
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
