---
timezone: UTC+8
---

# Jixiang Li

**GitHub ID:** Noe1017

**Telegram:** @13110917608

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->
一、核心痛点（v2 的问题）

在 Uniswap v2 里：

• 流动性 均匀分布在 0 ～ ∞ 的所有价格区间

• 但真实交易 只发生在当前价格附近

• 结果是：

• 99% 的资金几乎没被用到

• LP 资金效率极低

• 做市收益被严重摊薄

👉 v3 的全部设计，都是围绕 “提高资本效率” 展开的。

二、Uniswap v3 的 4 个核心优化

1️⃣ 集中流动性（Concentrated Liquidity）——最核心的创新

v2：

• 你提供流动性 = 在全价格区间做市

v3：

• 你可以只在 指定价格区间 \[Pmin, Pmax\] 提供流动性

📌 直觉理解：

不再在荒漠里撒钱，只在“最可能成交的路段”摆摊。

带来的结果

• 同样 TVL，深度更深

• LP 收益 ↑（单位资金手续费更高）

• 协议资本效率 ↑↑↑

⚠️ 副作用：

• 价格超出区间 → 你的流动性 失效（变成单边资产）

2️⃣ LP 头寸 NFT 化（Positions as NFTs）

在 v2：

• LP token 是 同质化 ERC20

在 v3：

• 每个 LP：

• 不同价格区间

• 不同投入比例

• 👉 无法再同质化

• 所以：LP 头寸 = ERC-721 NFT

NFT 里记录了什么？

• 价格区间

• 流动性数量

• 已累计未领取手续费

📌 本质：

LP 从“存钱”升级为 “主动策略仓位”

3️⃣ 多手续费等级（Multiple Fee Tiers）

v3 支持 同一交易对，多种手续费池：

手续费 适合场景

0.01% 稳定币 / 极低波动

0.05% 主流资产

0.3% 普通长尾资产

1% 高波动 / 小币

为什么重要？

• 波动大的资产 → LP 风险高 → 手续费要高

• 市场自己选择最合适的池子

📌 这是把 “风险定价” 引入 AMM。

4️⃣ Tick & Price Range 的工程级优化

v3 在底层做了大量 工程优化，不是纯经济模型：

Tick 机制

• 把连续价格空间 → 离散成 ticks

• 每个 tick 表示一个价格点

• 流动性只在 tick 区间内生效

好处

• 精准计算流动性变化

• Gas 成本可控

• 支持复杂做市策略

📌 这是 v3 复杂但强大的根基。

三、Uniswap v3 带来的范式变化

对 LP

• ❌ 不再是“无脑存钱”

• ✅ 更像：

• 做市商

• DeFi 策略玩家

• 类似 CEX 的限价区间做市

对协议

• 更少 TVL = 同等深度

• AMM 从「被动」→「半主动」

对生态

• 催生了：

• 自动做市策略（Rebalance）

• LP 管理协议（Arrakis、Gamma 等）

• 类似 CEX MM 的链上策略

四、总结

Uniswap v3 的核心优化是「集中流动性」，通过价格区间做市、NFT 化头寸和多手续费池，把 AMM 的资本效率和风险定价能力大幅提升，使 LP 从被动提供者转变为主动做市者。
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->

\# Neverland Money：Monad 生态的明星借贷协议

\## 项目概述

**Neverland Money** 是一个运行在 **Monad 区块链**上的下一代去中心化借贷协议，将经过实战检验的 **Aave V3** 借贷技术与创新的 **veTokenomics**（投票托管代币经济学）相结合。作为 Monad 原生协议，Neverland 专注于资本效率最大化和用户体验优化。\[Neverland Money\]([https://neverland.money/](https://neverland.money/))

该协议的核心理念是通过社区治理实现真正的去中心化，同时为用户提供即时流动性访问和完全的资产控制权。

\## 核心机制详解

\### DUST/veDUST 双代币模型

**DUST 代币**是 Neverland 生态的核心治理代币，用户可以通过以下方式获得：

\- 在协议上供应资产赚取利息

\- 借贷资产获得奖励

\- 参与平台活动

\*\*veDUST（投票托管 DUST）\*\*机制是协议的创新亮点：

\- 用户锁定 DUST 代币可获得 veDUST NFT

\- veDUST 持有者享有 **100% 协议收入分配权**

\- 投票权重随锁定时间递减，激励长期参与

\- 支持 NFT 形式的灵活交易和合并操作

\### 自偿还贷款（Self-Repaying Loans）

这是 Neverland 的独特功能：

\- 用户可设置自动将 veDUST 收益用于偿还贷款

\- 无需手动管理，实现"设置即忘记"的体验

\- 当贷款完全偿还后，多余收益自动存入用户账户

\### 高级自动化策略

\- **循环杠杆策略**：自动利用低利用率资金池最大化收益

\- **资本效率优化**：确保资金始终处于最优配置状态

\- **无缝性能**：基于 Monad 的高性能区块链实现快速执行

\## 最新市场表现

\### 里程碑式增长

| 指标 | 数值 | 时间节点 |

|------|------|----------|

| **TVL** | **1.06亿美元** | 2026年1月24日 |

| **利用率** | 78.8% | 最新数据 |

| **总收入** | 34.7万美元 | 累计 |

| **DUST 销毁量** | 16.67万枚 | 通缩机制 |

| **DUST 流通供应量** | 34.92万枚 | 当前 |

**历史性突破**：2026年1月22日，Neverland 成为首个 TVL 突破 1 亿美元的 Monad 原生应用，这不仅是协议的重要里程碑，也标志着 Monad 生态的巨大潜力。\[X\]([https://x.com/Neverland\_Money/status/2014417047254376647](https://x.com/Neverland_Money/status/2014417047254376647))

\### 生态系统整合

**合作伙伴关系**：

\- **Beefy Finance** 集成：推出 7 个单资产自动复投金库，支持 AUSD、WMON、USDC 等主要资产 \[X\]([https://x.com/Neverland\_Money/status/2014319102211326241](https://x.com/Neverland_Money/status/2014319102211326241))

\- **Kintsu 合作**：sMON 存款奖励翻倍，用户可获得双倍积分和增强的 DUST 奖励 \[X\]([https://x.com/Neverland\_Money/status/2015109410268311920](https://x.com/Neverland_Money/status/2015109410268311920))

\- **Octane Security** 合作：加强持续监控和威胁检测能力

\## 安全保障与技术审计

\### 专业安全审计

**Composable Security 审计报告**显示：

\- 发现并解决了 **23 个问题**，包括 1 个关键漏洞和 3 个高危漏洞

\- 重点审计了自定义业务逻辑，排除了成熟的 Aave 和 Velodrome 分叉代码

\- 核心组件包括奖励分配、投票权计算、收入分配等关键功能 \[Composable Security\]([https://composable-security.com/blog/neverland-security-review-of-lending-protocol/](https://composable-security.com/blog/neverland-security-review-of-lending-protocol/))

\### 技术架构优势

**基于 Aave V3**：

\- 利用经过实战检验的借贷框架

\- 继承了 Aave 的安全性和稳定性

\- 在此基础上添加创新功能

**Monad 区块链优势**：

\- 高性能执行环境

\- 低成本交易

\- 与以太坊生态兼容

\## 社区反馈与市场地位

\### 用户参与度

**自偿还贷款使用情况**：

\- 每周约 108 名用户启用自动还款功能

\- 周均自动还款金额约 5,600 美元

\- 用户满意度极高，体现了功能的实用性 \[X\]([https://x.com/Neverland\_Money/status/2014150088654794984](https://x.com/Neverland_Money/status/2014150088654794984))

\### 社区声誉

根据社交媒体反馈，Neverland 被社区成员称为"整个加密行业中最独特和最优秀的协议"，团队专业友好，社区氛围积极健康。\[X\]([https://x.com/Demonidus/status/2015186285242229174](https://x.com/Demonidus/status/2015186285242229174))

\## 项目澄清

需要注意的是，当前活跃的 **Neverland Money** 与较早期的 **Neverland Finance**（使用 HOOK 代币）是完全不同的项目。后者 TVL 较低且不再活跃，而 Neverland Money 是当前 Monad 生态中的明星项目。

\## 总结

Neverland Money 通过创新的 veTokenomics 和自偿还贷款机制，在短短两个月内实现了 TVL 破亿的惊人增长，成为 Monad 生态的标杆项目。其结合了传统 DeFi 的安全性与创新功能的便利性，为用户提供了真正的"魔法般"的 DeFi 体验。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->


````markdown
# Solidity Gas Optimization Guide

## Table of Contents
1. [Understanding Gas](#understanding-gas)
2. [Gas Cost Reference](#gas-cost-reference)
3. [Optimization Techniques](#optimization-techniques)
4. [Case Study Analysis](#case-study-analysis)
5. [Best Practices Checklist](#best-practices-checklist)

---

## Understanding Gas

### What is Gas?

Gas is the unit of measure for the computational effort required to execute operations on the Ethereum network. Each operation in the EVM (Ethereum Virtual Machine) consumes a specific amount of gas.

### Why Optimize Gas?

1. **Cost Savings**: Users pay less in transaction fees
2. **Better UX**: Lower barriers to entry for interacting with your contract
3. **Competitive Advantage**: Gas-efficient contracts are preferred by users
4. **Network Efficiency**: Contributes to overall network health

### Gas Price Components

```
Total Transaction Cost = Gas Used × Gas Price + Base Fee + Priority Fee
```

---

## Gas Cost Reference

### Opcode Costs (Approximate)

| Operation | Cost | Notes |
|-----------|------|-------|
| `SLOAD` | 2,100 (cold) / 100 (warm) | Reading from storage |
| `SSTORE` | 20,000 (new) / 5,000 (update) | Writing to storage |
| `MLOAD` / `MSTORE` | 3 | Memory operations |
| `CALLDATACOPY` | 3-12 | Copying calldata to memory |
| `KECCAK256` | 30 + 6 per word | Hashing |
| `EXTCODESIZE` | 2,600 (cold) | Checking contract size |
| `BALANCE` | 2,600 (cold) | Getting balance |

### Storage vs Memory vs Calldata

| Type | Read Cost | Write Cost | Notes |
|------|-----------|------------|-------|
| Storage | 2,100 gas | 20,000 gas | Persistent, expensive |
| Memory | 3 gas | 3 gas | Temporary, cheap |
| Calldata | Free | N/A | Input data, immutable |

---

## Optimization Techniques

### 1. Storage Packing

**Concept**: Pack multiple small variables into a single 32-byte storage slot.

**Why it matters**: Each storage slot costs 20,000 gas to initialize (SSTORE).

**Unoptimized:**
```solidity
bool public votingActive;      // Slot 0: 1 byte used, 31 wasted
bool public hasVoted;          // Slot 1: 1 byte used, 31 wasted
uint8 public candidateCount;   // Slot 2: 1 byte used, 31 wasted
uint8 public minVotingAge;     // Slot 3: 1 byte used, 31 wasted
// Total: 4 slots = 80,000 gas (deployment)
```

**Optimized:**
```solidity
// All packed in ONE 32-byte slot
bool public votingActive;      // 1 byte  ]\
bool public hasVoted;          // 1 byte  | > Total: 4 bytes
uint8 public candidateCount;   // 1 byte  |
uint8 public minVotingAge;     // 1 byte  /
// Padding: 28 bytes
// Total: 1 slot = 20,000 gas (deployment)
// Savings: 60,000 gas
```

**Rules for Packing:**
- Pack variables declared consecutively
- Order by size (largest to smallest within each slot)
- Each slot is 32 bytes
- bool = 1 byte, uint8 = 1 byte, uint16 = 2 bytes, etc.

---

### 2. Use Calldata Instead of Memory

**Concept**: Use `calldata` for function parameters that don't need modification.

**Why it matters**: Memory requires copying data, calldata references input directly.

**Unoptimized:**
```solidity
function addCandidate(string memory name) external {
    // Data copied from calldata to memory
    // Cost: ~100+ gas for short strings
}
```

**Optimized:**
```solidity
function addCandidate(string calldata name) external {
    // No copying, direct reference to calldata
    // Savings: ~100+ gas
}
```

**When to use each:**
- Use `calldata`: External functions, read-only parameters
- Use `memory`: Internal functions, parameters that need modification
- Use `memory`: When you need to modify string/bytes content

---

### 3. Custom Errors Instead of Require Strings

**Concept**: Define custom error types instead of using require with string messages.

**Why it matters**: Error strings are stored in contract bytecode and cost gas to deploy and use.

**Unoptimized:**
```solidity
require(votingActive, "Voting is not active");
// Deployment cost: string stored in bytecode
// Revert cost: ~50+ gas for string loading
```

**Optimized:**
```solidity
error VotingNotActive();

if (!votingActive) revert VotingNotActive();
// Deployment cost: minimal (just error selector)
// Revert cost: ~0-24 gas (no string loading)
```

**Gas Savings**: ~50-100 gas per revert

---

### 4. Smaller uint Types

**Concept**: Use the smallest uint type that can hold your values.

**Why it matters**: Smaller types can be packed and use less gas in operations.

**Unoptimized:**
```solidity
uint256 public candidateCount;  // Will never exceed 255
uint256 public totalVotes;      // Could exceed uint256 but uint128 is sufficient
```

**Optimized:**
```solidity
uint8 public candidateCount;    // Max: 255
uint128 public totalVotes;      // Max: ~3.4 × 10^38
```

**Type Selection Guide:**
| Type | Max Value | Use Case |
|------|-----------|----------|
| uint8 | 255 | Small counters, flags |
| uint16 | 65,535 | Medium counters |
| uint32 | 4.3 billion | Timestamps (2106) |
| uint64 | 1.8 × 10^19 | Large counters |
| uint128 | 3.4 × 10^38 | Token balances, voting |
| uint256 | 1.6 × 10^77 | Default, maximum range |

---

### 5. Unchecked Arithmetic

**Concept**: Use `unchecked` block for arithmetic that cannot overflow/underflow.

**Why it matters**: Solidity 0.8+ includes overflow checks by default (~20 gas per operation).

**Unoptimized:**
```solidity
for (uint256 i = 0; i < array.length; i++) {
    // Each i++ has overflow check
    // i cannot overflow given the loop condition
}
```

**Optimized:**
```solidity
for (uint256 i = 0; i < array.length; ) {
    // ...
    unchecked { ++i; }  // No overflow check
}
```

**When Safe to Use:**
- Loop counters with bounds
- Incrementing counters with known maximums
- Operations where overflow is logically impossible

**⚠️ WARNING**: Only use when you can PROVE overflow/underflow is impossible!

---

### 6. Cache Storage Variables

**Concept**: Load storage variables to memory once, use multiple times.

**Why it matters**: SLOAD = 2,100 gas, MLOAD = 3 gas.

**Unoptimized:**
```solidity
function processVotes() external {
    for (uint256 i = 0; i < candidates.length; i++) {
        // Each iteration reads from storage
        candidates[i].voteCount++;  // SLOAD + SSTORE
    }
}
```

**Optimized:**
```solidity
function processVotes() external {
    uint256 length = candidates.length;  // Cache in memory
    for (uint256 i = 0; i < length; ) {
        Candidate storage candidate = candidates[i];  // One SLOAD
        unchecked { ++i; }
    }
}
```

---

### 7. Loop Optimizations

**Combine multiple techniques:**

```solidity
// Unoptimized
for (uint256 i = 0; i < array.length; i++) {
    process(array[i]);
}

// Optimized
uint256 length = array.length;  // Cache array length
for (uint256 i = 0; i < length; ) {
    process(array[i]);
    unchecked { ++i; }  // Prefix increment
}
```

**Tips:**
- Cache array length in memory
- Use `unchecked` for increment
- Use prefix increment (`++i`) instead of postfix (`i++`)
- Consider `do-while` for always-executing loops

---

### 8. Short-Circuit Evaluation

**Concept**: Order conditions by execution cost and likelihood.

```solidity
// Unoptimized - expensive check first
if (expensiveCheck() || cheapCheck()) { }

// Optimized - cheap check first
if (cheapCheck() || expensiveCheck()) { }
```

---

### 9. Function Visibility

**Use stricter visibility when possible:**
- `private` / `internal`: Most gas efficient
- `public`: Creates dispatcher code
- `external`: Most efficient for public functions

---

### 10. Remove Redundant Code

**Unoptimized:**
```solidity
function getTotalVotes() external view returns (uint256) {
    return totalVotes;  // Unnecessary wrapper
}
```

**Optimized:**
```solidity
// Make totalVotes public instead
uint128 public totalVotes;
```

---

### 11. Events vs Storage

**Use events for one-time data:**

```solidity
// Unoptimized - storing all votes in storage
mapping(address => uint256) public allVotes;

// Optimized - emit event for indexing
event VoteCast(address indexed voter, uint256 choice);
```

---

## Case Study Analysis

### Voting Contract Comparison

#### Deployment Phase

| Metric | Unoptimized | Optimized | Savings |
|--------|-------------|-----------|---------|
| Storage Slots | 7+ | 3-4 | ~60,000 gas |
| Bytecode Size | Larger | Smaller | ~10,000+ gas |

#### Runtime Operations

| Operation | Unoptimized | Optimized | Savings |
|-----------|-------------|-----------|---------|
| addCandidate() | ~52,000 | ~46,000 | ~6,000 gas |
| vote() | ~48,000 | ~38,000 | ~10,000 gas |
| calculateWinner() | ~8,500 | ~6,200 | ~2,300 gas |
| Error Revert | ~24,000 | ~23,500 | ~500 gas |

### Key Optimizations Applied

1. **Storage Packing**: 4+ slots → 1 slot for small types
2. **Custom Errors**: Eliminated error string storage
3. **Calldata**: Used for read-only string parameters
4. **uint128**: Replaced uint256 where appropriate
5. **Unchecked**: Applied to safe arithmetic operations
6. **Cached Storage**: Reduced SLOAD operations in loops
7. **Loop Patterns**: Optimized iteration and increment

---

## Best Practices Checklist

### Pre-Deployment
- [ ] Pack storage variables efficiently
- [ ] Use appropriate uint types
- [ ] Replace require strings with custom errors
- [ ] Use calldata for external function parameters
- [ ] Remove unused variables and functions

### Code Review
- [ ] Check for repeated SLOAD operations
- [ ] Identify loops that can use unchecked arithmetic
- [ ] Verify storage layout is optimal
- [ ] Ensure events are used for one-time data
- [ ] Check for redundant code

### Testing
- [ ] Run gas profiler on all functions
- [ ] Compare gas costs before/after optimizations
- [ ] Test edge cases for unchecked arithmetic
- [ ] Verify optimizations don't break functionality

### Tools
- **Hardhat Gas Reporter**: `gasPrice: 20`
- **Foundry Gas Snapshots**: `forge snapshot`
- **Etherscan Gas Tracker**: Verify mainnet costs
- **Tenderly**: Advanced gas analysis

---

## Additional Resources

### Advanced Topics
1. **Assembly (Yul)**: Inline assembly for specific optimizations
2. **Bitmaps**: Bit manipulation for boolean arrays
3. **Merkle Trees**: Off-chain storage with on-chain verification
4. **Create2**: Predictable contract deployment
5. **EIP-1155**: Multi-token standard (gas efficient)

### Further Reading
- [Solidity Documentation on Gas](https://docs.soliditylang.org/en/latest/Control-Flow.html#gas-calculation)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
- [OpenZeppelin Gas Optimizations](https://docs.openzeppelin.com/upgrades-plugins/1.x/gas-cheatsheet)

---

## Quick Reference Card

```
┌────────────────────────────────────────────────────────────┐
│                    GAS SAVINGS REFERENCE                    │
├────────────────────────────────────────────────────────────┤
│ SSTORE (new)       │ 20,000 gas │ Avoid new storage slots  │
│ SLOAD              │  2,100 gas │ Cache in memory          │
│ Custom Error       │     ~50 gas │ vs require strings      │
│ Memory vs Calldata │    ~100 gas │ Use calldata when possible│
│ Unchecked          │     ~20 gas │ For safe arithmetic     │
│ Storage Pack       │ 20,000 gas │ Per slot saved           │
└────────────────────────────────────────────────────────────┘
```

---

*Generated for Gas Optimization Case Study*
*Solidity 0.8.20 | Hardhat | 2025*
````
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->



**Never Land 的安全性**，从链上风险、协议风险到经济激励风险全面拆解。

* * *

## 一、合约风险（核心链上风险）

### 1️⃣ 资产去向

-   你 supply 的 shMON **被锁在 Never Land 的智能合约里**
    
-   合约控制了你的资金，任何 bug / 后门都可能导致资金损失
    

### 2️⃣ 审计情况

-   我没有看到公开的 **安全审计报告**（至少在官网/主流信息源没查到）
    
-   没有审计的合约 **风险极高**，尤其是涉及流动性质押的资产
    

### 3️⃣ 可撤回性

-   如果合约允许你随时 withdraw → 风险稍低
    
-   如果存在 lock / unstake queue → 退场被延迟，万一合约出问题就麻烦
    

✅ 核心结论：

> **合约安全是第一风险点，如果没公开审计，你的资产是暴露在智能合约风险里的**

* * *

## 二、经济激励风险

### 1️⃣ Points 和 APY 是虚拟的

-   你获得的是 **积分（points）**
    
-   并不是真实收益
    
-   协议承诺的未来激励可能不兑现
    

### 2️⃣ 激励预期 vs 真实收益

-   Never Land 的 APY、奖励都是“估算 + 未来预期”
    
-   如果协议方不发 token 或中途调整规则，你的“收益”可能直接归零
    

✅ 核心结论：

> **你的收益不是真实现金流，更多是“期权性质的奖励”，不能保证兑现**

* * *

## 三、再利用 / Rehypothecation 风险

-   Never Land 的设计允许协议 **使用你的 shMON 做其他操作**
    
-   可能用于：
    
    -   流动性池
        
    -   协议内交易
        
-   这意味着：
    
    -   你可能承担额外风险
        
    -   但链上看不到这些操作（完全依赖合约逻辑）
        

* * *

## 四、网络和基础风险

-   如果 Monad 网络发生：
    
    -   节点被 slash
        
    -   出块异常
        
    -   资产被延迟结算
        
-   你的 shMON 在 Never Land 仍然 **依赖底层网络安全性**
    

* * *

## 五、风险总结表

| 风险类型 | 是否存在 | 影响 | 备注 |
| --- | --- | --- | --- |
| 合约漏洞 | ✅ | 可能直接丢钱 | 未公开审计 |
| 激励兑现 | ✅ | points / APY可能无价值 | 不是真 token / cash |
| 再利用风险 | ✅ | 协议可能使用你的资产 | 取决合约逻辑 |
| 网络 / Validator | ✅ | shMON 受底层网络影响 | PoS网络风险 |
| 流动性风险 | ✅ | 退出可能被延迟 | 取决合约规则 |

* * *

## 六、判断方法

如果你考虑安全性，要看三个指标：

1.  **合约是否经过公开安全审计**
    
2.  **资产是否可以随时 withdraw**
    
3.  **收益是否真实可兑现（points → token）**
    

> 如果三个条件都不完全满足，就要**认定风险较高**，属于**高风险激励实验性质**。

* * *

> **Never Land 是一个实验性、激励性质的链上协议，合约安全和收益兑现存在不确定性，不属于传统 PoS 质押，风险偏高。**
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->




10 Minute Guide | Obsidian + AI Agent

\---

\### **一、核心问题与理念**

\- **问题**：传统笔记工具存在“收藏不看”、信息孤岛、整理繁琐等问题。

\- **理念**：将知识库视为代码库，使用\*\*Obsidian\*\*（文本仓库）与\*\*AI Agent\*\*（智能管家）结合，实现“\*\*知识管理的自动化\*\*”。

\- **角色分工**：

\- **你（Editor）**：负责决策与判断。

\- **AI（Intern）**：负责执行、分类、整理。

\---

\### **二、工具选择**

\- **Obsidian**：

\- 使用Markdown纯文本，通用性强。

\- 本地存储，安全可控。

\- 支持双向链接`[[]]`），构建知识网络。

\- **AI Agent**（如Claude Code, Cursor等）：

\- 能直接读取和修改本地文件。

\- 支持批量处理文件，告别复制粘贴。

\---

\### **三、实操流程**

1\. **原始积累**：将所有资料（PPT、文章等）直接放入文件夹，无需预处理。

2\. **AI规划结构**：让AI分析资料并自动创建文件夹、拆分笔记。

3\. **建立链接**：AI插入标签和链接，将信息编织成知识网络。

4\. **数据清洗**：去重、统一格式。

5\. **补全信息**：

\- 客观信息：AI联网搜索补全。

\- 主观观点：标注“待确认”。

\---

\### **四、系统设计原则**

\- 创建\*\*规则文件\*\*（`Rules.md`），定义文件结构与命名规范。

\- 建议采用\*\*Inbox → Thinking → Creating → Archive\*\*流程。

\- **笔记三原则**：

1\. **独立性**：单篇笔记可独立阅读。

2\. **链接入句**：链接融入句子中。

3\. **观点命名**：标题即观点。

\---

\### **五、日常使用与维护**

\- **日常使用**：

\- 写作辅助、快速检索。

\- **园丁模式**：

\- 定期清理“孤儿笔记”。

\- **长期价值**：知识库具有复利效应，越用越顺手。

\---

\### **六、扩展应用场景**

\- 不仅适用于笔记，还适用于：

\- 文件整理（如清理C盘、批量重命名）。

\- 自动化工作流（如资讯抓取、日报生成）。

\---

\### **七、愿景与行动号召**

\- 目标是打造“\*\*数字分身\*\*”，让知识库成为你的“第二大脑”。

\- 建议从今天开始，下载Obsidian并写下第一条笔记。

\---
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->





从零到一：现代 Dapp 全栈开发实战

\---

\### **一、核心技术与工具栈**

\- **混合栈架构**：结合 **Hardhat**（部署、测试、脚本）、\*\*Foundry\*\*（合约开发、单元测试）、\*\*Next.js\*\*（前端框架）、\*\*Wagmi\*\*（Web3 前端交互）。

\- **开发环境**：推荐 Node.js v20 + pnpm。

\---

\### **二、智能合约开发与测试**

\- **合约工程化**：示例为 `WorkshopRegistry` 合约。

\- **混合测试策略**：

\- **Foundry** 用于单元测试与模糊测试（Fuzzing）。

\- **Hardhat + Viem** 用于集成测试，模拟前端交互与跨合约调用。

\- 使用 TypeScript 提升测试的可维护性和模拟能力。

\---

\### **三、部署与验证**

\- **声明式部署**：使用 **Hardhat Ignition** 替代传统脚本，支持断点续传、Gas 管理、状态定义。

\- **安全密钥管理**：使用 Hardhat Keystore 替代明文存储私钥。

\- **自动化验证**：支持部署后自动验证合约。

\---

\### **四、前端架构与交互**

\- **Next.js + Wagmi**：构建现代化、响应式的前端。

\- **解决 Hydration 问题**：通过 **Cookie 存储** 统一服务端与客户端状态。

\- **核心交互模式**：

\- **读取数据**：使用 `useReadContract` 监听合约状态。

\- **写入与签名**：处理交易与用户签名。

\- **处理 BigInt**：前端渲染时需显式调用 `.toString()`。

\---

\### **五、安全与最佳实践**

\- **合约安全**：

\- 防止重入攻击（Checks-Effects-Interactions）

\- 访问控制（onlyOrganizer 修饰器）

\- **前端安全**：

\- 输入验证

\- 避免 BigInt 序列化问题

\- **基础设施**：

\- 生产环境使用私有 RPC，避免公共节点限流。

\---

\### **六、项目全景与进阶路径**

\- **完整项目全景图**：展示了从合约到前端的完整开发流程。

\- **进阶学习方向**：

\- OpenZeppelin Wizard（合约模板）

\- Ethernaut CTF（安全挑战）

\- Foundry Cast（命令行工具）

\---

\### **七、核心理念**

\> **Code is Law. UI is the Bridge. GO BUILD.**

\> 强调智能合约的严谨性、用户体验的重要性，鼓励动手构建。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->






**《Uniswap 基础原理》**

* * *

## 一、Uniswap 是什么（一句话版）

> **Uniswap 是一种基于 AMM（自动做市商）的去中心化交易所，通过数学公式而不是订单簿来完成定价和交易。**

* * *

## 二、Uniswap V2：基础 AMM 原理

### 1️⃣ 恒定乘积做市模型（核心公式）

-   **公式**：  
    \[  
    x \\times y = k  
    \]
    
-   含义：
    
    -   `x`、`y`：池子中两种资产的数量
        
    -   `k`：常数
        
-   **价格**：  
    \[  
    p = \\frac{y}{x}  
    \]
    

👉 交易本质：  
用户用一种资产换另一种 → 改变池子比例 → 自动形成价格变化

* * *

### 2️⃣ 套利机制（价格回归市场）

-   Uniswap 池内价格 ≠ 市场价格时
    
-   套利者会不断交易
    
-   直到：
    
    -   池内价格 ≈ 外部市场价格
        

👉 **AMM 不主动“定价”，是套利者在“校准价格”**

* * *

### 3️⃣ LP（流动性提供者）与无常损失

-   LP 向池子中 **按比例提供两种资产**
    
-   收益来源：
    
    -   交易手续费
        
-   风险：
    
    -   **无常损失（Impermanent Loss）**
        
        -   当价格波动时
            
        -   LP 的资产组合价值 < 单纯 HODL
            

结论：

> 无常损失是 AMM 的**机制性结果**，无法彻底避免，只能靠手续费补偿

* * *

### 4️⃣ 闪电贷（Flash Loan）

-   特点：
    
    -   **先借 → 再还**
        
    -   同一笔交易内完成
        
-   用途：
    
    -   套利
        
    -   清算
        
    -   复杂 DeFi 组合操作
        
-   风险：
    
    -   如果交易结束前还不上 → 整笔交易回滚
        

👉 核心思想：**链上原子性**

* * *

### 5️⃣ TWAP（时间加权平均价格）

-   解决问题：
    
    -   防止瞬时价格被操纵
        
-   原理：
    
    -   对价格做时间维度平均
        
-   用途：
    
    -   链上预言机
        
    -   DeFi 定价参考
        

* * *

## 三、Uniswap V3：集中流动性革命

### 1️⃣ 集中流动性（最重要的升级）

-   V2：
    
    -   流动性分布在 **0 ~ ∞**
        
-   V3：
    
    -   LP 可以 **自定义价格区间**
        

效果：

-   💰 资金效率大幅提升
    
-   🎯 更像“专业做市”
    

* * *

### 2️⃣ Tick 系统（价格离散化）

-   将价格划分为一个个 **Tick**
    
-   每个 Tick：
    
    -   可能有流动性变化
        
-   作用：
    
    -   精确管理流动性边界
        
    -   提高计算与存储效率
        

* * *

### 3️⃣ 手续费与流动性分配

-   不同价格区间
    
-   不同 LP
    
-   **只在“有效区间内”赚手续费**
    

👉 V3 的 LP 更像“策略玩家”，而不是被动存钱

* * *

### 4️⃣ L 与 √P 公式

-   用 √Price 简化计算
    
-   提升合约执行效率
    
-   降低 gas 成本
    

* * *

## 四、Uniswap V4：模块化与可编程 AMM

### 1️⃣ Hook（钩子）机制

-   在关键节点插入自定义逻辑：
    
    -   交易前 / 后
        
    -   加 / 减流动性
        
-   能做什么？
    
    -   动态手续费
        
    -   限价单
        
    -   防 MEV 逻辑
        
    -   自定义流动性策略
        

👉 Uniswap 从 **DEX** 进化为 **DeFi 基础设施**

* * *

## 五、生态与开发者支持

-   Uniswap Foundation 提供：
    
    -   💸 资助
        
    -   🔍 审计补贴
        
    -   🧑‍💻 孵化器
        
    -   🏆 黑客松
        
-   强调：
    
    -   教育
        
    -   长期生态建设
        

* * *

## 六、高频 Q&A 核心结论速览

-   ❓ 无常损失能否避免？  
    ❌ 不能，只能被手续费对冲
    
-   ❓ 滑点 ≠ 价格影响
    
    -   价格影响：可计算
        
    -   滑点：不可控偏差
        
-   ❓ V3 手续费档位如何选？
    
    -   稳定币：0.01% / 0.05%
        
    -   主流币：0.3%
        
    -   高波动：1%
        
-   ❓ 池子会被掏空吗？  
    ❌ 不会，合约会校验储备量
    

* * *

## 七、一句话总总结

> **Uniswap 通过 AMM 模型，用数学公式替代订单簿；  
> V2 解决“能不能交易”，V3 解决“资金效率”，V4 让 AMM 变成可编程金融组件。**
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->







**《Elon 老师 Solidity 笔记》**

* * *

## 一、整体框架概览

这份文档本质上是一份 **Solidity + EVM 的入门到进阶学习笔记**，核心目标是：

> 帮你理解：  
> **智能合约是怎么在 EVM 里运行的、Solidity 的核心语法、以及写合约时最容易踩的坑**

内容从 **底层运行环境 → 语言特性 → 存储模型 → 合约设计与安全** 逐步展开。

* * *

## 二、核心内容总结

### 1️⃣ EVM 与智能合约运行环境

**重点在“原理认知”而不是只会写代码**

-   **EVM（Ethereum Virtual Machine）**
    
    -   是一个 **确定性的虚拟机**
        
    -   每个节点执行同样的字节码 → 得到同样的结果
        
-   智能合约：
    
    -   本质是 **部署在链上的程序**
        
    -   一旦部署，代码不可修改（除非用代理模式）
        
-   **Gas 机制**
    
    -   每一步计算、存储、调用都有成本
        
    -   防止死循环、DoS
        
    -   写合约 = 写“有成本的代码”
        

👉 这部分是在回答：  
**为什么 Solidity 要这么“反人类”，为什么要关心 gas、storage、memory**

* * *

### 2️⃣ Solidity 数据类型体系（非常核心）

（1）值类型 Value Types

特点：

> **直接存值，拷贝传递，gas 相对便宜**

包括：

-   `bool`
    
-   `uint / int`（重点是 uint256）
    
-   `address`
    
-   `bytes1 ~ bytes32`
    
-   `enum`
    

📌 关键理解点：

-   `address` ≠ 普通字符串
    
-   `address payable` 才能转账
    
-   uint256 是 EVM 的“原生整数”
    

* * *

（2）引用类型 Reference Types

特点：

> **不直接存值，存“引用”，涉及存储位置**

包括：

-   `string`
    
-   `bytes`
    
-   `array`
    
-   `mapping`
    
-   `struct`
    

📌 这里开始引出一个非常重要的概念：

* * *

### 3️⃣ 数据存储位置（Storage / Memory / Calldata）

这是 Solidity 的**灵魂考点**之一。

| 位置 | 特点 |
| --- | --- |
| storage | 链上永久存储，最贵 |
| memory | 临时内存，函数执行完就释放 |
| calldata | 只读、最省 gas（外部函数参数） |

关键结论：

-   **能用 calldata 就别用 memory**
    
-   **避免不必要的 storage 写操作**
    
-   mapping 只能在 storage
    

👉 这部分直接决定你合约是不是「烧钱合约」

* * *

### 4️⃣ 函数与修饰符（Function & Modifier）

-   函数可见性：
    
    -   `public`
        
    -   `external`
        
    -   `internal`
        
    -   `private`
        
-   `view` / `pure` 区别
    
-   `payable` 的意义
    

**Modifier（修饰符）**

-   用于权限控制、前置条件检查
    
-   常见场景：
    
    -   onlyOwner
        
    -   状态校验
        

📌 本质：

> Modifier = 函数级的“拦截器”

* * *

### 5️⃣ 合约交互与调用方式

-   合约之间可以互相调用
    
-   `call / delegatecall / staticcall`
    
-   重点强调：
    
    -   **delegatecall 的风险**
        
    -   代理合约（Upgradeable Contract）的基础
        

👉 为后面 DeFi / 升级合约埋伏笔

* * *

### 6️⃣ 事件（Event）与日志

-   Event：
    
    -   不参与合约逻辑
        
    -   用于 **链下监听**
        
-   常见用途：
    
    -   前端展示
        
    -   The Graph / Indexer
        
    -   交易追踪
        

📌 事件 ≠ 状态  
👉 是给“人”和“系统”看的

* * *

### 7️⃣ 常见安全问题与设计思维

虽然不是完整的安全审计，但已经点到了**核心风险**：

-   重入攻击（Reentrancy）
    
-   权限设计不当
    
-   状态更新顺序错误
    
-   不合理的 external call
    

👉 隐含思想：

> **Solidity 不是在写业务代码，而是在写“不可回滚的金融逻辑”**
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->








**分享会 - 社区运营基础 & 活动策划与执行流程：**

1.  **社群建设**：  
    会议介绍了如何搭建社群，特别是在Telegram上的社群创建与管理。参与者学习了如何设置群组的基本信息（如头像、名称、描述等）并选择合适的隐私设置（如公开或私密群组）。还讲解了如何设置管理员权限以确保社群管理的安全。
    
2.  **活动策划**：  
    讨论了如何策划一个线上活动（如Twitter Space）。首先，需要确定活动的主题、目标受众和活动时间。然后，通过收集信息并创建宣传海报进行预热和宣传，确保足够的参与者。还提到，活动期间，主持人应做好嘉宾介绍和问题库准备，确保活动流畅进行。
    
3.  **数据面板使用**：  
    强调了如何使用数据面板来监控和分析社群的活跃度和增长情况。通过面板可以查看成员数量、活跃用户、消息发布频率等数据，帮助运营人员调整策略以提高社群效果。
    
4.  **实操环节**：  
    会议还包括了实操部分，参与者可以动手实践社群管理和活动策划的流程，体验如何搭建、管理社群以及如何设置和分析Twitter Space活动。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->









**主题**：从 ERC-721 到 ERC-7962：基于哈希的代币标准

**主讲人**：Alex.Tian 老师

* * *

## 🎯 核心内容

### **ERC-7962 是什么？**

一个基于零知识证明原理的新型代币标准，旨在解决 ERC-721 在隐私保护和用户体验方面的不足。

### **三大核心特点**

1.  **隐私保护**
    
    -   使用**公钥哈希值**作为所有权标识，而非直接的地址
        
    -   所有权与交易发起地址解耦
        
    -   采用一次性密钥轮换机制（类似 UTXO）
        
2.  **Gas 费代付**
    
    -   支持第三方（如商家）代付交易费用
        
    -   用户无需持有 ETH 即可完成交易
        
    -   降低 Web2 用户进入 Web3 的门槛
        
3.  **账户抽象**
    
    -   用户只需签名表达意图
        
    -   无需理解钱包、私钥等复杂概念
        
    -   任何 relayer 都可以提交交易
        

* * *

## 💡 经典应用场景：星巴克会员案例

**场景描述**：

-   星巴克与机场休息室合作
    
-   星巴克会员可在机场休息室享受服务
    
-   **隐私需求**：星巴克不能直接将会员信息透露给机场
    

**ERC-7962 解决方案**：

1.  会员在机场出示 ZK 证明
    
2.  机场验证会员身份，但**不知道具体是谁**
    
3.  星巴克或机场代付 gas 费
    
4.  整个过程在链上完成，不可篡改
    

* * *

## 🔧 技术设计要点

### **与 ERC-721 的区别**

| 特性 | ERC-721 | ERC-7962 |
| --- | --- | --- |
| 所有权标识 | 地址 | 公钥哈希 |
| 隐私性 | 地址公开可查 | 哈希值难以追踪 |
| Gas 费 | 用户自付 | 支持代付 |
| Approve 机制 | 有 | 无（一次性密钥） |

### **零知识证明应用**

-   采用哈希函数实现简单的 ZK 证明
    
-   不是完整的代数体系，但足以证明"相等"关系
    
-   适用于会员身份验证等场景
    

### **安全设计**

-   结构化签名防止参数篡改
    
-   签名有效期机制
    
-   防重放攻击保护
    
-   强制密钥轮换增强不可关联性
    

* * *

## 🎪 优势与劣势

### **优势**

✅ 地址不上链，隐私保护强

✅ 批量代付，账户抽象灵活

✅ 降低 Web2 用户使用门槛

✅ 适合企业级批量分发、空投

### **劣势**

❌ Gas 成本比 ERC-721/20 高

❌ 公钥在交易时会暴露（需一次一换）

❌ 不向后兼容现有标准

❌ 对密钥管理要求较高

* * *

## 🙋 Q&A 环节精选

1.  **关于隐私与透明的矛盾**：ZK 证明在数学上保证不泄露具体信息，同时交易仍可验证
    
2.  **Gas 费谁来付**：商业场景中商家有动力代付（如星巴克为获得商业回报）
    
3.  **用户持有什么**：用户持有的是公钥（hash 前的值），类似传统密码，但由可信方（如星巴克）托管
    
4.  **反推问题**：哈希算法不可逆，无法从哈希值反推出原始公钥
    
5.  **与其他 ZK 方案的关系**：ERC-7962 使用简单的哈希方式，不是完整代数体系，但足够满足会员身份等场景
    

* * *

## 📚 相关资源

-   **GitHub**：ERC-7962 提案和代码
    
-   **Magic 论坛**：技术讨论和挑战
    
-   **实现案例**：唯一艺术（数字藏品平台）的简化实现
    

* * *

## 🎓 总结

ERC-7962 通过巧妙的哈希机制和账户抽象设计，在**隐私保护**、**用户体验**和**商业可用性**之间找到了平衡点，特别适合：

-   需要隐私保护的会员体系
    
-   Web2 向 Web3 迁移的过渡场景
    
-   企业级应用和批量操作
    

虽然在完全去中心化场景下需要权衡，但在信任商家的前提下，能显著降低普通用户使用区块链技术的门槛。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->










好的，我帮你整理成一版**简洁、可复用的工作总结**（适合发在工作群 / 周报 / 个人复盘里）：

* * *

### 今日工作总结

**1\. 报名 Monad × AI 活动**

-   完成 Monad × AI 相关活动的报名
    
-   明确参与方向，为后续 AI + Web3 项目实践和社区共建做准备
    

**2\. 修改并完善个人网站**

-   对个人网站内容进行更新与调整
    
-   优化个人信息与展示结构，更好地体现技术背景与项目经历
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->











1.  **KOL与BD合作**：
    
    -   **KOL合作**：讨论了与不同层级的KOL（如头部KOL、中部KOL、尾部KOL）的合作策略，强调头部KOL的影响力和粉丝量更为重要。对于项目方来说，选择合作的KOL不仅看粉丝数量，还要考虑他们的质量。
        
    -   **项目方的目标**：项目方不仅仅看KOL的品德和影响力，还看能否借助KOL来增加项目曝光，哪怕某些KOL不完全符合传统的品德标准，仍可能会产生反向效果，引发更多的关注。
        
2.  **KOL与运营工作**：
    
    -   运营的工作不仅是为品牌宣传，KOL的职责往往是展示光鲜的一面，而Web3的运营则需要更多的实操，尤其是项目本身的推广和维护。
        
    -   提到了KOL的不同类型，包括那些专门进行黑暗面曝光的KOL。
        
3.  **Web3的运营挑战**：
    
    -   **流量和内容**：运营人员需要不断与大流量的KOL互动，制造吸引人的内容，并保持高曝光率，这非常消耗精力，且容易陷入流量的恶性循环。
        
    -   **信息过载**：运营人员需要处理的信息量非常大，因此需要有筛选和集中注意力的能力。如何有效地选择对自己项目最有价值的信息是关键。
        
4.  **社群和任务发布**：
    
    -   提到了利用**任务发布平台**来扩展社群活动，通过任务驱动用户增长和活跃度。运营人员可以发布任务让用户执行特定行为（如点赞、评论、转发等），以换取奖励（如空投）。
        
5.  **KOL发展和评估**：
    
    -   讨论了KOL的成长路径，尤其是如何在推特等社交平台上积累粉丝，并通过做内容评测来吸引关注。通过创建有价值的内容，KOL可以获得更多的曝光并逐步积累粉丝。
        
    -   提到了KOL的经济效益和流量如何帮助提升账号权重，从而获取更多推流和曝光。
        
6.  **Web3运营的职业路径**：
    
    -   **跨学科的技能组合**：建议将技术和金融的知识结合起来，这对于从事Web3相关的工作尤其有帮助。对于那些希望进入技术或金融领域的人，能够同时掌握两者将是巨大的优势。
        
    -   提到了如何从零开始进行社群运营，特别是在国内，由于对Web3的敏感性，运营需要谨慎行事，避免过度推广带来麻烦。
        
7.  **Web3项目的推广与挑战**：
    
    -   **项目方的策略**：项目方在进行推广时，不仅仅依靠KOL和流量，也需要关注用户增长的真实性和实际转化。许多Web3项目的目标是通过在交易所上线来获得更多的关注和流量。
        
    -   **从副业到主业**：在Web3领域，许多从事运营的人员将其视为副业，等待积累到一定的粉丝基础和经济正向循环后，再考虑转为主业。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->












AI 及其基础概念分享会

1.  **AI与Web3融合的背景与趋势**：
    
    -   传统的AI，如聊天机器人，已经从简单的对话工具发展为能够执行任务并通过智能合约进行价值交换的“AI打工人”。
        
    -   到2026年，AI将不再只是“嘴替”，而是能够独立完成任务并且从中获利。
        
2.  **Web3与AI的结合**：
    
    -   Web3提供了强大的去中心化基础设施，能够支持AI Agent的操作。区块链的特性（如去中心化、透明性、高TPS、低交易费用）使得它能够处理AI代理之间的大规模交互和交易。
        
    -   区块链技术，特别是如ERC8004身份标准和X402支付协议，解决了AI Agent在Web3世界中的身份验证、支付问题及其经济活动的支持。
        
3.  **AI Agent的应用场景**：
    
    -   AI代理能够执行如自动化任务、数据查询、决策制定等功能，它们不仅仅是一个AI模型，而是通过与区块链结合，能够参与到去中心化的经济活动中。
        
    -   未来，AI代理将成为数字经济中的主体，自动进行交易、决策，甚至在一些环境下代表企业或个人签署合同和执行任务。
        
4.  **AI Agent的核心组件**：
    
    -   **LLM模型**：负责推理和生成指令。
        
    -   **向量数据库**：提供私有记忆和上下文。
        
    -   **API和工具**：让AI执行任务，例如调用外部服务或执行代码。
        
5.  **AI与Web3融合的挑战与解决方案**：
    
    -   **身份与信任**：AI代理的身份、行为需要可验证，区块链通过链上身份和记录保证了不可篡改的审计能力。
        
    -   **支付与结算问题**：传统的支付系统无法处理大量微支付，区块链技术（如X402协议）能够支持快速低费用的微支付。
        
    -   **AI责任与治理**：AI代理能够代为签署合同和做决策，未来需要解决AI行动的责任归属问题。
        
6.  **未来展望**：
    
    -   未来的数字经济将不再是由人类主导，而是由数以亿计的AI代理主导。Web3技术提供了基础设施支持，使得这些AI代理能够在去中心化网络中自主运作和交易。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->













* * *

## **分享会 - Web3 安全**

这是一场围绕 **Web3 安全、职业发展、技术认知与行业判断** 的系统性分享，核心在于：  
**用技术视角理解 Web3 的真实风险与机会，用可验证的方法论构建长期竞争力，而不是追逐短期投机。**

* * *

## 一、钱包安全：Web3 的第一性问题

**核心认知**

-   钱包被盗 ≠ 私钥泄露
    
-   **恶意签名 / 授权** 本身就可能转移资产或埋后门
    

**关键风险点**

-   授权合约可能包含隐藏权限
    
-   签名后的网站代码可能升级为恶意逻辑
    
-   同名代币、假价格展示极易误导用户
    

**实操建议**

-   热钱包（如 MetaMask）只放 **少量 Gas / U**
    
-   授权前使用 **Scam Sniffer** 等插件辅助判断（但不可完全依赖）
    
-   优先使用 **苹果生态设备**，降低被劫持概率
    

👉 本质：**签名 = 授权执行权，不是“确认信息”这么简单**

* * *

## 二、代币与资产识别：只认「合约地址」

**核心原则**

-   代币的唯一身份是 **合约地址（0x…）**
    
-   名称、Logo、价格都可以伪造
    

**DEX 操作铁律**

-   永远核对 Token Address
    
-   优先选择带 `Verified` 标记的代币
    
-   对问号 / 感叹号提示保持高度警惕
    

* * *

## 三、Web3 求职：作品 ≫ 头衔

### 1️⃣ 技术岗

-   GitHub 是第一简历
    
-   开源贡献 > 私有项目
    

### 2️⃣ 运营岗（非常关键）

**正确打开方式**

-   不拼“经验年限”，拼**认知深度**
    
-   用推特做公开作品集
    

**推荐内容方向**

-   拆解热门项目运营活动（Lighter / Oscar 等）
    
-   分析：
    
    -   用户是否精准
        
    -   激励与排名机制是否合理
        
    -   数值设计是否可持续
        
-   新手教程 + 真实参与体验
    

👉 初期 **中文推特更容易获得反馈与流量**

* * *

## 四、BD 与 DevRel：对“复合型能力”的要求

### BD

-   不强制资源，但**有资源是加分项**
    
-   交易所 BD：偏流量
    
-   项目方 BD：偏项目合作 / 集成
    
-   VC 背景资源价值较高
    

### DevRel（高门槛）

需要同时具备：

1.  **文档能力**（对开发者 & AI 友好）
    
2.  **Demo 能力**（前端 / 后端 / 微服务）
    
3.  **社区技术支持**
    
4.  **开发者活动组织能力**
    

👉 本质：**“工程师 + 产品 + 社区”三位一体**

* * *

## 五、Web3 产品经理的本质

-   必须 **同时懂技术 + 懂运营**
    
-   Web3 概念高度抽象，PM 要能“翻译”给用户
    
-   需要长期泡在社区，做一线客服
    
-   只懂技术 → 忽略真实用户需求
    

* * *

## 六、技术与行业判断（高价值部分）

### 稳定币

-   中心化稳定币：公司发行，多链部署需谈判 & 付费
    
-   去中心化稳定币（如 DAI）：
    
    -   依赖超额抵押 + 套利机制
        
    -   最大风险往往是 **经济模型漏洞，而非代码 Bug**
        

### 公链竞争

-   用户注意力有限 → 天然竞争
    
-   新链要成功，**必须比现有方案好 10 倍**
    
    -   更快
        
    -   更隐私
        
    -   新能力（ZK / 新执行模型等）
        
-   先发优势 ≠ 永久垄断（Bybit、Hyperliquid 是例子）
    

👉 评估公链价值，看 **技术创新能力，不看短期收益**

* * *

## 七、工具与方法论

-   **Dune**：链上数据分析（SQL 是核心）
    
-   **RootData**：项目信息聚合
    
-   **Surf AI**：辅助研究与分析
    
-   **IPFS**：理念正确，但稳定性不如中心化云
    

* * *

## 八、个人成长的底层经验

-   好奇心 + 基础功 = 长期复利
    
-   技术理解能反复带来机会
    
-   早期参与、真实贡献、主动推广，比“等机会”更重要
    

* * *

> Web3 不是拼运气的行业，而是一个**奖励长期认知、技术深度和真实贡献**的系统。

* * *
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->














**LXDAO** 是一个去中心化的自治组织（DAO，Decentralized Autonomous Organization），通常用于区块链和加密货币领域。其核心理念是通过区块链技术创建去中心化、无单一控制的组织形式，所有决策和操作由社区成员通过智能合约和代币治理来共同决定。

不过，关于 LXDAO 的具体背景、目标和功能，可能没有公开的详细信息，或它可能是某个特定项目或社区的名称，具体情况需要看其官方网站或白皮书。

### **DAO（去中心化自治组织）概述：**

为了更好理解 LXDAO 的含义，以下是 DAO 的一些基本特征：

1.  **去中心化治理**：
    
    -   DAO 不依赖传统的管理结构，没有单一的中央管理者。所有决策和管理由成员集体决定，通常使用区块链技术来保障透明度和公正性。
        
    -   这种去中心化的治理方式通常通过代币投票进行，代币持有者可以通过投票来决定项目的发展方向、资金的使用、协议的修改等。
        
2.  **智能合约**：
    
    -   DAO 的核心运行依赖智能合约。智能合约是自动执行的合约，不需要第三方中介，确保决策和操作的透明和自动化。
        
    -   例如，LXDAO 的所有决策和资金流动可能都由智能合约自动执行和记录，确保没有人为干预。
        
3.  **去中心化资金管理**：
    
    -   DAO 通常通过一个公共的资金池来管理资金，所有成员可以参与提案和投票决定如何使用这些资金。
        
    -   资金管理完全公开，任何成员都可以查看资金的流动和使用情况。
        
4.  **透明和去信任**：
    
    -   通过区块链技术，DAO 的所有操作都是透明的，可以追踪每一笔资金和每一个决策过程，消除传统组织中的信任问题。
        

### **LXDAO 的应用可能性**

根据 DAO 的基本结构，LXDAO 可能是一个去中心化的组织，以下是它可能的一些应用场景：

-   **去中心化金融（DeFi）平台**：LXDAO 可能是一个去中心化金融协议的治理平台，成员可以共同决定该平台的功能、资产池的配置、风险管理规则等。
    
-   **NFT 项目**：LXDAO 可能是一个去中心化的 NFT（非同质化代币）社区，社区成员可以共同管理和决策 NFT 的发行、交易和收益分配等。
    
-   **开源开发平台**：LXDAO 也可能是一个开源项目的管理平台，开发者可以通过 DAO 进行代码审查、功能提案、项目融资等。
    

### \*\*去中心化自治组织（DAO）\*\*是区块链技术带来的创新之一，旨在通过去中心化的方式管理组织、决策和资源。目前，DAO已经在加密货币、金融、NFT、社区治理等多个领域得到了广泛应用，但也面临着一些挑战和问题。未来，随着技术和治理结构的完善，DAO有望在更多领域发挥重要作用。

### **目前DAO面临的主要问题：**

1️⃣ **治理结构和决策效率问题**

-   **问题**：DAO通常通过社区成员投票来进行决策。然而，这种治理结构可能会存在一些问题，特别是当成员基数庞大时，投票和决策变得十分缓慢和低效。特别是当提案过于复杂或需要快速执行时，去中心化的决策过程可能无法快速做出响应。
    
-   **例如**：某些DAO的治理机制中，投票权往往与代币数量挂钩，这会导致**代币富者的声音更大**，可能会产生“财富集中”的问题，导致治理不公平。
    

2️⃣ **合规性和法律问题**

-   **问题**：DAO由于其去中心化和匿名性，面临着很多法律和合规性问题。例如，在不同司法管辖区，DAO的合法性、税收问题、参与者的责任等都没有明确的法律框架，导致很多DAO可能会面临法律风险，尤其是如果DAO参与到金融活动中。
    
-   **例如**：DAO中的资金池和投票机制可能会被认为是某些形式的证券交易，面临监管机构的审查。
    

3️⃣ **安全性问题**

-   **问题**：DAO依赖智能合约来自动执行规则和决策，如果智能合约代码有漏洞或被恶意攻击，DAO的资产和治理机制可能会被摧毁。例如，2016年的**The DAO攻击事件**，黑客通过利用代码漏洞，盗取了大量资金，最终导致DAO的解散和以太坊硬分叉。
    
-   **挑战**：尽管现代DAO已经引入了多层次的安全措施，但智能合约的安全性依然是DAO面临的一个核心问题。
    

4️⃣ **激励机制问题**

-   **问题**：DAO的运行依赖社区成员的积极参与，而大多数DAO通过代币激励机制来吸引参与者。但是，如何设置合理的奖励机制，既能激励贡献，又能避免过度集中或者恶意行为，依然是一个难题。
    
-   **例如**：某些DAO可能会面临“投机行为”问题，成员参与的动力不完全是为了组织的长期发展，而是为了短期的金融利益，这可能导致社区的健康发展受损。
    

5️⃣ **技术和用户友好性问题**

-   **问题**：大多数DAO平台对于非技术用户而言并不友好，操作复杂且需要较高的学习成本。例如，参与DAO的投票和提案、管理资金池等操作都需要一定的区块链和加密货币知识，这可能限制了DAO的普及。
    
-   **挑战**：DAO平台需要不断改进用户体验，使其更加简便、易用，以便吸引更多的普通用户和社区成员参与。
    

* * *

### **未来DAO的展望：**

1️⃣ **治理结构的改进与优化**

-   **展望**：DAO将不断优化其治理结构，采用更高效、更公平的投票和决策机制。例如，可以通过引入**分层治理**、**代理投票**等机制来优化治理效率，避免代币富者垄断决策权。
    
-   **前景**：使用 **DAO 2.0** 的模型来减少集中化和提高决策效率。随着技术发展，DAO的治理将变得更加**民主化**和**透明化**。
    

2️⃣ **合规性和法律框架的逐步明确**

-   **展望**：随着DAO在区块链和加密货币生态中地位的不断提升，越来越多的国家和地区可能会出台相关法律法规来**明确DAO的合法地位**和操作规范。
    
-   **前景**：随着**区块链技术的成熟**，DAO的法律框架将逐步得到建立，允许其在更广泛的商业和法律环境中运行，从而促进更多传统行业的参与。
    

3️⃣ **更强的安全性和技术保障**

-   **展望**：随着区块链技术和智能合约的不断发展，DAO将采取更多的**安全审计**、**风险控制**措施以防止黑客攻击和系统漏洞。DAO中的资产管理和交易安全性会得到进一步加强，降低智能合约漏洞带来的风险。
    
-   **前景**：**多签名钱包**、**量子加密技术**、**区块链审计工具**等技术将被广泛应用，提升DAO的整体安全性。
    

4️⃣ **激励机制的优化**

-   **展望**：DAO将探索更加多样化的**激励机制**，不仅仅通过代币奖励，还可以通过更多的参与式奖励、声誉奖励等方式吸引更广泛的成员参与。
    
-   **前景**：DAO的激励机制将更加注重**长期价值的创造**，减少**短期投机行为**，增强社区成员的责任感和归属感。
    

5️⃣ **用户友好的平台和工具**

-   **展望**：未来的DAO平台将更加**用户友好**，可以为非技术用户提供简便的操作界面和流程，降低入门门槛。例如，通过集成更多的**Web3工具**（如钱包、浏览器扩展、去中心化应用）和更清晰的UI/UX设计，使用户可以轻松参与DAO。
    
-   **前景**：随着**区块链浏览器**、**去中心化应用**的进一步发展，DAO将能为**普通用户**提供更加便捷和直观的操作界面，使DAO的参与门槛进一步降低。
    

6️⃣ **DAO跨行业的应用**

-   **展望**：DAO不仅限于加密货币和区块链行业，未来将扩展到更多行业，诸如**去中心化金融（DeFi）**、**NFT**、**供应链管理**、**内容创作平台**等。
    
-   **前景**：DAO将成为**跨行业应用**的基础设施之一，甚至有可能取代部分传统的组织形式，推动去中心化的组织文化和价值观普及。
    

* * *

## 资产子托管：如何提高安全性、降低管理私钥的复杂度？

在 **资产子托管**（Asset Sub-Custody）的场景中，提高安全性并降低管理私钥的复杂度是非常关键的。资产子托管通常涉及将客户的数字资产或私钥委托给第三方托管机构管理，因此，如何确保私钥的安全、管理的简便性、以及合规性是核心挑战。

以下是一些 **提高安全性** 和 **降低管理私钥复杂度** 的策略：

### 1\. **多重签名（Multi-Signature）技术**

多重签名是一种有效的安全手段，它要求多个私钥来授权交易。这意味着，即使某一个私钥被泄露或被攻击者获取，攻击者依然无法控制资金。

-   **优势**：
    
    -   **增加安全性**：至少需要多个授权方共同同意才能执行操作，这大大降低了单点故障的风险。
        
    -   **降低单个私钥的风险**：即使某个密钥被泄露，资产仍然不会受到威胁。
        
-   **管理私钥的复杂度**：
    
    -   可以将签名操作分布在不同的设备或人之间，不需要单个管理员控制所有私钥，减少了管理复杂度。
        

例如，采用 **2-of-3 签名** 模式：3个密钥分散在不同的地方，执行交易时需要其中2个签名。

### 2\. **硬件安全模块（HSM）**

硬件安全模块（HSM）是一个用于生成、存储和管理私钥的物理设备，它能防止私钥暴露于外部网络和操作系统，从而提供额外的安全保护。

-   **优势**：
    
    -   **防篡改**：HSM 是专门设计用于抗攻击的硬件设备，极大提高私钥的安全性。
        
    -   **高效管理**：在HSM中，私钥可以进行集中管理和自动化操作，减少手动操作错误。
        
-   **降低管理复杂度**：
    
    -   通过集中化的密钥管理，减少了传统模式下的私钥分发和存储复杂性。
        
    -   HSM 通常可以集成到托管平台的基础设施中，支持 API 接口调用和密钥管理的自动化。
        

### 3\. **密钥分割和冗余存储**

密钥分割技术将一个私钥分割成多个部分，这些部分分布存储在不同的位置或由不同的参与方持有。只有当所有的部分结合在一起时，才能恢复出完整的私钥，从而执行交易。

-   **优势**：
    
    -   **提高安全性**：即使一个存储部分被攻击或丢失，攻击者也无法单独访问资产。
        
    -   **降低单点故障风险**：密钥分散存储确保在任何单一位置发生问题时，资产仍然安全。
        
-   **管理复杂度**：
    
    -   分割后的密钥可以根据不同的安全要求存储在不同的地方，降低了密钥泄露的风险。
        

### 4\. **去中心化托管和智能合约**

去中心化托管通过智能合约和区块链技术实现对私钥和资产的安全管理。智能合约可以自动化执行资产管理操作，并根据预设的规则进行授权。

-   **优势**：
    
    -   **自动化和透明性**：智能合约是自动执行的，减少了人工操作的风险和复杂度，且所有操作都可以在区块链上验证，增强透明度。
        
    -   **避免单点故障**：去中心化的设计避免了传统托管模式中集中化存储私钥的风险。
        
-   **降低管理复杂度**：
    
    -   通过去中心化和智能合约，减少了人工干预和管理流程的复杂性。
        
    -   智能合约可以按照预定规则自动化完成资产的管理和转移，避免人工错误。
        

### 5\. **托管服务平台和钱包服务**

一些托管平台（如 Coinbase Custody、BitGo、Fireblocks 等）提供了专门的 **托管服务**，结合了多重签名、硬件安全模块、以及其他高级安全技术，提供安全的私钥管理和资产托管服务。

-   **优势**：
    
    -   **集成式解决方案**：这些平台已经集成了安全、备份、灾难恢复等多种方案，能够降低复杂性。
        
    -   **合规性和保险**：这些服务通常符合行业规范，并为客户提供保险服务，进一步保障资金安全。
        
-   **降低管理复杂度**：
    
    -   托管服务平台通常提供易用的管理界面和API接口，简化了私钥的管理操作。
        
    -   平台负责私钥的安全管理和备份，大大减少了用户的负担。
        

### 6\. **密钥生命周期管理（KLM）**

密钥生命周期管理涉及对密钥的生成、存储、使用和销毁进行完整管理。通过设定密钥的生命周期规则，避免了私钥的过期或被不当使用的风险。

-   **优势**：
    
    -   **密钥更新和销毁**：定期更换密钥或销毁不再使用的密钥，降低了长期持有密钥带来的安全隐患。
        
    -   **审计和追踪**：可以对私钥的使用进行追踪和审计，增强安全性。
        
-   **降低管理复杂度**：
    
    -   使用自动化工具来定期管理和更新密钥，无需手动操作。
        
    -   通过集中管理和自动化，避免了过多的手动操作和复杂的管理过程。
        

### 7\. **安全多方计算（MPC）**

安全多方计算（MPC）是一种加密技术，允许多个方共同计算某个函数的结果，而不暴露各自的输入。应用于资产子托管时，MPC 可以分布式地生成和管理私钥，而不需要任何单一方持有完整的私钥。

-   **优势**：
    
    -   **增强安全性**：私钥从来不会在任何单个节点上完全暴露，避免了私钥泄露的风险。
        
    -   **去中心化管理**：每个参与方只持有密钥的一部分，无法独立操作资金。
        
-   **降低管理复杂度**：
    
    -   MPC 技术自动分担了私钥管理的复杂性，无需手动管理多个部分。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
















会议主题：以太坊中文周会

主要内容：

1\. AnthurineXiang：

• 讲述了SBF被判刑及其上诉的相关情况。

• 提及了a16zcrypto投资Barbie龙代币和fireblock收购加密会计平台的投资和收购事件。

2\. Qiang：

• 分享了一篇文章的观点，对2025年和2026年的市场进行了预测，认为可能类似于互联网行业的发展阶段，2026年可能是胜者为王的行业主旋律。

• 提到了以太坊协议的发展状况良好以及Clarity法案的关键节点。

3\. DL：

• 讲解了Forstack升级后，皮尔达斯（可能是指某技术或平台）对区块和Blog传播速度的影响。

• 提到了OSL对2025年的回顾以及对20年的Web3展望。  

  
Web3 行业全局介绍 & 岗位概览：

### 1\. **会议开场**

-   主持人 **ETHPanda** 开场并欢迎大家，简单介绍了会议流程。会议的主题是**Web3行业概况及岗位分析**。
    
-   **Emily**（老师）将分享Web3行业的现状、发展趋势、各类岗位的要求和薪酬情况。
    

### 2\. **Web3行业背景**

-   **Web3**已从一个小圈子的理想主义讨论，发展到一个高速增长的行业。根据**Fortune Business Insights**的数据，Web3的年复合增长率接近50%。
    
-   **Web3的三阶段发展**：
    
    -   **2009-2014年**：早期阶段，只有比特币，更多是密码学和去中心化的理想；
        
    -   **2015年起**：智能合约的出现，出现了去中心化金融（DeFi），区块链应用得到初步发展；
        
    -   **2020年起**：行业爆发，各种概念如NFT、DeFi、元宇宙等快速涌现，区块链应用层全面展开。
        

### 3\. **行业变化**

-   **政治和金融环境的变化**：
    
    -   美国总统特朗普当选后，对加密行业支持政策的调整，带来了更多监管松绑。
        
    -   加密资产逐渐成为主流金融资产，传统金融巨头如贝莱德开始关注Web3。
        

### 4\. **Web3行业的就业情况**

-   **市场规模**：
    
    -   当前加密货币总市值为3.1万亿美元，Web3的市场规模约为69.4亿美元，并预计年复合增长接近50%。
        
-   **就业机会**：
    
    -   Web3行业目前依然存在较大的人才缺口，尤其是高级人才需求极大。
        
    -   **技术岗位**（如智能合约开发）薪资较高，**合规岗位**也十分重要，安全审计、法律和合规人才的需求量大。
        
    -   初级岗位的需求相对过剩，但**精英岗位**竞争激烈。
        

### 5\. **岗位要求和技能**

-   **Web3岗位画像**：
    
    -   技术岗（如智能合约开发）、合规法务和产品岗位依然是主要岗位类型。
        
    -   Web3企业往往偏好具有高学历、互联网背景，且具备良好学习能力和热情的候选人。
        
    -   初级岗位可以通过贡献开源代码或在社区活动中积累声誉来获得机会。
        

### 6\. **求职建议**

-   **实战路径**：
    
    -   **从Web2迁移到Web3**：有Web2大厂经验的候选人会受到欢迎，尤其是具有全球视野和较强沟通能力的人员。
        
    -   **生态参与**：通过在Web3项目中贡献代码、写报告或参与治理来积累经验，逐渐建立链上声誉。
        
    -   **建立链上简历**：通过参与社交平台、GitHub、投票记录等方式，增强自己的线上简历。
        

### 7\. **Q&A环节**

-   与会者提问，Emily就Web3的求职路径、岗位要求、薪酬待遇等问题进行了详细解答。
    

### 8\. **总结**

-   Web3行业仍在高速发展中，对技术和合规等专业人才有巨大需求。
    
-   要进入Web3行业，除了具备必要的技能外，**链上声誉和实际项目经验**至关重要。
    
-   最后，Emily强调了Web3行业的机会和挑战，并鼓励大家在合适的领域积累自己的经验和能力，积极参与到行业发展中。
    

这次会议重点介绍了Web3行业的就业趋势、岗位需求及相关技能要求，并给出了一些具体的求职路径和建议。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
