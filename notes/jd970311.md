---
timezone: UTC+8
---

# eyes have light 

**GitHub ID:** jd970311

**Telegram:** @JD185

## Self-introduction

我是web3行业的新人 欢迎大家多多指教

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
今天就学到了可以改owner的方法，简单也简单，用管理员身份去指定下一个管理员，皇帝选皇帝，世袭制，也可以是举贤制，但总的来说，就是管理员权限最大，没有他的支持，当不了下一个管理员。

\`\`\`

// 这是一个很常见的权限管理合约

contract Ownable {

address public owner; // 先定义一个状态亦是，给管理员空间占个茅坑

constructor() {

onwer = msg.sender; // 用构造函数把第一个部署的合约地址赋值给owner

}

modifier onlyOwner() {

require(msg.sender == owner, "not owner"); // 整一个函数修饰器，判断当前调用这个函数的地址是不是管理员，如果是管理员就放行，如果不是，就报错

\_;

}

function setOwner(address \_newOwner) external onlyOwner {

require(\_newOwner != address(0), "invalid address"); // 这是一个用来给管理员指定下一个管理员的函数，但是当前管理员指定的下一个管理员地址不能是0地址，否则会被锁死

owner = \_newOwner; // 把新地址扔给owner

}

function onlyOwnerCatCallThisFunc() external onlyOwner {

// Code 这是只有管理员可以调用的函数

}

function anyOneCanCall() external {

// Code 这是所有人都可以调用的函数，主要是用来测试合约是否可以正常管理权限，我试过了，没问题的

}

}

\`\`\`

智能合约中接收返回值

\`\`\`

contract FunctionOutputs {

// public是为了外部和内部都可以调用，pure纯函数意味着不需要访问状态变量，定义了两种返回类型，这个returns我没有去研究，但猜测是在返回值有两个或以上数量时才会修饰一下，返回的类型就在后面用（）装起来统一定义，跟在数据定义不一样

function returnMany() public pure returns (uint, bool) {

return(1, true);

}

function named() public pure returns (uint x, bool b) {

// 这里可以给返回值弄一个名字，在上面的返回类型里面直接定义

return(1, false);

}

function assigned() public pure returns (uint x, bool b) {

// 这个就直接在里面定义，可以不用return了，我感觉是这样

x = 1;

b = true;

}

function destructingAssigments() public pure {

(uint x, bool b) = returnMany(); // 这就是在函数里面调用其它函数的用法，用（）把需要接收的函数值类型和名称定义好，然后跟变量赋值一样使用

(, bool b) = returnMany(); // 这里是只想接收某一个值，这里只想接收布尔值，这个跟python里面列表切片一样，不想要也需要占个坑，不然会报错，因为返回两个值，只弄了一个值接收，就不知道传那个给它，我猜测是这样

}

}

\`\`\`

solidity里面的数组玩法、以及在内存中如何定义、如何调用返回数组

\`\`\`

contract Array {

uint\[\] public nums = \[1, 2, 3\]; // 给数组赋一个默认值，定义类型就是基础类型后面加个\[\]，其它倒是没什么区别

uint\[3\] public numsFixed = \[4, 5, 6\]; // 定义一个固定数组，与动态数组区别在于类型定义的\[\]里面是否有限定数量

function examples() external {

nums.push(4); // 这个跟git一样，push一下，作用是往原有数组后推入一个新的值，所以这里会把nums变成\[1, 2, 3, 4\]

uint x = nums\[1\]; // 跟其它语言没什么区别，获取数据索引的值，赋值给变量无符号整型x

nums\[2\] = 777; // 跟上面一样，把777赋值给数组索引位置，也就是改操作,这里在会变成\[1, 2, 777, 4\]

delete nums\[1\]; // 我发现solidit这些语言的关键字都会使用一些比较完整的单词，相比较一些简单的语言使用缩写来说，我反而觉得这种形式会更直观一点,但这个删除操作在solidity里面只能把值变成0，不能直接把值真的删除掉，从而改变数组值的数量，所以这里会变成\[1, 0, 777, 4\]

nums.pop(); // 要改变数组数量，就需要用到pop()方法去弹出最后一个值，这里就变成\[1, 0, 777\]

nint len = nums.length; //跟python里面的len()一样

// create array in memory

uint\[\] memory a = new uint\[\](5); // 这里需要用到memory内存关键字，在内存里面定义一个新的数据，但内存中不能使用动态数组，所以需要给这个数组定义一个长度，但这里我不理解的是，为什么不跟前面一样，直接在\[\]里面定义，还需要在\[\]后面再加个()定义长度，真麻烦（噢，这里我明白了，我被这个(5)迷惑住了，这里因为是内存，所以需要在运行时动态获取数组长度，这里其实是type(len)，前面是类型，后面是动态获取到的长度，因为很多时候不知道这个长度是多少，所以不能使用numsFixed，只能是当时获取到多少长度，就用new这个关键字在运行时赋值给数组，uint\[\]是动态数组，就没有限定死长度，大白话就是：用 ‎new T\[\](len) 来在 memory 里分配一个长度为 len 的动态数组

a\[1\] = 123; // 因为只能用固定长度的数组，所以像push()、pop()这些能改变长度的方法就不能使用了，索引和赋值是可以使用的，在内存中局部变量只能够定义定长数组，而动态数组只能够存在于状态变量中

}

// 这个返回类型里面需要输入数组的索引，如果需要数组全部内容，就需要在返回类型的()里面定义一个memory的内存存储类型，这样就可以把数组中的所有元素返回出来

function returnArray() external view returns (uint\[\] memory) {

return nums; // 通过函数来返回数组的全部内容

}

}

\`\`\`
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

-   web3比web2快？我理解其实不会，只是上去了合规审查的部分，出海更方便了。Ricky也委婉表达了这个观点。
    
-   web2 API与web3 agent的区别？应该只是省去了apikey支付的麻烦，以及使得调用、log更透明。有一些有点，但需要基于web生态。当然，一个agent可以同时支持web2调用和web3调用。
    
-   agent身份的问题。目前agent只是在web3中暴露一个API接口，实际代码还是部署在链下。所以身份只是一个API接口的身份，后端的实现可以随时更改。这样可能并不是特别让人信服。应该是把agent实现固定后放在TEE里面，不一定开源，但至少让用户知道是固定的，这样才有身份可言。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->


> 以太坊（Ethereum）是一个去中心化、开源并且具备智能合约功能的公共区块链平台。其核心组件是以太坊虚拟机（Ethereum Virtual Machine，EVM），它是一个图灵完备的虚拟机，能够执行智能合约代码，让区块链不再只是“记账”，而是可以运行各类程序和应用。

## **智能合约（Smart Contracts）**

智能合约是存储在区块链上的程序，由网络节点执行。现在以太坊已从早期的“矿工（PoW）”时代完全过渡到“验证者（PoS）”时代，这些验证者负责打包并执行合约。任何想要执行合约的人，都需要支付 Gas 作为手续费。

**比喻：**

可以把智能合约想象成自动贩卖机：你投入硬币（支付 Gas），选择饮料（调用合约函数），机器就自动出货（执行转账或业务逻辑），无需店员干预。每一笔操作都由分布式节点“自动执行”，并为此收取手续费，而且整个过程是公开可验证、不可随意篡改的。

## **分布式应用程序（dApps）**

以太坊上的分布式应用程序（dApp）部署在区块链上，不依赖单一服务器，也没有传统意义上的 “后台可关机”。只要以太坊网络和客户端软件还活着，dApp就很难被单一主体关停。

**比喻：**

分布式应用就像一间“永不打烊的 24 小时自动商店”。它运行在无数台电脑上，就算某些电脑坏了，其它电脑依然可以继续“营业”；没有哪一个人能按下总电源开关让整个应用消失。

## **代币（Tokens）**

智能合约可以创造代币供分布式应用程序使用，这些代币可以是：

-   可替代的（ERC-20）：例如游戏里的“金币”、治理代币、稳定币等；
    
-   不可替代的（ERC-721 / ERC-1155）：对应独特资产，如艺术品、门票或游戏角色。
    

**比喻：** 可以把代币想成游戏中的“金币”或“点券”，智能合约可以发行这些“金币”，供 dApp 使用。通过代币，玩家（用户）、投资者、管理者的利益被绑定在一起：大家都希望游戏（应用）做得越好、代币越有价值。而在融资场景里，代币还可以像电影上线前的“预售券”，在项目正式推出之前就向早期支持者出售——这就是人们常说的 ICO 或代币发行，只是现在监管和合规要求比早期要严格得多。

## **权益证明（PoS）与早期的工作量证明（PoW）**

以太坊最初采用的是工作量证明（Proof-of-Work, PoW）机制，和比特币类似，由“矿工”通过算力竞争出块；自 2022 年 9 月 15 日的 The Merge 升级起，以太坊**完全改用权益证明（Proof-of-Stake, PoS）**，淘汰了挖矿机制，能耗降低约 99.95%。

**PoW（工作量证明，历史上的以太坊共识）**

-   **机制原理：** 节点（矿工）投入算力“挖矿”，竞争解出复杂数学难题，以获得打包新区块的权利和区块奖励。
    
-   **安全性来源：** 依赖高昂的硬件与电力成本——攻击者要想“51% 攻击”，就必须付出极其巨大的算力和电费。
    

今天，以太坊主网已经不再使用 PoW，但理解 PoW 有助于对比共识机制的差异（例如你也可以顺带对比以太坊与比特币、以太坊与以太坊经典）。

**PoS（权益证明——以太坊当前使用的共识）**

-   **机制原理：** 节点（验证者）需要锁定（质押）一定数量的 ETH （标准门槛为 32 ETH）成为验证者；每个时隙由协议随机选出提议区块的验证者，并由其他验证者投票确认。质押越多、表现越稳定的验证者，长期来看被选中参与记账的频率更高。
    
-   **安全机制：** 恶意行为（例如双签、试图重组链）会触发“削减（slashing）”，验证者的部分或全部质押资产会被销毁或罚没；长时间离线也会逐步被罚没，形成强约束的经济激励，使验证者必须诚实在线地维护网络安全。
    

简单总结就是：**PoW 用电力和硬件“押注诚实”，PoS 用锁定的 ETH 和削减机制“押注诚实”，**而以太坊已经完成从前者向后者的迁移。

## **燃料费（Gas）**

“燃料”（Gas）是对计算与存储资源的计量单位，发送 ETH、转账代币、调用合约函数、部署合约，统统会消耗 Gas。EIP-1559 之后，Gas 费由“基础费（base fee）+小费（priority fee）”组成，其中基础费会被销毁，小费奖励给出块验证者。

**比喻：**

执行合约或转账就像开车：

-   每跑一步、每做一次计算操作都要“烧油”
    
-   ETH 就是你加在油箱里的燃料
    
-   车子开的越复杂、越远（例如复杂 DeFi 操作），耗油就越多
    

## **Proto-Danksharding（EIP-4844）与 Dencun 升级**

Proto-Danksharding （原型丹克分片，EIP-4844）已在 2024 年 3 月 13 日的 **Dencun 升级**中正式上线主网。它是以太坊迈向完整 Danksharding 的中间升级：

-   引入了新的“携带 blob 的交易类型” （blob-carrying transactions），为Rollup 提供临时数据空间；
    
-   这些 blob 数据只在共识层保存一段时间后被丢弃，不进入永久状态，从而极大减轻 L1 的存储压力；
    
-   实际效果是：L2 发布数据的成本大幅下降，很多 Rollup 的交易费用下降了 90% 甚至接近 99%。
    

**比喻：**

想象你开着车（普通以太坊交易），旁边挂着一个“小挂车” （blob 数据）：

-   你把大批货物（Rollup 的批量交易数据）先装到挂车上
    
-   车跑完该跑的路，过一段时间挂车会自动脱落回收，不再长期占用空间
    
-   主车（L1 状态）保持轻量，而 L2 的数据传输成本大幅降低。当前网络对 blob 数量采用保守限制
    
-   Dencun 上线初期每个区块最多约 6 个 blob，目标平均 3 个；随着PeerDAS 等技术部署，预计可逐步提升到每块十几个乃至几十个 blob
    

## **分片与 Danksharding**

基础概念：“分片”本质上是把一个大系统拆成多个“分区”并行处理，从而提升吞吐量。以太坊早期路线图曾设想通过“64 条分片链”来扩容。

**在以太坊中的最新设计：**

-   新路线不再强调“多条执行分片链”，而是转向Danksharding：它更像一种“数据分片（data-sharding）”，核心是引入更多 blob 数据空间，加上数据可用性采样（DAS），让节点只需要随机抽样检查一小部分数据，就能对整个大数据块“有把握”。
    
-   Proto-Danksharding 是迈向完整 Danksharding 的第一步；完整Danksharding 的目标，是在保持去中心化前提下，将每个区块可用的数据空间扩展到几十甚至上百个 blob，具体数值（如 64、128、256 等）仍在研究和参数调优中。
    

可以粗略理解为：**Proto-Danksharding 先给以太坊挂上“小挂车”，而完整Danksharding 则是把挂车扩展成“高速货运列车”，专门为 L2 输送数据。**

## **叔块（Uncle / Ommer Block）**

**叔块在转为权益证明后已停用。**补充一点背景，方便读者理解这一概念的历史位置：

-   在 PoW 时期，以太坊的出块是概率性的，有时会出现几乎同时挖出两个有效区块的情况。主链只会选择其中一个，另一个则成为“叔块” （或称 ommer），为减少因网络延迟对中小矿工的不公平，以太坊会对被包含的叔块给予部分奖励。
    
-   The Merge 之后，以太坊转为 PoS，共识流程完全不同，不再产生新的叔块；相关字段在区块头中基本被置零，仅为兼容历史数据和工具而保留。
    

**比喻：**

想象两个演员同时冲向领奖台，但只有一个能上台领奖；另一个虽然表现不差，只是运气稍差没被选中。主办方为了鼓励大家，给没上台的那位发了个“安慰奖”以示认可——叔块在 PoW 时代扮演的就是这种“安慰奖”角色。在今天的以太坊 PoS 里，这个奖项已经不再颁发，但它仍然是理解以太坊早期设计的重要一环。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/jd970311/images/2026-01-14-1768404142171-image.png)
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



0113 第二章

1\. 身份定义：什么是节点？

节点就是任何一台安装了以太坊软件并连接到网络的电脑。

它是整个网络的细胞，每个节点都在帮整个系统验证数据、同步信息。

2\. 内部结构：一个节点里的“双人小组”

在以太坊“合并”之后，一个完整的节点不再是单打独斗，而是变成了两个角色的搭档：

执行层（执行客户端）： 像是一个干活的书记员，主要负责处理交易、运行智能合约逻辑以及通过以太坊虚拟机（EVM）管理账户的状态。共识层（共识客户端）： 像是一个判决的法官，负专门负责运行权益证明（PoS）机制，通过管理验证者及其投票来确保全网对账本顺序达成一致。

执行客户端和共识客户端通过 Engine API 互相配合。

3\. 记忆能力：不同类型的节点

主要有三种。

全节点：保存所有区块数据并独立验证每一笔交易，是确保以太坊网络去中心化与安全性的核心支撑。

归档节点：在全节点基础上额外保存了自创世以来的所有历史状态快照，能够即时查询过去任意时刻的详细账本数据。

轻节点：仅保存区块头数据而不存储完整账本，依靠向全节点请求并验证证明来在资源受限的设备上运行

4\. 通信方式：节点之间如何“交朋友”与“传八卦”

节点们在网络里通过两种行为互动的：

找邻居： 刚上线的节点会像“加好友”一样，通过一份共享的通讯录找到其他节点。

传八卦（Gossip协议）： 网络里一旦有了新交易，节点们就会像“传八卦”一样，你告诉几个邻居，邻居再告诉他们的邻居，几秒钟内全网就都知道了。

5\. 实际意义：为什么要自己跑一个节点？

自己运行节点最大的好处就是隐私和掌控权。

因为不需要把自己的地址和账户信息暴露给第三方，也不需要求别人告诉你余额是多少，你自己就能验证。

6\. 实践指南：如何拥有自己的节点？

可以根据自己的电脑配置（比如需要多大的固态硬盘和内存）来选择是在家里跑还是租用云服务器。

即使不跑节点，也有一些“借用别人节点”的数据分析方法。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->




参加周会 创建钱包完成转账，铸造第一个nft，晚上参加分享会
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
