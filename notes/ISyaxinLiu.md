---
timezone: UTC+8
---

# ISyaxinLiu

**GitHub ID:** ISyaxinLiu

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
# 搭建区块链（一）

今天完成：

-   项目初始化
    
-   Block（区块）类的创建
    
-   测试驱动开发（TDD）
    
-   创世区块（Genesis Block）的实现
    

## 第一步：安装必要软件

### 1\. 安装 Node.js

-   访问 [nodejs.org](http://nodejs.org)
    
-   下载并安装 LTS 版本（长期支持版）
    
-   安装时保持默认选项即可
    

### 2\. 安装 Git Bash（强烈推荐）

-   访问 [git-scm.com](http://git-scm.com)
    
-   下载 Git for Windows 并安装
    
-   Git Bash 会随 Git 一起安装
    
-   **为什么要用它？** 因为它提供类似Mac/Linux的命令行环境，课程中的命令可以直接使用
    

## 第二步：验证安装

打开 **Git Bash**（安装后在开始菜单可以找到），输入以下命令检查：

bash

```bash
node -v
# 应该显示版本号，比如 v18.x.x

npm -v
# 应该显示版本号，比如 9.x.x
```

## 第三步：创建项目

在 Git Bash 中按顺序执行：

bash

```bash
# 1. 创建项目文件夹
mkdir cryptoChain

# 2. 进入文件夹
cd cryptoChain

# 3. 初始化 Node.js 项目
npm init -y

# 4. 安装测试库 Jest
npm i jest --save-dev
```

## 第四步：验证成功

bash

```bash
# 查看 package.json 文件内容
cat package.json
{
  "name": "cryptochain",           // 项目名称
  "version": "1.0.0",               // 版本号
  "description": "",                // 项目描述（暂时为空）
  "main": "index.js",               // 入口文件
  "scripts": {                      // 可执行的命令
    "test": "..."                   // 测试命令（稍后会修改）
  },
  "keywords": [],                   // 关键词（暂时为空）
  "author": "",                     // 作者（可以填你的名字）
  "license": "ISC",                 // 开源协议
  "type": "commonjs",               // 模块类型
  "devDependencies": {              // 开发依赖
    "jest": "^23.6.0"               // ✅ Jest 已安装！
  }
}
```

### 1\. 区块（Block）的四个核心数据

每个区块包含：

-   **timestamp**（时间戳）- 记录区块创建时间
    
-   **lastHash**（前区块哈希）- 前一个区块的哈希值
    
-   **hash**（当前哈希）- 当前区块的哈希值
    
-   **data**（数据）- 存储的实际内容（交易、信息等）
    

### 2\. JavaScript 类（Class）的基础

-   使用 `class` 关键字定义类
    
-   `constructor` 构造方法 - 创建实例时自动执行
    
-   `this` 关键字 - 指向当前实例
    
-   `new` 关键字 - 创建类的实例
    

### 3\. 编程最佳实践

-   当参数≥3个时，用**对象**包裹参数（而不是单独传参）
    
-   好处：**不用记住参数顺序**，减少错误
    

* * *

## 🛠️ 操作流程

### 第一步：创建 block.js 文件

在项目根目录下创建文件：

bash

```bash
# 在 Git Bash 中，确保你在 cryptoChain 目录
touch block.js
```

或者直接在 VS Code 中右键新建文件。

* * *

### 第二步：编写 Block 类

打开vscode, 在 `block.js` 中写入以下代码：

javascript

```javascript
// 定义 Block 类
class Block {
  // 构造函数 - 用对象包裹参数（最佳实践）
  constructor({ timestamp, lastHash, hash, data }) {
    this.timestamp = timestamp;  // 设置时间戳
    this.lastHash = lastHash;    // 设置前区块哈希
    this.hash = hash;            // 设置当前哈希
    this.data = data;            // 设置数据
  }
}

// 创建一个区块实例（测试用）
const block1 = new Block({
  timestamp: '01/01/01',
  lastHash: 'foo-last-hash',
  hash: 'foo-hash',
  data: 'foo-data'
});

// 打印查看
console.log('block1', block1);
```

* * *

### 第三步：运行测试

在命令行执行：

bash

````bash
node block.js
```

**预期输出：**
```
block1 Block {
  timestamp: '01/01/01',
  lastHash: 'foo-last-hash',
  hash: 'foo-hash',
  data: 'foo-data'
}
````

## 📚 核心知识点

### 1\. 测试驱动开发（TDD - Test Driven Development）

**定义：先写测试，再写代码**

**工作流程：**

```
1. 写测试 → 2. 测试失败（红色❌）→ 3. 写代码 → 4. 测试通过（绿色✅）→ 重复
```

### 2\. TDD 的三大好处

| 好处 | 说明 |
| --- | --- |
| 代码可靠 | 确保新功能不会破坏旧代码 |
| 提高效率 | 不用运行整个项目，只测试特定功能 |
| 学习机会 | 先看测试需求，自己实现代码 |

### 3\. Jest 测试框架的语法

javascript

```javascript
// describe - 定义测试组
describe('Block', () => {
  // it - 定义单个测试
  it('has a timestamp, lastHash, hash and data', () => {
    // expect - 断言/期望
    expect(block.timestamp).toEqual(timestamp);
  });
});
```

* * *

## 🛠️ 操作流程

### 第一步：修改 block.js

**1\. 注释掉测试代码：**

javascript

```javascript
class Block {
  // 先注释掉整个构造函数
  // constructor({ timestamp, lastHash, hash, data }) {
  //   this.timestamp = timestamp;
  //   this.lastHash = lastHash;
  //   this.hash = hash;
  //   this.data = data;
  // }
}

// 删除测试代码（block1 和 console.log）

// 添加导出语句
module.exports = Block;
```

* * *

### 第二步：创建测试文件 block.test.js

**文件命名规则：**`原文件名.test.js`

javascript

```javascript
// 1. 引入 Block 类
const Block = require('./block');

// 2. 定义测试组
describe('Block', () => {
  
  // 3. 声明测试变量
  let timestamp, lastHash, hash, data, block;
  
  // 4. 赋值（注意：相同键值可以简写）
  timestamp = 'a-date';
  lastHash = 'foo-hash';
  hash = 'bar-hash';
  data = ['blockchain', 'data'];
  
  block = new Block({
    timestamp,  // 等同于 timestamp: timestamp
    lastHash,
    hash,
    data
  });
  
  // 5. 编写测试
  it('has a timestamp, lastHash, hash and data', () => {
    expect(block.timestamp).toEqual(timestamp);
    expect(block.lastHash).toEqual(lastHash);
    expect(block.hash).toEqual(hash);
    expect(block.data).toEqual(data);
  });
});
```

* * *

### 第三步：配置 package.json

修改测试脚本：

json  无标题

```json
{
  "scripts": {
    "test": "jest --watchAll"
  }
}
```

`--watchAll` **的作用：**

-   自动监听文件变化
    
-   保存代码后自动重新运行测试
    

* * *

### 第四步：运行测试

在 Git Bash 中执行：

bash

````bash
npm run test
```

**第一次运行：**
```
❌ FAIL  block.test.js
  Block is not defined
```

**修复：** 在 block.test.js 顶部添加 `const Block = require('./block');`

---

### 第五步：逐步让测试通过（TDD 核心）

**1. 第一次运行测试 - 全部失败：**
```
❌ Expected: 'a-date'
   Received: undefined
```

**解决：** 取消 `constructor({ timestamp, lastHash, hash, data })` 的注释

---

**2. 第二次运行 - timestamp 通过：**
```
✅ timestamp 通过
❌ lastHash 失败
```

**解决：** 取消 `this.timestamp = timestamp;` 的注释

---

**3. 第三次运行 - lastHash 通过：**
```
✅ timestamp 通过
✅ lastHash 通过
❌ hash 失败
```

**解决：** 取消 `this.lastHash = lastHash;` 的注释

---

**4. 继续直到全部通过：**
```
✅ timestamp 通过
✅ lastHash 通过
✅ hash 通过
✅ data 通过

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
````

## 📚 核心知识点

### 1\. 什么是创世区块（Genesis Block）？

**问题：区块链的第一个区块怎么办？**

| 普通区块 | 创世区块 |
| --- | --- |
| 需要前一个区块的哈希 | 没有前一个区块！ |
| 数据来自真实交易 | 数据是硬编码的默认值 |
| 动态生成 | 程序启动时就存在 |

**比喻：**

-   创世区块 = 家谱的第一代祖先（没有父母信息）
    
-   普通区块 = 后代（有父母信息）
    

* * *

### 2\. 静态函数（Static Function）

**定义：** 不需要创建实例就能调用的函数

javascript

```javascript
// 普通函数 - 需要 new 创建实例
const block1 = new Block({...});
block1.someMethod();  // 在实例上调用

// 静态函数 - 直接在类上调用
Block.genesis();  // 不需要 new，直接调用
```

**为什么需要静态函数？**

-   创世区块只需要创建一次
    
-   不属于任何特定的区块实例
    
-   是整个区块链的起点
    

* * *

### 3\. SCREAMING\_SNAKE\_CASE 命名规范

javascript

```javascript
const GENESIS_DATA = { ... }  // 全大写 + 下划线
```

**含义：** 一眼就能看出这是**硬编码的全局常量**

| 命名风格 | 用途 | 示例 |
| --- | --- | --- |
| camelCase  驼峰命名法 | 普通变量/函数 | genesisBlock |
| PascalCase  帕斯卡命名法 | 类名 | Block |
| SCREAMING_SNAKE_CASE | 全局常量 | GENESIS_DATA |

* * *

## 🛠️ 操作流程

### 第一步：创建配置文件 config.js

**作用：** 存放全局常量和硬编码值

javascript

```javascript
// config.js
const GENESIS_DATA = {
  timestamp: 1,           // 时间戳设为 1
  lastHash: '-----',      // 前区块哈希（随便设）
  hash: 'hash-one',       // 当前哈希（随便设）
  data: []                // 数据为空数组
};

// 导出（注意是在对象里导出）
module.exports = { GENESIS_DATA };
```

**为什么用对象包裹？**

javascript

```javascript
// 方式1：直接导出
module.exports = GENESIS_DATA;
// 导入时：const GENESIS_DATA = require('./config');

// 方式2：对象包裹（推荐）
module.exports = { GENESIS_DATA };
// 导入时：const { GENESIS_DATA } = require('./config');
// 好处：可以导出多个常量
```

* * *

### 第二步：编写测试 block.test.js

在已有的 `describe('Block')` 里**再嵌套**一个 `describe`：

javascript

```javascript
const Block = require('./block');
const { GENESIS_DATA } = require('./config');  // 新增：导入创世数据

describe('Block', () => {
  
  // 原有测试...
  
  // 新增：创世区块测试组
  describe('genesis()', () => {
    
    // 创建创世区块实例
    const genesisBlock = Block.genesis();
    
    // 测试1：返回的是 Block 实例
    it('returns a Block instance', () => {
      expect(genesisBlock instanceof Block).toBe(true);
    });
    
    // 测试2：数据等于 GENESIS_DATA
    it('returns the genesis data', () => {
      expect(genesisBlock).toEqual(GENESIS_DATA);
    });
  });
});
```

* * *

## 💡 新语法详解

### 1\. 对象解构导入

javascript

```javascript
// config.js 导出
module.exports = { GENESIS_DATA };

// block.test.js 导入
const { GENESIS_DATA } = require('./config');
//      ↑ 解构语法，从对象中提取 GENESIS_DATA
```

**等价于：**

javascript

```javascript
const config = require('./config');
const GENESIS_DATA = config.GENESIS_DATA;
```

* * *

### 2\. instanceof 操作符

**作用：** 检查某个对象是不是某个类的实例

javascript

```javascript
const block = new Block({...});

console.log(block instanceof Block);  // true
console.log(block instanceof Array);  // false
```

**在测试中使用：**

javascript

```javascript
expect(genesisBlock instanceof Block).toBe(true);
//     ↑ 检查是否是 Block 类型        ↑ 期望结果是 true
```

* * *

### 3\. .toBe() vs .toEqual()  
3\. .toBe() 与 .toEqual()

| 方法 | 用途 | 示例 |
| --- | --- | --- |
| .toBe() | 比较基本类型（严格相等） | expect(true).toBe(true) |
| .toEqual() | 比较对象内容 | expect({a:1}).toEqual({a:1}) |

javascript

```javascript
// toBe - 用于布尔值、数字、字符串
expect(5).toBe(5);
expect(true).toBe(true);

// toEqual - 用于对象、数组
expect({name: 'Alice'}).toEqual({name: 'Alice'});
expect([1, 2, 3]).toEqual([1, 2, 3]);
```

* * *

### 4\. 嵌套 describe

javascript

````javascript
describe('外层测试组', () => {
  
  describe('内层测试组1', () => {
    it('测试1', () => {...});
  });
  
  describe('内层测试组2', () => {
    it('测试2', () => {...});
  });
});
```

**输出结果：**
```
Block
  ✓ has timestamp, lastHash, hash and data
  genesis()
    ✓ returns a Block instance
    ✓ returns the genesis data
````

* * *

## 📋 完整文件结构

### config.js（新建）

javascript

```javascript
const GENESIS_DATA = {
  timestamp: 1,
  lastHash: '-----',
  hash: 'hash-one',
  data: []
};

module.exports = { GENESIS_DATA };
```

* * *

### block.test.js（修改）

javascript

```javascript
const Block = require('./block');
const { GENESIS_DATA } = require('./config');  // ← 新增

describe('Block', () => {
  
  // === 原有测试 ===
  let timestamp, lastHash, hash, data, block;
  
  timestamp = 'a-date';
  lastHash = 'foo-hash';
  hash = 'bar-hash';
  data = ['blockchain', 'data'];
  
  block = new Block({
    timestamp,
    lastHash,
    hash,
    data
  });
  
  it('has a timestamp, lastHash, hash and data', () => {
    expect(block.timestamp).toEqual(timestamp);
    expect(block.lastHash).toEqual(lastHash);
    expect(block.hash).toEqual(hash);
    expect(block.data).toEqual(data);
  });
  
  // === 新增测试 ===
  describe('genesis()', () => {
    const genesisBlock = Block.genesis();
    
    it('returns a Block instance', () => {
      expect(genesisBlock instanceof Block).toBe(true);
    });
    
    it('returns the genesis data', () => {
      expect(genesisBlock).toEqual(GENESIS_DATA);
    });
  });
});
```

* * *

### block.js（暂时不改）

保持原样，因为还没写 `genesis()` 函数

* * *

## 🔄 运行测试

bash

````bash
npm run test
```

**预期结果：**
```
❌ FAIL  ./block.test.js
  Block
    ✓ has a timestamp, lastHash, hash and data
    genesis()
      ✗ Block.genesis is not a function
````

**这是正常的！** 因为我们还没写 `Block.genesis()` 函数。

* * *

## 🎯 下节课预告

下节课会实现：

javascript

```javascript
class Block {
  // ...原有代码...
  
  // 新增静态函数
  static genesis() {
    return new Block(GENESIS_DATA);
  }
}
```

## 📚 核心知识点

### 1\. 静态方法（Static Method）

**定义：** 属于类本身，而不属于实例的方法

javascript

```javascript
class Block {
  // 静态方法 - 直接在类上调用
  static genesis() {
    return new Block(GENESIS_DATA);
  }
  
  // 普通方法 - 需要实例才能调用
  someMethod() {
    // ...
  }
}

// 调用方式对比
Block.genesis();              // ✅ 静态方法
const block = new Block({...});
block.someMethod();           // ✅ 普通方法
```

* * *

### 2\. 工厂方法模式（Factory Method Pattern）  
2\. 工厂方法模式

**定义：** 不直接用构造函数，而是用专门的函数来创建实例

javascript

```javascript
// 方式1：直接用构造函数
const block = new Block({
  timestamp: 1,
  lastHash: '-----',
  hash: 'hash-one',
  data: []
});

// 方式2：工厂方法（更优雅）
const block = Block.genesis();
```

**好处：**

-   隐藏创建细节
    
-   代码更简洁
    
-   便于维护（只需改工厂方法）
    

* * *

### 3\. 静态方法中的 this

javascript

```javascript
class Block {
  static genesis() {
    return new Block(GENESIS_DATA);  // ← 可以写成这样
    return new this(GENESIS_DATA);   // ← 也可以写成这样
  }
}
```

**在静态方法中：**

-   `this` = 类本身
    
-   `this` = `Block`
    

* * *

## 🛠️ 操作流程（TDD 让测试通过）

### 第一步：准备工作

**布局窗口：**

-   左侧：命令行（运行 `npm run test`）
    
-   右侧：代码编辑器
    

**Jest 的监听模式：**

-   保存代码 → 自动重新运行测试
    
-   实时看到测试结果
    

* * *

### 第二步：解决第一个错误

**错误信息：**

bash

```bash
❌ Block.genesis is not a function
```

**解决方法：** 在 block.js 中添加静态方法

javascript

```javascript
// block.js
class Block {
  constructor({ timestamp, lastHash, hash, data }) {
    this.timestamp = timestamp;
    this.lastHash = lastHash;
    this.hash = hash;
    this.data = data;
  }
  
  // 新增：静态方法
  static genesis() {
    // 先留空
  }
}

module.exports = Block;
```

**保存后自动测试：**

bash

```bash
❌ Expected: Block instance
   Received: undefined
```

* * *

### 第三步：返回 Block 实例

javascript

```javascript
static genesis() {
  return new Block();  // 返回新实例
}
```

**保存后测试：**

bash

```bash
❌ Cannot destructure 'timestamp' of undefined or null
```

**原因：** 构造函数需要参数，但我们没传！

* * *

### 第四步：导入 GENESIS\_DATA

**在 block.js 顶部添加：**

javascript

```javascript
const { GENESIS_DATA } = require('./config');

class Block {
  // ...
}
```

* * *

### 第五步：使用 GENESIS\_DATA

javascript

```javascript
static genesis() {
  return new Block(GENESIS_DATA);
}
```

**保存后测试：**

bash

```bash
✅ PASS  block.test.js
  Block
    ✓ has timestamp, lastHash, hash and data
    genesis()
      ✓ returns a Block instance
      ✓ returns the genesis data
```

**全部通过！🎉**

* * *

### 第六步：优化代码（可选）

**将** `Block` **改为** `this`**：**

javascript

```javascript
static genesis() {
  return new this(GENESIS_DATA);  // this = Block
}
```

**测试依然通过！**

* * *

### 第七步：调试验证

**临时添加 console.log：**

javascript

````javascript
// block.test.js
describe('genesis()', () => {
  const genesisBlock = Block.genesis();
  
  console.log('genesisBlock', genesisBlock);  // ← 临时添加
  
  it('returns a Block instance', () => {
    expect(genesisBlock instanceof Block).toBe(true);
  });
  
  // ...
});
```

**命令行输出：**
```
genesisBlock Block {
  timestamp: 1,
  lastHash: '-----',
  hash: 'hash-one',
  data: []
}
````

**验证完后删除 console.log**
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->

以太坊网络本质是一个 **没有中央管理员、全球所有人共同维护的公开账本**（记录所有以太坊交易和数据），但这个账本有一套严格的 “记账规矩”（比如：怎么算一笔交易有效、怎么更新账本、怎么防造假）。**客户端软件**，就是把这些 “记账规矩” 翻译成电脑能看懂的程序，相当于给你的电脑装了一套 \*\*「合规记账工具 + 验真助手」\*\*它的核心工作：

1.  **按规矩验真假**：别人发来新的账本页（区块链里的「区块」），它会检查这笔账是不是符合规则，防止有人篡改数据；
    
2.  **同步账本信息**：把你的电脑账本，和全球其他电脑的账本对齐，保证大家的账本一模一样；
    
3.  **守护网络安全**：如果发现有人提交假账本，它会拒绝接收，不让造假信息混入全网。
    

简单说：**客户端是让电脑 “懂以太坊规则” 的软件，没有它，电脑根本不知道怎么和以太坊网络打交道。**

### 再搞懂：节点 = 以太坊网络的「联网成员」

**节点**，就是 **“装了客户端软件，并且连上网、和其他同类电脑互通的设备”**（电脑、服务器都算）。

举个实际例子，比如常见的以太坊客户端有 **Geth、Besu** 这两款（相当于不同品牌的 “记账工具”，但都遵守同一套规矩）。你在自己的笔记本上装了 Geth，打开软件后，它会自动连接到全球其他装了 Geth/Besu 的电脑，这时 **你的笔记本就变成了一个以太坊节点**，可以和全网一起同步账本、验证交易了。

执行客户端（EL）就是 “干活的”，共识客户端（CL）是 “定规矩 / 验对错的”。简单说：**执行客户端就是以太坊的 “实际办事员”，所有和 “具体交易、合约运行、数据存储” 相关的活，都是它干的**。Geth、Nethermind 这些，就是不同公司做的 “执行客户端套装”—— 就像格力、美的都做空调，功能都是制冷，但品牌 / 实现方式不同，都符合以太坊的 “办事规矩”。既然 EL 是 “干活的”，那得有人监督它干得对不对、决定该干哪份活，这就是共识客户端（CL）的事（相当于工厂的 “质检部 + 决策委员会”）；如果想赚质押收益（相当于给工厂当 “特邀质检员”），就需要验证者客户端 —— 它是挂在 CL 上的 “插件”，你质押 ETH 当押金，帮 CL 投票决策，干得好就拿收益。

以太坊节点的「搭积木结构」你的钱包/DApp（比如MetaMask、Uniswap）

↓ （想查余额/转ETH/用合约）

调用执行客户端（EL）的JSON-RPC接口 → 相当于“当事人找书记员办事”

↓ （执行客户端干活：处理交易、更新账户余额、运行智能合约）

执行客户端把处理好的“交易结果”交给共识客户端（CL） → 相当于“书记员把案卷交给审判长”

↓ （共识客户端决策：组织验证者投票）

共识客户端指挥验证者 → 提议区块+投票 → 确认这个区块合法

↓ （同步给全网）

执行客户端+共识客户端，各自通过自己的P2P网络 → 把结果同步给其他节点 → 相当于“法院把判决书发往全国”

## 为啥需要 Engine API？

合并前，执行客户端和共识客户端是 **“同一个软件里的两个模块”** —— 就像书记员和审判长在**同一个办公室**，一抬头就能说话，不用额外工具。合并后，它们变成了 **“两个完全独立的程序”** —— 相当于书记员和审判长被分到了**两个不同的楼层**，没法直接喊对方，也不能用法院对外的公开电话（比如给当事人用的查询电话），否则会泄露内部信息。这时候，就需要一根 **“内部专属专线电话”** —— 这就是 **Engine API**。它的唯一作用：**只让执行客户端（EL）和共识客户端（CL）之间秘密沟通，不对外公开**。它就是合并后以太坊节点的 **“内部沟通桥梁”** —— 让 “干活的书记员（EL）” 和 “拍板的审判长（CL）” 能高效、安全地配合，既不会耽误事，也不会泄露内部处理细节。

### 关键区别：Engine API ≠ 对外的 JSON-RPC 接口

很多人会混淆这两个接口，用法院的电话系统就能分清：

| 接口类型 | 相当于法院的什么电话 | 给谁用 | 用途 |
| --- | --- | --- | --- |
| Engine API | 书记员 ↔ 审判长的 内部专线 | 仅 EL 和 CL 之间 | 传递区块骨架、执行结果、合法性校验 |
| 执行客户端的 JSON-RPC 接口 | 法院对外的 服务大厅查询电话 | 钱包（MetaMask）、DApp（Uniswap）、普通 | 查账户余额、发起转账、调用智能合约 |

# 节点通信的 “社交流程”

以太坊节点就像一个个 **“社恐但必须社交的打工人”**，刚入职（启动）时谁都不认识，得先 **找到靠谱同事（节点）→ 拉上安全的私聊通道 → 再八卦传消息**。我们重点讲前两步。

## 第一步：节点发现（UDP + Kademlia）= 新人找同事，快速拓展人脉

### 1.1 Discovery 协议（Ping/Pong/FindNode/Neighbors）= 找同事的 4 句 “社交黑话”  
1.1 发现协议（Ping/Pong/FindNode/Neighbors）= 找同事的四句“社交黑话”

这四个指令就是节点之间 “打招呼、要联系方式” 的固定话术，我们对应到新人入职场景：

| 协议指令 | 新人入职大白话 | 实际作用 |
| --- | --- | --- |
| Ping  品 | 新人给老员工发微信：“在吗？” | 新节点给引导节点发消息，确认对方是否在线 |
| Pong | 老员工回：“在呢！” | 引导节点回复，证明自己在线，同时附带自己的 “身份 ID” |
| FindNode | 新人接着问：“能不能给我点其他同事的微信呀？” | 新节点向引导节点请求 “活跃邻居节点的联系方式” |
| Neighbors/Nodes  邻居/节点 | 老员工甩来一个微信群：“这里都是活跃同事，加吧！” | 引导节点返回一批相邻节点的地址，帮新节点扩充 “好友列表” |

**关键操作**：新节点拿到这批邻居地址后，会 **重复上述 4 步** —— 给新邻居发 Ping/Pong、要更多联系方式，直到好友列表塞满（达到预设上限）。

### 1.2 Kademlia（DHT 分布式哈希表）= 高效找同事的 “智能通讯录”

你可以把 Kademlia 理解为节点的 **“智能人脉管理工具”**，核心解决 “怎么快速找到目标节点” 的问题，类比成 **“快递分拨中心”** 更直观：

| Kademlia 规则 | 快递分拨中心大白话 | 节点实际操作 |
| --- | --- | --- |
| 每个节点有唯一 256bit ID | 每个快递分拨中心有唯一编号（比如 A001、A002、B001） | 节点的 ID 是一串唯一代码，相当于 “网络身份证” |
| 用 XOR 算 “距离”（不是地理距离） | 距离 = 编号的相似程度：A001 和 A002 距离近，A001 和 B001 距离远 | 节点不看物理位置，只看 ID 的相似性，相似 ID 就是 “近邻” |
| 找节点时 “逐级转发” | 想寄快递到 A100，先发给 A001→A001 转给更近的 A050→A050 转给 A100 | 节点找目标时，只把请求发给 “离目标 ID 更近的邻居”，不用全网广播，效率超高 |

**小结第一步**：新节点靠 UDP 发短信（Ping/Pong）确认在线，用 FindNode 要通讯录，再靠 Kademlia 这个智能工具快速拓展人脉，填满好友列表。

## 第二步：建立安全连接（TCP + RLPx/devp2p）= 拉上加密的 “私聊专线”

找到靠谱邻居后，不能再用短信（UDP）传重要数据了 —— 短信容易丢、容易被偷看，节点之间要传 **交易、区块** 这种核心信息，得用更靠谱的方式。

### 2.1 TCP = 从 “发短信” 升级到 “打电话”

TCP 协议相当于 **“手机通话”**，和 UDP（短信）的核心区别：

| UDP（短信） | TCP（通话） |
| --- | --- |
| 快，发完就走，不管对方收没收到 | 稳定，先确认对方能接，再传数据，丢包了会重发 |
| 适合 “打招呼、要地址” | 适合传 “交易、区块” 这种重要内容 |

节点之间用 TCP 建立连接，就像打一通 **“保证能接通、能听清”** 的电话，为后续传数据铺好稳定的管道。

### 2.2 RLPx/devp2p = 给通话加密，还能 “开多线私聊”

RLPx 是跑在 TCP 之上的 “安全工具”，devp2p 是以太坊的 P2P 协议栈，合在一起就是 **“加密的多任务通话线”**，拆成两个核心功能讲：

功能 1：加密会话 = 给电话加 “防窃听装置”

节点建立 TCP 连接后，第一步会 **交换密钥**，相当于给通话装了加密器 —— 第三方就算截获了数据，也看不懂内容，保证交易、区块不被篡改、不被偷看。

功能 2：多路复用 = 一条电话线，同时聊好几件事

这是 RLPx 最核心的操作，类比成 **“视频会议的分屏功能”**：

> 你和同事拉了一条视频会议线（TCP 连接），这条线不用拆，就能同时开 3 个小窗口：
> 
> 1.  窗口 1：传工作文件（同步区块）
>     
> 2.  窗口 2：发即时消息（传播交易）
>     
> 3.  窗口 3：请示工作（轻客户端请求数据）
>     

对应到以太坊节点：

-   一条 TCP 加密通道，通过 RLPx 同时跑多种子协议（比如 `eth/66` 同步区块、`les` 服务轻节点）；
    
-   不用为每种任务单独拉一条连接，节省资源，通信效率直接拉满。
    

**小结第二步**：节点用 TCP 搭好稳定管道，再用 RLPx 给管道加密 + 开 “分机”，实现安全高效的多任务通信。

* * *

## 最终总结：节点通信的两步走

| 步骤 | 技术组合 | 生活化类比 | 核心目的 |
| --- | --- | --- | --- |
| 1. 找邻居 | UDP + Kademlia | 新人发微信找同事，用智能通讯录拓展人脉 | 快速填满 “好友列表”，找到靠谱的通信对象 |
| 2. 建专线 | TCP + RLPx/devp2p | 和同事拉加密视频会议，一条线聊多件事 | 安全、稳定地传输交易、区块等核心数据 |

简单说：**UDP 负责 “打招呼找朋友”，TCP 负责 “正经聊正事”，RLPx 负责 “把正事聊得安全又高效”**。

## 一、Gossip 协议：办公室八卦的 “病毒式扩散”

把 **新交易 / 新区块** 比作 **办公室的一条劲爆八卦**（比如 “小王要升职了”），把 **节点** 比作 **同事**，传播过程分 4 步，和现实中传八卦一模一样：

| 以太坊节点操作 | 办公室八卦大白话 | 核心逻辑 |
| --- | --- | --- |
| 1. 某节点收到新交易 / 区块 | 1. 前台小姐姐先听到 “小王升职” 的八卦 | 消息总有第一个 “知情者”（比如刚发起转账的钱包节点、刚打包区块的验证者节点） |
| 2. 它随机挑几个没听过这个消息的邻居节点转发 | 2. 前台小姐姐赶紧偷偷告诉座位附近的 3 个同事：“我跟你说个事，别告诉别人啊！”（只挑没听过的人说，避免重复） | 不群发、不广播，只给 “不知情的人” 传，节省资源 |
| 3. 这些邻居节点收到后，再各自挑自己的不知情邻居转发 | 3. 这 3 个同事又转头告诉自己的好朋友：“我听说小王要升职了！” | 一传十、十传百，每一轮都让消息覆盖更多人 |
| 4. 几轮后，全网几乎所有节点都收到消息 | 4. 半天不到，全公司上百号人都知道 “小王升职” 了 | 不用中心指挥，消息自己就能铺满整个网络 |

### Gossip 协议的 3 个核心优点（对应八卦传播的优点）

| 技术优点 | 八卦传播的对应好处 |
| --- | --- |
| 完全去中心化，不用中心服务器 | 不用等领导开会通知，同事私下传就能让所有人知道 |
| 鲁棒性好（局部故障不影响全局） | 就算某几个同事请假了（节点离线），还有其他同事传，八卦照样能传遍公司 |
| 传播速度超快（几秒传遍全网） | 办公室八卦的传播速度，比发公司邮件快 10 倍 |

### 补充：执行层和共识层的 “八卦圈是分开的”

以太坊的执行层（EL）和共识层（CL）有各自的 P2P 网络，就像办公室里 **“业务部八卦圈” 和 “人事部八卦圈”** 互不干扰：

-   **执行层 Gossip**：传的是 **交易、普通区块**（比如 “张三转 ETH 给李四” 这种业务消息），用的是 devp2p 协议里的 eth/\* 子协议；
    
-   **共识层 Gossip**：传的是 **信标块、投票信息**（比如 “审判长选了哪个区块合法” 这种决策消息），用的是共识客户端自己的 gossip 协议。
    

* * *

## 二、请求 / 响应模式：主动 “追问八卦”，查漏补缺

光靠 “别人传八卦” 不够 —— 有时候你可能漏掉了某个消息（比如上班摸鱼没听到），这时候就需要 **主动去问**，这就是以太坊的第二种消息传播模式：**请求 / 响应**。

继续用办公室类比：

| 以太坊节点操作 | 办公室大白话 | 核心作用 |
| --- | --- | --- |
| 1. 节点发现自己缺了某个区块 / 交易 | 1. 你上班摸鱼，没听到 “小王升职” 的八卦，只听到大家在讨论，却不知道具体情况 | 节点同步数据时，发现自己的账本少了几页，或者漏了某笔交易 |
| 2. 它向邻居节点发送 “请求”：“请把 XX 区块发给我” | 2. 你主动去问同事：“他们说的小王升职是咋回事啊？快跟我讲讲！” | 节点主动向邻居索要自己缺失的数据 |
| 3. 邻居节点收到请求后，给它 “响应”：把对应的区块 / 交易发过去 | 3. 同事把八卦的来龙去脉详细讲给你听 | 邻居节点把缺失的数据传给它，帮它补全账本 |

### 两种模式的配合：八卦扩散 + 主动追问 = 全网数据一致

Gossip 协议负责 **“主动扩散新消息”**，保证新交易 / 区块快速传遍全网；

请求 / 响应模式负责 **“被动查漏补缺”**，解决个别节点漏听、漏收的问题。

两者结合，就能让以太坊成千上万的节点，都保持一模一样的账本。

* * *

## 最终总结

以太坊节点传消息，就像办公室传八卦：

-   **Gossip 协议** = 同事主动口口相传，几秒让消息铺满全网；
    
-   **请求 / 响应** = 没听到八卦的人主动追问，补全自己的信息；
    
-   执行层和共识层各有各的 “八卦圈”，互不干扰，各司其职。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



## **Web3的核心运作原理**

### **1\. 区块链：去中心化的账本**

区块链是Web3的基础设施，可以把它想象成一个"全民公开的记账本"：

传统银行转账时，银行的服务器记录"你给张三转了100元"。如果银行服务器出问题或者银行耍赖，你的记录可能就没了。

而区块链是这样运作的：全世界成千上万台电脑（叫"节点"）都保存着同一份账本。当你要转账时，这笔交易会被广播到所有节点，大家一起验证这笔交易是否合法（你账户里确实有这么多钱），验证通过后，所有人同时更新账本。这样一来，没有任何一个中心机构能篡改记录，因为要篡改就得同时控制全球51%以上的节点，这几乎不可能。

### **2\. 智能合约：自动执行的协议**

智能合约是部署在区块链上的程序，它的特点是"代码即法律"——一旦部署，任何人都无法修改，它会严格按照预设规则自动执行。举个例子：你和朋友打赌明天会不会下雨，赌注100元。传统方式需要找个中间人保管钱，但你们可能不信任他。用智能合约的话：你们各自把100元锁进合约，合约会自动从天气数据源获取明天的天气信息，然后自动把200元转给赢的人。整个过程透明、自动、不可篡改，不需要信任任何人。

### **3\. 钱包：你的数字身份**

在Web3世界里，钱包不只是存钱的工具，它是你的数字身份。

每个钱包有一对密钥：

-   **公钥**（像你的银行账号）可以公开，别人用它给你转账
    
-   **私钥**（像你的密码）必须保密，用它来证明你是钱包的主人
    

重要的是：**私钥就是一切**。谁掌握私钥，谁就拥有钱包里的资产。没有"找回密码"这个选项，丢了私钥就永远丢了。

### **4\. 共识机制：如何达成一致**

既然没有中心化的权威，这么多节点怎么就一笔交易达成共识呢？

**工作量证明（PoW）**：就像比特币用的方式。矿工们竞相解一道超级复杂的数学题，谁先解出来，谁就有权记录这一批交易，并获得奖励。这需要消耗大量电力。

**权益证明（PoS）**：比如以太坊现在用的。节点需要"质押"一定数量的代币，然后系统随机选择节点来验证交易。如果作恶会损失质押的代币，这样确保诚实。这种方式更节能。

## **Web3的实际运作流程举例**

假设你要在一个去中心化交易所（DEX）上用以太坊换USDC：

1.  **连接钱包**：你用MetaMask等钱包连接到DEX网站
    
2.  **授权交互**：钱包会弹窗让你签名授权，证明这个操作确实是你发起的
    
3.  **提交交易**：你设定要换多少，DEX的智能合约会计算兑换比例
    
4.  **支付Gas费**：你需要支付一笔"燃料费"给矿工/验证者，让他们把你的交易打包到区块链上
    
5.  **广播和验证**：交易被广播到网络，节点们验证合法性
    
6.  **打包入块**：交易被打包进新的区块，连接到区块链上
    
7.  **完成确认**：等待几个区块确认后，交易不可逆转，你的钱包里就收到了USDC
    

这整个过程可能需要几秒到几分钟，取决于网络拥堵程度和你愿意支付的Gas费。

## **为什么工作量证明（PoW）耗能巨大？**

### **1\. 挖矿竞赛的本质**

以比特币为例，它用的就是PoW机制。运作方式是这样的：想象一个场景：每10分钟要从全球矿工中选出一个"记账员"，让他有权记录这段时间的所有交易，并获得奖励（新产生的比特币+手续费）。

\*\*选择方式是什么呢？\*\*比拼谁先解出一道超级复杂的数学题。这道题没有巧妙解法，**只能靠暴力穷举**——就是不停地猜测、计算、验证，直到碰对答案。就像你要从1万亿个箱子里找到唯一装着钥匙的那个，只能一个个打开试。

### **2\. 全球矿工同时竞争**

关键在于：**全世界所有矿工都在同时拼命计算，但最终只有一个人能赢**。

比特币全网每秒进行约**600,000,000,000,000,000次**（60亿亿次）哈希计算。想象一下，全球几百万台专业矿机，7×24小时不停地高速运转，只为了每10分钟那一次中奖机会。那些没中奖的矿工，他们的所有计算都**白费了**——这就是能源浪费的根源。

### **3\. 为什么要设计得这么"浪费"？**

这不是bug，而是feature（特性）！这种"浪费"恰恰是安全性的来源：**防止攻击的成本**：如果你想篡改区块链记录，就需要控制全网51%以上的算力。以比特币为例，这意味着你要：

-   购买全球一半以上的矿机（几百亿美元）
    
-   支付巨额电费持续运行
    
-   即使攻击成功，比特币信誉崩塌，你的投入也血本无归
    

**用物理世界的资源（电力）保护数字世界的安全**——这就是PoW的逻辑。

### **4\. 耗能到底有多大？**

比特币网络年耗电量约**150-200太瓦时**，相当于：

-   荷兰或阿根廷全国一年的用电量
    
-   约占全球总用电量的0.5-0.7%
    

以太坊在2022年9月之前也用PoW，耗电量约为比特币的一半。

## **为什么权益证明（PoS）节能？**

### \*\*完全不同的逻辑：\*\*PoS不是比拼算力，而是比拼"质押的代币数量"。

**运作方式**：

1.  想当验证者？先锁定一定数量的代币（比如以太坊需要32个ETH，约10万美元）
    
2.  系统随机或按权重选择验证者来打包交易
    
3.  如果你诚实工作，获得奖励；如果作恶，质押的代币会被罚没（Slashing）
    

**为什么节能？**

验证一个区块只需要：

-   运行验证软件（一台普通电脑就够）
    
-   检查交易合法性（几秒钟的计算）
    
-   数字签名（密码学运算，几乎不耗能）
    

**没有任何"竞赛式计算"**，不需要成千上万台机器同时拼算力。

### **节能效果有多显著？**

以太坊从PoW转为PoS后（"The Merge"升级）：

-   **能耗下降了99.95%**
    
-   从原来的荷兰级别降到一个小镇的用电量
    
-   每笔交易的碳排放从20kg降到0.01kg
    

## **一、去中心化金融（DeFi）是什么？**

DeFi = Decentralized Finance（去中心化金融）  
DeFi = 去中心化金融

传统金融做什么事都要通过银行、券商、交易所这些机构，**DeFi就是把这些金融服务搬到区块链上，用智能合约代替银行职员**。

**对比理解**：

-   传统：你去银行存钱→银行员工审核→存入你的账户→银行用你的钱放贷赚利息→分你一点利息
    
-   DeFi：你直接把钱放进智能合约→合约自动匹配借款人→利息自动分给你，没有中间商
    

* * *

## **二、Uniswap（去中心化交易所）**

### **传统交易所 vs 去中心化交易所（DEX）**

**传统交易所**（比如币安、Coinbase）：

-   你要先把钱充值到交易所账户（把钱给他们保管）
    
-   交易所撮合买卖双方
    
-   你的资产实际上在交易所手里，你只是看到"余额"
    

**DEX（Decentralized Exchange）**：  
去中心化交易所（DEX）：

-   你的钱始终在自己钱包里，不需要充值到平台
    
-   直接用钱包连接网站，点几下就能交易
    
-   交易完成后，新币直接到你钱包，全程你掌控资产
    

### **AMM（自动做市商）是什么？**

AMM = Automated Market Maker（自动做市商）

**传统撮合机制**（像股票交易）：

-   买家挂单：“我要1000元买1个ETH”
    
-   卖家挂单：“我要1100元卖1个ETH”
    
-   需要买卖双方价格匹配才能成交
    

**AMM机制**（Uniswap用的）：

-   不需要买卖双方匹配
    
-   而是建一个"流动性池子"，里面放着大量的ETH和USDC
    
-   你想买ETH？直接从池子里拿ETH，把USDC放进去
    
-   价格由一个数学公式自动计算（简化版：池子里ETH越少，价格越贵）
    

**打个比方**：

-   传统交易所像"菜市场"：买菜的和卖菜的讨价还价
    
-   Uniswap像"自动售货机"：你投币，机器立刻给你商品，价格是固定公式算出来的
    

* * *

## **三、Aave（借贷协议）**

### **传统借贷 vs DeFi借贷**

**传统银行借贷**：

1.  你去银行申请贷款
    
2.  银行查你征信、审核材料
    
3.  可能等几天或几周
    
4.  批准后钱打到你账户
    
5.  按月还款，逾期会催收
    

**Aave这样的DeFi借贷**：

1.  你在Aave抵押10个ETH（假设价值3万美元）
    
2.  立刻借出价值2万美元的USDC（只能借抵押物价值的一定比例，比如70%）
    
3.  不需要审核、不需要征信、几分钟完成
    
4.  利息实时计算（可能年化3-8%，随市场变化）
    
5.  什么时候还都行，但如果ETH价格暴跌，你的抵押物不够了，会被自动清算（系统卖掉你的ETH还债）
    

### **TVL是什么？**

TVL = Total Value Locked（锁仓总价值）  
TVL = 总锁仓价值

就是**有多少钱放在这个协议里**。

比如Aave的TVL是100亿美元，意味着全球用户在Aave里存了100亿美元的各种加密资产。TVL越高，说明协议越受信任、规模越大。

**类比**：就像银行说"我们管理的资产规模是1000亿"，TVL是DeFi协议的"资产规模"。

* * *

## **四、MakerDAO 和 DAI稳定币**

### **什么是稳定币？**

加密货币价格波动太大（ETH今天3000美元，明天可能2500美元），没法当"钱"用。

**稳定币**就是锚定法定货币的加密货币，比如：

-   1 USDT ≈ 1美元
    
-   1 DAI ≈ 1美元
    

### **两种稳定币类型**

**1\. 中心化稳定币（USDT、USDC）**：

-   像Tether公司发行USDT，他们说"我们银行账户里有10亿美元，所以发行10亿个USDT"
    
-   你要相信这个公司真的有这么多钱
    
-   他们可以冻结你的USDT
    

**2\. 去中心化稳定币（DAI）**：

-   MakerDAO用智能合约发行DAI
    
-   你抵押1.5万美元的ETH，可以铸造1万个DAI
    
-   如果ETH跌价，系统会自动卖掉你的ETH，保证DAI价值稳定
    
-   没有公司能冻结你的DAI
    

**打个比方**：

-   USDT像"人民币兑换券"：银行说可以1:1换人民币，你要信银行
    
-   DAI像"黄金兑换券"：后面真的锁着黄金在金库里，智能合约自动管理
    

* * *

## **五、Lido 和 EigenLayer（质押相关）**

### **什么是质押（Staking）？**

还记得我之前讲的PoS共识机制吗？以太坊现在用的就是PoS。

**质押**就是：你把32个ETH锁进以太坊网络，成为验证者，帮忙验证交易，然后赚取奖励（年化大概3-5%）。

**问题**：

-   需要整整32个ETH（约10万美元），普通人没这么多钱
    
-   ETH被锁住了，不能卖、不能用，失去了流动性
    

### **Lido解决了什么问题？**

Lido提供**流动性质押**：

1.  你只有1个ETH？没关系，存到Lido
    
2.  Lido把大家的ETH凑一起，达到32个就帮你们去质押
    
3.  同时给你1个**stETH**（质押凭证）
    
4.  stETH可以自由交易、可以在其他DeFi协议里用
    
5.  你既赚到质押奖励，又保留了流动性
    

**类比**：

-   传统质押像"定期存款"：钱锁死了，到期才能取
    
-   Lido像"活期存款"：一样赚利息,但随时能用
    

### **EigenLayer 再质押是什么？**

**再质押（Restaking）** = 一份资产多重使用

1.  你在Lido质押ETH，得到stETH，赚取3%年化
    
2.  你把stETH再存到EigenLayer  你将 stETH 重新存入 EigenLayer
    
3.  EigenLayer用你的stETH为其他区块链项目提供安全保障
    
4.  你额外再赚一层奖励（可能再加2%年化）
    
5.  总收益可能达到5%，但风险也更高（两层都可能被罚）
    

**类比**：

-   传统质押：你把钱存银行赚利息
    
-   再质押：你用银行存款证明做抵押，再去贷款投资，赚双份收益（但也有双倍风险）
    

* * *

## **六、RWA（现实世界资产上链）**

RWA = Real-World Assets（现实世界资产）  
RWA = 现实世界资产

### **这是什么意思？**

把现实世界的资产（房产、国债、黄金、公司股权等）**代币化**，在区块链上交易。

**传统方式买美国国债**：

1.  需要开美股账户
    
2.  可能需要几千美元起步
    
3.  交易时间受限（美股开盘时间）
    
4.  可能要几天结算
    

**RWA方式买代币化国债**：

1.  用加密钱包就能买
    
2.  10美元也能买
    
3.  24/7随时交易
    
4.  几分钟结算
    

### **BlackRock（贝莱德）为什么做这个？**

BlackRock是全球最大资产管理公司（管理10万亿美元）。

他们发行的**BUIDL基金**：

-   投资美国国债和现金
    
-   代币化放在区块链上
    
-   每个代币值1美元，每天分红
    
-   普通人用加密钱包就能买"美国国债"
    

**意义**：

-   传统金融巨头进入Web3，说明这个行业在成熟
    
-   普通人能轻松投资以前门槛很高的资产
    
-   资产可以24小时交易、全球流通
    

**类比**：就像支付宝的余额宝把货币基金普及给普通人，RWA把各种传统金融资产普及给全球有网络的人。

* * *

## **总结：这些协议在干什么？**

| 协议 | 传统金融对应 | 普通人能干什么 |
| --- | --- | --- |
| Uniswap | 交易所 | 随时兑换各种代币，不需要开户 |
| Aave | 银行借贷 | 存币赚利息，或抵押借贷，秒到账 |
| MakerDAO/DAI | 稳定币发行商 | 用DAI在链上支付、避免币价波动 |
| Lido | 理财产品 | 小额也能质押ETH赚收益 |
| EigenLayer | 杠杆投资 | 用质押的币再赚一层收益 |
| RWA | 基金公司 | 在链上买美国国债、房产份额 |

**核心理念**：把银行、券商、基金公司做的事，用智能合约实现，让全球任何有网络的人都能参与，不需要开户非常好的问题！这个问题触及了Web3最核心的争议。我给你一个诚实、理性的分析。

**传统金融体量**：

-   全球银行业资产：约**140万亿美元**
    
-   全球股市市值：约**100万亿美元**
    
-   全球债券市场：约**130万亿美元**
    
-   全球支付交易量：每天**数万亿美元**
    

**DeFi体量**（2025年初）：

-   整个DeFi锁仓总值（TVL）：约**1000-1500亿美元**
    
-   占传统金融的比例：**0.03%左右**
    

**现实**：DeFi现在连传统金融的零头都不到。说"取代"还为时尚早。

* * *

## **为什么传统金融很难被完全取代？**

### **1\. 普通人真的需要"去中心化"吗？**

**大多数人的真实想法**：

-   "我的钱丢了，我要找银行客服"✅
    
-   "我忘了密码，我要重置密码"✅
    
-   "有人盗刷我的卡，我要冻结账户"✅
    

**DeFi的现实**：

-   私钥丢了=钱永远丢了，没有客服
    
-   转错地址=钱永远找不回，没有撤销
    
-   被黑客盗了=自己承担损失，没有保险
    

**举个真实例子**： 2021年，有人在给某DeFi协议转账时，错误地把手续费设成了700ETH（当时价值200万美元），本该只花几美元。这笔钱永远找不回来，因为没有"撤销"功能。

**普通人真的准备好承担这种责任吗？** 大部分人不是。

### **2\. 法律和监管的保护**

**传统金融的保护**：

-   存款保险：银行倒闭，政府赔你（中国50万，美国25万美元）
    
-   反欺诈保护：信用卡被盗刷，银行给你退款
    
-   法律追诉：出问题可以起诉银行、报警
    
-   争议解决：可以投诉、仲裁
    

**DeFi的现实**：

-   智能合约有bug被黑，你自己承担（已经发生几十次了，损失数十亿美元）
    
-   被钓鱼网站骗签名授权，钱被转走，找谁都没用
    
-   项目方跑路（Rug Pull），你报警警察都不知道怎么处理
    

**真实案例**：

-   2022年，Luna/UST崩盘，投资者损失**400亿美元**，至今大部分人血本无归
    
-   2023年，FTX交易所破产，客户**80亿美元**被挪用，CEO被判25年，但钱大部分拿不回来
    

### **3\. 传统金融的效率优势**

很多人以为DeFi更高效，实际上：

**支付速度**：

-   支付宝/微信支付：**秒到**，还能撤销
    
-   以太坊转账：15秒-几分钟，还要等几个确认，**不可撤销**
    
-   比特币转账：10分钟-1小时
    

**交易成本**：

-   银行转账（国内）：**免费**或几毛钱
    
-   支付宝/微信：**免费**
    
-   以太坊转账：网络拥堵时可能**几十到几百美元**（2021年牛市时，转个账要50美元Gas费）
    

**用户体验**：

-   银行App：忘记密码→手机验证→重置→继续用
    
-   DeFi钱包：私钥丢失→**游戏结束**，几万几十万美元说没就没
    

### **4\. 大部分金融服务需要"信任"和"人的判断"**

**举些例子**：

**房贷**：

-   银行会评估你的收入、工作稳定性、未来还款能力
    
-   智能合约怎么评估？只能看"你现在有多少加密资产"
    
-   DeFi只能做**超额抵押**（抵押150元借100元），这对买房没意义
    

**保险**：

-   传统保险会调查理赔真实性、有人工审核
    
-   DeFi保险遇到灰色地带怎么判断？完全依赖"预言机"（提供外部数据的服务），如果预言机出错或被操纵呢？
    

**信用卡**：

-   你可以"先消费后还款"，因为银行相信你会还
    
-   DeFi做不到，因为智能合约无法判断你的信用
    

* * *

## **但DeFi也有传统金融做不到的事**

### **1\. 金融普惠（Financial Inclusion）**

**真实场景**：

-   阿富汗女性在塔利班统治下被禁止开银行账户，但她们可以用加密钱包接收国际援助
    
-   委内瑞拉恶性通胀（年通胀率1000%+），人们用稳定币保护资产
    
-   移民工人跨国汇款，传统渠道收费10-20%，用加密货币可能只要1-2%
    

**传统金融的门槛**：

-   全球约**17亿人**没有银行账户
    
-   跨境汇款平均成本：**6-7%**
    
-   开户需要身份证明、居住证明、最低存款额
    

**DeFi只需要**：

-   一部手机+网络
    
-   不需要身份证明
    
-   1美元也能参与
    

### **2\. 透明度和可组合性**

**传统金融**：

-   你不知道银行拿你的钱做了什么
    
-   各个金融产品相互隔离，无法组合
    

**DeFi**：

-   所有交易公开可查（虽然匿名）
    
-   我可以把Aave借的钱→在Uniswap交易→存到Lido质押→用stETH在Curve做流动性挖矿，一气呵成
    
-   这叫"金融乐高"，传统金融做不到
    

### **3\. 抗审查和资产自主权**

**真实案例**：

-   2022年，加拿大政府冻结参与卡车司机抗议者的银行账户
    
-   很多国家政府可以冻结"不听话"的人的银行账户
    
-   塞浦路斯2013年银行危机，政府直接从储户账户扣款
    

**DeFi**：

-   没有人能冻结你的加密钱包（除非你用中心化交易所）
    
-   你真正拥有自己的资产
    

* * *

## **更可能的未来：融合，而非取代**

### **现实中正在发生的事**

**传统金融拥抱区块链技术**：

-   **摩根大通**：开发了JPM Coin，用于机构间结算
    
-   **花旗银行**：测试代币化存款
    
-   **贝莱德**：发行代币化货币基金BUIDL
    
-   **Visa/Mastercard**：支持加密货币支付
    
-   **香港、新加坡**：央行数字货币（CBDC）试点
    

**他们的逻辑**：

-   用区块链技术提高效率（特别是跨境支付、证券结算）
    
-   但保留中心化控制和监管合规
    
-   这叫**许可链（Permissioned Blockchain）** 或 **CeDeFi（中心化DeFi）**
    

### **未来可能的分工**

| 场景 | 更适合传统金融 | 更适合DeFi |
| --- | --- | --- |
| 日常支付 | ✅ 快、便宜、可撤销 | ❌ 慢、贵、不可逆 |
| 储蓄 | ✅ 有保险、稳定 | ❌ 风险高 |
| 贷款（信用） | ✅ 能评估信用 | ❌ 只能超额抵押 |
| 跨境汇款 | ❌ 慢、贵（2-5天，5-10%费用）  ❌ 缓慢、昂贵（2-5 天，5-10%费用） | ✅ 快、便宜（分钟级，1-2%） |
| 金融普惠 | ❌ 门槛高 | ✅ 低门槛 |
| 抗审查需求 | ❌ 政府可干预 | ✅ 难以审查 |
| 投机/套利 | ❌ 限制多 | ✅ 24/7开放 |
| 资产证券化 | ❌ 流程复杂 | ✅ 智能合约自动化 |

* * *

## **我的诚实看法**

### **不会完全取代，原因如下**：

1.  **大多数人不需要"去中心化"** —— 他们需要的是便利、安全、有人兜底
    
2.  **监管不会消失** —— 政府不会允许不受控的金融系统
    
3.  **技术还不成熟** —— 扩容、用户体验、安全性都有大问题
    
4.  **惯性太强** —— 几百年的金融体系有巨大的既得利益和社会惯性
    

### **但会长期共存，各有价值**：

**传统金融的未来**：吸收区块链技术，变得更高效（但保留中心化控制）

**DeFi的未来**：

-   服务传统金融覆盖不到的人群（无银行账户、受制裁国家）
    
-   提供特殊需求（隐私、抗审查、跨境）
    
-   作为创新实验场，推动传统金融改革
    

**打个比方**：

-   就像互联网没有"取代"线下世界，而是创造了新的空间
    
-   电商没有"取代"实体店，但改变了商业格局
    
-   DeFi不会"取代"传统金融，但会重塑金融版图
    

### **对你的建议**：

1.  **不要被极端言论洗脑** —— 无论是"DeFi革命论"还是"区块链骗局论"
    
2.  **理解技术，但保持理性** —— Web3有价值,但不是万能的
    
3.  **风险意识** —— 如果要参与DeFi,只投入你能承受损失的钱
    
4.  **关注实际应用** —— 看它到底解决了什么真实问题，而不是炒作概念
    

* * *

**思考题**： 在中国，DeFi有多大发展空间？考虑到支付宝/微信支付已经这么方便，央行数字货币（数字人民币）也在推进，普通中国人还需要DeFi吗？
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->





第一天打卡：

主要做了三件事：

1.  阅读021 学习以太坊第 1 章 了解了一些关于区块链和以太坊的基本知识
    
2.  听Web3 行业全局介绍 & 岗位概览，了解了大致的岗位以及努力的方向
    
3.  创建了metamask钱包，并第一次领取了活水，也转了一点给同学
    

以下是详细的内容：

## 基本概念

**以太坊（Ethereum）**是一个去中心化、开源并且具备智能合约功能的公共区块链平台。

**智能合约（Smart Contract）** 是一种写在区块链上的自动化协议程序，可以在满足预先设定条件时，自动执行约定好的操作，而不需要人工干预或第三方中介。

**以太坊虚拟机（Ethereum Virtual Machine，EVM）**是以太坊的核心组件，它是

一个图灵完备的虚拟机，能够执行智能合约代码，让区块链不再只是“记账”，而是可以运行各类程序和应用。

**以太（Ether，缩写为 ETH）**加密货币作为其内部交易的“燃料”（Gas），用于支付交易费用和计算服务

**燃料(Gas)** 是以太坊里对“计算工作量”的计价方式，用 ETH 来支付。

**不可替代代币（NFT，Non-Fungible Token）**技术上，NFT是一段写在区块链上的智能合约记录，记录了：

-   唯一编号（Token ID）
    
-   拥有者地址
    
-   相关规则（如转让、版税）
    

**铸造 NFT** \= 把“某个东西的所有权信息”写进区块链，在区块链上创建一个新的、唯一的 NFT

**第 1 步：准备“作品”**

可以是：图片（JPG / PNG）音乐（MP3）视频（MP4）甚至一段文字⚠️ 注意：作品本身一般不直接存到区块链上

**第 2 步：把作品存到“链下**

因为区块链存储很贵，所以通常：上传到 IPFS / Arweave / 云存储得到一个唯一链接（Hash）👉 区块链只保存“指向它的地址”

**第 3 步：创建 NFT 智能合约**

智能合约会规定：NFT 的标准（如 ERC-721 / ERC-1155）每个 NFT 的唯一编号（Token ID）谁是初始拥有者 是否有转售版税

**第 4 步：发起“铸造交易”**

用钱包（如 MetaMask）：调用合约的 mint 函数支付 Gas（用 ETH）这一步是真正上链的关键

**第 5 步：NFT 诞生** 区块链记录：NFT 已存在 Token ID 是多少 拥有者是谁 指向哪份作品 👉 全世界都可以验证

**去中心化金融（DeFi）：**

借贷协议、去中心化交易所、衍生品、稳定币、收益聚合器……

**去中心化自治组织（DAO）：**

规则写进合约，由代币持有者投票治理，无“董事会拍脑袋”。

### 验证者具体在做什么？

以太坊 PoS 中，验证者主要做两件事：

**提议区块（propose）**：某个时隙里会选出一个验证者来打包区块

**证明/投票（attest）**：其他验证者对区块投票确认（证明它有效）

如果验证者：

-   **离线**：会被扣一点收益/罚一点（轻罚，逼你保持在线）
    
-   **作恶（比如双签）**：会触发 **slashing 削减**（重罚，可能损失很大）
    

### 打包区块是什么意思？

“打包区块”就是：把**一堆待处理的交易**（比如转账、调用智能合约）按规则**整理成一个新区块**，并把这个新区块**发布到以太坊链上**，让全网认可它成为“最新一页账本”。

把以太坊想成一本**不断追加的新账本**：

-   **交易** = 一条条记账请求（“A 给 B 转 1 ETH”“我在 Uniswap 换币”）
    
-   **区块** = 一页账本
    
-   **打包区块** = 负责把这一页写好、盖章、交给全网确认的人（PoS 里是“被选中的验证者”）
    

在以太坊 PoS 里，一次“出一个区块”通常是：

-   **1 个验证者被随机选中当“提议者”（proposer）**：负责把交易打包成新区块并发布。
    
-   **很多其他验证者当“证明者/投票者”（attesters）**：对这个区块投票确认它有效。
    

所以是：**1 个负责写这一页账本 + 一群负责盖章确认**。

### 为什么要一群人投票？

因为这样才能做到“去中心化的共识”：

-   如果只有 1 个验证者说了算，他就可能乱写账。
    
-   有很多验证者一起核对投票，作恶更难、成本更高。
    

### 那“最终确认”需要多少验证者？

不需要你记精确数字，只要抓住这个直觉：

-   区块刚出来时，是\*\*“被一批验证者投票支持”\*\*，就算比较稳了（常说的 _finality 之前的确认_）。
    
-   过一段时间，达到协议的最终性（finality）后，区块基本就**不可逆**了——这也依赖**大量验证者的投票**来完成。
    

如果你问的是更直观的问题： **“每个区块是不是只由一个验证者产生？”**——是的，**提议者只有一个**； 但\*\*“每个区块是不是只需要一个验证者认可？”\*\*——不是，**需要很多验证者一起认可**。

## web3交易过程

## 0）你在钱包里点“发送”之前：交易其实是一份“指令包”

一笔以太坊交易本质上包含这些关键信息（你不一定都手填，但钱包都会帮你填）：

-   **from**：你的地址（由签名自动确定）
    
-   **to**：收款地址或合约地址
    
-   **value**：转多少 ETH（如果只是调用合约也可能是 0）
    
-   **data**：调用合约函数时的参数（普通转账通常为空）
    
-   **nonce**：你这个地址发出的第几笔交易（同一地址必须按 nonce 顺序上链）
    
-   **gas limit**：你愿意给这笔交易最多用多少“计算量”
    
-   **费用参数（EIP-1559）**：
    
    -   **maxFeePerGas**：你愿意支付的“每单位 gas 的最高单价”
        
    -   **maxPriorityFeePerGas**：你愿意给打包者的小费（tip）
        
    -   实际上交易要至少覆盖 **base fee + tip**，其中 base fee 会被销毁，tip 给打包者/验证者
        

> 直觉：nonce 决定“排队顺序”，费用决定“别人愿不愿意优先处理你”。

* * *

## 1）签名：你把这份“指令包”变成不可伪造的交易

你点确认后，钱包会用你的私钥对交易签名（不会把私钥发出去）。  
签完以后，这笔交易就有了唯一的 **交易哈希 TxHash**（像收据编号）。

* * *

## 2）广播：交易进入 mempool（交易池）

钱包会把签名后的交易发给一个以太坊节点（可能是你用的钱包/Infura/Alchemy/自建节点）。

节点会先做“基础检查”：

-   签名对不对、nonce 对不对
    
-   你余额是否够支付 `value + 最高可能手续费`
    
-   gas limit、费用参数是否合理（至少有机会覆盖当前 base fee）
    

通过后，它会把交易放进 **mempool**，并转发给其他节点——这时你在浏览器里会看到 **Pending（待打包）**。

* * *

## 3）打包前：谁决定“这笔交易进哪个区块”？

在 PoS 里，以太坊把时间切成：

-   **slot：12 秒一个**
    
-   **epoch：32 个 slot**
    

每个 slot 会随机选出 **1 个验证者当“提议者（proposer）”** 去提出新区块 。

但“新区块里具体放哪些交易、交易怎么排序”在现实里经常是：

-   由提议者自己从 mempool 挑（更简单的情况）
    
-   或者通过“构建者/区块构建市场”拿到一个更赚钱的交易排序方案（你可以先把它理解成：大家都倾向选**手续费更高/更赚钱/更可执行**的交易顺序）
    

所以你**无法在 pending 阶段精确确定**它会进第几个区块，只能用费用等因素提高“尽快进区块”的概率。

* * *

## 4）区块内执行：交易不是“写进去就算完”，还要真正跑一遍

当某个 proposer 把你的交易放进区块后，全网执行层会**按区块里给定的顺序执行交易**：

-   普通转账：扣你余额、加对方余额（固定 21,000 gas）
    
-   调合约：EVM 执行 `data` 里的函数逻辑，读写合约存储、发事件日志等
    
-   如果执行中**触发 revert**：
    
    -   状态改动会回滚
        
    -   **但 gas 仍然消耗**（因为计算已经做了）
        

执行完会生成一份 **receipt（回执）**，里面有：

-   status（成功/失败）
    
-   gasUsed
    
-   logs（事件日志，用于前端/索引器显示“发生了什么”）
    
-   blockNumber、transactionIndex（你最终要找“它在哪个区块”就看这两个）
    

* * *

## 5）确认与“最终性”：什么时候算真的不可逆？

区块提出后，其他验证者会对区块进行投票/证明（attestation），区块就会逐渐“更难被回滚”。

在以太坊当前的 PoS 设计下，通常在**约两个 epoch**后能达到非常强的经济意义上的“最终性（finality）”，也就是大约 **12.8 分钟**（理想网络条件下）。

你在区块浏览器里看到的：

-   **1 confirmation、2 confirmations…**：只是“在它后面又接了多少个区块”，越多越稳
    
-   **finalized**（或类似标记）：基本可以认为不可逆（除非极端大故障/大规模作恶）。
    

## web3技术人员主要工作内容

### 1) 智能合约工程师（Solidity / 协议开发）

-   设计与实现合约：代币、AMM/借贷、NFT、拍卖、治理、权限系统
    
-   写测试、做形式化/模糊测试、Gas 优化
    
-   处理升级（Proxy）、跨链、预言机集成、权限/多签方案
    
-   上线部署与版本管理（主网/测试网、多链）
    

**常见技术栈**

-   语言：**Solidity**（以太坊系主流）、Vyper（少量）
    
-   框架：**Foundry**（forge/cast/anvil）、Hardhat（也很常见）
    
-   合约库：OpenZeppelin、Solmate
    
-   测试：forge test / hardhat test、fuzz（Foundry/Echidna）
    
-   安全工具：Slither、Mythril、Echidna、Manticore（视团队成熟度）
    
-   调试/模拟：Tenderly、anvil/fork、mainnet-fork
    

* * *

### 2) Web3 前端工程师（DApp 前端）

-   做钱包连接、签名、交易发送、状态展示、错误与网络切换
    
-   处理链上数据读取：余额、头寸、NFT、交易历史、价格等
    
-   兼容多钱包/多链，提升交互体验（失败重试、gas 估算、Pending 状态）
    

**常见技术栈**

-   Web：**React / Next.js / TypeScript**
    
-   钱包/链交互：**ethers.js** 或（更现代）**viem + wagmi**
    
-   钱包标准：WalletConnect、EIP-1193 Provider、SIWE（Sign-In with Ethereum）
    
-   UI/状态：TanStack Query、Redux/Zustand（看团队习惯）
    

* * *

### 3) 链下后端 / 区块链基础设施工程师

-   提供 API：用户数据、资产聚合、报价、风控、活动等
    
-   监听链上事件、解析交易，做索引与缓存（否则前端直接读链会很慢/贵）
    
-   管理节点/RPC：自建或对接服务商，做限流、容灾、监控
    
-   处理任务队列：发奖、清算、自动化执行、批处理
    

**常见技术栈**

-   语言：Node.js/TypeScript、Go、Python、Java（都常见）
    
-   数据：Postgres、Redis、Kafka/RabbitMQ
    
-   索引：The Graph（subgraph）、自建 indexer（监听 logs + 解析 ABI）
    
-   存储：IPFS/Arweave（元数据）、对象存储
    
-   云与运维：Docker、K8s、CI/CD、监控告警（Prometheus/Grafana）
    

* * *

### 4) 安全工程师 / 审计方向

-   做威胁建模：重入、权限绕过、价格操纵、闪电贷、MEV 风险
    
-   静态/动态分析、fuzz、形式化验证（成熟团队会做得更深）
    
-   代码审计与上线清单：多签、timelock、权限最小化、应急开关策略
    

**常见技术栈**

-   Slither / Mythril / Echidna / Foundry fuzz
    
-   形式化：Certora / Scribble / K Framework（取决于预算与要求）
    

## 来自群里森理的钱包教程

## MetaMask钱包版

图文教程版：[https://humdrum删-volleyball-4a2删.notion删.site/2e54867ff3e180b5bc84e33a7e2f9835](https://humdrum删-volleyball-4a2删.notion删.site/2e54867ff3e180b5bc84e33a7e2f9835)

省流版：安装MetaMask -> 开启测试网（Google ETH） -> 复制地址领币（俗称领水） -> 转账 -> 拿链接交作业

纯文字版：

在chrome扩展商店搜索MetaMask，安装

安装完毕——创建新钱包——注册

进入钱包

最开始我们是看不到测试网Sepolia的，点击右上角—网络—滑倒最底下，显示测试网络

这时我们的钱包就准备好了

点击收款，复制接收地址（我一般复制Ethereum）

然后去测试网领币（领水）—— [https://cloud删.google删.com/application/web3/faucet/ethereum](https://cloud删.google删.com/application/web3/faucet/ethereum)

选择Ethereum Sepolia（0.05ETH）这一项

粘贴自己的收款地址，ETH到手

然后查看账户，到账了以后就可以打款给别的同学了

选择发送ETH，填入别的同学的钱包地址与发送金额

确认交易，稍等片刻

确认交易完成后点击这个交易

点击在区块浏览器上查看

然后我们就会跳转Etherscan的页面但是不重要

复制顶部的这一串网址，即为我们所需的tx link
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
