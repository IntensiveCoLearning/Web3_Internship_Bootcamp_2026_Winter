---
timezone: UTC+8
---

# AxonKitty

**GitHub ID:** AxonKitty

**Telegram:** @AxonKitty

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-28
<!-- DAILY_CHECKIN_2026-01-28_START -->
开始准备黑客松，方向预测市场。
<!-- DAILY_CHECKIN_2026-01-28_END -->

# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->

# 1｜Some facts of ERC-7962

## 什么是ERC-7962？

首先，**ERC** 是 **Ethereum Request for Comments** 的缩写，中文通常翻译为“以太坊征求意见稿”或“以太坊请求评论”。/这是一个以太坊社区用于提出、讨论和标准化应用层协议的编号系统，类似于互联网领域的 RFC（Request for Comments）标准。ERC 是以太坊改进提案（EIP）的一种特定类别，专门针对应用层标准（如代币、NFT、智能合约接口等），而非底层协议变更。

常见 ERC 示例：

-   **ERC-20**：最著名的同质化代币（fungible token）标准，用于创建可互换、可分割的代币（如 USDT、DAI、UNI 等大多数加密货币）。
    
-   **ERC-721**：非同质化代币（NFT）标准，用于唯一、不可互换的资产（如数字艺术、收藏品、游戏道具）。
    
-   **ERC-1155**：多功能代币标准，同时支持同质化和非同质化代币，常用于游戏批量发行。
    
-   **ERC-7962**：基于密钥哈希的代币标准，专注于隐私保护和权限委托。
    

什么是 ERC-7962 ？

-   搜索到的定义：ERC-7962 是一种“把代币所有权从地址抽象到密钥哈希”的新型代币标准，主要解决传统 ERC-20/721 在隐私、权限委托、机构使用场景下的痛点，是 2025–2026 年期间 Ethereum 应用层比较重要的一项隐私友好型代币原语。
    
-   它也叫：KeyHash 资产标准。
    
-   核心创新是对资产的归属权证明的改变。资产的归属权证明从传统的账户模型account based，切换到了哈希关联模型hash-linked。
    
-   他并不是要取代现有的ERC20，而是要解决”地址及身份“这个特性带来的束缚。
    

How ERC-7962 works？

-   核心的构成：relayer（中继者）、
    

## 是给谁用的？

产品是为了满足需求，解答了用户是谁，就能倒推这个产品满足的需求是什么。

一句话：

> \[!note\] ERC-7962 是给那些希望“资产归我管，但身份不公开”以及“想要极致流畅体验”的人准备的。 它把以太坊从一个“透明的公共账本”变成了一个“支持授权验证的隐形保险箱”。

那么这个协议谁最可能使用？

1.  极度关注隐私的大户和机构。场景：大额结算、大额或大量薪酬发放
    
    1.  对于传统的ERC20协议，一旦你给某人转过账之后你的地址就暴露了，而且和你这个地址相关的所有余额历史记录参与过的Defi协议都会一览无余。这个协议允许用户给每一笔资产，每一个联系人都生成一个keyhash，这个key hash代替了地址这个概念。即在链上，你只能看到keyhaa转账给了keyhashb，但是你无法看到这个keyhash背后代表的是哪个地址，也就无法把也就无法看到这个地址背后的余额历史记录，和参与过的defi协议。
        
2.  Web2用户 or 无 gas 入场者。场景：地址余额无感地使用 web3 产品。
    
    1.  对于web3而言，破圈的最大障碍，其实就是如果一个新用户想要操作链上资产，它必须要购买加密货币作为Gss费。比如购买以太坊，作为Gss费，才能在链上进行操作。
        
    2.  用户可以完全不接触购买 ETH 代币，只需要在前端用密钥签名，就可以由 relayer 或者开发者支付这个 gas 费，进而像 web2 应用那样使用。这个密钥可以是：私钥、手机指纹或面容派生的密钥。
        
    3.  对地址和余额，无感。
        
3.  合规机构和托管服务商。场景：资产映射、内部清算
    
    1.  机构只需要管理大量的`keyHash`，而不是创建 EOA (外部地址) 地址。
        
        1.  区别是什么？
            
    2.  这个资产的映射只有机构的后台能看到。
        
    3.  链上访问者只能看到前台的`keyHash`，无法分析机构的资金流向和持仓分布。
        
4.  Dapp 开发者。
    
    1.  用户不需要：连接钱包 -> 弹出 Gas 确认 -> 等待成交。
        
    2.  用户一次性签署多个针对不同 `keyHash` 的授权消息，由后端在最优时间点提交上链，极大提升了用户体验（UX）。而这个授权签署，由开发者构建的“离线签名批处理”功能实现。
        

| 受众群体 | 核心需求 | ERC-7962 提供的价值 |
| --- | --- | --- |
| 隐私主义者 | 隐藏财富总量、切断地址关联 | 资产与地址解耦，实现伪匿名。 |
| 小白用户 | 零成本、零门槛上手 | 无需储备 Gas 费，纯签名交互。 |
| 企业/机构 | 合规、防跟踪、内部风控 | 链上轨迹模糊化，降低商业情报泄露风险。 |
| 开发者 | 极致的交互体验 (UX) | 支持代付机制，简化用户操作路径。 |

# Q：对机构而言，EOA 模式和KeyHash 模式的区别是什么？

> 合规机构和托管服务商。场景：资产映射、内部清算。机构只需要管理大量的keyHash，而不是创建 EOA (外部地址) 地址。区别是什么？

实际地址的管理：

1.  EOA 模式： 机构要管理用户地址，需要使用 HD 钱包通过助记词派生无数地址，1个 user，对应一个地址；100w个 user，就是100w 个地址。每个 address 都要预存 gas，100w 个 address 的 gas 路费就是巨大的浪费。
    
    1.  私钥泄露，地址的资产清零。
        
2.  KeyHash 模式：机构创建一个热钱包地址作为 relayer 中继者，存入足够的 gas 费。用户的资产以 KeyHash 形式，存在 ERC7962 合约里，无需预存 gas。
    
    -   **逻辑：** 机构后台记录：`用户A = keyHash_1`。当用户 A 要在内部系统提现或划转时，机构只需生成一个符合 ERC-7962 规范的签名（甚至可以用机构的主私钥对 `keyHash_1` 进行授权签名）。
        
    -   **区别：** 所有的资产划转在链上看起来是 `keyHash` 之间的数据交换，而不需要频繁切换发送方（`msg.sender`）地址。
        
3.  由此，机构可以零成本地给海量用户生成资产表示，上链结算时，由中心化的热钱包统一支付 gas。
    

从合规机构和托管商的角度来看，管理 **KeyHash**（ERC-7962 模式）与管理 **EOA（外部账户）地址**（传统模式）的区别主要体现在以下四个维度：

* * *

### 1\. 链上资源占用与“冷启动”成本

-   **传统 EOA 模式：** 如果一家机构有 100 万个用户，它必须在逻辑上对应 100 万个以太坊地址。
    
    -   **痛点：** 每一个 EOA 地址如果要发起交易，里面必须先有 ETH（Gas 费）。给 100 万个地址分发“路费”是一个巨大的工程，且极易造成资金碎片的浪费。
        
-   **ERC-7962 (KeyHash) 模式：** 机构只需要一个“热钱包”地址作为 **Relayer（中继者）**，里面存入足够的 Gas 费。
    
    -   **区别：** 用户的资产以 `keyHash` 的形式存在合约里。这些 `keyHash` 只是 32 字节的数据，它们**不需要预存 ETH**。
        
    -   **结果：** 机构可以零成本地为海量用户生成资产标识，只有在真正需要上链结算时，才由中心化的热钱包统一支付 Gas。
        

### 2\. 管理负担：私钥派生 vs 链上状态记录

-   **传统 EOA 模式：** 机构需要管理 100 万对私钥/公钥。为了安全，通常使用 HD 钱包（分层确定性钱包）通过一个助记词派生出无数地址。
    
    -   **风险：** 归集资产时，机构必须逐个调用这 100 万个地址的私钥进行签名并广播。
        
-   **ERC-7962 (KeyHash) 模式：** 机构可以维护一套\*\*“影子账本”\*\*。
    
    -   **逻辑：** 机构后台记录：`用户A = keyHash_1`。当用户 A 要在内部系统提现或划转时，机构只需生成一个符合 ERC-7962 规范的签名（甚至可以用机构的主私钥对 `keyHash_1` 进行授权签名）。
        
    -   **区别：** 所有的资产划转在链上看起来是 `keyHash` 之间的数据交换，而不需要频繁切换发送方（`msg.sender`）地址。
        

### 3\. 内部清算的隐私与合规（最核心区别）

-   **传统 EOA 模式（透明的）：** 访问者可以通过浏览器看到机构的资金归集路径（例如：用户 A 地址 -> 机构中转地址 -> 机构冷钱包）。这种路径是固定且容易被追踪的，商业机密近乎透明。
    
-   **ERC-7962 (KeyHash) 模式（模糊的）：** \* **内部清算：** 机构可以在合约内直接触发 `keyHash_A` 到 `keyHash_B` 的转移。
    
    -   **视角：** 对外部观察者来说，他们只看到合约内部的数据发生了变动，但无法得知这两个 `keyHash` 是否属于同一个机构，也无法得知背后对应的真实钱包地址。
        
    -   **合规性：** 机构可以向监管部门有选择地披露 `keyHash` 与身份的对应关系（可审计性），而对普通公众保持隐藏
        

### 4\. 账户抽象（AA）的天然兼容性

-   **传统 EOA 模式：** EOA 是死板的，一旦私钥泄露，地址下的所有资产归零。
    
-   **ERC-7962 (KeyHash) 模式：** `keyHash` 本质上是一个“逻辑锁”。
    
    -   **优势：** 托管商可以为 `keyHash` 设置更复杂的验证逻辑。例如：如果要动用这个 `keyHash` 的资产，需要“用户签名 + 机构风控模块签名”同时满足。这种逻辑直接写在 ERC-7962 扩展合约里，比管理 EOA 的多签要灵活得多。
        

* * *

### 维度对比总结表

| 维度 | 管理 10,000 个 EOA 地址 | 管理 10,000 个 KeyHash |
| --- | --- | --- |
| Gas 准备 | 每个地址都要存入 ETH | 仅需一个 Relayer 统一支付 |
| 资金归集 | 极其繁琐，产生大量小额碎粉 | 逻辑划转，无碎片产生 |
| 外部可见性 | 资金流向链上一清二楚 | 仅见哈希变动，业务逻辑隐藏 |
| 系统复杂性 | 高（需维护海量地址索引） | 低（仅需维护 KeyHash 映射表） |
| 安全性 | 暴露单一地址即暴露该地址全部 | 资产级隔离，KeyHash 之间无关联 |

* * *

### 机构视角的“一句话总结”：

**管理 EOA 就像是给 100 万个员工每人发一张银行卡（每张卡都要充年费、管密码）；而管理 KeyHash 就像是在公司总账户下设立 100 万个虚拟子账户，外部只看到总账户在动，而内部谁领了多少钱，只有你手里的账本（KeyHash 映射）最清楚。**

这种模式让 Web3 机构在处理**大规模高频业务**时，效率更接近 Web2 系统。

# Q：看起来变得中心化了，这会不会给机构作恶的机会？

> 结论：机构难以作恶。

**ERC-7962 的设计精髓**在于：它利用了区块链的**不可篡改性**，将“所有权”和“执行权”进行了分离。简单来说：**机构可以帮你关门、付物业费，但它拿不走你保险柜里的钥匙。**

我们可以从以下三个技术维度来拆解“为何机构难以作恶”：

* * *

### 1\. 私钥的唯一控制权（数学级的防线）

虽然机构管理着 `keyHash`，但合约在代码层面上锁死了：**任何资产变动必须提供对应的私钥签名。**

-   **即使机构想作恶：** 如果托管商（或其内部黑客）想私自转走你 `keyHash` 下的资产，他们必须伪造一个你的私钥签名。
    
-   **数学保障：** 根据 $ecrecover$ 原理，只有拥有私钥的人才能生成有效签名。机构手里只有你的 `keyHash`（哈希后的指纹），通过哈希值反推私钥在数学上是不可能的。
    
-   **结论：** **执行权（Gas/Relayer）在机构，但处分权（私钥/签名）始终在你手里。**
    

### 2\. 抗审查与自救机制

你担心的“中心化”通常表现为：**“如果机构不帮我提交签名（Relayer 罢工），我不就没法动钱了吗？”**

为了防止这种“软性作恶”，优秀的 ERC-7962 实现通常会保留**紧急自救通道**：

-   **直接交互：** 用户如果愿意自己支付 Gas，可以直接调用合约的 `transferFromKeyHash` 函数，绕过机构的 Relayer。
    
-   **强制提现：** 协议可以设计一个“退出窗口”，如果 Relayer 拒绝服务，用户可以通过任何其他的第三方中继者（甚至是自己起一个节点）来广播自己的签名。
    

### 3\. 透明度与审计的“双面性”

虽然对外部（匿名访问者）来说是隐私的，但对链上合约来说是**完全透明**的。

-   **证据留存：** 每一笔通过 Relayer 提交的交易，其原始签名（$v, r, s$）都会永久记录在链上。
    
-   **不可抵赖性：** 如果机构真的未经授权动用了资金，它无法抹除链上记录。由于机构没有你的私钥，它唯一的作恶手段是“利用合约漏洞”或“签名重放”。
    
-   **防重放攻击：** ERC-7962 强制要求每一笔签名包含 `nonce`。机构无法把你的一个旧签名拿去再执行一次。
    

* * *

### 中心化 vs. 去中心化的实际边界

我们可以用下表对比机构在不同模式下的作恶能力：

| 风险维度 | 传统 CEX (完全中心化) | ERC-7962 托管 (半中心化) | 纯 EOA (完全去中心化) |
| --- | --- | --- | --- |
| 机构挪用资金 | 极易 (账面数字，无链上约束) | 极难 (受智能合约签名校验约束) | 不可能 |
| 拒绝服务 (冻结) | 容易 | 较难 (用户可自行寻找其他 Relayer) | 不可能 |
| 隐私泄露 | 完全泄露给机构 | 完全泄露给机构 (但对公众隐私) | 对全球公开 |

* * *

### 潜在风险点

虽然 ERC-7962 本身在数学上是安全的，但如果**机构在实现上**耍花招，仍有风险：

1.  **合约管理权限：** 如果 ERC-7962 合约本身留有“管理员后门”（Owner 权限），机构可以直接通过修改合约逻辑划转资产。所以，**合约是否开源、是否放弃管理权限**至关重要。
    
2.  **前端劫持：** 如果你使用的机构 App 是闭源的，它可能会在你签名时悄悄替换掉目标地址。这属于**操作层面的诈骗**，而非协议本身的漏洞。
    

### 总结

ERC-7962 实际上是用“执行的中心化”**（为了效率和隐私）换取了**“资产的去中心化”\*\*（通过数学签名保证安全）。
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->


# 1｜Some facts of ERC-7962

## 什么是ERC-7962？

首先，**ERC** 是 **Ethereum Request for Comments** 的缩写，中文通常翻译为“以太坊征求意见稿”或“以太坊请求评论”。/这是一个以太坊社区用于提出、讨论和标准化应用层协议的编号系统，类似于互联网领域的 RFC（Request for Comments）标准。ERC 是以太坊改进提案（EIP）的一种特定类别，专门针对应用层标准（如代币、NFT、智能合约接口等），而非底层协议变更。

常见 ERC 示例：

-   **ERC-20**：最著名的同质化代币（fungible token）标准，用于创建可互换、可分割的代币（如 USDT、DAI、UNI 等大多数加密货币）。
    
-   **ERC-721**：非同质化代币（NFT）标准，用于唯一、不可互换的资产（如数字艺术、收藏品、游戏道具）。
    
-   **ERC-1155**：多功能代币标准，同时支持同质化和非同质化代币，常用于游戏批量发行。
    
-   **ERC-7962**：基于密钥哈希的代币标准，专注于隐私保护和权限委托。
    

什么是 ERC-7962 ？

-   搜索到的定义：ERC-7962 是一种“把代币所有权从地址抽象到密钥哈希”的新型代币标准，主要解决传统 ERC-20/721 在隐私、权限委托、机构使用场景下的痛点，是 2025–2026 年期间 Ethereum 应用层比较重要的一项隐私友好型代币原语。
    
-   它也叫：KeyHash 资产标准。
    
-   核心创新是对资产的归属权证明的改变。资产的归属权证明从传统的账户模型account based，切换到了哈希关联模型hash-linked。
    
-   他并不是要取代现有的ERC20，而是要解决”地址及身份“这个特性带来的束缚。
    

How ERC-7962 works？

-   核心的构成：relayer（中继者）、
    

## 是给谁用的？

产品是为了满足需求，解答了用户是谁，就能倒推这个产品满足的需求是什么。

一句话：

> \[!note\] ERC-7962 是给那些希望“资产归我管，但身份不公开”以及“想要极致流畅体验”的人准备的。 它把以太坊从一个“透明的公共账本”变成了一个“支持授权验证的隐形保险箱”。

那么这个协议谁最可能使用？

1.  极度关注隐私的大户和机构。场景：大额结算、大额或大量薪酬发放
    
    1.  对于传统的ERC20协议，一旦你给某人转过账之后你的地址就暴露了，而且和你这个地址相关的所有余额历史记录参与过的Defi协议都会一览无余。这个协议允许用户给每一笔资产，每一个联系人都生成一个keyhash，这个key hash代替了地址这个概念。即在链上，你只能看到keyhaa转账给了keyhashb，但是你无法看到这个keyhash背后代表的是哪个地址，也就无法把也就无法看到这个地址背后的余额历史记录，和参与过的defi协议。
        
2.  Web2用户 or 无 gas 入场者。场景：地址余额无感地使用 web3 产品。
    
    1.  对于web3而言，破圈的最大障碍，其实就是如果一个新用户想要操作链上资产，它必须要购买加密货币作为Gss费。比如购买以太坊，作为Gss费，才能在链上进行操作。
        
    2.  用户可以完全不接触购买 ETH 代币，只需要在前端用密钥签名，就可以由 relayer 或者开发者支付这个 gas 费，进而像 web2 应用那样使用。这个密钥可以是：私钥、手机指纹或面容派生的密钥。
        
    3.  对地址和余额，无感。
        
3.  合规机构和托管服务商。场景：资产映射、内部清算
    
    1.  机构只需要管理大量的`keyHash`，而不是创建 EOA (外部地址) 地址。
        
        1.  区别是什么？
            
    2.  这个资产的映射只有机构的后台能看到。
        
    3.  链上访问者只能看到前台的`keyHash`，无法分析机构的资金流向和持仓分布。
        
4.  Dapp 开发者。
    
    1.  用户不需要：连接钱包 -> 弹出 Gas 确认 -> 等待成交。
        
    2.  用户一次性签署多个针对不同 `keyHash` 的授权消息，由后端在最优时间点提交上链，极大提升了用户体验（UX）。而这个授权签署，由开发者构建的“离线签名批处理”功能实现。
        

| 受众群体 | 核心需求 | ERC-7962 提供的价值 |
| --- | --- | --- |
| 隐私主义者 | 隐藏财富总量、切断地址关联 | 资产与地址解耦，实现伪匿名。 |
| 小白用户 | 零成本、零门槛上手 | 无需储备 Gas 费，纯签名交互。 |
| 企业/机构 | 合规、防跟踪、内部风控 | 链上轨迹模糊化，降低商业情报泄露风险。 |
| 开发者 | 极致的交互体验 (UX) | 支持代付机制，简化用户操作路径。 |

# Q：对机构而言，EOA 模式和KeyHash 模式的区别是什么？

> 合规机构和托管服务商。场景：资产映射、内部清算。机构只需要管理大量的keyHash，而不是创建 EOA (外部地址) 地址。区别是什么？

实际地址的管理：

1.  EOA 模式： 机构要管理用户地址，需要使用 HD 钱包通过助记词派生无数地址，1个 user，对应一个地址；100w个 user，就是100w 个地址。每个 address 都要预存 gas，100w 个 address 的 gas 路费就是巨大的浪费。
    
    1.  私钥泄露，地址的资产清零。
        
2.  KeyHash 模式：机构创建一个热钱包地址作为 relayer 中继者，存入足够的 gas 费。用户的资产以 KeyHash 形式，存在 ERC7962 合约里，无需预存 gas。
    
    -   **逻辑：** 机构后台记录：`用户A = keyHash_1`。当用户 A 要在内部系统提现或划转时，机构只需生成一个符合 ERC-7962 规范的签名（甚至可以用机构的主私钥对 `keyHash_1` 进行授权签名）。
        
    -   **区别：** 所有的资产划转在链上看起来是 `keyHash` 之间的数据交换，而不需要频繁切换发送方（`msg.sender`）地址。
        
3.  由此，机构可以零成本地给海量用户生成资产表示，上链结算时，由中心化的热钱包统一支付 gas。
    

从合规机构和托管商的角度来看，管理 **KeyHash**（ERC-7962 模式）与管理 **EOA（外部账户）地址**（传统模式）的区别主要体现在以下四个维度：

* * *

### 1\. 链上资源占用与“冷启动”成本

-   **传统 EOA 模式：** 如果一家机构有 100 万个用户，它必须在逻辑上对应 100 万个以太坊地址。
    
    -   **痛点：** 每一个 EOA 地址如果要发起交易，里面必须先有 ETH（Gas 费）。给 100 万个地址分发“路费”是一个巨大的工程，且极易造成资金碎片的浪费。
        
-   **ERC-7962 (KeyHash) 模式：** 机构只需要一个“热钱包”地址作为 **Relayer（中继者）**，里面存入足够的 Gas 费。
    
    -   **区别：** 用户的资产以 `keyHash` 的形式存在合约里。这些 `keyHash` 只是 32 字节的数据，它们**不需要预存 ETH**。
        
    -   **结果：** 机构可以零成本地为海量用户生成资产标识，只有在真正需要上链结算时，才由中心化的热钱包统一支付 Gas。
        

### 2\. 管理负担：私钥派生 vs 链上状态记录

-   **传统 EOA 模式：** 机构需要管理 100 万对私钥/公钥。为了安全，通常使用 HD 钱包（分层确定性钱包）通过一个助记词派生出无数地址。
    
    -   **风险：** 归集资产时，机构必须逐个调用这 100 万个地址的私钥进行签名并广播。
        
-   **ERC-7962 (KeyHash) 模式：** 机构可以维护一套\*\*“影子账本”\*\*。
    
    -   **逻辑：** 机构后台记录：`用户A = keyHash_1`。当用户 A 要在内部系统提现或划转时，机构只需生成一个符合 ERC-7962 规范的签名（甚至可以用机构的主私钥对 `keyHash_1` 进行授权签名）。
        
    -   **区别：** 所有的资产划转在链上看起来是 `keyHash` 之间的数据交换，而不需要频繁切换发送方（`msg.sender`）地址。
        

### 3\. 内部清算的隐私与合规（最核心区别）

-   **传统 EOA 模式（透明的）：** 访问者可以通过浏览器看到机构的资金归集路径（例如：用户 A 地址 -> 机构中转地址 -> 机构冷钱包）。这种路径是固定且容易被追踪的，商业机密近乎透明。
    
-   **ERC-7962 (KeyHash) 模式（模糊的）：** \* **内部清算：** 机构可以在合约内直接触发 `keyHash_A` 到 `keyHash_B` 的转移。
    
    -   **视角：** 对外部观察者来说，他们只看到合约内部的数据发生了变动，但无法得知这两个 `keyHash` 是否属于同一个机构，也无法得知背后对应的真实钱包地址。
        
    -   **合规性：** 机构可以向监管部门有选择地披露 `keyHash` 与身份的对应关系（可审计性），而对普通公众保持隐藏
        

### 4\. 账户抽象（AA）的天然兼容性

-   **传统 EOA 模式：** EOA 是死板的，一旦私钥泄露，地址下的所有资产归零。
    
-   **ERC-7962 (KeyHash) 模式：** `keyHash` 本质上是一个“逻辑锁”。
    
    -   **优势：** 托管商可以为 `keyHash` 设置更复杂的验证逻辑。例如：如果要动用这个 `keyHash` 的资产，需要“用户签名 + 机构风控模块签名”同时满足。这种逻辑直接写在 ERC-7962 扩展合约里，比管理 EOA 的多签要灵活得多。
        

* * *

### 维度对比总结表

| 维度 | 管理 10,000 个 EOA 地址 | 管理 10,000 个 KeyHash |
| --- | --- | --- |
| Gas 准备 | 每个地址都要存入 ETH | 仅需一个 Relayer 统一支付 |
| 资金归集 | 极其繁琐，产生大量小额碎粉 | 逻辑划转，无碎片产生 |
| 外部可见性 | 资金流向链上一清二楚 | 仅见哈希变动，业务逻辑隐藏 |
| 系统复杂性 | 高（需维护海量地址索引） | 低（仅需维护 KeyHash 映射表） |
| 安全性 | 暴露单一地址即暴露该地址全部 | 资产级隔离，KeyHash 之间无关联 |

* * *

### 机构视角的“一句话总结”：

**管理 EOA 就像是给 100 万个员工每人发一张银行卡（每张卡都要充年费、管密码）；而管理 KeyHash 就像是在公司总账户下设立 100 万个虚拟子账户，外部只看到总账户在动，而内部谁领了多少钱，只有你手里的账本（KeyHash 映射）最清楚。**

这种模式让 Web3 机构在处理**大规模高频业务**时，效率更接近 Web2 系统。

# Q：看起来变得中心化了，这会不会给机构作恶的机会？

> 结论：机构难以作恶。

**ERC-7962 的设计精髓**在于：它利用了区块链的**不可篡改性**，将“所有权”和“执行权”进行了分离。简单来说：**机构可以帮你关门、付物业费，但它拿不走你保险柜里的钥匙。**

我们可以从以下三个技术维度来拆解“为何机构难以作恶”：

* * *

### 1\. 私钥的唯一控制权（数学级的防线）

虽然机构管理着 `keyHash`，但合约在代码层面上锁死了：**任何资产变动必须提供对应的私钥签名。**

-   **即使机构想作恶：** 如果托管商（或其内部黑客）想私自转走你 `keyHash` 下的资产，他们必须伪造一个你的私钥签名。
    
-   **数学保障：** 根据 $ecrecover$ 原理，只有拥有私钥的人才能生成有效签名。机构手里只有你的 `keyHash`（哈希后的指纹），通过哈希值反推私钥在数学上是不可能的。
    
-   **结论：** **执行权（Gas/Relayer）在机构，但处分权（私钥/签名）始终在你手里。**
    

### 2\. 抗审查与自救机制

你担心的“中心化”通常表现为：**“如果机构不帮我提交签名（Relayer 罢工），我不就没法动钱了吗？”**

为了防止这种“软性作恶”，优秀的 ERC-7962 实现通常会保留**紧急自救通道**：

-   **直接交互：** 用户如果愿意自己支付 Gas，可以直接调用合约的 `transferFromKeyHash` 函数，绕过机构的 Relayer。
    
-   **强制提现：** 协议可以设计一个“退出窗口”，如果 Relayer 拒绝服务，用户可以通过任何其他的第三方中继者（甚至是自己起一个节点）来广播自己的签名。
    

### 3\. 透明度与审计的“双面性”

虽然对外部（匿名访问者）来说是隐私的，但对链上合约来说是**完全透明**的。

-   **证据留存：** 每一笔通过 Relayer 提交的交易，其原始签名（$v, r, s$）都会永久记录在链上。
    
-   **不可抵赖性：** 如果机构真的未经授权动用了资金，它无法抹除链上记录。由于机构没有你的私钥，它唯一的作恶手段是“利用合约漏洞”或“签名重放”。
    
-   **防重放攻击：** ERC-7962 强制要求每一笔签名包含 `nonce`。机构无法把你的一个旧签名拿去再执行一次。
    

* * *

### 中心化 vs. 去中心化的实际边界

我们可以用下表对比机构在不同模式下的作恶能力：

| 风险维度 | 传统 CEX (完全中心化) | ERC-7962 托管 (半中心化) | 纯 EOA (完全去中心化) |
| --- | --- | --- | --- |
| 机构挪用资金 | 极易 (账面数字，无链上约束) | 极难 (受智能合约签名校验约束) | 不可能 |
| 拒绝服务 (冻结) | 容易 | 较难 (用户可自行寻找其他 Relayer) | 不可能 |
| 隐私泄露 | 完全泄露给机构 | 完全泄露给机构 (但对公众隐私) | 对全球公开 |

* * *

### 潜在风险点

虽然 ERC-7962 本身在数学上是安全的，但如果**机构在实现上**耍花招，仍有风险：

1.  **合约管理权限：** 如果 ERC-7962 合约本身留有“管理员后门”（Owner 权限），机构可以直接通过修改合约逻辑划转资产。所以，**合约是否开源、是否放弃管理权限**至关重要。
    
2.  **前端劫持：** 如果你使用的机构 App 是闭源的，它可能会在你签名时悄悄替换掉目标地址。这属于**操作层面的诈骗**，而非协议本身的漏洞。
    

### 总结

ERC-7962 实际上是用“执行的中心化”**（为了效率和隐私）换取了**“资产的去中心化”\*\*（通过数学签名保证安全）。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->



学习 Dapp 开发
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->




今天参加了 Monad 成都的黑客松，新的经历，挺好的。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->





欠债越来越多了：

1.  Uniswap 原理
    
2.  AAVE 原理
    
3.  Dapp 开发实战
    
4.  周六的黑客松
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->






昨天和今天两个老师分别讲了 solidity 的基础开发和 uniswap 的技术细节，我还在研究哈哈，就不写总结了。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->







这两天刚看完 Austin Griffith 大佬的 Web2 转 Web3 课程的第二周前两节，真的有一种“醍醐灌顶”的感觉。以前我觉得开发 DApp 就是写 React 前端，然后连个 MetaMask，但这两节课完全没碰前端，纯靠写脚本（Scripting）跟区块链交互。

说实话，这种“黑客视角”让我对区块链的理解深了一个层次。下面是我作为一个初学者的详细学习复盘：

### 核心感悟：原来 DApp 不只是网页

以前我总以为 DApp = 智能合约 + 网页前端。

这两节课让我明白，网页只是一个 UI 壳子。只要我有节点（RPC）和私钥，我可以用 Node.js 脚本直接跟链对话。这意味着我可以写机器人、写自动化测试、写后台服务，而不需要任何图形界面。

### 必须要懂的“三驾马车”

刚开始写代码时，我对几个概念特别晕，现在终于理清楚了：

1.  **Provider（提供者）= 只有眼睛的观察者**
    
    -   它就像是一个连接区块链的“插座”。
        
    -   它只能“读”。我想查余额、查现在的区块高度、查 ENS 域名是谁的，只用 Provider 就够了。
        
    -   它不需要私钥，也不需要消耗 Gas，因为看一眼链上数据是免费的。
        
2.  **Wallet（钱包）= 钥匙**
    
    -   它就是管理我的私钥和公钥的地方。
        
    -   但是在代码里，光有一个 Wallet 对象其实干不了啥，它得连上 Provider 才能发挥作用。
        
3.  **Signer（签名者）= 有手的执行者**
    
    -   这是最关键的概念。当把 Wallet 连上 Provider，它就变成了 Signer。
        
    -   它既能看到链上数据，又能拿私钥对交易进行“签名”并发送出去。
        
    -   凡是要花 Gas 的操作（转账、写合约），必须用 Signer。
        

### 踩过的最大的坑：单位换算

这绝对是初学者最容易崩溃的地方。在 JavaScript 里，数字一大就会出错（精度丢失），而以太坊最小单位 Wei 是 10 的 18 次方，大得离谱。

我学到了两条死命令：

1.  **给人看的时候**：用 `ethers.utils.formatEther()`。它把那串很长的 Wei 变成我们熟悉的 "1.0" ETH。
    
2.  **给机器发的时候**：用 `ethers.utils.parseEther()`。比如我想转 1 个 ETH，绝不能直接写数字 1，要转成 BigNumber 格式的 Wei。
    
3.  **千万别用 JS 做数学运算**：不要写什么 `balance + 1`，要用 `balance.add(1)`。
    

### 怎么跟智能合约“聊天”？

以前觉得调用合约很神秘，现在总结下来，其实就只要凑齐三样东西：

1.  **地址（Address）**：合约住在哪里？
    
2.  **ABI（说明书）**：合约能干什么？（有哪些函数、要传什么参数）。
    
3.  **Signer/Provider**：我是谁？（我是只是来看看，还是要改数据）。
    

代码里就是一行：

const contract = new ethers.Contract(地址, ABI, Signer);

最有意思的是，如果我调用的函数是 `read` (比如查价格)，它是瞬间返回的；但如果是 `write` (比如 mint 一个 NFT)，我就得等待。Austin 演示了 `await tx.wait()`，这种代码停在那里等矿工打包的感觉，真的非常 Web3。

### 烧脑时刻：手搓交易数据 (Raw Transaction)

Day 2 最后一波操作真的秀到我了。

平时我们调用 `contract.transfer(to, amount)` 觉得很自然。但 Austin 演示了如果不通过合约对象，怎么转账。他手动拼凑了一串十六进制数据（Hex Data）：

-   前 4 位是“函数签名”（告诉合约我要调哪个功能）。
    
-   后面接上参数的编码。
    

然后直接把这串乱码一样的 Hex 发送给合约地址，居然真的成功执行了！

这让我明白了一件事：以太坊虚拟机（EVM）其实根本看不懂函数名，它只认这些 Hex 编码。那些好用的库（Ethers.js）只是帮我们把人类语言翻译成了机器语言而已。

### 最后的保命提醒：安全！安全！

跟着做练习的时候，我差点就把带私钥的代码 push 到 GitHub 上了……

视频里反复强调 OpSec（操作安全性）。

-   私钥永远永远不要硬编码在代码里。
    
-   一定要用 `.env` 文件存私钥。
    
-   一定要把 `.env` 加到 `.gitignore` 里。
    
-   如果私钥一旦泄露（哪怕只有一秒），就要默认那个钱包废了。
    

### 总结

这两节课学完，我感觉自己从“玩钱包的用户”变成了“能控制钱包的开发者”。虽然现在只能写写脚本在测试网转转币，但这种通过代码掌控资产的感觉，真的很爽。接下来我要去研究怎么把这些脚本连到前端页面上了！
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->








作为一个最近刚开始卷 Web3 智能合约开发的新手，我把这两天跟着教程学习的心得总结一下。

### 1\. 环境搭建：Web2 的习惯，Web3 的命门

在 Web3 开发里，**Node.js** 依然是咱们的老朋友，建议用 `n` 或 `nvm` 来管理版本。初始化项目还是 `npm init`，但我发现为了代码能前后端复用，在 `package.json` 里设置 `"type": "module"` 来使用 **ES6 模块语法**（`import/export`）非常方便，这样脚本代码就能直接粘到 React 前端去用了。

**安全警告：** 在 Web2 我们习惯用 `.env` 存 API Key，在 Web3 这更是命门。**千万别把存有私钥或助记词的** `.env` **上传到 GitHub**，否则你的资产一秒钟就会被卷走。

### 2\. 核心三剑客：Provider, Signer, 和 Wallet

这是我刚上手时最容易搞混的三个概念，也是 `ethers.js` 的核心：

-   **Provider（提供者）**：它是你连接区块链的“只读”窗口。你可以通过 Infura、Alchemy 或者自己跑个本地节点（比如 Nethermind）来接入。你可以用它查余额、查区块高度，但它不能帮你签名发交易。
    
-   **Signer（签名者）**：它是拥有私钥的实体，能对交易进行数字签名。
    
-   **Wallet（钱包）**：在 `ethers.js` 里，钱包既是 Signer 也能连接 Provider。我们可以代码生成随机钱包，或者从助记词/私钥导入。
    

### 3\. BigNumber 与单位转换：拒绝溢出

这是 Web2 开发者最头疼的地方：JavaScript 的 `Number` 类型处理不了以太坊中那么大的数值（以太坊数值经常达到 $10^{18}$ 甚至更大）。

-   **BigNumber**：为了防止溢出，`ethers.js` 使用特殊的 BigNumber 对象来处理数学运算（如 `.add()` 或 `.mul()`），千万别直接转成 JS 数字做运算。
    
-   **单位转换**：1 ETH 等于 $10^{18}$ Wei。别去数 18 个零，要用内置工具：
    
    -   `formatEther`：把大数转成人类看得懂的字符串（比如 1.5 ETH）。
        
    -   `parseEther`：把人类输入的字符串转成 BigNumber（发交易必备）。
        

### 4\. 玩转智能合约：ABI 就是你的 Swagger

要跟智能合约打交道，你得有两样东西：**合约地址**和 **ABI**。

-   **ABI (Application Binary Interface)**：你可以把它理解为 Web2 里的 **API 定义文件或 Swagger**。它是一个 JSON 数组，告诉 `ethers.js` 合约有哪些函数、需要什么参数。如果合约在 Etherscan 上验证过，你可以直接把 ABI 拷下来用。
    
-   **读 vs 写**：
    
    -   **读合约**（如查询 `balanceOf`）：不需要消耗 Gas，用 Provider 就能搞定。
        
    -   **写合约**（如 `mint` 或 `transfer`）：必须通过 **Signer** 发起交易，并支付 Gas 费。如果函数标记为 `payable`，你还得在交易里塞点真金白银（ETH）。
        

### 5\. 底层逻辑：一切皆交易与 Call Data

这两天最让我“脑洞大开”的认知是：**与合约交互本质上就是发了一笔带有特殊数据的交易**。

-   **Call Data**：当你调用一个函数时，其实是往交易的 `data` 字段里填了一串十六进制数。
    
-   **Method ID**：它是函数签名（如 `mint()`）哈希后的前 4 个字节。合约节点看到这串 ID，就知道你想调哪个函数了。
    
-   **Nonce 与 Gas**：每笔交易都有一个 Nonce（序号），必须按顺序执行。如果你交易卡住了，可以用相同的 Nonce 调高 Gas 费来“加速”交易。
    

### 6\. 实操感悟：发代币交易

我们还试了在主网上给别人发 **DAI**（一种 ERC-20 代币）。这不像发 ETH 那么简单，你需要调用 DAI 合约的 `transfer` 函数。通过查看 Etherscan 上的交易详情，我亲眼看到了那串封装了接收地址和金额的 **Call Data**，这种底层掌控感太棒了。

**总结一下：** 虽然 Web3 里的各种报错信息（比如 `unpredictable gas limit`）非常玄学，但只要理清了 **Provider/Signer** 和 **ABI/Call Data** 的关系，代码写起来就比手动点 MetaMask 爽多了！
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->










今天主要是学习了Web3 实习计划中关于 **ERC-7962（Key Hash Based Tokens）** 的分享会的内容，主要内容涵盖了从传统 ERC-721 到新型隐私协议 ERC-7962 的演进。

**1\. 背景与痛点：**

-   **隐私泄露：** 传统的 ERC-721/ERC-20 标准将资产所有权与以太坊地址（Address）强绑定，导致链上行为可追踪，容易暴露用户隐私。
    
-   **用户体验（UX）门槛：** 用户必须持有 ETH 支付 Gas 费，且需要管理地址隐私，操作复杂。
    

**2\. 核心解决方案：ERC-7962**

-   **核心概念：** 提出以 **KeyHash（公钥哈希）** 而非钱包地址作为资产所有权的标识。
    
-   **解耦机制：** 将“所有权”与“交易发起者”解耦。用户只需对意图进行签名（EIP-712），任何第三方（Relayer）都可以持有 Gas 代为提交交易上链。
    
-   **覆盖范围：** 同时支持 NFT（ERC-KeyHash721）和同质化代币（ERC-KeyHash20）。
    

**3\. 技术实现要点：**

-   **验证逻辑：** 使用 ECDSA 验证签名人与链上存储的 `keyHash` 是否一致，而非校验 `msg.sender`。
    
-   **安全性设计：** 引入 `nonce` 防止重放攻击，设置 `deadline` 控制签名有效期。
    
-   **状态管理：**
    
    -   **NFT：** `tokenId` 映射到 `keyHash`。
        
    -   **FT：** 采用类似 UTXO 的风格，转账时将余额拆分给新的 `keyHash`。
        

**4\. 优缺点分析：**

-   **优势：** 增强隐私（地址不上链）、支持无 Gas 交易（代付）、支持批量操作和账户抽象。
    
-   **劣势：** Gas 成本高于传统标准、公钥在 input data 中暴露（建议配合 Key 轮换使用）、不向后兼容现有标准。
    

* * *

### 第二部分：学习笔记（编程初学者视角）

主题： 竟然可以不要“地址”？初探 ERC-7962

时间： 2026-01-18

讲师： Alex Tian

1\. 核心概念冲击：地址 $\\neq$ 身份

作为一个刚学过 Solidity 的新手，我的认知一直停留在 `mapping(address => uint256) balances` 这种结构上。也就是说，在以太坊里，“我”就是我的“钱包地址”。

但这个 ERC-7962 彻底颠覆了这个逻辑：

-   **以前：** 资产属于 `0x123...` 这个地址。只有用这个地址发交易（`msg.sender`）才能转账。
    
-   **现在：** 资产属于一个“密码锁的哈希值”（KeyHash）。谁有对应的钥匙（私钥）能签个名，谁就能转账。至于这个交易是谁发到链上的？根本不重要！
    

2\. 代码层面的“Aha!”时刻

看 PPT 里的接口定义时，我发现了一个巨大的区别：

-   **传统 ERC-721：** `transferFrom(from, to, tokenId)`
    
    -   _逻辑：_ 检查 `msg.sender` 是不是 `from` 或者被授权了。
        
-   **ERC-7962：** `transfer(tokenId, toKeyHash, key, signature)`
    
    -   _逻辑：_ 代码里完全不 check `msg.sender`！它把 `key`（公钥）拿去哈希一下，看等不等于资产现在的 owner (`keyHash`)；再用 ECDSA 验证那个 `signature` 是不是这个 `key` 签的。
        

这就像：

以前去银行取钱，必须本人（地址）带着身份证去柜台。

现在是写一张支票（签名），随便找个跑腿小哥（Relayer）拿去银行就能兑现，银行只认签名，不认跑腿小哥是谁。

3\. 还有个叫 UTXO 的东西？

在讲代币（ERC-KeyHash20）的时候，提到转账像“切蛋糕”（UTXO 风格）。

-   比如我有 100 块，要转给你 10 块。
    
-   **传统 ERC-20：** 我的余额 -10，你的余额 +10。
    
-   **ERC-7962：** 把我的 100 块“销毁”，生成两笔新钱：10 块归你的 KeyHash，90 块归我的**新** KeyHash。
    
-   _笔记：_ 为什么要换新 KeyHash？因为 PPT 说公钥在交易时会暴露，为了隐私，每次用完就换把锁，这叫“Key 轮换”。
    

* * *

### 第三部分：个人感想与思考

听完这次分享，除了技术细节，我有几点比较深的感触：

1\. 隐私与便利的博弈

我在写简单的 DApp 时，总觉得直接用 address 最方便。但是 ERC-7962 提醒了我，区块链的“透明”其实是一把双刃剑。如果我买了一个很羞耻的 NFT，或者存了一大笔钱，我不希望所有人都通过我的地址把我的底裤都扒出来。ERC-7962 这种“基于密码学所有权”而非“基于账户所有权”的思路，虽然 Gas 贵了点，但对于需要隐私的大户或者企业来说，绝对是刚需。

2\. Web3 的“用户体验”终于要正常了

之前教朋友用钱包，解释什么是 Gas、为什么要存 ETH 才能转 USDT，简直是灾难。ERC-7962 这种设计天然支持 Gas 代付。这意味着以后新用户可能根本不需要知道什么是 ETH，直接像用支付宝一样，签个名就把事办了，背后的 Gas 可以由项目方或者钱包商补贴。这才是 Mass Adoption（大规模应用）该有的样子。

3\. 兼容性的担忧

虽然技术很酷，但 PPT 也诚实地列出了缺点：不兼容现有标准。现在的 OpenSea、Uniswap 都是基于标准 ERC-721/20 的。如果发了一个 ERC-7962 的 NFT，现有的市场可能根本识别不了。这可能需要一个新的生态或者中间层来适配。

总结：

这个协议有点像是在以太坊的应用层重新造了一套“比特币式”的隐私交易系统（UTXO + 脚本验证）。作为初学者，我觉得虽然现在看代码还有点晕（特别是签名验证那块），但这种“把底层复杂度封装起来，留给用户简单体验”的思维，绝对是我以后做项目需要学习的方向。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->











主题：Ethers.js 基础与交易脚本

背景：有 Java/Python 后端经验，熟悉常规 API 调用，初次接触区块链脚本开发。

1\. 为什么选择 Ethers.js？

在 Web3 开发中，JavaScript 库是连接前端/后端与区块链节点的桥梁。虽然 Web3.js 存在时间更久，但 Ethers.js 目前似乎更受欢迎。从代码风格来看，Ethers.js 的模块化设计更好，且自带 TypeScript 定义，这对习惯强类型的 Java 开发者来说比较友好。

2\. 开发环境配置

-   **运行时**：基于 Node.js。
    
-   **模块系统**：视频中特意强调在 `package.json` 中添加 `"type": "module"` 以启用 ES6 的 `import` 语法。这比 Node 传统的 `require` 更接近 Python 的 import 风格，代码可读性更强。
    
-   **依赖管理**：
    
    -   `ethers`：核心库。
        
    -   `dotenv`：用于管理环境变量。
        
-   **安全性（关键）**：作为后端开发者，我们习惯将配置放在配置文件中。在 Web3 中，私钥（Private Key）就是最高权限的凭证。**绝对严禁**将私钥硬编码在脚本里，必须使用 `.env` 文件加载，并确保其在 `.gitignore` 列表中。这与我们在常规后端开发中保护数据库密码或 AWS Key 的逻辑一致，但风险更高（资产直接丢失）。
    

3\. 核心对象模型：Provider 与 Signer

这部分可以类比数据库连接和权限管理：

-   **Provider (提供者)**：
    
    -   **类比**：只读的数据库连接或 API 客户端。
        
    -   **功能**：负责连接区块链节点（如 Infura 或 Alchemy）。通过它我们可以读取链上数据（区块高度、余额、ENS 解析），但无法修改状态。
        
    -   **底层**：本质上是对 JSON-RPC 接口的封装。
        
-   **Signer / Wallet (签名者/钱包)**：
    
    -   **类比**：拥有“写”权限的认证用户 session。
        
    -   **功能**：持有私钥，用于对交易数据进行密码学签名。
        
    -   **逻辑**：区块链上的任何状态改变（转账、调用合约写方法）都需要消耗 Gas 并经过数字签名验证。`Wallet` 类通常继承自 `Signer`。
        

4\. 数据类型的大坑：BigNumber

这是从 Python/Java 转到 JavaScript 开发 Web3 最不适应的一点。

-   **问题**：以太坊的最小单位 Wei 是 $10^{18}$ 级别。JavaScript 的 `number` 类型基于 IEEE 754 双精度浮点数，会有精度丢失问题（类似 Java 的 `double` 或 Python 的 `float`）。
    
-   **解决方案**：Ethers.js 提供了 `BigNumber` 类（类似 Java 的 `BigDecimal` 或 Python 原生的无限精度 `int`）。
    
-   **最佳实践**：
    
    -   严禁使用 JS 原生运算符（`+`, `-`）直接操作涉及金额的数字。
        
    -   **格式化**：`ethers.utils.formatEther(bn)` —— 将链上的 BigNumber (Wei) 转换为人类可读的 String (ETH)。
        
    -   **解析**：`ethers.utils.parseEther("1.0")` —— 将字符串 (ETH) 转换为链上可用的 BigNumber (Wei)。
        

5\. 交易流程与异步处理

视频演示了一个从测试网（Rinkeby）发送 ETH 的脚本。流程如下：

1.  **初始化**：实例化 Provider，通过私钥实例化 Wallet 并连接 Provider。
    
2.  **构建交易**：定义接收方（`to`）和金额（`value`）。有趣的是，Ethers.js 支持直接传入 ENS 域名（如 `xx.eth`），库内部会自动解析为十六进制地址，类似 DNS 解析。
    
3.  **发送与等待**：
    
    -   `wallet.sendTransaction(tx)`：将签名后的交易广播到网络内存池（Mempool）。
        
    -   `await tx.wait()`：**关键步骤**。这与常规 HTTP 请求不同，HTTP 返回 200 通常意味着成功，但在这里，广播成功不代表交易成功。必须等待矿工打包并产出区块。这个 `await` 实际上是在轮询链上状态，直到确认交易被包含在某个区块中。
        

6\. 总结与思考

今天的脚本编写解开了之前使用 MetaMask 时的黑盒逻辑。从代码层面看，区块链交互本质上就是：

构建数据 -> 私钥签名 -> RPC 广播 -> 异步轮询确认。

作为初学者，最大的风险点在于私钥管理和数值精度控制。接下来的重点应该是学习如何通过脚本与智能合约（ABI 接口）进行更复杂的交互。

**To-Do List:**

1.  在测试网申请更多测试币。
    
2.  尝试写一个脚本，批量查询一组地址的余额。
    
3.  深入理解 JS 的 Promise 和 async/await 机制，这在处理链上异步事件时至关重要。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->












# 脚本编写与智能合约交互

* * *

### 一、 开发环境准备与 Ethers.js

1.  **Node.js 与版本管理：** 建议使用 `n` 或 `nvm` 等版本管理器，以便在不同项目间切换 Node 版本。
    
2.  **项目初始化：** 通过 `npm init` 创建项目，并在 `package.json` 中设置 `"type": "module"`，这样可以使用 **ES6 模块导入（Import）** 和 **顶级 await（Top-level await）**，增加代码的可移植性。
    
3.  **Ethers.js 库：** 这是一个轻量级的 JavaScript 辅助库，用于与以太坊通信。它提供了处理大数字（BigNumber）、格式化数据、管理钱包和连接智能合约的工具。
    
4.  **环境变量安全：** 使用 `.env` 文件配合 `dotenv` 库来存储 API 密钥和私钥，并通过 `.gitignore` 确保这些敏感信息不会上传到 GitHub。
    

### 二、 核心概念：提供者 (Providers) —— “只读”窗口

**Provider** 是你连接以太坊网络的节点接口，它仅允许**读取**区块链数据。

-   **实践应用：**
    
    -   **获取节点：** 可以使用自建节点（如 Austin 背后的硬件节点）、第三方服务（Infura、Alchemy）或 ethers 的默认提供者（仅用于测试）。
        
    -   **基本查询：** 通过 `provider.getBlockNumber()` 获取当前区块高度，验证连接是否存活。
        
    -   **ENS 解析：** 使用 `provider.resolveName("atg.eth")` 将域名转换为地址，或用 `provider.lookupAddress(address)` 进行反向查询。
        

### 三、 核心概念：大数字 (BigNumber) 处理

以太坊的数值远超 JavaScript 的安全整数范围。

-   **实践应用：**
    
    -   **格式化：** 使用 `ethers.utils.formatEther(wei)` 将巨大的 Wei 转换为人类可读的 ETH 单位。
        
    -   **解析：** 使用 `ethers.utils.parseEther("1.5")` 将用户输入的 ETH 字符串转换为机器处理的 BigNumber。
        
    -   **数学运算：** 不能使用标准的 `+` 或 ，必须使用 BigNumber 对象的内置方法，如 `.add()` 或 `.mul()`。
        

### 四、 核心概念：钱包 (Wallets) 与 签名者 (Signers) —— “读写”权限

**Signer** 拥有私钥，可以对交易进行加密签名。**Wallet** 是 Signer 的一种具体实现。

-   **实践应用：**
    
    -   **创建钱包：** 可以通过 `Wallet.createRandom()` 随机生成，或从助记词（Mnemonic）结合路径（Path）派生出多个账户。
        
    -   **私钥导入：** 可以通过 `new ethers.Wallet(privateKey)` 将现有私钥导入脚本（需注意去除 0x 前缀或确保变量非空）。
        
    -   **离线签名：** 即使不连接 Provider，Wallet 也可以离线签名消息（ECDSA），用于身份验证或离线交易准备。
        

### 五、 综合实践：发送交易 (Transactions)

发送一笔交易需要将 **Signer** 连接到 **Provider**，从而获得“发送”到网络的能力。

1.  **构造交易：** 确定接收者（To）和金额（Value）。如果接收者是 ENS 域名，必须先通过**主网 Provider** 解析出地址（即便是在测试网上发交易）。
    
2.  **两阶段等待：**
    
    -   `await signer.sendTransaction(tx)`：等待交易发送到**内存池（Mempool）**，此时你会获得交易哈希（Hash）。
        
    -   `await tx.wait()`：等待交易被矿工打包并**上链（Mined）**，这才是交易最终成功的标志。
        
3.  **调试技巧：** 当交易失败或地址解析为 `null` 时，可能会意外地执行“合约创建”操作，务必在发送前打印调试信息。
    

### 六、 新奇见解与进阶心得

-   **性能差异：** 连接自己的本地节点（如 Nethermind）比使用 Infura 等公共 API 快得多，适合需要大规模抓取数据的场景。
    
-   **跨网络挑战：** 一个脚本可能需要同时管理多个 Provider（例如用主网 Provider 查 ENS，用测试网 Provider 发交易），这是 Web3 开发者常遇到的逻辑复杂点。
    
-   **盲点清除：** 脚本编写能让我理解 Metamask 背后发生的细节（如 Nonce、Gas 估计），从而从普通用户进化为“权力用户”。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->













# Day4 ENS, DEX, Identity, Inventory, Sybil

以太坊身份识别（Identity）、资产清单（Inventory）以及去中心化服务交互的核心知识。通过这些工具，用户可以在 Web3 世界中建立跨平台的持久化身份。

* * *

### 一、 核心概念：Web3 身份与 ENS

1.  **账户派生：**
    
    -   在 MetaMask 中，基于同一个助记词（Seed Phrase）可以派生出无数个不同的账户地址。这为用户在不同场景下使用不同身份提供了便利。
        
2.  **ENS (以太坊域名服务) —— Web3 的“名片”：**
    
    -   **定义：** 类似于 Web2 的 DNS（将 IP 映射为域名），ENS 将复杂的以太坊地址（如 `0xae94...`）映射为易记的名称（如 `sanfordstout.eth`）。
        
    -   **反向解析 (Reverse Record)：** 这是一项关键设置，允许应用程序在用户登录时从地址反查出对应的 ENS 名称并进行展示。
        
    -   **持久性：** ENS 是跨平台的。一旦设置完成，无论是登录 Uniswap、Etherscan 还是 Zapper，你的身份和名称都会随你流动。
        

* * *

### 二、 交互逻辑：DEX 与 自动化做市商 (AMM)

1.  **CEX vs. DEX：**
    
    -   **中心化交易所 (CEX)：** 基于订单簿（Order Book）系统，本质上是一个记录买卖意愿的中心化数据库。
        
    -   **去中心化交易所 (DEX)：** 如 Uniswap，是运行在以太坊上的智能合约。它不依赖中心化服务器，而是通过合约内储备的代币对进行兑换。
        
2.  **“自动售货机”比喻：**
    
    -   Austin 将 DEX 比作**不可停止且抗审查的自动售货机**。
        
    -   其运作机制像一个天平：合约中存有等价值的两种代币（如 ETH 和 DAI）。当你放入 ETH 时，天平倾斜，你必须拿走相应价值的 DAI 来使天平重新平衡。这种自动调整价格的机制被称为“价格函数”。
        
3.  **流动性提供者 (LP)：** 任何人都可以向这些储备池提供代币并成为流动性提供者，从而在他人进行兑换时赚取手续费。
    

* * *

### 三、 稳定币机制：以 DAI 为例

为了规避加密货币的价格剧烈波动，Web3 引入了稳定币（如 DAI）。

-   **超额抵押：** DAI 的生成通常是通过抵押 ETH 等资产获得的**超额抵押贷款**。例如，抵押价值 100 美元的 ETH 可能只能借出 60 美元的 DAI。
    
-   **稳定性维护：** 通过智能合约的铸造和销毁机制，以及二级代币（如 Maker）的调节，DAI 努力将其价格锚定在 1 美元。
    
-   **清算机制：** 如果抵押品（ETH）的价格下跌到不足以支撑借出的 DAI，合约会自动触发清算逻辑以保护系统安全。
    

* * *

### 四、 比较新奇的内容与进阶洞察

1.  **ENS 实际上是早期的 NFT：** 虽然人们常将 ENS 视为域名，但它在技术底层上是**非同质化代币（NFT）**。注册域名的过程本质上是铸造（Mint）了一个唯一的 Token ID。
    
2.  **“提交-揭示”（Commit-Reveal）防抢注机制：**
    
    -   为了防止机器人通过监视交易池（Mempool）并在同一区块内以更高昂的 Gas 费抢注你想要的域名，ENS 采用了两步走战略。
        
    -   用户先发送一个加密的“承诺”（Commit），等待至少一分钟后再发送“揭示”（Reveal）交易。这种博弈论设计确保了注册过程的公平性。
        
3.  **女巫攻击（Sybil Attack）与身份得分：**
    
    -   在 Web3 中伪造身份极其简单（如本课随机生成的 `sanfordstout.eth`），因此证明一个地址背后是“真实人类”是一个难题。
        
    -   **新颖的解决思路：** 目前许多项目不再依赖顶层认证，而是通过**行为评分**。例如，检查该地址是否参与过链上投票、是否签署过消息或是否有频繁的人类交互记录。评分越高，代表其越像“真人”。
        
4.  **资产清单（Inventory）的透明性：**
    
    -   借助 Zapper 等工具，只需输入一个 ENS 域名，即可查看该身份名下的所有代币、流动性池份额甚至历史记录。这展示了 Web3 数据的开放性：你的资产不再锁在某个公司的服务器里，而是跟随你的身份公开存在于区块链上。
        

# Day4 NFT

本节课的主题是 **NFT（非同质化代币）**。通过实际操作买卖、铸造（Mint）以及分析代码，深入探讨了数字所有权、元数据存储以及 Web3 的抗审查特性。

* * *

### 一、 NFT 的核心定义与价值

-   **什么是 NFT：** 全称为 Non-Fungible Token，代表一种**独特的数字所有权**。与可以互相替换的代币（如 ETH）不同，每个 NFT 都是独一无二的。
    
-   **链上溯源（Provenance）：** 艺术家在链上铸造作品，所有人都能验证该作品是否出自原作者之手。这种**真实性**和**社区归属感**是 NFT 价值的核心，即使他人复制了图像，也无法复制其链上的所有权记录。
    
-   **身份与清单的流动性：** 你的 NFT（如 ENS 域名）就是你的 Web3 身份。无论你切换到哪个平台（OpenSea, Zapper, Rarible），你的**资产清单（Inventory）都会随你而去**，体现了以用户为中心的数据逻辑。
    

* * *

### 二、 技术底层：ERC-20 vs ERC-721

理解这两者的区别是掌握 Web3 的关键：

-   **ERC-20（同质化代币）：** 像银行账本一样记录**余额（Balance）**。当 A 发送 50 个代币给 B，合约只是在 A 的余额里减去 50，给 B 加上 50。所有代币都是一样的，像黄金或石油一样可以混合。
    
-   **ERC-721（非同质化代币）：** 像收集棒球卡，合约记录的是**每个唯一索引（Token ID）的持有者（Owner）**。转移资产时，是修改特定 ID 对应的所有者地址。
    

* * *

### 三、 NFT 的存储机制：链上 vs 链下

NFT 并不是将图片直接“塞”进区块链，通常有以下两种方式：

1.  **IPFS（星际文件系统）—— 链下存储：**
    
    -   **内容寻址（Content Addressable）：** 文件的地址是由其内容的哈希值决定的。如果内容发生微小变化，哈希地址也会完全改变。
        
    -   **不可篡改性：** 这种机制确保了 NFT 指向的元数据（Metadata）是**不可更改的（Immutable）**。
        
    -   **局限性：** 虽然是点对点存储，但如果没人继续“固定”（Pin）这些数据，内容可能会丢失。
        
2.  **On-Chain SVG —— 全链上存储：**
    
    -   将图像代码（如 SVG 标签）直接写在智能合约中。
        
    -   **优势：** 具有极强的**可组合性（Composability）**。例如，NFT 的颜色或形状可以根据链上变量（如持有时间、买卖热度）实时改变。
        
    -   **劣势：** 存储成本极其昂贵，通常被视为一种“技术炫技”或艺术尝试。
        

* * *

### 四、 实用技巧与风险防范

-   **直接与合约交互：** 如果前端网站挂了，你可以通过 **Etherscan 的“Write Contract”** 功能直接铸造 NFT（前提是合约已验证）。
    
-   **验证的重要性：** 在发送资金前，应检查合约是否在 Etherscan 上开源并获得“绿色对勾”验证。**不透明的合约是巨大的红旗（Red Flag）**。
    
-   **警惕“Web2 式审查”：** 并不是所有 Web3 应用都完全去中心化。有些平台（如 Foundation）会重度筛选（Curate）显示的内容，甚至不显示某些符合标准的 NFT。
    
-   **防止被“Rug”：** 如果一个 NFT 的数据存储在中心化服务器（私有服务器）而非 IPFS，开发者可以随时更换你拥有的图像，这构成了安全弱点。
    

* * *

### 五、 新奇洞察：Web3 的赋能

-   **创作者经济：** NFT 允许艺术家跳过中间人（如 Spotify），直接连接并变现其“核心粉丝”。
    
-   **版税逻辑（Royalties）：** 开发者可以将**版税规则直接写进代码**，确保艺术家的二次销售收益能自动拨付，而不需要依赖中介平台的信誉。
    
-   **可组合的游戏道具：** 如 Loot 项目，它只提供属性描述，具体的游戏场景和表现形式交由社区开发者去自由创造，展示了 Web3 的**免许可协作**魅力。
    

# Day5 交易、Gas、L2 与多签钱包

本周课程通过一系列实战操作，展示了 Web3 用户从基础操作向“权力用户”（Power User）进阶的过程。重点在于理解以太坊交易的底层机制，以及如何处理 Web3 中常见的“挫折时刻”。

* * *

### 一、 交易、Gas 与 Nonce 深度理解

1.  **Gas 机制：出价与执行**
    
    -   **Max Fee（最高费用）：** 相当于你在区块空间拍卖中的“竞价”。矿工/验证者是贪婪的，他们会优先选择出价最高的交易进入内存池（Mempool）。
        
    -   **Gas Limit（Gas 限制）：** 决定了程序执行的步数。每一步链上操作（如存储、计算）都会消耗 Gas，设置限制是为了防止程序进入死循环（停机问题）。
        
    -   **EIP-1559 后的费用：** 交易费由基础费（Base Fee）和优先费（Priority Fee，即小费）组成。通常设置 1.5 到 2 Gwei 的优先费即可确保交易顺利进行。
        
2.  **Nonce（随机数）：交易的顺序**
    
    -   **定义：** 每个账户发送的每笔交易都有一个唯一的 Nonce，代表这是该账户的第几笔交易。
        
    -   **顺序性：** 交易必须按 Nonce 顺序执行。如果 Nonce 为 6 的交易因为 Gas 给得太低而卡住，Nonce 为 7 及以后的交易即便给再高的 Gas 也无法先行通过。
        

* * *

### 二、 故障排除：处理“卡住”的交易

1.  **加速与取消：**
    
    -   **加速（Speed Up）：** 发送一笔具有相同 Nonce 但 Gas 费用更高的交易，覆盖原交易。
        
    -   **取消（Cancel）：** 发送一笔相同 Nonce、高 Gas 且金额为 0 的交易（通常是发给自己），抢在原交易前被打包。
        
2.  **MetaMask 重置（Reset Account）：**
    
    -   **作用：** 这是一项高级功能，可以清除 MetaMask 的交易历史和本地缓存的待处理交易，但**不会清空你的资产或私钥**。当 MetaMask 显示的 Nonce 与链上不一致或钱包出现逻辑错误时，可以使用此功能。
        

* * *

### 三、 二层网络 (L2) 与跨链桥

1.  **为什么要用 L2（如 Optimism）：**
    
    -   **优势：** L2 的交易速度极快且费用低廉（通常只需几美分），同时继承了以太坊 L1 的安全性。
        
    -   **跨链体验：** 通过跨链桥（Bridge）将资产从 L1 转移到 L2 时，会经历一个资产在两边都不可见的“真空期”，这属于正常现象。
        
2.  **网络配置：** 切换到 L2 通常需要手动或通过 dApp 引导添加 RPC URL 和 Chain ID（如 Optimism 的 Chain ID 是 10）。
    

* * *

### 四、 DeFi 与智能合约交互实操

1.  **ERC-20 的“批准”（Approve）模式：**
    
    -   当你使用代币（如 DAI）在 DEX 交易或在 Aave 借贷时，必须先发送一笔“Approve”交易，授权智能合约调用你的代币，然后再发送第二笔实际的交互交易。
        
2.  **直接通过 Etherscan 交互：**
    
    -   不通过项目前端，直接在 Etherscan 的合约页面调用函数。例如，DAI 合约使用了一些缩写的变量名，如 `wad`（金额）和 `xt`（目的地）。
        
3.  **借贷逻辑（Aave）：**
    
    -   抵押资产（如 ETH）会换回凭证代币（如 aWETH）。注意**清算风险**：如果抵押品价值下跌，你的头寸可能被清算。
        

* * *

### 五、 新奇内容与进阶洞察

-   **多签钱包（Gnosis Safe）：**
    
    -   这是一种基于智能合约的钱包，通过 **M-of-N（如 4 人中需 2 人签名）** 的逻辑工作。它消除了单点故障风险：即便一个私钥丢失或泄露，资金依然安全。
        
-   **WalletConnect 的神奇用法：**
    
    -   可以将多签钱包（Safe）通过 WalletConnect 连接到普通的 dApp（如 Uniswap）。当你点击交换时，dApp 会生成一个请求发送到多签管理界面，由多位签署人进行离线投票并最终执行。
        
-   **“浮动”交易（Floating Transaction）：**
    
    -   Austin 提到的技巧：在深夜 Gas 费较低时，手动设置一个极低的 Gas（如 10 或 11 Gwei）并发送，让交易在内存池中“漂浮”，直到全网 Gas 下降到该水平时自动成交。
        
-   **对抗性思维：** Web3 的用户体验虽然有时很糟糕（如 ENS 在 L2 上不普及、MetaMask 报错），但这也正是构建者的机会所在。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->














### Todo List:

-   学习以太坊第一章上下的混淆概念
    
-   《021》第2章+第3章
    
-   攻防挑战
    
-   分享会：合规
    
-   分享会：安全
    

# 分享会

## 安全

Q11：2025年Web3安全攻击呈现出哪两个截然不同的主要趋势？

A：

1.  **精准猎杀 (Targeted Hunting)：** 针对头部交易所、高净值用户或特定协议，进行精心策划、长期潜伏的攻击（如针对Bybit的攻击） 。
    
2.  **广撒网 (Broad Casting)：** 针对普通用户的大规模自动化攻击，如Rug Pull工厂、钓鱼网站、批量私钥窃取 。
    

Q12：Bybit交易所损失15亿美金的案件中，黑客采取了什么高明的攻击手段？

A： 黑客没有直接攻击Bybit，而是渗透了其使用的多签管理服务商Safe的前端开发人员 。黑客并未进行广撒网攻击，而是精准针对Bybit的几个管理账号植入恶意代码，使得管理人员在看到的交易界面是正常的，但在签名时实际上签署了被篡改的恶意交易 。

Q13：UxLink事件中，黑客是如何利用“AI深度伪造 (Deepfake)”进行社会工程学攻击的？

A：

-   **建立联系：** 黑客首先在Telegram上冒充合作伙伴或投资人，与项目高管建立联系 。
    
-   **视频会议欺诈：** 双方约定视频会议，黑客利用Deepfake技术伪造面容和声音，让高管误以为对方是真实的合作伙伴 。
    
-   **植入恶意软件：** 在获取信任后，黑客在会议中发送精心伪造的链接（如虚假的会议软件下载链接），诱导高管下载安装，从而控制其设备 。
    

Q14：什么是“地址投毒 (Address Poisoning)”攻击？其核心原理是什么？

A：

-   **原理：** 攻击者通过脚本生成一个与用户常用转账目标地址“首尾字符完全相同”的黑客地址 。
    
-   **手段：** 向用户钱包发送小额资金或伪造的USDT（其实是无价值代币），使该黑客地址出现在用户的交易历史中 。
    
-   **目的：** 利用用户只核对地址首尾的习惯，诱导用户在下次转账时直接从历史记录中复制该黑客地址，导致资金转错 。
    

Q15：以太坊EIP-7702升级引入了什么样的新型钓鱼风险？

A：

-   **机制变化：** EIP-7702赋予了普通地址（EOA）智能合约的能力，允许地址进行“委托（Delegate）”操作 。
    
-   **攻击手法：** 攻击者诱导用户签署一个恶意的Delegate权限。一旦签署，即使黑客没有私钥，也能通过代码逻辑设置“一旦该地址收到资金，自动转走” 。
    
-   **欺诈场景：** 黑客甚至会故意泄露一些已经签署了恶意Delegate的地址私钥，诱骗受害者以为捡到了有钱的钱包，当受害者转入Gas费或代币想提现时，资金会被瞬间自动转走 。
    

Q16：什么是“软件供应链攻击”？在AI编程时代有何新特点？

A：

-   **定义：** 攻击者不是直接攻击目标软件，而是在软件依赖的插件、代码库或开发工具中植入恶意代码（如Trust Wallet浏览器插件曾被植入后门） 。
    
-   **AI时代特点：** 开发者使用AI辅助编程（AI Coding）时，如果过度依赖AI生成的代码且未做人工审查，可能会自动引入带有恶意逻辑的代码库或插件，因为AI可能并未识别出这些库的安全性问题 。
    

Q17：针对Web3新用户，安全专家建议的“四不大法”具体指什么？

A：

1.  **不点：** 不轻易点击Telegram、Zoom、微信等发来的不明链接，需多方验证 。
    
2.  **不签（绝不盲签）：** 钱包弹出签名请求时，必须看懂签名内容（是授权还是转账），拒绝不明就里的签名 。
    
3.  **不装：** 不通过他人发送的链接安装软件，必须去官方渠道下载 。
    
4.  **不转：** 转账前仔细核对完整地址，不轻信所谓的“高回报矿池”或代投骗局 。
    

## 合规

Q1：在中国大陆，“发币”这一行为本身是否直接构成犯罪？

A： 不一定。如果只是单纯为了好玩发一个币（如Meme币），没有进行后续的“公开融资”行为，通常不触犯违法犯罪风险 。大陆主要打击的是借发币进行的“公开融资”行为（ICO）。

Q2：为什么虚拟货币交易所的“永续合约”业务在中国大陆极易被定性为“开设赌场罪”？

A：

-   办案单位往往不懂虚拟货币技术，会将合约交易中“买涨买跌”的模式简单理解为“押大小”的赌博行为 。
    
-   与传统金融（股票、期货）不同，交易所若未设置“买定离手”机制，且对风险控制权掌握在开盘人员手中，更容易被视为赌博而非金融活动 。
    
-   交易所被视为赌博网站，运营人员则被视为开设赌场的人员 。
    

Q3：技术人员（程序员）在涉币案件中能否以“技术中立”作为无罪辩护理由？

A： 很难。虽然技术人员常辩解自己只负责代码、处于中立状态，但办案单位通常能找到司法解释，将为赌博软件提供技术支持的人员认定为“共犯” 。

Q4：在中国大陆，“虚拟货币挖矿”是否还有合规的操作空间？

A： 有一定空间。虽然有政策禁止，但在实际操作中，部分项目方通过转型为“AI超算中心”的名义与政府签协议，甚至获取政策福利 。算力可以合规地以外贸形式卖给海外，只要能说明海外人员是用于AI支持而非单纯挖矿即可 。

Q5：个人在出金（将U换成法币）时，什么是“路径攻击”或“反向洗钱”风险？

A： 这是一种新型风险。由于海外洗钱成本增加，犯罪分子（车队）会故意将通过欺诈等手段获得的“赃款”（人民币），打入正常的求职者或晋升者账户，甚至要求受害人向指定账户转账 。这会导致受害人的账户因接收赃款而被公安冻结或立案 。

Q6：使用“U卡”（加密货币借记卡）存在哪些具体的资金安全风险？

A：

-   **挂靠风险：** 某些发卡方是将用户挂靠在一家公司名下作为“员工”，一旦该公司被查，用户资金会被牵连冻结 。
    
-   **资金池风险：** 部分发卡方背后其实是几个合伙人控制的多签钱包，用户充值的钱实际上进了这个私人的池子。如果合伙人闹矛盾、账户被冻结或卷款跑路，用户的卡将无法使用 。
    

Q7：什么是“配侦公司”？它们对Web3项目方构成什么威胁？

A： “配侦公司”是与公安合作的技术公司，拥有强大的链上数据分析能力 。它们会主动分析在大陆展业的项目方资产归集地址，甚至派人入职项目方进行证据固定（卧底），然后向公安举报以获取线索奖励（返点） 。

Q8：如果为海外持牌的Web3交易所远程工作，如何判断自己是否有法律风险？

A：

-   **牌照含金量：** 仅有美国MSB牌照可能不够，因为其合规门槛相对较低 。
    
-   **是否隔离大陆：** 需验证该交易所是否屏蔽了大陆IP，是否允许使用大陆手机号/邮箱注册 。如果未做隔离且允许大陆用户注册，即使公司声称不展业，员工仍面临风险 。
    
-   **业务板块：** 如果工作内容涉及合约、期权等高风险板块，风险等级较高 。
    

Q9：Web3公司若用USDT给大陆员工发工资，会产生什么劳动法层面的后果？

A： 存在极大隐患。曾有案例显示，员工离职后仲裁称未收到工资。由于大陆不支持虚拟货币的法偿性，仲裁机构可能不支持USDT作为工资支付凭证，导致公司被判需用人民币重新支付一遍工资 。

Q10：如果由于出金导致银行卡被冻结（冻卡），应该如何应对？

A：

-   **初次冻结：** 如实向办案单位说明情况，提供交易记录证明是正常生意或兼职收入，通常做个笔录后问题不大 。
    
-   **多次冻结：** 如果屡次因出金涉及赃款被冻结，办案人员可能会推断你“明知”资金来源有问题，从而倾向于认为你涉嫌犯罪 。
    
-   **退赔解冻：** 在某些情况下，为了尽快解冻账户以恢复生意，当事人可能需要与公安协商，退还涉案的赃款部分
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
















## 1 理论学习

src：[021 学习以太坊第 1 章](https://github.com/XiaoHai67890/021Ethereum/blob/main/%E3%80%8A021%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E3%80%8B%E5%BC%80%E6%BA%90%E6%95%99%E6%9D%90.pdf)

1.  以太坊的起源于发展
    
2.  以太坊平台定位
    
3.  核心特性：智能合约、Dapp、Token、PoS、Gas
    
4.  分片。
    

-   在 Dencun 升级之后的新特性。通过引入 blob-carrying transactions。blob 数据可以比喻为“小挂车”，挂在主车（普通以太坊交易）上。主车（L1 状态）保持轻量，而 L2 的数据传输成本大幅降低。
    
-   目的：给 Rollup 提供临时数据、通过部分数据闲置后的丢弃以减轻 L1的存储压力。
    
-   效果：L2发布数据的成本大幅下降，Rollup 的交易费用下降90%以上。
    

5.  协议层的 ETH
    

-   Gas：即手续费，所有交易都要给这个钱。
    
-   Pos 质押保证金：validator 需要质押的 ETH 金额。恶意的 validator 会被 slash。质押保证金越多，攻击成本越高。
    

6.  应用层的 ETH 的作用：
    

-   是记账单位，是结算货币，是链上现金
    
-   是抵押品
    
-   NFT 铸造与交易货币。
    

## 2 实践

1.  Mint第一个NFT。【完成】
    
2.  Dapp 开发的工具安装和基本操作学习。
    

## 3 分享会

1.  一笔交易的生命周期：Wallet签名、RPC传播该交易、排队、Validator 挑选、Block 落盘、查询。
    
2.  gas fee 越多，出块越快吗？
    
3.  验证服务器所在地，根据服务器数量排序：美国 > 德国 > 中国。
    
4.  对于验证客户端，validator 会用占比小的客户端以降低大占比的影响。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


















# 开营

### 大神太多

能入选实习计划，我很高兴，觉得自己距离进入 web3 行业又进了一步。开营也是也挺热闹的，出乎意料地是，非常多的大神，包括但不限于地产高管、律师、雅思大神、代码大神、各种英美澳加的留学生，觉得自己更得努力了。学习内容很密集，每天应该都会过得很充实。

### 选择加密就是选择未来

最近一直在看《主权个人》，真的是让我脑子一次次 shock 到。Crypto 的“私钥即身份”“代码即宪法”的属性，真是《主权个人》描述的世界——暴力垄断的失效、个体凭借加密技术获得真正主权、摆脱地域与制度约束，amazing！

还有xiaohai 老师在群里提到 infinite garden 的提法来自于《有限与无限的游戏》，这不是巧了吗？也是我在看的书，其中的关于“无限游戏”的哲学也很 shock 我，Crypto 仍然是个无限游戏，延续它自身就是它的玩法。

# 做中学

今天正式开始残酷共学第一天，还没适应，只能赶紧调整好状态。主要做了这些：

1.  测试网任务，send 以太坊测试币给他人。
    
2.  认真的开始看以太坊的技术文档第一章，发现了一个 web3和 web3.0的区别：
    

-   Web3.0：构建实体间的语义关系网络。包括本体工程、语义查询语言（SPARQL）、链接数据等典型技术。【是不是 Palantir 采用的“本体论”？】
    
-   Web3：去中心化互联网。也就是我们所在的产业的名字。
    

3.  Side project：这几天在 vibecoding 一个自己的加密资产监控面板，虽然是学 X 上大神的想法，但是突然觉得 ai 对于我的意义就在于加速了 idea-build-launch 这个过程爽。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
