---
timezone: UTC+8
---

# fortune

**GitHub ID:** fca2025774696-art

**Telegram:** @fortune_119

## Self-introduction

一个web3数字游民，本科在读，渴望学习

## Notes

<!-- Content_START -->
# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->
Hardhat部署与交互流程回顾

[https://www.notion.so/Hardhat-2f56783dcc81805aa86ee3cf0cb940e5?source=copy\_link](https://www.notion.so/Hardhat-2f56783dcc81805aa86ee3cf0cb940e5?source=copy_link)

Foundry部署与交互流程回顾

[https://www.notion.so/2f56783dcc8180298e86cc537690384b](https://www.notion.so/2f56783dcc8180298e86cc537690384b)
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->

# Web3投研分析的主要框架

### 1\. 7步評估框架 (The 7 Step Framework)

1.  **團隊 (Team)：**
    
    -   **核心：** 投資項目本質上是投資於人。需查看創始人的過往記錄、資歷（如 Google、Apple 等名企背景）以及是否有知名風投（如 a16z、Sequoia）背書。
        
    -   **紅旗 ：** 匿名團隊且缺乏可信背景、僅由名人代言但無實質投入。
        
2.  **產品與增長 (Product & Traction)：**
    
    -   **核心：** 查看用戶體驗（UX）和鏈上數據。關鍵指標包括：活躍錢包數、註冊用戶數、每日/每週成交量及其增長率。
        
    -   **紅旗：** 代碼未經審計、UI/UX 極差（難以留存用戶）、存在大量虛假交易。
        
3.  **社區與治理 (Community & Governance)：**
    
    -   **核心：** 社區質量重於數量。需深入 Discord 和 Twitter 觀察對話是否有意義，而不僅僅是討論幣價。
        
    -   **紅旗：** 伺服器人數眾多但無實際互動（多為機器人）、成員只關心價格。
        
4.  **代幣經濟學 (Tokenomics)：**
    
    -   **核心：** 考慮代幣的激勵機制、供應量分佈及如何促進網絡參與度與安全性。
        
5.  **安全性 (Security)：**
    
    -   **核心：** 智能合約審計是關鍵。了解項目所處區塊鏈的安全性及其過往是否有漏洞或宕機記錄。
        
    -   **紅旗：** 代碼實踐粗糙、曾發生資金遺失或數據操縱。
        
6.  **願景與路線圖 (Vision and Roadmap)：**
    
    -   **核心：** 路線圖應具備雄心且務實。例如 NFT 項目是否通過元宇宙或 IP 授權來增加代幣效用（Utility）。
        
    -   **紅旗：** 堆砌熱門詞彙（如「基於 NFT 的元宇宙 DAO」）、抄襲其他項目的發展藍圖。
        
7.  **市場機會 (Market Opportunity/TAM)：**
    
    -   **核心：** 評估市場規模（Total Addressable Market）。項目是解決了實際問題，還是「拿著錘子找釘子」？
        
    -   **紅旗：** 需求極低、市場定位過於狹窄且難以擴展。
        

* * *

### 2\. 不同領域的成功指標

文章指出 Web3 的不同子行業應使用不同的衡量標準：

-   **NFTs：** 關注系列收藏品的總市場價格（Combined Market Price）。
    
-   **DeFi：** 關鍵指標為 **總鎖定價值 (TVL)**。
    
-   **遊戲 (Gaming)：** 關注交易量（Transactional Volume），反映玩家的參與度和活躍度。
    
-   **DAOs：** 查看社區收入（服務型 DAO）或社區參與熱度（社交型 DAO）。
    

### 3\. 已代幣化 vs 未代幣化項目

-   **已代幣化：** 有公開交易市場，價值由市場供需決定。
    
-   **未代幣化：** 類似早期初創公司，價值主要基於風投（VC）的預期和股權估值。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->


代币经济学分析需要注意的5点:

1.代币分配模型

代币在创始人及团队 投资者 公众与社区之间的分配情况

2.代币通胀型/通缩型

代币设计目的是随着时间推移增加供应量（奖励网络参与者推动其普及），还是采用销毁机制来减少供应量（减少供应来造成价格上涨压力）

3.治理代币

项目提供治理代币，持有者拥有对协议变更的投票权。

4.归属计划和长期利益一致性

代币有具体的解锁时间表，项目会利用股权归属计划来协调创始人，早期投资者和社区成员之间的激励机制

-   代币会随着时间推移逐步解锁
    
-   防止产品发布后出现大规模抛售压力
    
-   鼓励主要利益相关者做出长期承诺
    

5.实用代币分析

代币的实际效用对长期价值有影响

-   该代币在其生态系统中发挥什么作用
    
-   功能是否必有且有价值
    
-   无需令牌能否执行此函数
    

6.代币的供需动态

最大供应量/流通供应量/发行计划

注意其完全稀释估值
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->



DoS攻击类型：

1\. 数组无限增长：

\- 攻击者创建大量账户调用participate()

\- 数组变得巨大，操作耗gas

\- 可能使selectWinner()无法执行（超出gas限制）

2\. 外部调用失败导致状态锁定：

\- selectWinner()中：先更新状态，后转账

\- 如果转账失败（例如winner是合约且没有receive函数）

\- contestEnded不会被设置为true

\- 合约永远锁定，无法选出新获胜者

3\. Gas限制攻击：

\- 循环遍历大数组可能超出区块gas限制

\- 某些函数可能永远无法成功执行

4\. 区块gas限制攻击：

\- 某些操作必须在单笔交易内完成

\- 如果数据量太大，无法完成

签名重放攻击原理：

1\. 基础问题：

\- 同一个签名被使用多次

\- 不同用户使用相同签名

2\. 跨链重放：

\- 合约部署在以太坊主网和Polygon

\- 用户在两条链上都有地址

\- 签名在主网使用后，可以在Polygon再次使用

3\. 消息构造不完整：

\- 未包含链ID：不同链的签名应该隔离

\- 未包含合约地址：相同链上不同合约应该隔离

\- 未包含用途标识：同一合约内不同功能应该隔离

4\. 时间限制缺失：

\- 签名应有有效期

\- 过期签名应拒绝

存储指针问题详解：

1\. 未初始化指针：

\- User storage user; // 指向slot 0

\- slot 0是第一个状态变量的位置

\- 修改user实际上修改了owner变量

2\. EVM存储布局：

+-----------------+

| Slot 0: owner |

| Slot 1: users | <- mapping位置

| Slot 2: userList|

+-----------------+

3\. 正确初始化：

\- User storage user = users\[\_user\];

\- 这样指针指向mapping中的具体位置

4\. 数组越界：

\- Solidity数组访问不自动检查边界

\- 越界访问可能导致：

\* 访问其他存储槽

\* 消耗大量gas

\* 意外状态修改

时间戳攻击原理：

1\. 矿工控制权：

\- 矿工可以调整block.timestamp在±15秒内

\- 可以跳过某些区块来影响时间

2\. 常见攻击场景：

\- 预测随机数：如果使用block.timestamp作为随机种子

\- 操纵时间锁：通过调整时间戳提前解锁

\- 抢跑交易：通过调整gas和交易顺序

3\. 溢出攻击：

\- lockTime += \_seconds

\- 如果\_seconds很大，可能溢出归零

\- 攻击者可以立即提款

常见逻辑错误类型：

1\. 价格计算错误：

\- 未考虑手续费

\- 使用过时的储备数据

\- 四舍五入方向错误

2\. 执行顺序错误：

\- 先转账后检查（类似重入）

\- 状态更新顺序错误

3\. 数学计算错误：

\- 整数除法精度损失

\- 乘法溢出风险

\- 错误的比例计算

4\. 退款逻辑错误：

\- 退款给错误地址

\- 退款金额计算错误

\- 未处理零钱

漏洞原理：

1\. Solidity 0.8.0之前，整数运算不自动检查溢出

2\. uint8 取值范围：0-255 (2^8-1)

3\. 255 + 1 = 256，但256的二进制是 1\_0000\_0000

4\. uint8只存储8位，所以变为 0000\_0000 = 0

5\. 同样，0 - 1 = -1，但uint不能为负，下溢变成255

安全影响：

1\. 余额计算错误：用户可能获得巨额代币

2\. 投票权重计算错误：可能操纵DAO投票

3\. 时间计算错误：可能绕过时间锁
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->




# 核心一：EVM为何设计成“逐条执行”？

EVM将智能合约代码编译为一连串操作码（OpCode），并按  取指→解码→执行  的循环逐条运行。这样设计是为了实现五个核心目标：

共识确定性：全球所有节点逐条执行相同的、精确定义的操作码，确保对同一笔交易计算出完全一致的新状态，这是区块链不分裂的基础。

精确Gas计费：为每条操作码明确定义Gas成本，实现细粒度计费。这能防止无限循环和资源滥用（DoS攻击），让“攻击网络”在经济上不可行。

实现简单与多客户端兼容：小而简单的指令集（栈机风格）便于用不同编程语言实现多种客户端（如Geth, Nethermind），只要遵循同一规范，结果就能一致。

安全隔离（沙盒）：合约只能通过有限的、受控的操作码来改变状态（栈、内存、存储）。任何越界行为（如栈溢出）都会被立即中止并回滚。

可审计与可调试：逐条执行使得每一步状态变化都可追踪，为安全审计、问题调试和交易回放提供了可能。

注意：“逐条执行”不意味只有顺序执行。控制流指令如  JUMP （无条件跳转）、 JUMPI （条件跳转） 和  JUMPDEST （跳转目标标记） 可以改变程序计数器（PC），从而实现 if/else 、循环等复杂逻辑。

核心二：为什么每条操作码都要收Gas？

Gas机制为执行“定价”，同时解决四个关键问题：

防止DoS攻击与无限循环：如果没有Gas，攻击者可以用无限循环或重操作拖垮网络。Gas机制将“无限计算”转化为“无限烧钱”，使其失去攻击价值。历史上多次EIP升级（如EIP-150, EIP-2929）都在调整操作码价格以应对新型攻击。

激励矿工/验证者：运行节点需要真实的硬件和带宽成本。Gas费（ gasUsed \* gasPrice ）补偿了这些成本，为网络安全提供了经济基础。

精确计量资源消耗：不同操作码成本差异巨大，反映其真实资源开销：

便宜：简单计算（ ADD ,  MUL ）。

较贵：扩展内存（ MLOAD ,  MSTORE ）。

非常贵：读写存储（ SLOAD ,  SSTORE ）、外部调用（ CALL ）。

为开发者提供可优化的成本模型：透明的Gas成本表让开发者能针对性优化合约（例如，减少存储写入、合并外部调用），工具（如Hardhat, Foundry）也能提供Gas消耗分析报告。

# 一、Gas 基础概念与单位

Gas是什么：衡量计算工作量的抽象单位，用于度量交易或合约调用消耗的计算、存储、带宽等资源。

费用单位：

ETH：主币。

wei：最小单位，1 ETH = 10¹⁸ wei。

Gwei：常用中间单位，1 Gwei = 10⁹ wei，1 ETH = 10⁹ Gwei。

费用计算（经典公式）：

总费用 (ETH) =  GasUsed （消耗的Gas量） ×  GasPrice （单位Gas价格，单位Gwei/Gas） ÷ 10⁹

例如：一笔转账消耗 21,000 Gas，GasPrice 为 20 Gwei/Gas，则总费用为 0.00042 ETH。

# 二、EIP-1559（伦敦升级）后的重大变革

自2021年伦敦升级后，Gas价格和费用结构变为 “三段式”，彻底改变了手续费市场：

Base Fee（基础费）：

由协议自动计算和调整，根据区块拥堵程度（实际Gas使用量 vs. 目标值）动态浮动。

这部分费用会被直接销毁（Burn），不归验证者所有。

影响：使ETH成为一种“带使用费的资产”，网络越忙，销毁越多，有时会导致ETH净通缩。

Priority Fee / Tip（优先费/小费）：

用户额外支付给验证者（出块者）的激励，以获得更快的打包速度。

这是验证者的主要交易收入来源（连同区块奖励）。

Max Fee（最高费用）：

用户愿意为每单位Gas支付的最高价格（ maxFeePerGas ）。

实际支付的有效单价 =  Base Fee  +  Priority Fee ，但总价不会超过  Max Fee 。

新交易类型：交易中需指定  maxFeePerGas  和  maxPriorityFeePerGas ，钱包会基于当前网络情况推荐设置。

# 三、Gas 机制如何防止网络攻击与滥用

Gas机制的核心是将“攻击成本”货币化，将潜在的攻击者锁在一个昂贵且有限的沙盒中：

每条OpCode都明码标价：

简单计算（如 ADD ）便宜，读写存储（ SSTORE ）或创建合约则非常昂贵。

让DoS攻击和无限循环在经济上变得“不划算”。

交易 Gas Limit：

每笔交易都设有Gas上限，防止单笔交易无限循环拖垮节点。Gas用完则交易回滚，已消耗Gas不退还。

区块 Gas 上限与弹性容量：

每个区块有总Gas使用上限（EIP-1559后改为“目标值+2倍弹性上限”）。

防止攻击者一次性塞满整个区块，影响仅限于单个高价区块。

经济抑制与状态反滥用：

垃圾交易（Spam）成本高：想塞满网络？Base Fee会因拥堵而飙升，且这部分钱直接被销毁，攻击者持续作恶的成本指数级上升。

削弱Gas退款：通过升级（如EIP-3529）大幅削减了通过  SELFDESTRUCT  或清空存储来“薅羊毛”的退款机制，防止滥用导致状态膨胀。

# 一、交易异常：Gas耗尽后的结果

当交易Gas不足（OutOfGas）时，EVM会异常退出，结果有三：

状态全部回滚：交易内的所有操作（如转账、修改合约状态）均不生效。

已消耗Gas不退还：节点已执行的计算需要得到报酬，这是为防止DoS攻击（若退还，攻击者可免费发送必然失败的复杂交易来消耗网络资源）。

交易仍被打包：交易会进入区块，但状态标记为“失败”，可在区块浏览器查看。

# 二、Gas机制的三层防护网

每条指令都付费：任何计算或存储都有明确成本。

硬性资源上限：每笔交易和每个区块都有Gas上限，限制单次攻击能消耗的资源。

费用市场+销毁机制：EIP-1559后，网络越拥堵，基础费（BaseFee）越高且被销毁，使持续攻击成本剧增。

# 三、降低Gas成本的合约设计原则（核心）

减少存储写入： SSTORE  最贵。应先于内存中完成计算，最后只写入一次结果。

善用数据位置：

外部函数只读参数用  calldata ，比  memory  便宜。

重复读取的存储值应先缓存到  memory  变量，避免多次  SLOAD 。

优化数据结构：

使用  mapping  + 索引数组，而非遍历大数组。

将多个小整数（如  uint64 ,  bool ）打包到同一个32字节存储槽。

避免链上大循环：将遍历、排序等复杂计算移至链下，链上仅验证结果（如用Merkle证明）。

利用新特性：

使用  constant / immutable  存储固定配置，节省部署Gas。

使用EIP-1153的 瞬态存储（ TSTORE / TLOAD ）存放单笔交易内的临时状态（如重入锁），减轻长期状态负担。

微优化技巧：

对确无溢出的算术使用  unchecked {}  块。

条件判断中将廉价的检查放在前面，利用短路逻辑。

用位运算（bitmask）管理多个布尔标志。

# 四、科学测试与度量Gas

使用工具量化优化效果：

Hardhat +  hardhat-gas-reporter ：测试时自动输出各函数Gas消耗。

Foundry：使用  forge test --gas-report  生成Gas报告，便于对比优化前后差异。

Tenderly/区块浏览器：进行逐操作码跟踪，分析真实交易中哪个调用最耗Gas。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->





一、EVM 是什么？

一句话定义：EVM 是一台运行在每个以太坊节点上的虚拟计算机，它把 “交易 + 智能合约字节码” 作为输入，通过确定性的执行规则和 Gas 机制，计算出新的链上状态，并保证全网所有节点结果一致。

核心比喻：EVM = 全网共享的 “状态机 + CPU”。

二、EVM 的内部构成

EVM 为合约执行提供了一个包含以下核心部件的运行环境：

全局状态：记录所有账户（EOA 和合约）的余额、Nonce、代码哈希和存储根。

字节码：由 Solidity 等语言编译而成的 EVM 指令序列，每条指令有固定 Gas 消耗。

堆栈：用于临时存放计算数据和地址，深度为 1024。

内存：临时字节数组，执行期间存取数据，执行后丢弃。

存储：每个合约独有的永久性键值存储，读写成本高。

执行上下文：包含单次调用的环境信息，如发送者、转账金额、Gas 等。

Gas 计费系统：为每条指令和每次状态变更计费，防止资源滥用。

简单类比： 堆栈 + 内存  像 CPU 的寄存器和内存； 存储  像链上的数据库； 字节码  像 CPU 指令集。

三、智能合约在 EVM 上的运行流程

写与编译：用 Solidity 写代码，编译得到字节码和 ABI。

部署：EOA 发起一笔交易，将部署字节码放入  data  字段。EVM 执行该代码，将运行时代码永久写入链上，生成一个合约地址。

调用：用户或其他合约向该地址发送交易或调用，附带函数选择器和参数。EVM 执行对应字节码，读写存储、修改状态。

状态更新与共识：执行产生新的状态根，全网节点按相同规则复现结果，达成共识。

四、为什么要有 Gas 机制？

核心作用：防止无限循环攻击；让复杂运算和存储写入“谁用谁付钱”；为区块打包者提供交易优先级排序的市场。

近期升级调整：历次升级（如 Istanbul、Dencun）会调整特定操作的 Gas 成本或引入新指令（如  MCOPY ）以优化效率。重要变化： SELFDESTRUCT  操作码的语义已被大幅限制（EIP-6780），不再能随意删除合约。

五、EVM 的确定性与沙盒约束

确定性：合约执行不能依赖外部可变信息（如网络 API），只能使用区块头、链上状态等有限数据源。

沙盒隔离：合约代码不能访问节点文件系统或网络，只能通过 EVM 预设的上下文与外部交互。

影响：这解释了为何需要预言机来获取链下数据，以及为何真正的随机数需要外部服务（如 Chainlink VRF）。

六、EVM 为何如此重要？

统一的执行环境：所有节点运行相同的 EVM 规则，确保了全球状态的一致性。

智能合约的基石：支持 DeFi、NFT、DAO 等去中心化应用自动执行。

隔离性与安全性：沙盒环境隔离了合约，Gas 机制防止资源滥用。

生态系统与兼容性：已成为行业事实标准，主流 L1/L2（如 BNB Chain, Arbitrum, zkSync）均兼容 EVM，实现了“一次编写，多链部署”的生态效应。

持续创新基础：支持 Layer 2、ZK-EVM、EOF 格式升级等前沿扩展。

七、EVM 的局限

Gas 成本高：网络拥堵时用户体验差。

性能有限：单链 TPS 有上限，扩容依赖 Rollup 等二层方案。

升级压力大：需极端谨慎地保持向后兼容。

状态膨胀：历史状态持续增长，给节点存储带来长期压力。

八、合约在 EVM 中运行的 7 个阶段

写合约：开发者编写 Solidity 源代码。

编译：编译为部署字节码和运行字节码，生成 ABI。

发送部署交易：EOA 发起交易， data  字段包含初始化代码。

分配合约地址并写入代码：EVM 执行初始化代码，计算地址并永久存储运行时代码。

合约被调用：用户发送交易，EVM 解析  calldata ，执行字节码。

EVM 执行部件协同工作：程序计数器、堆栈、内存、存储等部件按指令流协同工作。

状态修改或回滚：执行成功则更新状态，Gas 耗尽或遇到  revert  则回滚状态变更（但已消耗的 Gas 不退还）。

九、核心类比

将智能合约执行比作标准化厨房：

Solidity 源码是菜谱。

编译是把菜谱翻译成机器步骤卡（字节码）。

部署是把步骤卡钉在某个工位（合约地址）并准备食材（初始状态）。

调用函数是点菜。

EVM 是厨师，严格按照步骤卡，使用临时案板（内存）、工具台（堆栈）和冷藏库（存储）做菜。

失败相当于中途炸厨房，所有改动撤销，但燃气费（Gas）照付。

总结：EVM 是以太坊“世界计算机”的大脑和CPU，它通过确定性的沙盒环境、Gas 经济模型和统一的指令集，支撑了整个智能合约生态的运行与创新。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->






1.今日操作

使用remix完成第一个智能合约（留言板）的编写，同时将remix部署进seplodia，将合约部署进测试网

2.今日学习内容

一、部署合约后的关键产出

合约地址：部署后在链上生成的唯一标识，用于定位和交互（如调用函数、转账ETH）。

部署交易哈希：用于在区块浏览器中追踪本次部署交易。

ABI（应用二进制接口）：在编译阶段生成的“接口说明书”，供前端或脚本理解如何调用合约函数。部署后，可通过验证源码在区块浏览器（如Etherscan）上自动获取并显示。

二、Solidity智能合约的核心组件

状态变量：永久存储在链上的数据，构成合约状态。可用  public 、 internal 、 private  控制可见性。

函数：执行操作的代码块。通过可见性（ public 、 external 、 internal 、 private ）和状态可变性（ pure 、 view 、 payable 、默认可修改）来定义其调用方式和行为。

事件：向链上日志“广播”消息的轻量机制，供前端监听，用于记录历史、通知用户。

构造函数：仅在部署时执行一次，用于初始化合约状态（如设置所有者）。

修饰符：可重用的代码块，用于在函数执行前/后添加检查逻辑（如权限验证）。

结构体/枚举：用于定义自定义复合数据类型和有限值集合，帮助构建清晰的数据模型。

自定义错误：自Solidity 0.8.4起，可定义  error  类型，与  revert  配合使用，比旧式错误信息更省Gas且可携带参数。

核心关系：将编译产物（字节码和ABI）部署到链上得到合约地址，而合约的内部逻辑则由上述各类组件组合实现。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->







一、智能合约的核心概念

本质：部署在区块链上的一段 “代码 + 状态” 程序，由交易触发，按预设规则自动执行。

关键特性：

自动执行：条件满足即执行，无需可信中介（如数字自动售货机）。

结果确定：相同输入在所有节点产生相同输出（代码即法律）。

公开可审计：所有调用和状态变更永久记录在链上，可追踪验证。

默认不可变：部署后字节码无法直接修改。升级需通过代理合约（Proxy） 等模式替换逻辑，保留状态和地址。

非完全匿名：地址不绑定实名，但所有行为公开可追踪，属“假名制”。强隐私需额外方案（如零知识证明）。

二、Solidity：以太坊的主流合约语言

核心优势：

EVM原生：专为以太坊虚拟机设计，编译高效。

生态最强：拥有最丰富的工具链（Hardhat、Foundry）、审计库（OpenZeppelin）和开发者社区。

多链兼容：学会即可开发大多数EVM兼容链（如Arbitrum、Polygon）的应用。

安全成熟：经历大量实战考验，有系统的安全实践和工具支持。

学习路线建议：了解基础 → 读官方文档做例子 → 用Remix/Hardhat/Foundry工具实操 → 学习安全漏洞与最佳实践 → 部署测试网项目。

三、合约编译产物

编译智能合约主要生成：

字节码：EVM可执行的机器码。

创建字节码：部署时执行，负责将运行时代码写入链上。

运行时代码：部署后存储在合约地址的实际执行代码。

ABI（应用二进制接口）：描述合约公共函数和事件的JSON文件，是与合约交互的“接口说明书”。

元数据：包含编译器版本、源码引用等信息的JSON文件，用于合约验证和透明度。

其他中间产物（如AST、源映射、EVM汇编）：主要用于高级调试、审计和Gas优化。

一句话总结：智能合约是以太坊上自动执行的确定性程序，用Solidity编写并编译成字节码和ABI等产物后部署，构成了去中心化应用的逻辑核心。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->








1.Dune初步了解，查询使用

2.Remix的使用教程学习，界面了解，初步部署合约
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->









# 1.合约存储结构与EOA结构

一、合约账户的存储结构

所有账户在系统中都被记录为一个四元组：(nonce, balance, storageRoot, codeHash)。

balance（余额）：EOA和合约账户都有，都能持有和转移ETH。

storageRoot（存储根）：只有合约账户真正使用，它是一棵Merkle树的根哈希，记录了该合约所有状态变量（如mapping、uint等）。EOA的此字段是固定空值。

codeHash（代码哈希）：合约账户存储其EVM字节码的哈希；EOA的此字段是空字符串的哈希。

核心区别：合约账户既有“钱”（balance），又有“账本”（storage），还有“自动规则”（code）。而EOA只有“钱”和发起交易的能力。

二、EOA与合约账户的调用机制

发起者只能是EOA：一条链上交易的起点，必须是一个由私钥签名的外部交易。这由EOA（或扩展形式）完成。

合约是被调用者：合约账户无法主动发起新的顶层交易。它只能在被EOA或其它合约调用时，在其代码逻辑内执行操作（如转账、修改状态）。

调用方式：在合约执行中，可以通过  call 、 delegatecall 、 staticcall  等方式调用其他合约，这些都属于当前交易内部的 消息调用，不会产生独立的新交易。

三、关于“智能账户”的补充

ERC-4337（账户抽象）：用户操作的“智能账户”本质是一个合约钱包。用户提交  UserOperation ，但最终由一个叫 Bundler 的服务用其EOA打包成普通交易上链。底层规则未变。

EIP-7702：允许EOA在一笔交易的生命周期内，临时授权一段合约代码来执行复杂操作。这增强了EOA的能力，但并未改变“合约不能主动发起交易”的底层规则。

四、钱包（以MetaMask为例）如何管理EOA

核心是本地私钥：助记词（SRP）是生成私钥的种子。私钥和助记词始终由用户在本地设备加密保存，不会上传服务器。

交易签名流程：当你在dApp点击操作后，MetaMask会在本地用私钥对交易签名，然后将已签名的交易通过RPC节点广播出去。节点从未接触你的私钥。

智能账户支持：MetaMask通过支持ERC-4337标准，允许用户使用具备批量操作、社交恢复等功能的合约钱包。但用户对根私钥的控制权这一核心没有改变。

总结：理解以太坊账户，关键是抓住 EOA是行动起点（由私钥控制），合约是规则执行者（由代码控制） 这一根本。所有的新功能（AA、EIP-7702）都是在这一基础上构建的更灵活的使用方式。对于用户，安全核心始终是 保管好本地助记词和私钥。

# 附加部分

第一部分：代币与合约的关系

代币本质是合约内部的“记账系统”：

ERC-20 代币（同质化）在合约内部用  mapping  记录每个地址的余额和授权额度。

ERC-721 代币（NFT）用  mapping  记录每个  tokenId  的持有者地址以及各地址的余额。

所谓“拥有”代币，实质是合约的存储（storage） 里为你记了一笔账，并不是你的地址里多了一个独立的“硬币”或图片。

代币操作就是合约调用：

转币不是从你的地址直接发一笔“代币交易”。

流程是：你的EOA向代币合约地址发起交易，交易的  data  字段编码了如  transfer()  这样的函数调用。

合约执行时，检查权限和余额，然后更新内部存储（mapping），完成转账。本质是“调用代码+改存储”。

第二部分：合约的不可变性与升级

代码默认不可更改：

合约一旦部署，其字节码便永久存储在链上，默认无法修改。2024年 Dencun 升级（EIP-6780） 后，这一特性更加固化。

SELFDESTRUCT 操作语义已变（重要）：

历史上  SELFDESTRUCT  可用于销毁合约，释放地址以便重新部署。

Dencun 升级后，该操作仅在“创建合约的同一笔交易内调用”时才会真正删除代码和状态。在其他情况下，它只会转走余额，代码和基础数据仍保留。

因此，不应再在新合约中依赖此操作来实现升级、清仓等逻辑。

当前主流升级方案：代理合约模式：

由于上述变化，历史上通过  SELFDESTRUCT + CREATE2  实现的“同地址升级”（变形合约）模式已基本失效。

现在的标准做法是使用代理合约（Proxy）：一个永不变的代理合约持有状态，并通过  delegatecall  调用可更换的逻辑实现合约，从而实现业务逻辑的升级，同时保持用户交互的地址不变。

一句话概括：代币是合约记的账，操作代币就是调用合约改账本；合约代码本身不可改，历史上通过自毁来升级的方式已过时，现在升级靠代理合约。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->










# 1.今日学习:EOA账户基础

一、账户基础

EOA（外部账户）：由私钥控制，能主动发起交易，是链上所有操作的起点。类比为“银行卡”。

合约账户：由智能合约代码控制，不能主动发起交易，只能在被调用时被动执行。类比为“自动售货机”。

二、地址格式

地址本质是20字节数据， 0x 是十六进制表示的前缀，用于让人和程序识别。

EIP-55校验码（混合大小写）由客户端处理，用于防止输入错误，链上执行不区分大小写。

三、高级账户管理

多签钱包：需M个管理员中N个批准才能执行交易（如Gnosis Safe），提升团队资产安全性。

时间锁：对敏感操作（如升级）强制加入执行延迟（如48小时），为社区提供反应时间。

四、重要澄清：谁能真正发起交易？

根本规则：在协议层，只有EOA能主动发起顶层交易。

看似例外的情况：

ERC-4337（账户抽象）：用户提交 UserOperation ，但最终由Bundler用其EOA打包成普通交易上链。

“自触发”合约：由链下自动化服务（如Gelato）的EOA在满足条件时发起调用。

核心不变：无论ERC-4337还是未来的EIP-7702，都未改变“交易起点必须是EOA签名”这一底层规则。它们只是让“签名、付费、操作组合”变得更灵活。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->











# 1.今日学习汇总（以太坊网络结构）

一、节点架构：执行客户端与共识客户端

合并后，一个完整节点由两部分通过 Engine API 协作构成：

执行客户端：负责“算结果，管状态”。

职责：处理交易、运行EVM、维护最新区块链状态。

类比：厨师 - 负责烹饪菜肴（处理交易，生成状态结果）。

常见软件：Geth, Nethermind, Besu, Reth 等。

共识客户端：负责“选结果，定正统”。

职责：运行PoS共识，组织验证者出块与投票，决定最终链。

类比：经理 - 负责决定哪道菜上桌（哪个区块被全网接受）。

常见软件：Prysm, Lighthouse, Teku, Nimbus 等。

协作流程（关键）：

本地出块：共识客户端（经理）通过  engine\_forkchoiceUpdated  和  engine\_getPayload  通知执行客户端（厨师）准备并交付一个包含交易的“执行负载”。

验证他人区块：共识客户端收到新区块后，用  engine\_newPayload  让执行客户端重算验证其正确性，再决定是否投票。

二、节点同步模式

节点同步是指获取并验证所有历史数据的过程，主要有三种模式：

全同步：

做法：从创世区块开始，下载并重放执行所有交易，独立验证。

特点：最安全、最慢（需数天甚至更久）。

快照同步：

做法：先下载最新区块头和一个可信的状态快照，然后并发填充状态数据，最后同步最新区块。

特点：速度快（几小时到一天），是 Geth 等客户端的默认模式。

轻同步：

做法：只下载区块头，需要具体数据时向全节点请求并验证。

特点：存储要求极低，适合手机钱包，无法参与出块。

三、节点间交换的数据类型

节点在P2P网络中交换多种数据以保持同步：

区块数据：包括区块头（元数据、父哈希、状态根）和区块体（交易列表）。

交易与收据：交易细节及其执行后的收据（Gas消耗、事件日志）。

状态数据：账户余额、合约代码和存储，以 状态树片段 形式交换。

网络控制信息：用于发现节点、维持连接的 Ping/Pong 等消息。

# 2.个人进行链上数据的一些基础

一、网络规模与去中心化保障

节点数量：公开探测到的节点约 1-2万个，活跃验证者约 100万个（2025年11月数据）。

去中心化体现：

多客户端：无单一客户端占主导（如Geth份额已降至约37%）。

全球分布：节点遍布全球，避免单点故障。

基础设施混合：约半数节点为自建，托管节点也分散于多家云服务商。

验证者分散：近百万验证者使用不同方案，经济权力分散。

无需许可：任何人可运行节点独立验证。

二、Gossip协议

机制：像“传八卦”，节点将新消息（交易、区块）随机转发给少数邻居，邻居继续扩散，几秒内覆盖全网。

作用：实现去中心化、高容错、可扩展的信息传播，是交易、区块及PoS共识消息同步的核心。

三、个人节点搭建

节点类型选择：

全节点：需 500GB-1TB 存储，适合绝大多数开发者。

归档节点：需 2-12TB+ 存储，用于深度历史查询。

轻节点：存储极小，仅验证区块头，功能有限。

硬件与部署：

全节点推荐：4核CPU，16GB内存，2TB NVMe SSD。

归档节点要求更高：8核+，64GB内存，10TB+企业级SSD。

部署：可本地（隐私好）或云服务器（稳定）。

客户端与同步：

必须同时运行：1个执行客户端（如Geth） + 1个共识客户端（如Lighthouse）。

同步模式：开发推荐快照同步，归档同步用于构建归档节点。

启用JSON-RPC：配置客户端开启HTTP/WS端口（如8545），即可让dApp或脚本连接自己的节点。

数据分析：可配合 Ethereum ETL 等工具将链上数据导出到数据库。

四、不跑节点的数据分析方法 (图片7-10)

无需自建节点，也可通过以下方式分析链上数据：

SQL平台：如 Dune、Flipside，直接写SQL查询已解析的数据并可视化。

公共数据集：如 Google BigQuery 中的以太坊数据集，适合企业级分析与关联业务数据。

浏览器API：如 Etherscan API，适合脚本轻量查询。

数据API服务：如 Covalent，提供已结构化的业务数据视图。

混合方案：历史数据用BigQuery/Dune，实时数据用托管RPC服务（如Infura），平衡能力与成本。

核心一句话：以太坊通过上万节点和百万验证者在软件、地理、基础设施上的分散来实现去中心化；个人可根据需求选择运行不同类型的节点，或直接利用现有数据服务进行开发与分析。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->












# 1.以太坊节点与网络学习

一、节点如何连接与通信

新节点上线会经历三个阶段：

发现（找邻居）：通过引导节点，使用UDP协议和Kademlia算法（像快递网络找最近站点）发送Ping/Pong和FindNode请求，逐步发现并填充“邻居列表”。

连接（拉专线）：与选中邻居建立加密的TCP连接，并使用RLPx/devp2p协议在同一连接上多路复用区块同步、交易广播等多种子协议（如同一条电话线开多个分机）。

传播（传八卦）：

Gossip协议：新交易/区块像八卦一样被节点随机转发，几秒内传遍全网。

请求/响应：缺失的历史数据，直接向邻居点对点请求获取。

二、三种核心节点类型

全节点：

存什么：所有区块 + 最近约128个区块的完整状态（更老的状态会被“修剪”）。

做什么：能独立验证所有交易和区块，是完全自托管、不求人的入口。像大型图书馆，有全部书目和最新版本的书。

归档节点：

是什么：禁用修剪的全节点，额外保存从创世块至今每一个区块高度下的完整状态快照。

用途与代价：供链上分析、审计、回测使用（如区块浏览器），但存储巨大（TB级），维护成本高。像国家档案馆。

轻节点：

存什么：只保存区块头，不存完整区块和状态。

特点：资源消耗极低，可在手机等设备运行。需要时向全节点索要数据，并利用区块头中的Merkle根进行密码学验证，实现“不信任但可验证”。像移动目录机，只存索引，借书时核对。

三、为何要自己运行全节点？（对开发者/机构）

隐私与安全：交易和查询不经过第三方RPC服务商，防止IP地址与链上身份被关联。

抗审查与韧性：避免依赖公共RPC可能遇到的限流、宕机或交易过滤，确保业务自主和稳定。

践行“不要信任，要验证”：本地验证所有数据，为金融、风控、审计提供可信的数据源。

支持去中心化与客户端多样性：增加网络独立副本，并有意识地选择非主流客户端（如不用占比过高的Geth），提升整个网络的抗风险能力。

提供稳定数据底座：可自建索引、分析面板等内部服务，获得低延迟、可定制的RPC接口。

获得协议主权：在协议升级或分叉时，能自主决定跟随哪条链，掌握“用脚投票”的治理话语权。

配置自由：根据性能、运维和合规需求，自由选择客户端（Geth, Nethermind, Besu等）并调整参数。

核心一句话：自己运行全节点，是为了拿回安全隐私、基础设施韧性、协议话语权这三件东西。

归档节点是区块链的“时间机器”，核心是能直接查询任意历史时刻的链上状态。

主要功能与优势：

1\. 即时历史查询：快速回答“某地址在某历史区块的余额是多少？”等问题，无需从头重放交易。

2\. 支持高级RPC：允许调用

“eth\_getBalance” 等方法时指定历史区块高度，这对调试、审计、分析至关重要。

3\. 分析审计基础：是区块浏览器、数据分析、合规审计等服务的必需基础设施。

核心代价：

\* 存储需求巨大：需要 2TB 至 12TB+ 的存储空间。

\* 同步耗时极长：首次同步需重放所有历史交易，通常耗时数周甚至数月。

一句话总结：归档节点是用海量存储空间换取“穿越时间”直接查询历史状态的能力，是专业数据服务的重型工具。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->














# 1.学习链上数据的第一天：了解以太坊的节点与客户端架构

## 梳理笔记如下，三点关注，CL EL RPC

## 以太坊节点与客户端架构

核心变化（The Merge之后）：一个完整的以太坊节点不再是单一程序，而是由两个核心客户端（执行 + 共识）通过标准接口组合而成。

1\. 三大核心组件

执行客户端：旧称Eth1客户端。

职责：负责“干活的”。

监听并执行交易与智能合约。

维护区块链的当前状态（账户余额、合约数据）。

对外提供  eth\_  开头的JSON-RPC接口。

常见软件：Geth, Nethermind, Besu 等。

共识客户端：旧称Eth2或信标链客户端。

职责：负责“当法官的”。

运行权益证明（PoS）共识算法。

组织验证者对区块进行提议和投票。

决定哪条链是规范的主链。

常见软件：Lighthouse, Prysm, Teku 等。

验证者客户端（可选）：

职责：负责“当陪审团代表的”。

如果想质押ETH并参与出块赚取收益，需要在共识客户端上运行此客户端。

管理验证者密钥，在轮到时报出区块，并对看到的区块进行投票。

2\. 关键接口与网络

Engine API：

执行客户端和共识客户端之间通信的“专线电话”。

一个内部的JSON-RPC接口，用于传递区块骨架、执行结果和验证信息。

对外接口：

应用通过 Web3库（如web3.js）与节点交互。

对执行层的调用走  web3.eth （连接执行客户端）。

对共识层的调用走  web3.beacon （连接共识客户端）。

P2P网络：

执行客户端和共识客户端都有自己的P2P网络，用于与其他节点同步区块、交易和共识消息。

3\. 核心关系与总结

客户端 vs. 节点：

客户端：指软件实现（如Geth、Lighthouse）。

节点：指运行这些客户端软件的一台电脑或服务器实例。

全节点构成：

一台电脑 + 1个执行客户端 + 1个共识客户端 = 一个全节点。

若再挂上 验证者客户端 = 一个验证节点。

一句话总结：合并后，以太坊节点像一家法院，执行客户端是整理案卷和计算的书记员，共识客户端是做出最终裁决的法官，两者通过Engine API这条内部热线紧密协作，共同维护网络。

## 2.Web3的安全与合规

安全（钱包安全，谨防钓鱼u，合约链接，EIP-2612许可说明，空投陷阱，不要乱泄露地址）

合规（注意审查项目方背景，出入金安全）
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->















# 1.教材学习

## 生态创新：DeFi NFT DAO

1\. DeFi（去中心化金融）AMM / DEX：Uniswap用  x\*y=k  等公式自动做市，取代订单簿。

去中心化借贷：Aave/Compound通过超额抵押和资金池进行借贷，利率由算法自动调节。

稳定币：DAI通过超额抵押和链上治理保持与美元挂钩。

Layer2扩展：

OP Rollup（如Optimism）：默认交易正确，有人质疑才复查（欺诈证明）。

ZK Rollup（如zkSync）：每批交易附带零知识证明，主链只验证证明。

跨链互操作：通过跨链桥连接不同链，但也带来了安全风险。

2\. NFT（非同质化代币）

基础标准：ERC-721（唯一资产）、ERC-1155（可批量混合管理）。

品牌应用：用作数字藏品、会员凭证，实现“物理+数字”联动。

NFT钱包化（ERC-6551）：让NFT能持有其他资产、主动交互、记录链上历史。

NFT角色管理（ERC-7432）：为NFT添加可编程的角色与权限系统，支持租赁、临时授权等场景。

3\. DAO（去中心化自治组织）

协议DAO：如Aave/Uniswap的DAO，负责管理协议参数、资金和升级。

公共物品与资助DAO：如Gitcoin，用二次方融资等机制资助开源项目。

创意型DAO：如Nouns DAO，通过每日拍卖NFT筹集社区金库，集体决策资金用途。

其他应用：也已应用于慈善、艺术收藏、科研资助等领域。

# 2.确定暂时职业规划与四周初步学习计划

链上数据/投研（兼具审计）

[https://www.notion.so/2e747175679b80ecadcef2eb955f635b](https://www.notion.so/2e747175679b80ecadcef2eb955f635b)

# 3.EVM机制初步了解

Event与Log，Gas销毁机制
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
















1.完成测试网转币（sepolia测试网）

2.学习区块链基础内容，包括以太坊dApps的概念与应用，以太坊平台定位与核心特性

3.确定总结初步的职业定位：链上数据/投研（学习审计知识）

4.保证内容持续输出记录（社交平台）
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
