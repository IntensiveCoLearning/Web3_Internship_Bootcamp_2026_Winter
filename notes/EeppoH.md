---
timezone: AEDT(UTC+11)
---

# EeppoH

**GitHub ID:** EeppoH

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->
2. **智能合约（Smart Contracts）**：

-   智能合约是 Dapp 的核心，它定义了应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。
    
-   在以太坊平台上，智能合约通常使用 **Solidity** 编程语言编写，并通过 **Ethereum Virtual Machine (EVM)** 执行。
    

3. **数据检索器（Indexer）**：

-   智能合约通常以 Event 形式释放日志事件，比如释放代表 NFT 转移的 Transfer 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中
    
-   Dapp 在前端进行数据展示时需要检索器内的数据。
    

帮助DApp把乱七八糟的链上数据整理成前端一秒能用的数据库。

**Indexer 并非 DApp 的必要组成部分，但在实际生产环境中几乎是必备基础设施。**

**Indexer 是一个链下后端服务，通常使用 TypeScript / JavaScript 编写，通过监听区块链事件并将其结构化存储，为 DApp 提供高效的数据查询能力。**

**Indexer是跟随交易的发生实时更新数据库的嘛？**

**Indexer不处理memepool，不会在交易“还没确认”就写数据库，一旦区块出现很快就能同步。**

**现实生活中的交易pending，confirmed vs Indexed**

**pending等于刷卡中，也就是交易进入mempool**

**confirmed银行入账，上链成功**

**Indexed 银行APP显示账单，Indexer已更新**
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->

Dapp架构和开发流程

去中心化应用（Dapp）是与传统集中式应用不同的全新应用模式，通常运行在区块链或分布式网络上。

Dapp 的核心特点在于去中心化，意味着应用的逻辑和数据不由单一实体控制，而是由多个参与者共同维护。

Dapp架构主要由三个核心部分组成：前端（User Interface）智能合约、数据检索器、区块链和去中性化存储。

前端是DApp与用户交互的界面，通常由HTML、CSS和JavaScript构成。

与传统Web应用不同的点在于DApp前端不会直接连接区块链网络，通过钱包注入的 Provider 或第三方 RPC 节点 与区块链交互：

-   **Provider**：前端的“统一接口抽象”
    
-   **RPC 节点**：真正和区块链对话的远程节点
    
-   Metamask=provider+RPC（默认）
    
-     通过 RPC 节点对 智能合约发起只读调用（如 eth\_call），获取合约状态、事件日志等链上数据（只能看看，不能动手操作，比较像查看银行余额）
    
    -   对需要修改状态的操作，由前端构造对 智能合约的交易调用，交由钱包完成签名后，再通过 RPC 节点广播到区块链网络并最终上链执行（改变状态需要花钱）
        
-   前端还需要集成区块链钱包（如 MetaMask）来进行身份验证和签署交易，确保用户的隐私和安全。
    

总结：看数据直接问区块链，移动资产的话钱包需要帮你签字再上链
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->


**空格**

**中英文之间需要增加空格；在 Cloud 上，数据存储是围绕 X 进行的**

**中文与数字之间需要增加空格；今天吃饭花了 200 元**

**数字与单位之间需要增加空格； 我家宽带有 10 Gbps （例外，度数/百分比与数字之间不需要增加空格）**

**全形标点与其他字符之间不加空格**

**标点符号**

不重复使用标点符号

标点符号用全形中文

数字使用半形字符

遇到完整的英文整句、特殊名词，其内容使用半形标点

**名词**

专有名词使用正确大小写

不要使用不地道缩写 TypeScript不能写出TS
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->



```remix-solidity
pragma solidity ^0.8.0;

contract SimpleStorage {
    // 这个变量用来存一个数字
    uint256 public myNumber;

    // 写入函数：把数字存进去 (要花 Gas)
    function store(uint256 _num) public {
        myNumber = _num;
    }
function addOne() public {
    myNumber += 1;
}
    // 读取函数：把数字读出来 (免费)
    function retrieve() public view returns (uint256) {
        return myNumber;
    }
}
```

最近实在太忙了，感觉代码这一块需要大块时间来慢慢弥补➕理解（对于我这个小白来说）。今天的打卡是靠自己写出了绿色的完整合约。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->




Sat 17 Jan 复习了一遍过去一周所有的概念

**区块链是什么**

• **区块链 = 公开的账本**：记录谁给谁转了多少、调用了什么合约等。记账会有相应的奖励（比特币），但不是谁都可以记账需要争取资格，并且接受全网（全世界所有节点）的检查。

• **去中心化**：不是银行/公司一家记账，而是很多人一起记账、一起保存账本。

• **不可篡改**：一旦写进账本，想偷偷改掉会被全网发现（成本极高）。

**分布式网络 / 节点**

• **节点 = 运行区块链软件的电脑/服务器**

• 每个节点都保存一份账本副本。

• 因为节点遍布各地，**没有任何人能随便改账本**。

**哈希（Hash）**

• **哈希 = 数字指纹**

• 任意内容（交易/区块/文件）→ 生成固定长度的“指纹”，把“任意内容”压缩成一串固定长度指纹的计算方法。

• 内容哪怕改一个字符，指纹都会完全变。

• 区块链就像账本每一页都有前一页的哈希值，改一个数字就要改整本

**比特币（BTC）为什么有奖励**

• 在比特币里，维护网络/打包区块的人（矿工）会得到奖励：

• **区块奖励（新币）+ 交易手续费**

• 目的：让大家愿意提供算力来保护网络、记账。

**以太坊（Ethereum）是什么**

• 以太坊不只是“转账系统”，更像：

• **一个全球共享的计算机（全球计算机）**

• 它不仅能转 ETH，还能运行程序（智能合约），支撑 DeFi、NFT、DAO 等。

**PoW / PoS**

• **PoW（Proof of Work，工作量证明）**：靠“算力竞争”来决定谁记账（挖矿）。

• **PoS（Proof of Stake，权益证明）**：靠“质押资产 + 随机选择/规则”来决定谁记账（验证者）。

• 以太坊已从 PoW 转向 PoS

**验证者如何工作**：

-   **准入门槛**：质押 32 ETH 成为验证者
    
-   **工作方式**：系统随机选择验证者来提议和验证区块
    
-   **奖励机制**：验证者获得新发行的 ETH + 交易费用
    
-   **惩罚机制**：作恶者质押的 ETH 被销毁（Slashing）
    

**以太坊的账户系统：EOA / CA**

• **EOA（外部账户）**：你用 MetaMask 控制的账户（有私钥），能主动发起交易。

• **CA（合约账户）**：智能合约所在的账户（有代码，没有私钥），**不能主动发交易**，只能被 EOA 触发后执行。

现实生活中的例子来类比，EOA=银行账户，私钥=银行卡密码，公钥=银行账号，CA=自动售货机

**Gas 模型是什么**

• **Gas = 在以太坊上“运行/写入账本”的成本**

• 转账、调用合约、部署合约

都要付 Gas（用 ETH 支付）。

• Gas 的作用：

1\. 给验证者报酬（经济激励）

2\. 防止滥用网络（比如无限循环占计算资源）

3\. 让“全球计算机”能长期运转

**AMM 是什么**

• **AMM（Automated Market Maker，自动做市商）**：不用挂买卖单、直接和“资金池”交易的机制。

• 现实生活中的比喻：**自动售货机 + 自动改价**

**Uniswap v2 的核心：x·y = k**

• 资金池里两种资产数量分别是：

• x = ETH 数量

• y = USDC 数量

• 交易后合约会调整库存，让它满足一个定价约束（常见写法）：

• **x · y ≈ k**

• 直觉：别人买走 ETH（x 变少）→ ETH 变贵；别人卖出 ETH（x 变多）→ ETH 变便宜。

无常损失Impermanent loss 用户存入CA的资产比例永远不变，内容会改变。

当我成为 LP 时，我会向 CA 账户存入一对资产。系统会根据我存入资产在当时整个资金池中的价值占比，为我铸造对应数量的 LP Token，从而确定我占资金池的比例。在我不退出 LP 的情况下，无论之后发生多少交易，资金池里的资产数量会持续变化，但我持有的 LP Token 数量不变，因此占资金池的比例也保持不变。交易只会改变我这份比例中包含的资产结构，不会改变比例本身。

现实中还有手续费、加/退流动性等因素会让“k”出现变化，但你这个阶段把它当成“交易定价的核心规则”就很好。

**以太坊生态分层：L1 / L2 / Sidechains**

• **L1（主网）**：以太坊本体，最安全但贵/慢。

• **L2（二层）**：把很多交易在 L2 处理，再把结果打包提交给 L1 确认 → **更便宜更快，安全仍靠 L1**。

• **Sidechain（侧链）**：一条独立链，通过桥连主网 → **更便宜更快，但安全主要靠自己**。（非主流，正在被抛弃）

**应用层 / 协议层 / 扩展层 （和L1/L2/Sidechains不是一一对应）**

• **应用层**：你直接用到的产品（Uniswap、Aave、OpenSea、MetaMask UI）。

• **协议层**：以太坊底层规则（共识、EVM、账户、Gas）。

• **扩展层**：帮助变快变便宜的方案（L2、侧链、未来一些扩展技术）。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->





昨天留下的问题，LP TOKEN证明的不是存入的ETH或者USDC在mempool里的存款，LP TOKEN证明的是自己的存款在CA账户里的比例。

这个比例本身不会变，只要没有新增LP和退出的LP，交易得再多，这个比例也不会变。但是这个比例的资产内容会一直在变，因为有人用ETH换USDC也会有人用USDC换ETH，所以池子里X/Y一直在变化。昨晚把mempool和CA账户的资产概念混淆了，mempool的唯一作用是暂存“还没有被请求的交易”。

> LP Token 记录的是“池子的份额”，

> mempool 只是“排队的请求列表”，

> 钱和比例只存在于链上状态，不存在于 mempool。

为什么要记录这个比例？这个比例决定了你能分到多少手续费 ，你退出时能拿回多少资产。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->






什么是EVM? Ethereum Virtual Machine以太坊虚拟机。想象以太坊不是一本单纯的账本（像比特币那样只记转账），而是一台**全世界联网的超级电脑**，这台电脑能跑程序、执行代码、玩游戏、借贷、交易NFT……但它**不是一台实体电脑**，而是**分布在全球成千上万台节点电脑上的“虚拟电脑”**。

这个“虚拟电脑”的操作系统/CPU/执行引擎，就是 **EVM**。

**它到底干啥？（核心作用）**

-   **运行智能合约**：你用 Solidity写一个合约，编译成“字节码”然后部署到以太坊上。 EVM 负责读取这些字节码，一步步执行，就像你的电脑运行 .exe 文件一样。
    
-   **更新整个网络的状态**：每笔交易（转 ETH、调用合约）都会触发 EVM 计算“旧状态 → 新状态”。 比如：你调用 Uniswap swap，EVM 算出“你的 USDC 少了，ETH 多了，池子流动性变了”，然后全网节点都同步这个新状态。
    

直觉可能以为我在和CA账户交易的时候拿到的钱是从某个别人的EOA里转出来的，但是那些资产曾经来自别人的EOA，一旦存进CA，就不再属于任何具体人，CA本身就是一个账户，而且是一个能持有资产的账户。LP会存钱到CA里，LP会获得LP TOKEN证明自己的存款在mempool里的比例，只记比例，不记哪一枚币是谁的。**这个mempool里的比例不是实时更新？？明天继续搞懂这个问题**

-   **保证大家结果完全一样**：全世界节点都跑同一个 EVM，输入一样（交易 + 旧状态），输出必须完全相同（新状态）。这叫**确定性**（deterministic），是区块链共识的基础。如果有人改代码，结果不一样，全网就分叉了。
    

以太坊的核心价值，通过代码实现无需信任的自动化规则（如智能合约），三个关键机制：账户系统、Gas模型和以太坊虚拟机（EVM）

我们平时使用 **账户系统** 里面的 **外部账户（EOA）** 与区块链中的其他用户的 **外部账户（EOA）** 或者与智能合约所在的 **合约账户（CA）** 进行交互，而其中的 **Gas 模型** 是支撑整个网络的经济基础， **Gas 模型** 和其他经济来源支撑着全球的 **以太坊虚拟机（EVM）** 来实现以太坊网络。

我们平时使用 账户系统 里面的 外部账户（EOA） 与区块链中的其他用户的 外部账户（EOA） 或者与智能合约所在的 合约账户（CA） 进行交互，而其中的 Gas 模型 是支撑整个网络的经济基础， Gas 模型 和其他经济来源支撑着全球的 以太坊虚拟机（EVM） 来实现以太坊网络。

我跟合约账户交互和我跟外部账户交互有什么不同？？

与EOA交互，本质是人给人转账；与CA交互，本质是人触发一段不可篡改的程序运行

Gas在EOA to EOA时只是记账付费（手续费），在EOA to CA时是计算➕状态修改的费用。

每个账户都包含四个关键字段：

-   **Nonce**：防止重复交易的计数器（EOA 记录发送次数，CA 记录创建合约次数）。
    
-   **余额**：账户持有的 ETH 数量（单位为 Wei）。
    
-   **CodeHash**：EOA 为空哈希，CA 存储合约字节码的哈希值。
    

• • **StorageRoot**：记录账户数据的 Merkle 树根哈希（如 NFT 归属关系）。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->







23:30 Tue 13 Jan 2026 因为工作原因今天晚上的闲暇时间不是很多，继续在阅读入门导读。

今晚就只在钻研一个问题，什么是Layer1, Layer2,Sidechains?什么是Application Layer应用层、Protocol Layer协议层、Scaling Layer扩展层？

L1（主网）随着用户以及交易量的增加，光有个L1无法满足所有用户的交易需求，为了减少排队于是有了L2（二层扩展解决方案）和sidechains，假如以太坊永远都只有十个人互相交易就不用L2和sidechains了。

**L1的定位：**

-   区块链系统的“最终裁判”和“公证处”
    

**主要职责：**

-   维护共识与安全
    
-   存储最终状态
    
-   确保交易不可篡改
    

**特点：**

-   安全性最高
    
-   去中心化程度高
    
-   但速度慢、费用高、吞吐量有限
    

L2=以太坊的合单快递，把海量小包裹（交易）打包成一个大包裹、只付一个大包裹的邮费，主网确认后大家再分摊手续费。（交易的安全还是靠L1兜底的）---which is L2和sidechains最大的分水岭

> **L2 是：把“交易执行”放到链下，把“最终结果 + 证明”交给 L1 ---明天继续纠结这句话，放到链下是什么意思**

Sidechains靠bridge和主网（L1）连接，sidechains有点像第三方机构，安保是自己的团队，不完全靠主网，交易速度快费用低。但是如果这个第三方机构出事了，主网不能兜底。sidechains就是牺牲了安全，拉满了速度和最低的交易费（gas）

Application layer就是我们每天能接触到的和以太坊交易相关的产品比如metamask，各种app。

Protocol Layer算是web3的法律法规，看不见摸不着但是存在像是底层规则，

### **在以太坊里就包括共识机制（PoS）EVM执行合约、账户规则、Gas规则**

Scaling layer扩展层 提升性能和降低成本的解决方案。我的理解是包含了L2，这两个概念肯定有重叠的部分。

今日复盘：边上班别学真的好累啊，尤其是时差加早起。但是学了就很棒了，明天继续努力吧，坚持到底比较重要，我也不知道能走到哪一步。13 Jan End
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->








**区块链基础概念**

**区块链是一种去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据。每条链由一系列按照时间顺序相连的“区块”组成，每个区块包含了多笔交易数据及元数据，确保了数据记录的完整性与可追溯性。**

**区块：交易记录等一些信息，和之前的区块摘要（哈希）**

-   **区块链就像一个写不完的账本，每一页就是一个区块，每一页都写满了交易记录（转账、合约等实际内容）、**
    
-   **同时每一页右上角都盖了一个指纹章（本页的哈希值）**
    
-   **下一页的左上角都会先抄写前一页的指纹章内容（前一页的哈希值）**
    
-   如此循环会形成一种连锁反应的保护机制，要想改动一笔交易，就必须同时改掉后面所有页的指纹
    

区块链的特性：不可篡改，公开透明、匿名，快速交易

一个区块链网络中有非常多的节点（矿机）来记账，每个节点都会记录完整的、相同的区块链信息！

每一个节点基本上就是一台（或多台）电脑/服务器/设备，但不是所有节点都叫“矿机”，也不是所有“矿机”都一定是完整节点。组装了对应的区块链软件，并且连接网络参与工作采暖节点。

**节点（Node）** = 任何一台运行了区块链软件、连入网络的设备（电脑、服务器、甚至手机、树莓派），它参与网络的“记账验证、数据传播”等工作。

**矿机** = 专门用来“挖矿”（算哈希、竞争出块）的硬件设备，通常是高性能的ASIC矿机（比特币）或GPU/CPU集群（以太坊早期），它们**必须运行节点软件**才能工作，所以**矿机一定是节点**，但**节点不一定是矿机**。

节点激励机制：网络节点服务提供商可以得到奖励，比如比特币。比特币具有货币的属性，它的价格由供需关系决定，不过容易受到热点新闻的影响出现大幅度波动。

比特币的优点也是缺点，难以追踪和限制

以太坊（Ethereum）被称为“区块链 2.0”，它不仅是一种加密货币（以太币 ETH），更是一台支持智能合约的“全球共享计算机”。

比特币共识机制，工作量证明（Proof of Work），矿工通过算力竞争记账权。挖矿是指

       • 全世界的矿工用电脑算一道**非常难但答案很好验证的数学题**

• **谁最先算出来，谁就获得记账权**

• 这个人把最近的交易打包成一个区块（block）

👉 本质是：**用算力竞争记账权**

挖矿就是在没有人当老板的情况下，大家怎么一起记账。谁付出的成本最高，谁就临时当一次记账员。

全世界会有很多人（很多台电脑）同时竞争“记账”资格为了获得奖励（比特币），平均10min会有一个胜利者。

奖励胜利者的比特币来自两个地方。1.新生成的币，写在代码里，所有人都提前知道，慢慢变少（通胀控制）。 2. 交易手续费，发起交易者给的小费。

Mon 12 Jan 23:40 -----明天还要上班的原因，今天就只了解了一些基本概念，感谢ChatGPT老师用很多大白话给我解释了很多专业术语。今天已经完成了入门导读的前两个部分，还有许多笔记需要完善。

今日复盘的话，在做Meta Mask转钱任务和铸造Mint的时候碰到了一些问题，最后看到群消息发现有些确实是bug，在这里浪费了一些时间，因为自己是完全零基础所以还是有些害羞在群里问问题。希望明天会有时间完成12号和13好的所有任务！

EoA=External owned Account (银行账户) 公钥（银行账号）私钥（银行卡密码）
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
