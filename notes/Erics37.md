---
timezone: UTC+8
---

# Erics37

**GitHub ID:** Erics37

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->
深入探讨 Solidity 中的 **“合约 (Contract)”** 与 Python/C++ 中的 **“类 (Class)”** 之间的异同

1\. 核心概念映射表

首先，建立一个直观的概念映射：

| 特性 | Solidity (智能合约) | Python / C++ (传统编程) | 关键区别 |
| 定义关键字 | contract | class | 语法极其相似 |
| 实例化 | 部署 (Deployment) | 实例化 (Instantiation) | 部署是上链过程，消耗真金白银 (Gas) |
| 实例引用 | address (地址) | 指针 (C++) / 引用 (Python) | 地址是全球唯一的 20 字节十六进制字符串 |
| 成员变量 | 状态变量 (State Variables) | 实例变量 / 成员变量 | 状态变量永久写在区块链“硬盘”上 |
| 构造函数 | constructor | __init__ / ClassName() | 部署时只执行一次，之后永远无法再次调用 |
| 方法调用 | 交易 (Transaction) / 调用 (Call) | 函数调用 | 外部调用需要签名、付 Gas 并等待矿工打包 |
| 析构/销毁 | selfdestruct (已不推荐) | __del__ / ~ClassName() | 合约通常追求“永生”，极难彻底删除 |

* * *

### 2\. 详细异同点分析

2.1 实例化：从“内存分配”到“链上部署” (最大差异)

**Python/C++**: `obj = MyClass()`

**发生地**: 计算机内存 (RAM)。

**成本**: 几乎为零，毫秒级完成。

**生命周期**: 进程结束或对象销毁时，内存释放，数据消失。

**Solidity**: `new MyContract()` 或 使用工具部署

**发生地**: **以太坊区块链网络**。

**本质**: 发送一笔特殊的交易，将编译后的**字节码**上传到链上，并生成一个唯一的**合约地址** (Contract Address) 。

**成本**: **非常昂贵**。部署一个标准合约可能花费几十到几百美元的 Gas 费。

**生命周期**: **永生**。一旦部署，代码和数据永久存在于全球所有全节点的数据库中，不可篡改，除非硬分叉 。

2.2 数据存储：成员变量 vs 状态变量

-   **Python/C++**:
    

类的成员变量存在**堆栈/堆内存**中。

访问速度极快。

程序重启后数据丢失（除非手动写文件/数据库）。

-   **Solidity**:
    

合约的成员变量被称为**状态变量 (State Variables)** 。它们直接存储在区块链的 **Storage (存储树)** 中。

**特性**: **自动持久化**。你不需要写 SQL 或文件保存代码，变量的值就像写在石头上一样，永远保存在那里。

**代价**: **读写极其昂贵**。修改一个状态变量的值需要消耗大量 Gas。

_迁移建议_: 永远不要把 Solidity 合约当成普通类来存大量数据（如存一张图片），只存关键的哈希或逻辑状态。

2.3 方法调用：函数跳转 vs 交易消息

-   **内部调用 (Internal Call)**:
    

Solidity 的 `private` 或 `internal` 函数调用与 C++/Python 几乎一样，是内存中的跳转，Gas 费较低。

-   **外部调用 (External Call)**:
    

当你调用另一个合约的函数，或者用户调用你的合约时，这**不是**简单的函数跳转。

**本质**: 发送一条**消息 (Message)**。

**限制**: 只能传递值类型或简单的引用类型，不能像 Python 那样传递一个复杂的对象引用。

**安全性**: 外部调用存在**重入攻击 (Reentrancy)** 风险——对方合约可能会恶意反向回调你，这在 C++/Python 中很少见 。

**可见性修饰符**: Solidity 特有的 `external` 关键字，表示函数只能被外部调用，不能被合约内部直接调用（省 Gas）。

2.4 接口与多态

-   **相似点**:
    

Solidity 支持 `interface` (接口) 和 `abstract contract` (抽象合约)，用法与 C++ 的纯虚类或 Java/Python 的接口非常像

支持多重继承：`contract Dog is Animal, Pet { ... }` 。

**不同点**:

**远程调用接口 (ABI)**: 要调用另一个已经部署的合约，你不需要它的源代码，只需要它的 **ABI (应用二进制接口)** 和 **地址**。这就像在 API 开发中只需要 JSON 文档一样 。

* * *

### 3\. 代码思维迁移示例

**场景：一个简单的计数器**

**Python 写法 (内存版):**

Python

```
class Counter:
    def __init__(self):
        self.count = 0  # 存在内存里，重启就没了

    def increment(self):
        self.count += 1
```

**Solidity 写法 (链上版):**

Solidity

```
contract Counter {
    // 状态变量：存在区块链上，永久保存，写入要花钱
    uint256 public count; 

    // 构造函数：部署时执行一次
    constructor() {
        count = 0;
    }

    // 外部交易：每次调用这个函数，用户都要付 Gas 费
    function increment() external {
        count += 1;
    }
}
```

### 总结-solidity的特点

1.  **超级单例**: 部署后在全网只有一个“真身”（位于特定地址）。
    
2.  **自带数据库**: 它的成员变量就是一张不需要维护的数据库表。
    
3.  **付费运行**: 每次调用它的 `public/external` 方法，调用者都要投币 (Gas)。
    
4.  **不可撤销**: 代码发上去就改不了了（除非用高级的代理模式），不像 Python 脚本可以随时修修补补 。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->

### 一份代码的微观结构

-   🔴 ：Solidity 语言规定必须这样写的词（固有用法）。
    
-   🔵：变量名、函数名。
    

Solidity

```
// 🔴 SPDX-License-Identifier: MIT  <-- 版权声明（固定写法）
// 🔴 pragma solidity ^0.8.0;       <-- 版本指令（固定写法）

// 🔴 contract 🔵 Bank {            <-- contract 是关键字; Bank 是你起的合约名
    
    // 1. 状态变量（存放在链上，类似数据库字段）
    // 🔴 address 🔴 public 🔵 owner;     <-- 类型(address) 可见性(public) 变量名(owner)
    // 🔴 mapping(🔴 address => 🔴 uint256) 🔴 public 🔵 balances; 
    // ^-- 映射类型(mapping) 固有用法(=>) 变量名(balances)

    // 2. 构造函数（部署时只运行一次）
    // 🔴 constructor() {
    //     🔵 owner = 🔴 msg.sender;  <-- msg.sender 是全局变量(固有用法)，代表部署者
    // }

    // 3. 函数定义
    // 🔴 function 🔵 deposit() 🔴 public 🔴 payable { 
    // ^-- 关键字   函数名     可见性   可支付(能收钱)
        
        // 🔴 require(🔴 msg.value > 0, "Empty"); <-- 错误检查(固有用法)
        
        // 逻辑处理
        🔵 balances[🔴 msg.sender] += 🔴 msg.value; 
    // }
// }
```

* * *

### 函数结构

Solidity 的函数定义就像拼乐高，有 6 个关键部位。

公式：

function + 函数名 + (参数列表) + 可见性 + 状态修饰符 + returns (返回值)

1\. 头部定义（必填 & 自定义）

-   `function`: **\[固定\]** 告诉编译器这里开始定义函数。
    
-   `myFunction`: **\[自定义\]** 你给函数起的名字。
    
-   `(uint256 _amount)`: **\[自定义\]** 参数名和类型。习惯上参数名前加下划线 `_` 以区分状态变量。
    

2\. 可见性修饰符 (Visibility) —— **\[固定，4选1\]**

决定了谁能看到、谁能调用这个函数。

-   `public`: **最开放**。所有人（内部、外部、其他合约）都能调。
    
-   `private`: **最封闭**。只有**本合约内部**能调，继承的子合约都不能调。
    
-   `internal`: **家族通用**。本合约和**继承的子合约**能调，外部不能调。
    
-   `external`: **仅限外部**。只有外部用户或其他合约能调，**本合约内部不能直接调**（省 Gas，效率高）。
    

3\. 状态修饰符 (Mutability) —— **\[固定，3选1\]**

决定了函数对链上数据（状态）的权限。

-   (不写): **默认**。可读、可写链上状态（最贵）。
    
-   `view`: **只读**。能看链上数据，但不能改（不消耗 Gas，除非被其他合约调用）。
    
    -   _场景：查询余额、查询名字。_
        
-   `pure`: **纯净**。**不读也不改**链上数据，纯粹算数学题。
    
    -   _场景：计算_ `1+1=2`_。_
        
-   `payable`: **可收钱**。**特殊修饰符**，带上它，函数才能接收 ETH，否则发币过来会报错。
    

4\. 返回值 (Returns) —— **\[固定\]**

-   `returns (uint256)`: 声明返回的数据类型。注意是 `returns` (复数)。
    

* * *

### 全局变量与函数

**不需要定义，直接用**。

1\. 身份与环境 (Context)

-   `msg.sender` (**最核心**): 当前**调用者**的地址。谁调用的这个函数，值就是谁。
    
    -   _用途：权限控制（你是管理员吗？）、记录谁存了钱。_
        
-   `msg.value`: 调用时附带发送了多少 **ETH**（单位是 wei）。
    
    -   _用途：判断用户付了多少钱。_
        
-   `block.timestamp`: 当前区块的**时间戳**（秒级）。
    
    -   _用途：锁定时间、倒计时。_
        
-   `tx.origin`: 交易的**原始发起人**（一定是一个真人/EOA，不是合约）。
    
    -   _警告：安全风险高，尽量少用，一般用_ `msg.sender`_。_
        

2\. 错误处理 (Error Handling)

Solidity 遇到错误会**回滚（Revert）**，即撤销之前所有的操作，并退还剩余 Gas。

-   `require(条件, "报错信息")`: **最常用**。如果条件不满足，就回滚。
    
    -   _例：_`require(balance >= amount, "余额不足");`
        
-   `revert("报错信息")`: 直接回滚。常用于复杂的 `if/else` 逻辑中。
    
-   `assert(条件)`: 用于检查**不应该发生**的内部错误（如代码逻辑 bug）。消耗所有 Gas，慎用。
    

3\. 资产发送 (Sending ETH)

假设要把 ETH 转给地址 `addr`：

-   `addr.transfer(amount)`: **老用法，不推荐**。Gas 限制 2300，容易失败。
    
-   `addr.send(amount)`: **老用法，不推荐**。失败返回 false，不自动回滚。
    
-   `payable(addr).call{value: amount}("")`: **推荐用法**。
    
    -   _解释_：最底层的调用方式，防重入攻击需配合 CEI 模式。
        
    -   _写法_：`(bool success, ) = payable(receiver).call{value: 1 ether}(""); require(success, "Transfer failed");`
        

4\. 数学与加密

-   `keccak256(abi.encodePacked("abc"))`: **哈希计算**。生成唯一的 32 字节哈希值。
    
    -   _用途：生成随机数（伪随机）、生成唯一 ID、验证签名。_
        
-   `abi.encode(...)`: **编码**。将数据打包成字节码。
    

* * *

### 经典数据结构

1.  **Mapping (映射/哈希表)**
    
    -   语法：`mapping(Key类型 => Value类型) 变量名;`
        
    -   _例子_：`mapping(address => uint256) public userBalances;`
        
    -   _解释_：一本账本，查 `address` (人)，得到 `uint256` (钱)。
        
2.  **Struct (结构体)**
    
    -   语法：`struct 名字 { ... }`
        
    -   _例子_：
        
        Solidity
        
        ```
        struct User {       // 固有用法 struct; 自定义名 User
            uint256 id;     // 成员变量
            string name;
        }
        User public admin;  // 使用结构体定义变量
        ```
        
3.  **Array (数组)**
    
    -   `uint256[] public arr;` (动态数组，长度可变)
        
    -   `uint256[10] public arrFixed;` (固定数组，长度固定)
        
    -   _操作_：`arr.push(1);` (增加), `arr.pop();` (删除最后一个), `arr.length` (查长度)。
        

### 一张图总结

| 类别 | 关键字 (固有用法) | 含义 |
| 基础 | contract, interface, library | 定义合约、接口、库 |
| 存储 | memory, storage, calldata | 临时内存、永久存储、输入数据 |
| 函数 | public, private, view, payable | 可见性与权限 |
| 全局 | msg.sender, msg.value | 谁调用的？付了多少钱？ |
| 全局 | block.timestamp | 现在几点了？ |
| 控制 | require, revert, emit | 检查错误、触发事件 |
| 类型 | mapping, struct, uint256, address | 数据类型 |
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->


如果把 Dapp 比作一个淘宝网站，智能合约开发就是编写那个“自动处理订单、扣款、发货”且“无法被老板随意篡改”的后台程序。

### 1\. 核心定义：它是“链上的后端”

在传统 Web2 开发中，后端代码运行在中心化服务器（如 AWS）上，控制着数据库。而在 Web3 开发中：

-   智能合约就是后端逻辑：它是一段部署在区块链（如以太坊）上的代码，定义了业务规则（例如：转账规则、投票机制、NFT 铸造逻辑）。
    
-   区块链就是数据库：合约的状态变量（State Variables）直接永久存储在链上，构成了应用的状态。
    
-   自动执行的承诺：它像一台\*\*“自动售货机”\*\*。只要用户投入足够的资金（Gas + Value）并按下按钮（调用函数），合约就会严格按照写死的代码执行，没有任何中介能阻拦。
    

### 2\. 开发环境与工具：你需要装配什么？

实习手册强调，现代智能合约开发不再是手写二进制代码，而是有一套成熟的工程化工具链：

-   编程语言：Solidity 是绝对的主流，它是一种静态类型、面向对象的语言，语法类似 JavaScript 和 C++。
    
-   开发框架：
    
    -   Foundry：基于 Rust，速度极快，目前非常流行。它让你用 Solidity 写测试代码，不仅能编译、部署，还能进行模糊测试（Fuzzing）。
        
    -   Hardhat：基于 JavaScript/TypeScript，生态丰富，插件多，适合需要复杂脚本部署的项目。
        
    -   Remix：基于浏览器的 IDE，无需安装环境，适合新手快速测试和原型开发。
        
-   交互接口：你的电脑（或前端）通过 RPC（远程过程调用） 节点与区块链沟通。你可以把 RPC 想象成连接银行核心系统的 ATM 机。
    

### 3\. 开发全流程：从写代码到上链

第一步：编写合约 (Writing)

你需要定义合约的结构，通常包含：

-   状态变量：记录数据（如 `mapping(address => uint256) public balances` 记录余额）。
    
-   函数：执行逻辑（如 `transfer` 函数修改余额）。
    
-   事件 (Events)：合约执行时的“日志广播”，方便前端和检索器（Indexer）监听链上发生了什么。
    

第二步：编译 (Compiling)

机器看不懂 Solidity，编译器会将其转换为两个核心产物：

-   Bytecode (字节码)：这是给 EVM（以太坊虚拟机）看的机器码，最终部署到链上的就是这一串 16 进制字符。
    
-   ABI (应用二进制接口)：这是给前端（JS 代码）看的“说明书”。它描述了合约有哪些函数、参数类型是什么，前端必须拿着 ABI 才能正确调用合约。
    

第三步：测试与安全 (Testing & Security)

这是 Web3 开发与 Web2 最大的不同——代码即金钱，且不可撤销。

-   必须写测试：使用 Foundry 或 Hardhat 编写单元测试，覆盖各种边缘情况。
    
-   安全防护：必须防范经典漏洞，如重入攻击（Reentrancy）（先更新状态再转账）、整数溢出（Solidity 0.8+ 已内置保护）和权限控制（谁能提款）。
    
-   审计：上线前通常需要第三方机构（如 OpenZeppelin, 慢雾）进行代码审计。
    

第四步：部署 (Deploying)

将编译好的 Bytecode 发送到区块链上。

-   环境选择：通常先在 Sepolia 或 Holesky 这样的测试网部署，因为主网部署需要消耗真金白银的 ETH（Gas 费）。
    
-   上链：部署成功后，你会得到一个合约地址（Contract Address），这就是你的程序在链上的“家”。
    

### 4\. 它如何与世界交互？

智能合约部署后不是孤岛，它需要与前端配合形成 Dapp：

-   读数据：前端可以通过 RPC 节点免费读取合约状态（调用 `view` 函数）。
    
-   写数据：当用户要执行操作（如留言、转账）时，前端会唤起用户的钱包（如 MetaMask），请求用户对交易进行签名。签名后的交易广播到网络，矿工打包并执行合约代码，消耗用户的 Gas。
    
-   数据索引：为了应对复杂查询（比如“查询某用户持有的所有 NFT”），通常还会开发一个检索器（Indexer），它监听链上事件并存入传统数据库供前端查询。
    

### 5\. 高阶挑战：Gas 优化

在 Web2，代码效率低一点可能只是服务器多跑几毫秒；在 Web3，代码效率低意味着用户要付更多的钱。

-   Gas 优化是合约开发的重要一环。例如，尽量减少写入存储（Storage）的操作，多用内存（Memory），因为链上存储极其昂贵。
    

总结： 智能合约开发就是用 Solidity 语言编写一套严谨的业务逻辑，通过编译生成机器码和接口说明书，在本地环境（Foundry/Hardhat）进行近乎苛刻的安全测试后，将其部署到区块链网络上。一旦部署，它就成为了一个不可篡改、自动运行、公开透明的后端服务，等待着前端通过钱包签名来触发它的功能。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->



随着以太坊完成“合并”（The Merge）并迈向以 Layer 2 为中心的扩容新阶段，Web3 行业正从早期的草莽探索期，逐步转型为以高性能基础设施和真实应用场景为驱动的成熟生态。对于想要入局的建设者而言，理解技术路线图（Roadmap）不仅是理解行业的未来，更是看清就业机会的“导航图”。

本文将结合以太坊的最新发展，深入探讨 Web3 的行业前景与由此衍生的就业机遇。

* * *

## 一、 行业前景：从“资产炒作”到“价值互联网”

Web3 的核心愿景是构建一个无需许可、抗审查且所有权归用户的“价值互联网”。根据最新的技术与生态演进，未来前景主要集中在以下三个维度：

### 1\. 基础设施：Layer 2 与低费率时代的到来

过去，高昂的 Gas 费是阻碍 Web3 大规模应用的主要瓶颈

现状：随着“坎昆升级”（Dencun）引入 EIP-4844（Blob 交易），以太坊主网已转型为数据可用性（DA）层和结算层，而将高频交易推向 Layer 2（如 Arbitrum, Optimism, Base 等

前景：L2 的手续费已大幅下降，这使得高频交互的应用（如链上游戏、社交网络、微支付）在经济上成为可能 2。未来的技术路线（Danksharding）将进一步释放带宽，为承载千万级用户做好准备

### 2\. 金融深化：DeFi 的复利效应与 RWA

去中心化金融（DeFi）不再局限于简单的代币互换。

流动性与再质押：流动性抵押（LST）和再质押（Restaking，如 EigenLayer）不仅提高了资金效率，还创造了新的“安全服务”市场

RWA（现实资产上链）：国债、股权等传统金融资产正通过合规渠道上链，贝莱德等机构的入场标志着“链上金融”与传统金融的深度融合

### 3\. 应用生态：NFT 与 DAO 的功能化

NFT：正从单纯的“小图片炒作”转向实用性。未来的 NFT 将更多作为会员凭证（SBT）、游戏道具、甚至现实世界的资产证明（房产、票据）

DAO：去中心化组织正在探索更成熟的治理模式，用于资助公共物品（如 Gitcoin）、管理协议国库或进行集体投资

## 二、 就业方向：技术为核，多元并进

Web3 的就业市场不再仅限于“炒币”，而是需要具备深厚技术功底或特定行业认知的专业人才。基于以太坊生态的构成，主要的就业方向如下：

### 1\. 核心技术类：硬核建设者

这是行业需求最大、薪资天花板最高的领域。

智能合约工程师：这是 Web3 的“后端开发”。你需要精通 Solidity 语言，理解 EVM（以太坊虚拟机）的运行机制，掌握 Gas 优化技巧，并熟悉 Hardhat 或 Foundry 等开发框架

协议/客户端工程师：负责维护区块链网络本身（如 Geth, Prysm 客户端）。这通常涉及到 Go、Rust 或 C++ 等底层语言，需要深入理解 P2P 网络、共识算法（PoS）和密码学

安全审计专家：由于智能合约不可篡改且涉及资金，安全性至关重要。审计师需要能识别重入攻击、整数溢出、逻辑漏洞等风险。这是一个“高薪且高压”的精英方向

扩容与密码学研究员（ZK）：随着 ZK-Rollup 的兴起，对零知识证明（Zero-Knowledge Proofs）有研究能力的数学家和密码学家极其稀缺

### 2\. 应用与前端类：连接用户与链

Web3 全栈/前端工程师：通过 ethers.js、viem 等库，将传统的前端页面（React/Vue）与区块链节点连接。你需要处理钱包连接、交易签名、事件监听等特有逻辑

数据分析师：利用 SQL（在 Dune 或 Flipside 上）或 Python 分析链上数据。DeFi 协议需要分析师来优化经济模型、监控风险；VC 需要分析师来追踪资金流向和用户行为

### 3\. 非技术/综合类：生态的粘合剂

Web3 社区强调“共识”与“协作”，因此非技术岗位同样重要。

产品经理（PM）：需要理解 Tokenomics（代币经济学）和 DAO 的治理逻辑，设计出既符合去中心化精神又具有良好用户体验（UX）的产品

社区经理与运营：Web3 项目往往由社区驱动。运营者需要管理 Discord/Telegram，组织治理投票，连接全球贡献者，建立项目共识

法律与合规：随着 RWA 和机构资金的进场，懂得如何处理监管框架、合规发行代币的法律人才需求激增
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->




# 智能合约是如何工作的

### 1\. 核心定义与账户结构

智能合约本质上是以太坊网络中的一种特殊账户，称为合约账户（Contract Account）。它与我们常用的钱包账户（EOA）有本质区别：

代码控制：合约账户没有私钥，其行为完全由内部的代码逻辑（Code）控制，而EOA由私钥控制。

账户四要素：在以太坊的世界状态中，智能合约账户包含四个核心字段：

1, Nonce：记录该合约创建了多少个其他合约（防止重放）。

2, Balance：账户持有的ETH余额（合约也能像人一样持有资金）。

3, StorageRoot：指向该合约的存储树（Merkle-Patricia Trie）根哈希，这里保存了合约的所有状态变量（如代币余额表、游戏数据等）。

4, CodeHash：合约代码（EVM字节码）的哈希值，标识了该账户的逻辑。

### 2\. 生命周期与工作流程

A. 编写与编译 (Development)

开发者使用高级语言（如 Solidity）编写逻辑，然后通过编译器将其转换为机器能读懂的两种产物：

1.  字节码（Bytecode）：EVM（以太坊虚拟机）真正执行的指令集。
    
2.  ABI（应用二进制接口）：一份JSON格式的“说明书”，告诉前端或其他合约如何与该合约交互（有哪些函数、参数类型等）。
    

B. 部署 (Deployment)

合约是如何上链的？

创建交易：用户发起一笔特殊的交易，目标地址（to）为空，数据字段（data）包含合约的初始化代码。

地址生成：合约地址不是随机的，通常由`创造者地址 + Nonce`计算得出（CREATE），或者通过`创造者地址 + 盐 + 代码哈希`计算（CREATE2），后者可以预测合约地址。

初始化：EVM执行初始化代码（构造函数），设置初始状态，然后将\*\*运行时代码（Runtime Bytecode）\*\*永久存储在链上。

C. 执行机制 (Execution via EVM)

当有人调用合约时，EVM（以太坊虚拟机）作为执行引擎开始工作。这是一个沙盒环境，保证了全网所有节点执行结果的一致性。

逐条执行：EVM将字节码拆解为操作码（OpCode），如`ADD`（加法）、`SSTORE`（写存储），逐条解释执行。

数据存储区：

Stack（栈）：用于临时运算，类似CPU寄存器。

Memory（内存）：临时数据存储，交易结束后丢弃。

Storage（存储）：永久保存合约状态（如`mapping`变量），写入成本极高。

D. 资源限制 (Gas Mechanism)

为了防止死循环或恶意攻击，执行每一步操作都需要消耗Gas（燃料）。

付费原则：发起交易的人必须预付Gas。

耗尽回滚：如果在执行过程中Gas用完（Out of Gas），EVM会立即停止并回滚所有状态修改，但已经消耗的Gas不会退还。

### 3\. 关键特性与限制

被动触发：智能合约不能主动发起交易。它必须由一个外部账户（EOA）发起交易来触发，或者由其他已经被触发的合约进行调用（内部消息调用）。

不可篡改性：合约一旦部署，其代码逻辑默认为不可修改。如果发现Bug，通常无法直接“修补”，只能通过\*\*代理模式（Proxy Pattern）\*\*将请求指向新的逻辑合约来实现“升级”。

公开透明：合约的字节码、状态变量和每一笔交易记录在链上都是公开可见的，任何人都可以进行审计。

### 4\. 总结

智能合约的工作机制可以概括为：“代码即法律，EVM即法庭”。

1.  开发者写好规则（代码）。
    
2.  部署后，代码变成链上的一个账户（有地址、有存储）。
    
3.  用户发交易触发代码。
    
4.  EVM在全网节点上以确定的方式执行代码，修改账户状态（如余额变化）。
    
5.  Gas机制确保系统不会因为恶意代码而停机。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->





## 1, 链上身份与资产交换

> **核心主题**：ENS、DEX (去中心化交易所)、链上身份

### 1\. 核心概念

-   **链上身份 (Identity)**：在 Web3 中，你的钱包地址就是你的通用账户。不同于 Web2 每个 APP 都要注册账号，Web3 是“一个账户走天下”，你的资产（Inventory）和声誉随地址移动。
    
-   **ENS (Ethereum Name Service)**：将复杂的 `0x...` 地址映射为易读的名称（如 `sanford.eth`），类似于把 IP 地址变成网址。
    
-   **DEX (Uniswap)**：去中心化交易所。不依赖中心化机构（如币安、Coinbase），直接通过智能合约在链上进行代币兑换。
    

### 2\. 实操流程

1.  **创建/管理账户**：在 MetaMask 中创建新账户（Account），体验同一助记词下管理多个地址。
    
2.  **注册 ENS 域名**：
    
    -   访问 ENS 应用，搜索心仪域名。
        
    -   **Commit 机制**：第一笔交易“提交请求”（防抢注），等待约 1 分钟。
        
    -   **Register 机制**：第二笔交易正式注册。
        
    -   **反向解析 (Reverse Record)**：设置将地址指向域名，这样 DApp 就能显示你的名字而不是 `0x...`。
        
3.  **使用 Uniswap 换汇**：
    
    -   连接钱包，体验“身份跟随”（网站自动识别 ENS 域名）。
        
    -   将 ETH 兑换为稳定币（如 DAI）。理解稳定币是为了避险（如避免 ETH 价格波动）。
        
    -   **理解 DEX 原理**：这就像一台自动贩卖机，资金池（Pool）里有 ETH 和 DAI，你放入一种，按比例取出另一种，全程由合约执行。
        
4.  **查看资产大盘 (Zapper)**：
    
    -   访问 Zapper.fi 等资管平台，输入 ENS 域名，查看该地址下所有的 Token、NFT 和 DeFi 仓位。验证“数据公开透明，前端只是展示工具”的特性。
        

* * *

## 2, NFT 原理与元数据

> **核心主题**：ERC-721、IPFS、元数据 (Metadata)

### 1\. 核心概念

-   **同质化 vs 非同质化**：
    
    -   **ERC-20 (同质化)**：像钞票，你的 1 ETH 和我的 1 ETH 没区别，记录的是**余额 (Balance)**。
        
    -   **ERC-721 (非同质化/NFT)**：像艺术品或房产证，每个 Token 都有唯一的 **ID**，记录的是**所有权 (Owner)**。
        
-   **元数据 (Metadata)**：NFT 长什么样（图片、属性）通常不存放在昂贵的区块链上，而是存放其**链接 (URI)**。
    
-   **IPFS**：去中心化存储网络。通过内容哈希寻址（Content Addressing），保证图片一旦上传，只要有人存储，内容就不可被篡改（改了内容，哈希/地址就会变）。
    

### 2\. 实操流程

1.  **购买/铸造 (Mint) NFT**：
    
    -   可以直接通过项目官网 Mint，也可以直接在 Etherscan 上调用合约的 `mint` 函数（展示“绕过前端直接交互”的能力）。
        
2.  **查看元数据 (Token URI)**：
    
    -   在 Etherscan 读取合约，输入 Token ID，获取 `tokenURI`。
        
    -   **关键检查**：查看 URI 是指向中心化服务器（如 `http://api.game.com/...`，有被项目方篡改风险）还是 IPFS（如 `ipfs://...`，相对安全不可篡改）。
        
3.  **全链上 NFT (On-chain NFT)**：
    
    -   演示如 SVG NFT，其图像数据直接由智能合约代码生成（SVG 代码在链上），完全不依赖外部存储，最为持久。
        
4.  **跨平台展示**：
    
    -   在 OpenSea 买的 NFT，去 Rarible 或 Zapper 也能看到。验证 NFT 是存在链上的，不属于任何单一平台。
        

* * *

## 3, 进阶技巧与安全

> **核心主题**：Gas 机制、Nonce（交易序号）、Layer 2、多签钱包

### 1\. 核心概念

-   **Nonce (交易序号)**：防止重放攻击。交易必须按顺序执行（Nonce 1 -> 2 -> 3）。如果 Nonce 2 卡住了，Nonce 3 永远不会被打包。
    
-   **Gas 战争**：出价高者得区块空间。
    
-   **Layer 2 (如 Optimism)**：通过 Rollup 技术实现“主网安全，侧链速度”，Gas 费极低。
    
-   **多签钱包 (Multisig/Gnosis Safe)**：需要 N 个人中的 M 个人签名才能执行交易（如 2/3 签名）。比单一私钥更安全，适合资金管理。
    

### 2\. 实操流程 (故障排除演练)

1.  **模拟“交易卡死”与加速**：
    
    -   故意设置极低的 Gas 费发送交易，导致交易一直 Pending（卡在内存池）。
        
    -   **加速 (Speed Up)**：在钱包点击加速，本质是发出一笔**相同 Nonce 但 Gas 费更高**的交易来覆盖旧交易。
        
2.  **取消交易**：
    
    -   如果不想加速，可以发一笔 **0 ETH 转给自己** 的交易，将 Nonce 设置为与卡住的那笔交易相同，且 Gas 给高，以此“顶掉”原交易。
        
3.  **Layer 2 跨链 (Bridge)**：
    
    -   使用 Bridge 将 ETH 从主网跨到 Optimism。
        
    -   体验 L2 的秒级确认和极低 Gas 费。
        
4.  **多签钱包体验**：
    
    -   创建一个 Gnosis Safe (现为 Safe)，设置 2/3 多签规则。
        
    -   发起转账提案，体验“一人提案，多人签名”的流程。
        
    -   **WalletConnect**：演示如何用多签钱包连接 DApp（如 Uniswap），作为机构/团队身份进行交互。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->






# Web3 安全与合规

使用费曼笔记结构。

1\. 直觉模型 (Mental Model)

“悬崖边的全透明银行”

请把 Web3 世界想象成一座建立在悬崖边的 全透明银行。

\* 安全（Security）：在这个银行里，没有保安拿着枪巡逻，而是靠 “自动触发的陷阱”（Slashing 罚没机制）来防盗。任何人如果想在大厅里搞破坏（比如双重投票），地板会瞬间裂开，直接没收他的押金。同时，因为金库大门（智能合约）是透明玻璃做的，黑客不需要炸药，只需要拿着放大镜找玻璃上的裂缝（代码漏洞）就能把钱吸走。

\* 合规（Compliance）：以前这家银行只收只有数字代码的“游戏币”，现在它开始接受现实世界的黄金和房产（RWA 现实资产）。为了收这些真金白银，它必须在门口装上 “安检门”（KYC/AML），不再是蒙面人随便进出，而是要穿西装打领带，符合现实世界的法律法规。

2\. 核心逻辑链

逻辑推导：从“代码自治”到“经济博弈”与“现实融合”

\* 因为 区块链（特别是 PoS 以太坊）不再依赖算力挖矿，而是依赖验证者质押资产（Staking）来维护共识，

\* 所以 安全的本质从“比拼硬件成本”变成了“纯粹的经济博弈”：必须设计一套 Slashing（罚没）机制，让作恶的成本（损失 32 ETH 甚至更多）远高于作恶的收益。

\* 导致 系统安全性不再由“好人多”决定，而是由“作恶太贵”决定。同时，随着 DeFi 试图引入国债、股权等 RWA（现实世界资产） 以获取真实收益，导致 纯链上的匿名规则无法满足监管要求，必须引入审计、合规基础设施，形成“合规 DeFi”的新形态（注：此处参考教材关于 RWA 与合规 DeFi 的展望）。

3\. 反常识/盲点

\* 盲点一：开源不等于安全，反而是“公开的靶子”。

初学者常以为“代码开源”意味着大家都在检查，所以很安全。但在 Web3 中，黑客比白帽子更勤奋。智能合约一旦部署就难以修改（Immutability），一个微小的逻辑漏洞（如重入攻击）在传统软件里可能只是个 Bug，在这里就是直接提款机。透明性既是信任的来源，也是攻击者的便利。

\* 盲点二：惩罚（Slashing）不仅是罚款，更是“社死”。

在 PoS 机制下，验证者如果作恶（如双重签名），不仅会损失金钱（ETH 被烧掉），还会被 强制驱逐（Force Exit） 出网络。这不是简单的“交罚单走人”，而是直接被剥夺了参与系统的资格，这种“经济+权限”的双重剥夺是 Web3 安全独有的威慑力。

\* 反常识：合规不是 Web3 的对立面，而是资产增值的“放大器”。

很多人认为 Web3 就是要逃避监管。但教材指出，Web3 的未来潜力在于 RWA（现实资产上链）。只有拥抱监管和合规（如 KYC/AML），机构级的万亿资金（国债、股票市场）才能进入链上。不合规，Web3 永远只是个小的金融游戏；合规，才是从“离岸赌场”变成“全球交易所”的关键。

4\. 我的思考

以前我总觉得 Web3 的安全是靠‘密码学’这种高深的技术来保证的，读完这份教材才发现，真正的防线其实是\*\*‘赤裸裸的人性博弈’\*\*。PoS 的 Slashing 机制简直就是把‘贪婪’变成了护城河——你越想赚钱，就越不敢作恶。而且，我原本以为 Web3 是法外之地，但看到 RWA 和合规 DeFi 的趋势，我意识到 ‘代码即法律’（Code is Law）正在向‘代码适应法律’演变。这不仅没让 Web3 变味，反而让它有了承载真实世界财富的资格。这才是以太坊想做的‘世界计算机’，而不是一个黑客游乐场。”
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->







# Web3 工作原理与运行机制

Web3 的本质是去中心化的价值互联网。它通过区块链技术，将互联网的控制权从中心化平台（如 Google、Facebook）交还给用户。以下是其具体的工作逻辑与运行流程：

## 一、 Web3 的核心运行机制：从中心化到点对点

传统的 Web2 运行在“客户端-服务器”架构上，而 Web3 运行在由成千上万个节点组成的**点对点（P2P）网络**上 。

**节点发现与连接**：当一个 Web3 节点（如以太坊节点）启动时，它通过 UDP 协议和 Kademlia 算法发现邻居节点，并建立加密的 TCP 连接 。

**“八卦”协议传播（Gossip）**：网络没有中央站，信息（交易、区块、投票）像“传八卦”一样在邻居间随机转发，数秒内即可传遍全球 。

**共识验证**：每个节点都会独立验证收到的信息。只有通过共识机制（如以太坊的 PoS）确认的信息，才会被记录在不可篡改的账本中 。

## 二、 账户体系：私钥即所有权

在 Web3 中，你的身份不是账号密码，而是**外部拥有账户（EOA）**

**私钥控制**：EOA 由私钥直接控制。私钥派生公钥，公钥生成地址（以 `0x` 开头） 。

**数字签名**：任何操作（如转账、调合约）都必须经过私钥签名。网络只认签名，不认人。丢失私钥意味着永久失去对账户资产的控制权 。

**自主权**：用户无需向任何机构申请即可创建账户，且没有任何单一实体能冻结该账户 。

## 三、 智能合约

智能合约是部署在区块链上的代码。它是 Web3 实现自动化、无中介协作的关键 。

**自动执行**：逻辑被写死在合约中（如“如果 A 收到货，则释放资金”）。一旦触发条件满足，代码会自动执行，无需律师或中介

**图灵完备**：以太坊的虚拟机（EVM）是图灵完备的，意味着它可以运行几乎任何逻辑，从而支持了 DeFi（金融）、NFT（资产）、DAO（组织）等复杂应用 。

**透明且不可篡改**：合约一旦部署，其代码和状态对全网公开，且默认不可更改，确保了规则的公平性 。

## 四、 去中心化应用

一个完整的 Web3 应用（dApp）通常由以下两部分组成：

**前端界面**：用户交互的网页或移动端，通常通过 Web3 库（如 ethers.js）连接到节点 。

**后端逻辑**：运行在区块链上的智能合约。

**Gas 机制**：为了防止网络被滥用，用户执行合约操作时必须支付 Gas 费（以 ETH 支付）。这就像是给“世界计算机”运行程序付的小费 。

## 五、 分层运作

为了解决性能瓶颈，Web3 正在向分层架构演进：

**Layer 1（主网）**：负责极致的安全、共识和最终结算，是整个系统的“大法官” 。

**Layer 2（扩展层）**：如 Rollup，在链下批量处理成千上万笔交易，然后将压缩后的数据和证明提交回 Layer 1，从而实现低费率和高速度 。

## 六、 Web3 是如何转动的？

1.  **用户发起**：用户通过钱包签名一笔交易。
    
2.  **网络广播**：交易通过 P2P 网络传播到全球验证者手中。
    
3.  **虚拟机执行**：验证者在 EVM 中运行对应的智能合约代码。
    
4.  **共识达成**：验证者对执行结果达成一致，打包成区块。
    
5.  **状态更新**：全网节点更新状态（如你的余额减少，NFT 归属权变更），交易完成。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->








## Web3实习计划是？

由 ETHPanda 和 LXDAO 发起的 Web3 冬季实习计划是一项为期 4 周的免费实战课程，旨在通过运营、技术入门及深度技术三大方向的系统学习，帮助新人快速入行并对接实习或全职岗位。活动于 1 月 12 日正式启动，采用严格的“每日打卡”淘汰机制（每周缺勤不得超过 2 次）与积分排位体系，前两周专注技能共学，第三周进行黑客松实战，第四周直接对接就业资源。

## 阅读完《以太坊》第一章以及《以太坊概览》入门导读后，提出了一些问题。

### 1\. 为什么说PoW除了比PoS环保，还能提高协议的安全性和去中心化程度？

能耗降低是最直观最显著的。但是这样的转变有更深层次的逻辑。

首先是提高了攻击成本：在PoS下，攻击者要进入链，首先要抵押ETH代币，然而一旦对链发起攻击，协议则可以通过罚没机制直接销毁攻击者抵押的资产。然而在PoW中，协议无法直接攻击到入侵者，例如无法销毁攻击者的矿机。

第二，PoS摆脱了对电力和硬件的高度依赖，降低了普通用户的参与门槛，有助于提高分布效率，使网络变得扩展且丰富，提高了抗打击能力。

第三，PoS架构分离了执行层和共识层，这意味着即使某个软件版本出现漏洞，也不会导致整个网络瘫痪，提升了系统的鲁棒性。

### 2\. “图灵完备”对以太坊作为“世界计算机”的意义？它与比特币的脚本有何本质区别？

比特币的脚本语言是有意设计为非图灵完备的，不支持循环语句，以确保交易解析的简单和极高安全性。而以太坊的 EVM 是图灵完备的，这意味着只要给定足够的Gas，它能执行任何可计算的协议。因而图灵完备使得以太坊具有极高的延展性。同时，为了防止图灵完备带来的死循环攻击，以太坊引入了 Gas 机制，确保任何程序如果运行时间过长或消耗资源过多，都会因停气而终止。

### 3\. Layer 2（L2）与 Layer 1（L1）的关系是如何演变的？

在早期，L1 尝试承担所有工作。

现在的路线图中，L1 演变为结算层和数据可用性层，负责极致的安全和终局性；L2 演变为执行层，在链下处理成千上万条交易，然后将压缩后的结果和证明传回 L1。

Rollup通过将计算移至链下，仅将交易数据存储在 L1，既继承了以太坊的安全性，又极大提升了 TPS。通过引入 Blob 空间，L1 为 L2 开辟了专门的数据通道，标志着以太坊正式转型为支撑 L2 生态扩展的基础底座，而非直接与用户交互的零售接口。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
