---
timezone: UTC+8
---

# shaopingZH

**GitHub ID:** shaopingZH

**Telegram:** @ZHANGSHAOPING

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->
### 📝 智能合约笔记：YourCollectible.sol 源码解析 (严谨版)

**1\. 合约定位**  
这是一个基于 OpenZeppelin 库构建的**全功能型** NFT 合约模板。它在基础 ERC721 之上，集成了存储扩展和链上索引功能，适合作为**学习标准实现**或**中小型项目**的起步代码。

**2\. 核心组件解析 (继承分析)**

-   **ERC721:** NFT 的基础标准实现。
    
-   **ERC721Enumerable (链上索引扩展):**
    
    -   _功能：_ 在链上维护所有 Token ID 的数组和索引。
        
    -   _解决痛点：_ 标准 ERC721 仅能查询余额 (balanceOf)，难以直接查询“某个用户持有的具体 Token ID 列表”。
        
    -   _代价（Trade-off）：_ 虽然方便了前端查询，但会显著增加 Mint 和 Transfer 时的 **Gas 消耗**（因为每次转账都要重排数组）。_注：很多大型项目会选择不加它，而是依赖 The Graph 等链下索引服务。_
        
-   **ERC721URIStorage:**
    
    -   _功能：_ 支持为每一个 Token ID 单独设置 metadata URI。
        
    -   _场景：_ 适用于每个 NFT 指向完全不同 IPFS 链接的场景。
        
-   **Ownable:** 提供基本的权限控制（onlyOwner）。
    

**3\. 核心逻辑：mintItem**

code Solidity

downloadcontent\_copy

expand\_less

```
function mintItem(address to, string memory uri) public returns (uint256)
```

-   **自增 ID (tokenIdCounter):** 使用简单的计数器生成 ID，确保 ID 唯一且连续。
    
-   **安全性 (\_safeMint):**
    
    -   相比 \_mint，它增加了一道检查：如果接收地址是**合约**，会调用其 onERC721Received 方法。
        
    -   _严谨说明：_ 这能防止 NFT 被误转入**不支持 NFT 处理逻辑的合约**中锁死，但无法防止转入丢失私钥的普通账户（EOA）。
        
-   **元数据 (\_setTokenURI):** 将特定的 URI 绑定到刚生成的 ID 上。
    

**4\. 存储优化：BaseURI**

-   **逻辑：** return "[https://ipfs.io/ipfs/](https://ipfs.io/ipfs/)";
    
-   **作用：** 提取公共前缀。链上只存储差异化的 Hash 部分，读取时拼接。
    
-   **意义：** 减少了链上存储的字节数，一定程度上降低了部署和交互成本。
    

**5\. 关于 Override (重写)**

-   **现象：** 代码底部的 override 函数。
    
-   **原因：** 由于 Solidity 的多重继承机制，当父合约（ERC721）和扩展合约（Enumerable/URIStorage）存在同名函数时，必须显式指定调用顺序（使用 super），以解决菱形继承问题。这是 Solidity 语法的强制要求。
    

**6\. 总结**  
这个合约展示了如何利用 OpenZeppelin 快速搭建一个**功能完备**的 NFT 系统。

-   **优点：** 开发效率高，安全性有标准库背书，功能覆盖全。
    
-   **注意：** 在生产环境中，需要根据项目对 Gas 成本的敏感度，决定是否保留 Enumerable 扩展。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->


**Ethernaut Level 0 核心知识点：**

1.  **Web3 交互：** 我们不仅可以通过网页按钮（前端）跟区块链交互，还可以直接在控制台使用 JavaScript（通过 Web3.js 或 Ethers.js 库）直接调用合约函数。
    
2.  **Await 的作用：** 区块链的交互都是**异步**的（需要等待节点响应），所以在控制台调试时，使用 await 关键词可以让我们直接看到返回结果，而不是一个未完成的 Promise 对象。
    
3.  **合约是透明的：** 只要没有设置权限限制，我们可以读取合约里的任何 public 变量（比如这里的 password），这也提醒我们在开发时，**绝对不能把真的机密数据直接存在链上**，因为谁都能查到。
    

**Fallback 与 Receive 函数**  
这一关教的是合约如何处理“不请自来”的转账。

1.  **receive() external payable**: 当有人单纯往合约里转账（不调用任何函数，calldata 为空）时，如果合约写了这个函数，就会自动运行这里面的代码。
    
2.  **漏洞原理：** 很多合约会在 receive 里写一些逻辑（比如记录谁转了钱）。但如果像本关一样，把“修改权限”的逻辑写在了 receive 里，攻击者只需要转一笔小钱，就能触发这个后门，窃取权限。
    

**构造函数命名事故 (Constructor Naming Vulnerability)**

这是 Solidity 早期版本的一个重大设计缺陷。

-   **原理：** 在 Solidity 0.4.22 之前，构造函数必须和合约同名。如果开发者手误（比如 Fallout 写成了 Fal1out），编译器不会报错，而是把它当成一个普通的公开函数。
    
-   **后果：** 任何人都可以调用这个函数，重新执行初始化逻辑（比如窃取 Owner 权限）。
    
-   **修复：** 现在的 Solidity 强制使用 constructor 关键字，彻底杜绝了这种“手滑”导致的惨案。
    

**历史趣闻：** 这一关致敬的是 **Rubixi** 智能合约事件，当时开发者把合约名 Rubixi 的构造函数错写成了 DynamicPyramid（因为改了文件名忘了改函数名），结果任何人都能进去把钱提走。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->



### 📘 知识点：为什么卖币要签两次字？(Approve & TransferFrom)

**1\. 现象：**  
在 Uniswap 或 OpenSea 交易时，第一次操作某种代币（比如 USDT），系统总是强制让我先发一笔叫 **Approve** 的交易。等这笔交易确认了，然后按钮才会变成 Swap/Sell，这时候再发第二笔交易才能把币卖掉。

**2\. 核心逻辑：我的钱，合约不能随便拿**  
ERC20 标准：

-   **我自己**转账给别人：调用 transfer，想转就转。
    
-   **别人（智能合约）** 想拿我的钱：它没有权限直接扣款。
    

只有我先调用 approve 函数，在代币合约的账本上写下一笔：“我允许 Uniswap 动用我 100 个币”，才算完成了授权（Allowance）。  
接着，Uniswap 的合约再去调用 transferFrom，拿着我的授权记录去把钱划走。

**3\. 安全警示：无限授权 (Infinite Approval)**  
为了省去每次都要 Approve 的 Gas 费，很多 DApp 会默认让我授权“无限额度”（比如 11579...一长串数字）。

-   **风险：** 这相当于给了对方一张无限透支的信用卡。
    
-   **后果：** 万一这个 DApp 的合约有后门或者被黑了，黑客不需要我的私钥，直接凭着这个无限授权，就能把我的 USDT 全部转空。
    
-   **对策：** 用完不知名的小项目后，一定要去 [**Revoke.cash**](http://Revoke.cash) 这种工具把授权取消掉，才算真正安全。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->




### **知识点：require 函数与“时光倒流” (Revert)**

**1\. 合约里的“保安”：**  
你会在代码最前面写一句类似这样的话：

code Solidity

downloadcontent\_copy

expand\_less

```
require(msg.value >= 0.1 ether, "Not enough money!");
```

这行代码的意思就是：保安站在门口查票，**只有**你付的钱大于等于 0.1 ETH，**才**让你进门继续执行后面的代码；**如果**没给够，直接把你拦回去，并冲你喊一句 "Not enough money!"。

**2\. 核心特性：时光倒流 (Revert)**  
这是区块链最神奇的地方。  
假设你的函数里有 3 步操作：

-   第一步：修改了一个数据（比如计数器 +1）。
    
-   第二步：做了一些计算。
    
-   第三步：碰到了 require，而且**条件不满足**（报错了）。
    

**这时候会发生什么？**  
它不仅仅是停止运行，而是会触发 **Revert（回滚）**。  
也就是说，**之前第一步里做出的修改（计数器 +1）会全部作废，就像时光倒流一样，恢复到交易发生之前的状态。**

**📝 笔记总结：**  
在 Web2 写代码（比如 Python），程序报错可能只是一半没跑完，前面的数据已经改了。  
但在 Web3（Solidity），交易具有**原子性（Atomicity）**。**require** 不仅是做判断的，更是用来保命的——**只要**最后一步没跑通，**那么**整个过程就像没发生过一样，这样**才**能保证账本永远不会乱。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->





### **知识点：Metadata (元数据) 与 JSON 标准**

在做 Simple NFT 的时候，你可能注意到代码里并没有地方让你上传 JPG 图片，只有一个叫 TokenURI 的东西。这背后的逻辑是 Web3 开发必须懂的“潜规则”。

**1\. 链上只存“路标” (Pointer)**  
由于在以太坊上存 1MB 的数据可能要花几万美金（Gas 费），所以我们**绝对不会**把图片直接存进合约里。

-   **合约里存什么？** 只存一个字符串链接，叫 tokenURI。
    
-   **例子：** ipfs://QmYourHash.../1.json
    

**2\. 链下才存“真身” (JSON)**  
当你把这个链接放到浏览器里打开，你会发现它不是图片，而是一个**文本文件（JSON 格式）**。这才是 NFT 的本体。  
标准的 **ERC721 Metadata** 格式长这样：

code JSON

downloadcontent\_copy

expand\_less

```
{
  "name": "My Simple NFT #1",
  "description": "这是我在 SpeedRunEthereum 做的第一个 NFT",
  "image": "ipfs://QmImageHash.../1.png",  // 这里才指向真正的图片
  "attributes": [ ... ]
}
```

**3\. 谁在读这个文件？**  
你的合约其实并不关心图片长啥样。是 **OpenSea、MetaMask** 这些前端应用，它们会：

1.  去链上读你的 tokenURI。
    
2.  顺着链接去下载那个 JSON 文件。
    
3.  解析 JSON 里的 "image" 字段，把图片展示给用户看。
    

**📝 笔记总结：**  
NFT 的合约只是个“收据”，而 Metadata（那个 JSON 文件）才是“商品说明书”。**开发 NFT 不仅仅是写 Solidity，更重要的是要懂得如何生成和托管这个标准的 JSON 文件**，否则你的 NFT 在 OpenSea 上就是一张裂开的图。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






### 知识点：Events (事件) —— 链上最便宜的“广播系统”

**1\. 核心机制：链上发声，链下听**

-   **代码行为：** 在 ERC721 标准里，每次转账或铸造，最后都会有一行代码：emit Transfer(from, to, tokenId);
    
-   **比喻：** 智能合约就像一个关在黑屋子里的机器人。修改变量（State Variable）是它在屋里写日记，外面人看不见（除非主动敲门去查）。但 emit Event 就像是机器人往窗外放了一只**信鸽**，告诉全世界：“刚刚发生了这件事！”
    

**2\. 为什么不用变量存数据？（Gas 费刺客）**

-   **省钱大法：** 在以太坊上存数据（SSTORE）极贵。如果你想记录“谁在什么时间 Mint 了什么”作为历史记录：
    
    -   **用数组存：** 贵到破产。
        
    -   **用 Event 存：** 非常便宜（Gas 费通常只有存储变量的 1/10 甚至更低）。
        
-   **代价：** Event 存的数据是\*\*“只写”\*\*的。智能合约自己读不到自己以前发的 Event（机器人放飞了信鸽，它自己就抓不回来了）。
    

**3\. 实战意义：Indexed (索引) 的魔力**  
在代码里，你常看到 event Transfer(address indexed from, ...)。

-   **Indexed 关键词：** 加了这个词，就相当于给信鸽绑了个**特定颜色的丝带**。
    
-   **作用：** 前端或后端（如 The Graph）可以极快地过滤出相关信息。比如：“只监听所有 from = 我 的事件”。如果没有 indexed，前端就得把全网的信鸽抓下来一只只看信的内容，效率极低。
    

* * *

**一句话总结：**  
**Events (事件)** 是连接区块链“黑盒”与 Web 前端“界面”的低成本通信协议。它是给**人**（和前端程序）看的，不是给**合约**看的。以后设计合约时，如果数据不需要被合约逻辑再次使用，只为了留痕展示，**永远优先用 Event，别用变量存。**
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->







关于 **ERC721 数据存储逻辑与 Gas 权衡** 的深度知识点笔记

### 知识点：ERC721 的“单向映射”与 Enumerable 的代价

**1\. 核心矛盾：Mapping 的“失明”**

-   **现象：** 在标准的 ERC721 代码中，核心数据结构是 mapping(uint256 => address)。
    
-   **本质：** 这是一种**单向查找**机制。
    
    -   **能做：** 拿着 TokenID 查主人（比如：查 #100 号是谁的）。
        
    -   **不能做：** 拿着主人查 TokenID（比如：查 Alice 名下所有的 NFT）。
        
-   **原因：** Solidity 中的 Mapping 就像一个没有目录的巨大仓库，它不记录“列表”。如果要强制查询某人名下的所有币，链上必须遍历所有 ID，这会导致 Gas 费爆炸甚至超出区块上限。
    

**2\. 解决方案：ERC721Enumerable**

-   **定义：** 这是一个官方扩展标准，它额外增加了数组（Array）来记录 Token 的索引。
    
-   **功能：** 开启后，合约可以轻松返回 tokenOfOwnerByIndex，让前端直接读取用户的 NFT 列表。
    

**3\. 关键权衡 (The Trade-off)**  
这是新手进阶必须理解的“守恒定律”：**查询越方便，写入越昂贵。**

-   **使用 Enumerable：** 读取数据很爽，但在执行 mint 或 transfer 时，合约需要同时修改 Mapping 和 Array，导致 **Gas 费大幅上升**（可能贵 30%-50%）。
    
-   **不使用 Enumerable：** 写入操作（Mint/转账）很便宜，但前端无法直接问合约要列表。
    
    -   _替代方案：_ 依赖链下索引工具（如 **The Graph** 或 Alchemy API）来帮用户整理数据，而不是把数据“死记”在链上。
        

* * *

**总结：**  
区块链不仅是存数据的，更是**计费**的。在写合约时，如果不是必须在链上遍历数据，尽量不要用 Enumerable，把复杂的查询压力甩给链下（Off-chain），把最贵的链上资源留给核心逻辑，这才是“省 Gas”的高级心法。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->








今天开始挑战这个 Challenge 0，最多的感觉就是终于把“网页”和“区块链”给连起来了，以前看智能合约代码觉得挺枯燥的，然后当我真的启动了前端页面，点击按钮，看着小狐狸钱包弹出来让我签名，接着过了一会儿页面上真的刷出来一张我的 NFT 卡片，我才突然反应过来，原来 DApp 的逻辑是这样跑通的，普通网站点个按钮可能就是改改数据库，而在这里每一次点击其实都是在向区块链发号施令，只有亲眼看到那个交互流程跑通了，才明白为什么 Web3 的开发需要把前端和合约结合得这么紧密。做完之后我就在想，我现在是在这个练习自带的网页上看到我的 NFT，那如果我把它部署到真正的公链上，像手机钱包能自动识别出来我刚发的这个币吗，还是说我得去钱包里手动添加合约地址，它才知道这里有个新资产？还有就是，我现在在本地测试，代码写错了可以随便改并重新部署，可是如果我真的把它发布到主网上去了，突然发现 NFT 的名字拼错了或者逻辑写得不对，那还能像平时做网站那样在后台修一下 Bug 吗，还是说一旦上链，这个错误就永远刻在那儿改不了了？
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->









今天跟着做 Simple NFT 的挑战，感觉真的挺不一样的。以前总觉得发 NFT 是个很复杂的技术活，然后自己真的去 import 了代码库，写了那个 mint 函数，才发现原来就是在搭积木，只要符合标准，几行代码就能把东西造出来。接着我在控制台看到那个交易成功的哈希值，还有 Gas 费扣掉的过程，有点明白之前书里说的“代码即资产”是啥意思。原来就是我看得到摸得着的一段逻辑。做完这些操作之后，我就在想两个问题：一个是，我现在发的这个 NFT，图片虽然能显示，但要是存图片的那个普通网站挂了，这 NFT 岂不是就废了？这才让我明白为什么得用 IPFS。另一个是，现在的代码是谁都能免费领，那如果我想搞个限量版或者收钱才能领，是不是就得在代码里加个“如果不满足条件就报错”的命令？
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->










今天还是在看Web3 实习手册[「安全与合规」](https://web3intern.xyz/zh/security/)部分和 021 学习以太坊第 3&4 章

第一个是对**安全**有了更具体的概念：它不只是保管好私钥那么简单，而是通过合规（KYC）和防范机制（反女巫、多签）来建立信任。在没有法律托底的链上世界，理解规则和代码逻辑，才是保护资产的唯一方式。

然后，我把零散的技术名词串联起来了。前面看 ENS、NFT、ERC标准和 IPFS 都是分开的，现在才明白它们其实是一套组合拳：标准定义了资产是什么，IPFS 确保存储了什么，ENS 解决了怎么找到它。这些基础设施共同构成了我在链上的“所有权”。

在然后是，关于 Gas 机制、L2 和交易处理的学习，还是有搞不懂的地方，明天再看看吧，或许有新发现！！
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->











通过《安全与合规》的学习让我弄明白了 Web3 这种“自己负责自己资产”的核心逻辑，特别是知道了私钥保护和授权管理是防范风险的第一步。了解到了以太坊上不同标准的作用，就像 ENS 是为了让地址好记，ERC20 和 ERC721 区分了普通代币和独一无二的 NFT，而 IPFS 则是为了保证这些资产的数据不丢失。比较实用的是学会了怎么看 Gas 费和处理交易卡死的问题，然后明白了多签钱包是团队管理的保险，而 L2 和借贷协议则是提高资金效率的进阶，这些知识让我知道链上操作的每一步底层在发生什么、风险在哪里都有了大概的理解。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->












今天看了021 学习以太坊第 1&2 章，觉得Web3 的本质是把，控制权真正还给用户：通过助记词掌控自己的钱包，在以太坊这条全世界共享的去中心化计算机上运行智能合约，自由交换资产、参与 dApp，而不再依赖中心化平台。钱包（尤其是助记词）就是 Web3 世界的起点，它既是身份证，也是银行卡，更是通往所有权利与风险的唯一钥匙。学会安全保管助记词、理解 Gas 与交易、初步认识 Uniswap 这样的 AMM 机制，就是迈出 Web3 第一步的关键。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
