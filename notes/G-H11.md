---
timezone: UTC+8
---

# G-H11

**GitHub ID:** G-H11

**Telegram:** @SCFh4meCOn21354

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-28
<!-- DAILY_CHECKIN_2026-01-28_START -->
# **Uniswap V3 学习笔记**

Uniswap V3是**自动做市商（AMM）发展史上的革命性升级**，通过引入“集中流动性”等核心创新，从根本上提升了资本效率，并为流动性提供者（LP）提供了前所未有的控制力。

### **一、 核心理念：从“均分”到“集中”的流动性**

**1\. V2的问题：资本效率低下**

在V2中，LP的流动性均匀分布在从0到无穷大的整个价格范围内。这意味着**大部分资金永远闲置**，从未参与交易。例如，一个ETH/DAI池中，只有极小部分流动性用于在ETH价格为$1,800-$2,200的常见区间内交易，其余资金只是在“待命”。

**2\. V3的解决方案：集中流动性**

V3允许LP将资金**集中部署在自定义的特定价格区间内**。如果价格保持在该区间内，LP将赚取全部的交易手续费，且因其提供的流动性密度更高，资本效率可以是V2的**数百甚至数千倍**。一旦市场价格超出该区间，其流动性将完全转换为其中一种资产，停止赚取费用，直到价格重新进入区间。

### **二、 核心机制：**

**1\. 新定价曲线：有界常数乘积**

V2的公式 `x * y = k` 演变为V3的 `(x + L / √P_u) * (y + L * √P_l) = L²`，其中：

-   `L` 代表“流动性”，是一个综合了两种资产数量的新概念。
    
-   `P_l` 和 `P_u` 分别是流动性区间的**下限价格**和**上限价格**。
    
-   当价格在区间内时，池子行为类似于V2，但储备金曲线更陡峭（流动性更集中）；当价格触及边界时，其中一种资产耗尽，流动性变为单一资产。
    

**2\. 体系架构：合约交互与资产流动**

Uniswap V3的体系比V2更复杂，其核心合约的交互与用户资产流动遵循以下路径：

**3\. 非同质化流动性：NFT 作为凭证**

V2使用同质化的**LP Token**作为凭证。而在V3中，由于每个头寸的价格区间、投入金额和创建时间都独一无二，因此使用**ERC-721非同质化代币**来代表每个流动性头寸。这张NFT记录了头寸的关键参数（如价格区间、流动性份额L等），使其可以独立转让、交易或用于其他DeFi应用。

**4\. 多级手续费与协议费用**

-   **分层手续费**：V3为不同风险/交易量的交易对提供了\*\*0.05%、0.30%、1.00%\*\*三档手续费等级，由池子创建者选择。这允许稳定币对（如USDC/DAI）采用更低费率以促进高频交易，而非稳定币对（如ETH/DAI）保留较高费率以补偿LP的波动风险。
    
-   **协议费用**：与V2的“开关”不同，V3设计了一个更巧妙的协议费用机制，其激活和费率（不超过LP费用的25%）由去中心化的治理决定。
    

### **三、 核心代码解析**

**1\. 核心数据结构：**`Slot0`**,** `Position` **与** `Tick`

```
// 核心状态变量，存储在单个存储槽中以节省Gas
struct Slot0 {
    uint160 sqrtPriceX96; // 当前价格 (以 sqrt(price) * 2^96 格式存储，兼顾精度与Gas)
    int24 tick;           // 对应的价格tick索引
    ...
}

// 记录某个地址在特定价格区间的头寸信息
struct Position {
    uint128 liquidity; // 该头寸提供的流动性L
    uint256 feeGrowthInside0LastX128; // 用于计算应得手续费的快照
    uint256 feeGrowthInside1LastX128;
}

// 价格刻度管理，每个tick对应一个价格
struct TickInfo {
    uint128 liquidityGross; // 所有以该tick为边界的流动性总和
    int128 liquidityNet;    // 进入/离开该tick时流动性的净变化
    ...
}
```

**2\. 关键函数：**`mint`**,** `swap`**,** `collect`

-   `mint`：铸造流动性。根据提供的价格区间和资产数量，计算流动性 `L`，更新对应 `Tick` 的状态，并将头寸信息写入调用者的 `Position` 映射中。
    
-   `swap`：执行交易。核心是一个**循环**：在当前的 `tick` 内，按照恒定乘积公式计算；当交换量耗尽当前 `tick` 的流动性时，价格移动到下一个 `tick`，并更新 `sqrtPriceX96` 和 `tick`。这个过程可能跨越多个 `tick`。
    
-   `collect`：收取手续费。通过比较当前的 `feeGrowthGlobalX128` 和头寸内存储的 `feeGrowthInsideLastX128` 快照，计算出该头寸应得的累计手续费并提取。
    

**3\. 高精度与Gas优化**

-   `sqrtPriceX96`：使用 `Q64.96` 定点数（64位整数，96位小数）存储价格的平方根，在极大价格范围和计算精度间取得平衡。
    
-   `tick`：价格被离散化为 `tick`。每个 `tick` 对应一个价格，其索引与价格的关系为：`p(i) = 1.0001^i`。这意味着价格每增长0.01%（1个基点），`i`增加1。这种设计允许用整数运算高效地处理对数级的价格变化。
    

### **四、 高级特性与应用场景**

**1\. 范围订单**

V3的流动性头寸可以作为一种“范围订单”。例如，如果当前ETH价格为$2,000，LP可以在$2,100-$2,200的区间提供纯ETH的流动性。如果价格上涨进入该区间，ETH将被逐步卖出为DAI，**自动在目标价位执行了卖出订单**。

**2\. 灵活的费用复投策略**

拥有多个集中流动性头寸的LP，可以根据市场走势主动管理。例如，在波动市可以将流动性集中在一个窄区间以获取高费率，在趋势市则可以将区间放宽以避免频繁出界，或跟随价格移动区间以“追逐趋势”。

**3\. 更优的预言机**

V3预言机在V2的TWAP基础上进行了重大升级。它不再需要存储所有累积值，而是可以**存储单个最近的观测值**，并允许外部调用者**在任一时间长度内计算TWAP**，大幅降低了链上数据存储和计算的成本。

### **总结**

Uniswap V3通过引入**集中流动性、非同质化头寸和多级费率**，将AMM从一种通用的流动性基础设施，转变为一个**高效、可组合且充满策略性的金融基元**。它代表了DeFi从“简单可用”到“专业高效”的重要转折。尽管其复杂性增加，但它为专业流动性提供者和高级DeFi应用打开了新的大门，继续巩固了Uniswap作为链上金融核心基础设施的地位。
<!-- DAILY_CHECKIN_2026-01-28_END -->

# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->

# **Uniswap V2 学习笔记**

Uniswap V2是一个**里程碑式**的去中心化交易所（DEX）协议，它基于**自动做市商（AMM）** 模型，允许任何人在以太坊上无需许可地创建交易对并提供流动性，实现了高效的ERC-20代币兑换。

### **一、 核心概念与工作原理**

**1\. 两类核心用户**

Uniswap V2的生态由两类主要参与者构成：

-   **流动性提供者（LPs）**：为交易对（如DAI/USDC）的资金池同时存入两种等值的ERC-20代币，从而获得代表池中份额的**流动性代币（LP Token）** 作为凭证。他们通过赚取交易者支付的手续费（通常为0.3%）获得收益。
    
-   **交易者**：向资金池存入一种代币，并根据当前汇率从池中取出另一种代币。
    

**2\. 恒定乘积做市商模型**

协议的核心定价机制是 **“恒定乘积公式”**：`x * y = k`。

-   `x`和`y`分别代表流动性池中两种代币的储备量。
    
-   `k`是一个在每次交易后（扣除手续费前）保持不变的常数。
    
-   **工作原理**：当交易者用`x`代币购买`y`代币时，`x`的数量增加，`y`的数量减少。为了保持`k`不变，`y`代币的价格会随之上升。这种设计确保了池中始终有流动性，且价格随着买卖行为自动、连续地调整。
    

**3\. 基本工作流程**

![UniswapV2.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/G-H11/images/2026-01-27-1769522901303-UniswapV2.png)

### **二、 架构设计：核心与外围分离**

Uniswap V2采用模块化设计，将高价值的资产保管逻辑与复杂的交互逻辑分离，以增强安全性。

| 合约类型 | 核心合约 | 外围合约 |
| --- | --- | --- |
| 代表合约 | UniswapV2Pair.sol (交易对合约) | UniswapV2Router02.sol (路由合约) |
| 核心职责 | 保管资产。管理特定交易对的流动性池，执行最基础的兑换、流动性添加/移除操作，并维护储备金状态。 | 提供友好接口与高级功能。处理复杂的交易路由（如多跳兑换）、计算最优输入/输出金额、与WETH（包装ETH）交互等，为用户简化操作。 |
| 安全性要求 | 极高。代码力求简洁、可审计。 | 相对较低，可灵活升级或替换。 |

这种分离意味着普通用户和开发者通常只与`Router`合约交互，而`Pair`合约则在后台安全地管理资金。

### **三、 核心合约**`UniswapV2Pair`**源码关键解析**

`UniswapV2Pair.sol`是存放流动性的核心合约，继承自`UniswapV2ERC20`（LP Token的标准实现）。

**1\. 关键状态变量**

```
// 使用 uint112 存储储备量，并共享一个256位存储槽以提高Gas效率[citation:1]
uint112 private reserve0;
uint112 private reserve1;
uint32 private blockTimestampLast; // 上次操作的时间戳[citation:1]

address public token0; // 排序后的代币0地址
address public token1; // 排序后的代币1地址
uint public kLast; // 最近一次流动性事件后的 reserve0 * reserve1[citation:1]
```

**2\. 核心函数：**`swap`

```
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
```

-   **功能**：执行一笔兑换。
    
-   **关键逻辑**：
    
    1.  确保输出金额`amount0Out`或`amount1Out`大于0。
        
    2.  检查输出后剩余储备量仍满足 `(reserve0 - amount0Out) * (reserve1 - amount1Out) >= kLast`（此处`kLast`为交易前`reserve0 * reserve1`），防止池子被掏空。
        
    3.  向接收者`to`转账输出代币。
        
    4.  如果`data`长度大于0，则调用`to`地址的`uniswapV2Call`函数，**这是实现“闪电兑换”的钩子**。
        
    5.  更新储备金余额，并调用`_update`函数。
        

**3\. 核心函数：**`mint` **与** `burn`

-   `mint(address to)`: 当用户**添加流动性**时调用，铸造新的LP Token给`to`地址。铸造数量基于注入的流动性占当前总流动性的比例计算。
    
-   `burn(address to)`: 当用户**移除流动性**时调用，销毁调用者的LP Token，并将对应比例的两种底层代币发送给`to`地址。
    

**4\. 精度与预言机：**`_update`**函数**

这是协议中最关键的内部函数之一，在每个流动性事件（`mint`, `burn`, `swap`）结束时被调用。

-   **更新储备量**：将合约当前的真实代币余额赋值给`reserve0`和`reserve1`。
    
-   **累积价格**：利用`blockTimestampLast`和当前区块时间戳的差，计算并累加`price0CumulativeLast`和`price1CumulativeLast`。这两个值记录了**时间加权平均价格（TWAP）**，为外部协议提供了抗操纵的价格预言机数据。
    
-   **精度处理**：使用`UQ112x112`库（一种224位数，高112位为整数，低112位为小数）来处理计算中的分数，以应对Solidity不支持浮点数的问题。
    

### **四、 V2的关键特性与改进**

相比于V1，V2引入了多项重要创新：

| 特性 | 描述 | 解决的问题/带来的价值 |
| --- | --- | --- |
| 任意ERC-20交易对 | 支持直接创建ERC-20/ERC-20交易对，无需再通过ETH作为中介。 | 减少了一半的交易步骤和Gas成本，降低了交易滑点。 |
| 时间加权平均价格预言机 | 通过累积价格（price*CumulativeLast）为每个池子内置了链上TWAP预言机。 | 极大地增加了价格操纵的成本和难度，为其他DeFi协议（如借贷）提供了可靠的价格输入。 |
| 闪电兑换 | 允许用户在同一笔交易中先提取代币，再归还或支付其他代币。 | 无需初始资本即可进行套利，提高了市场效率；也可用于其他复杂的DeFi组合操作（如清算）。 |
| 协议费用开关 | 设计了一个可开关的0.05%协议费用（从0.3%手续费中抽取），收益可导向治理设定的地址。 | 为协议创造了潜在的营收能力，由去中心化治理控制。 |
| 更优的Gas与兼容性 | 用Solidity重写，优化Gas；支持非标准ERC-20代币（如返回void的transfer）。 | 降低用户成本，提高协议兼容性和用户体验。 |

**无常损失解释**：当流动性提供者存入的代币市场价格比率发生变化时，其持有时与存入资金池产生的资产价值之间的差额。简单来说，如果其中一种代币价格剧烈波动，提供流动性可能比单纯持有这两种代币的收益更低。这是AMM流动性提供者需要承担的主要风险。  
总之，Uniswap V2通过其优雅而强大的设计——**恒定乘积公式、核心/外围分离架构、内置TWAP预言机和闪电兑换**——不仅解决了V1的关键限制，更奠定了DeFi Summer的基础，成为无数后续协议组合与创新的“乐高积木”。
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->


# **ERC标准学习笔记**

### **1、ERC-20 - 可替代代币标准**

**定义：**ERC-20是以太坊上同质化代币（Fungible Token）的标准接口规范，定义了代币合约必须实现的基本函数和事件，确保不同代币之间的互操作性。REC-20提供标准化的授权机制，它确保了确保代币余额查询、转账等基础功能的一致性。

**运用场景：**

-   治理代币（如UNI、AAVE）
    
-   实用代币（用于支付服务费用）
    
-   稳定币（USDT、USDC的实现基础）
    
-   DeFi协议中的流动性代币
    

### 2、**ERC-721 - 非同质化代币标准**

**定义：**ERC-721是首个NFT（非同质化代币）标准，每个代币都有唯一标识符（tokenId），代表独一无二的数字资产。ERC-721为独一无二的数字资产提供标准化表示，它主要解决数字艺术、收藏品无法在链上确权的问题，提供所有权证明和转移的标准机制。

**运用场景：**

-   数字艺术品（如CryptoPunks、Bored Apes）
    
-   游戏道具和角色
    
-   虚拟房地产
    
-   身份凭证和证书
    
-   门票和会员资格
    

### 3、**ERC-1155 - 多代币标准**

**定义：**ERC-1155是灵活的多代币标准，单个合约可以同时管理同质化和非同质化代币，支持批量操作。ERC-1155为解决批量转账时Gas费过高的问题，减少了游戏、NFT平台等多代币场景的合约部署成本，避免多个代币合约间的交互复杂性，是统一管理FT和NFT，简化系统架构。

**运用场景：**

-   游戏资产系统（武器、货币、皮肤等）
    
-   多版本收藏品系列
    
-   企业忠诚度积分系统
    
-   需要批量操作的NFT市场
    

### 4、**ERC-165 - 接口检测标准**

**定义：** ERC-165提供了合约如何声明自己支持的接口的标准方法，使其他合约可以检测某个合约实现了哪些功能。ERC-165为解决合约升级后接口变化导致的兼容性问题，提供合约注册中心提供技术基础。 **运用场景：**

-   钱包应用检测代币类型（ERC-20/721/1155）
    
-   DeFi协议验证目标合约是否支持特定功能
    
-   工厂合约验证部署的合约是否符合要求
    
-   代理模式中的功能检测
    

### 5、**ERC-223 - 防止代币丢失标准**

**定义：** ERC-223是对ERC-20的改进，在转账到合约地址时添加回调机制，防止代币误转入不支持ERC-20的合约而永久丢失。ERC-223需要两次交易才能完成转账到合约（先approve再transferFrom）。 **运用场景：**

-   需要直接向合约转账的场景
    
-   简化用户交互流程（一次交易完成转账和调用）
    
-   需要合约自动处理代币转入的场景
    

### **6、ERC-1363 - 可支付型代币**

**定义：** ERC-1363在ERC-20基础上添加了转账后执行回调的功能，使代币可以作为支付手段并自动触发业务逻辑。ERC-1363代币支付需要两次交易（转账+调用），因此无法实现"一键购买"用户体验。 **运用场景：**

-   订阅服务支付（支付后自动续订）
    
-   在线商城（支付后自动发货）
    
-   DeFi协议（支付后自动存入资金池）
    
-   NFT市场（购买后自动转移所有权）
    

### 7、**ERC-777 - 增强的代币标准**

**定义：** ERC-777是ERC-20的增强版本，引入了操作员（operator）概念和发送/接收钩子（hooks），提供更安全的代币交互机制。ERC-777主要解决ERC-20授权机制不安全（无限授权常见）以及无法在转账前后执行自定义逻辑等问题。 **运用场景：**

-   需要高级权限管理的企业代币
    
-   需要转账前后执行检查的场景（如合规检查）
    
-   需要代币回调机制的应用
    
-   替代ERC-20的安全升级方案
    

### 8、**ERC-4626 - 金库代币化标准**

**定义：** ERC-4626是为收益型金库（Vault）设计的代币化标准，将存入金库的资产转换为份额代币，统一了各种收益聚合器的接口。ERC-4626为用户难以在不同金库间比较和切换，无法标准化的计算收益率和份额等问题提供一个解决方案。 **运用场景：**

-   收益聚合器（Yearn、Harvest等）
    
-   借贷协议的存款凭证
    
-   流动性挖矿的质押凭证
    
-   结构化产品的基础层
    

### 9、**ERC-2612 - 离线授权标准**

**定义：** ERC-2612通过链下签名实现代币授权，允许用户通过签名而非交易来授权第三方使用其代币，显著降低Gas成本。ERC-2612为解决ERC-20授权需要支付Gas费，用户在授权时需要两次交易等授权额度管理复杂等问题。 **运用场景：**

-   DeFi协议一键操作（存款、借款等）
    
-   无Gas交易（通过中继器代付Gas）
    
-   批量交易授权
    
-   跨链桥的快速授权
    

### 10、**ERC-3009 - 签名转账标准**

**定义：** ERC-3009扩展了ERC-2612，不仅支持授权签名，还支持通过签名直接执行转账操作，提供更大的灵活性。ERC-3009为解决ERC-2612仅支持授权，仍需后续交易执行等无法通过一次签名完成完整操作问题。 **运用场景：**

-   完全无Gas的代币转账
    
-   第三方支付处理
    
-   定期支付订阅
    
-   多步骤交易的优化
    

### 11、**ERC-3643 - 合规代币标准**

**定义：** ERC-3643（原T-REX）是为受监管资产设计的代币标准，内置复杂的权限管理系统，支持KYC/AML等合规要求。ERC-3643为解决证券型代币缺乏标准化合规机制、无法在链上强制执行转让的限制所作出的符合监管要求的合规性证明。

**运用场景：**

-   证券型代币发行（STO）
    
-   房地产代币化
    
-   私募股权数字化
    
-   受监管的RWA（现实世界资产）代币化
    

### 12、**ERC-735 / ERC-725 - 身份声明标准**

**定义描述：** ERC-725定义链上身份代理合约，ERC-735定义身份声明（Claim）标准，共同构成去中心化身份（DID）系统的基础。ERC-735 / ERC-725是对链上缺乏标准化的身份表示，用户无法证明个人属性或资质提供一个方案标准。

**运用场景：**

-   去中心化身份系统
    
-   可验证凭证发行与验证
    
-   链上声誉系统
    
-   符合监管要求的身份验证
    

### 13、**ERC-2981 - NFT版税标准**

**定义：** ERC-2981定义了NFT版税的标准接口，允许创作者在NFT二次销售时自动获得版税，无需依赖中心化平台。ERC-2981的制定为NFT创作者难以从二次销售中获益以及在各平台版税实现不一致所作出的一个统一标准。

**运用场景：**

-   数字艺术品市场
    
-   音乐和视频NFT
    
-   创作者经济平台
    
-   需要自动版税分配的任何NFT
    

### 14、**ERC-4907 - 可租赁NFT标准**

**定义：** ERC-4907在NFT所有权基础上分离出使用权，允许NFT所有者将使用权出租给他人，而无需转移所有权。ERC-4907是在对闲置NFT资产无法产生收益和游戏道具、虚拟地产等需要租赁的场景缺乏标准提供一个可行方案。

**运用场景：**

-   虚拟房地产租赁
    
-   游戏道具出租
    
-   数字服装试穿
    
-   会员资格的临时转让
    

### 15、**ERC-6551 - 代币绑定账户标准**

**定义：** ERC-6551允许每个NFT拥有自己的智能合约账户，使NFT可以持有资产、与其他合约交互，成为独立的链上实体。ERC-6551针对NFT只能被动持有，也无法主动交互无法为NFT建立链上身份和历史记录且与NFT相关的资产需要分散管理等问题提供的一个思路方案。

**运用场景：**

-   游戏角色NFT持有装备和道具
    
-   PFP NFT作为社交身份持有资产和凭证
    
-   可组合的NFT生态系统
    
-   NFT作为DAO的参与实体
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->




# **Polymarket架构与链上数据解码**

解决中~
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->






# Scaffold-ETH 2知识总结

### **一、环境搭建与项目初始化**

**1、创建项目：**`npx create-eth@latest`

-   **输入项目名称**，例如`my-dapp`。
    
-   **选择智能合约框架**：通常选择`Hardhat`（生态成熟）或`Foundry`（测试速度快）。
    
-   工具会自动完成项目创建和所有依赖的安装。
    

### **二、核心项目目录结构**

| 路径 | 主要用途 | 关键内容说明 |
| --- | --- | --- |
| 项目根目录 | 项目管理与脚本 | package.json：定义了项目的启动、构建、部署等所有脚本命令，是操作入口。 |
| packages/hardhat/ | 智能合约开发环境 | 包含以太坊开发的所有后端部分。 |
| ├─ contracts/ | 存放Solidity合约源码 | 你的业务合约（如YourContract.sol）和外部依赖（如@openzeppelin）都在此。 |
| ├─ deploy/ | 部署脚本目录 | 00_deploy_your_contract.js 等脚本，定义了合约的部署逻辑和初始化参数。 |
| ├─ test/ | 合约测试文件 | 为合约编写的单元测试和集成测试文件（使用Hardhat/Foundry）。 |
| └─ ignition/ (或 deployments/) | 部署产出目录 | 存放部署后生成的artifacts（合约接口描述）和deployedAddresses.json（记录各网络合约地址）。 |
| packages/nextjs/ | 前端DApp应用 | 基于Next.js构建的前端界面。 |
| ├─ app/ | Next.js App Router核心 | 存放页面（page.tsx）、布局（layout.tsx）和API路由。 |
| ├─ components/ | 可复用UI组件库 | scaffold-eth/下提供开箱即用的组件，如Address、Balance、Input等。 |
| ├─ hooks/ | 自定义React Hooks | scaffold-eth/下的核心交互钩子，如useScaffoldContractRead/Write，封装了与合约交互的逻辑。 |
| ├─ utils/ | 工具函数与配置 | scaffold.config.ts（前端核心配置文件）和notification.tsx（交易通知）等。 |
| └─ contracts/ | 已部署合约的引用 | 由框架自动生成的deployedContracts.ts，前端通过此文件获取当前网络的合约地址和ABI，切勿手动修改。 |

### **三、交互钩子解析**

| 类别 | 钩子名称 | 核心用途 | 是否消耗 Gas |
| --- | --- | --- | --- |
| 合约交互 | useScaffoldContractRead | 读取合约数据/视图函数 | 否 |
|   | useScaffoldContractWrite | 发送交易，修改合约状态 | 是 |
|   | useDeployedContractInfo | 获取合约的地址与 ABI | 否 |
| 事件监听 | useScaffoldEventSubscriber | 订阅并实时响应合约事件 | 否 |
|   | useScaffoldWatchContractEvent | 另一种事件监听方式（可手动控制） | 否 |
| 状态与账户 | useScaffoldEthPrice | 获取 ETH 当前价格（USD） | 否 |
|   | useAccountBalance | 获取指定地址的 ETH 余额 | 否 |
|   | useNetworkColor | 获取当前链的标识颜色 | 否 |
| 交易增强 | useTransactor | 增强交易体验（通知、确认） | - |

### **1、合约交互钩子**

`useScaffoldContractRead`**：读取数据**

这是最常用的只读钩子，用于调用合约中 `view` 或 `pure` 函数。

**使用场景**：获取用户余额、DAO提案列表、NFT的总供应量等。**返回的** `data` **已经过解析**（例如 `BigInt` 被转换为 `number`）。

`useScaffoldContractWrite`**：发送交易**

用于发送交易、修改链上状态的钩子。

**状态说明**：

-   `isLoading`: 用户未签名，交易在钱包待处理。
    
-   `isMining`: 交易已签名，正在链上打包。
    
-   交易成功或失败会**自动触发全局通知**。
    

`useDeployedContractInfo`**：获取合约元数据**

这个钩子会自动根据当前连接的网络（`targetNetworks`），从 `deployedContracts.ts` 中读取对应合约的地址和 ABI。**通常用作其他钩子（如** `useScaffoldContractRead`**）的内部依赖，你很少需要直接使用它**。

### **2、事件监听钩子**

`useScaffoldEventSubscriber`**：自动订阅事件**

最常用的事件监听方式，组件挂载时自动订阅，卸载时自动清理。

`useScaffoldWatchContractEvent`**：手动控制监听**

与 `useScaffoldEventSubscriber` 功能类似，但提供更多手动控制选项，监听逻辑更灵活。

### **3、状态与账户信息钩子**

`useAccountBalance`**：获取 ETH 余额**

`useScaffoldEthPrice`**：获取 ETH 价格**

此钩子从 CoinGecko API 获取价格，**注意有速率限制**，生产环境建议使用自己的 API Key。

`useNetworkColor`**：获取网络颜色**

用于 UI 标识，根据链 ID 返回预设颜色（如主网：绿色，Goerli：蓝色）。

### **4、交易增强钩子**

`useTransactor`**：包装交易执行器**

这是一个**高阶工具**，用于包装 `writeAsync` 或任何返回 Promise 的交易函数，为其**添加统一的 UI 反馈**（如交易等待、成功/失败的通知）。

### **四、总结**

**1、理解目录结构**：明确合约在哪里写、前端在哪里改、配置在哪里调。

**2、遵循工作流**：从`contracts/`编写合约 → `yarn deploy`部署 → 在`app/page.tsx`中通过Hooks调用。

**3、善用内置组件**：优先使用`components/scaffold-eth/`中的组件（如`AddressInput`）构建UI，它们已与Hooks深度集成。

**4、修改配置**：通过`scaffold.config.ts`轻松切换开发网络和调整应用行为。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->







链上留言板ing~

在VSCode上打算一起把智能合约、hardhat、sepolia测试网部署以及前端一起做成一个DAPP
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->








# Ethernaut知识整理

### 1、**Hello Ethernaut**

目的：熟悉控制台中调用合约方法的基础指令。

通关流程：通过开头提示调用info()开始的指令一步步操作，通关关键就是找到密码，最后调用一个类似解密的方法，输入密码参数即可通关。

### 2、**Fallback**

目的：理解合约中代码逻辑，利用其中逻辑漏洞提走代币。

解析：要求将`withdraw`函数里的资金提取，但是权限仅限于`onlyOwner`，成为`onlyOwner`有两种方法，一是贡献值要大于原先的合约拥有者`contributions[msg.sender] > contributions[owner]`，即贡献大于1000ETH；二则是在最后的函数漏洞，需要同时满足`msg.value > 0`（合约账户有钱）以及`contributions[msg.sender] > 0`（需要有贡献值）。那么解题路线就清晰了，有两条方法，但是第二条方法是利用函数漏洞，能够将损耗降到最小。所以两个条件中贡献值可以执行`contribute`一次就可以成为贡献组成员中的一名拥有贡献值；然后账户有钱这个条件满足需要用到转账函数，但是在`Fallback`合约里没有支持转账的函数方法，所以要去哪里找呢？前面有提示就告知我们了，可以在`contract`指令下显示出所有的函数方法，`Fallback`合约里没有我们可以在这个合约外部找到一个`sendTransaction`交易的函数方法，使用`sendTransaction({value: toWei("0.000001")})`即可满足第二个条件，然后后可以验证合约`owner`检查是否变更为自己的钱包账户，最后调用`withdraw`函数提取里面的全部资金以完成任务。

### 3、**Fallout**

目的：找出其中漏洞，理解学习智能合约的安全问题

解析：过关要求是成为合约`owner`，仔细观察合约可以发现，调用`Fal1out`函数就可以成为`owner`，但是合约名跟函数名好像一样，在 Solidity 0.4.22 版本之前，构造函数是通过定义一个与**合约名完全同名**的函数来声明的。在这个合约中，合约名叫 `Fallout`，但这个函数名是 `Fal1out`（注意是数字 `1`，而不是字母 `l`）。由于拼写错误，这个函数没有与合约名完全相同，因此它不被认为是构造函数，而只是一个普通的、公开的、可支付的函数。任何人都可以调用它。简单调用`Fal1out`函数即可通关。因此，在审计或阅读合约时，必须仔细核对构造函数的名字（如果是旧合约），或检查是否使用了 `constructor` 关键字（新合约）。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->










# Uniswap工作原理

Uniswap的核心是**自动做市商（AMM）机制**，它用智能合约中的**流动性池**和**数学公式**取代了传统交易所的订单簿，实现了无需中介和许可的代币兑换。

AMM的工作原理可以概括为：**用户与池交易，公式决定价格**。

**1、流动性池（Liquidity Pools）**：每个交易对（如ETH/USDC）都有一个由用户众筹的资金池。提供资金的用户称为**流动性提供者（LP）**。

**2、恒定乘积公式（x \* y = k）**：这是定价核心。`x`和`y`代表池中两种代币的数量，`k`是恒定乘积。任何交易都必须确保交易后`k`值不变。例如，当用户用USDC购买ETH时，池中ETH减少，USDC增加，根据公式，ETH价格会**自动上涨**，从而完成交易和定价。

**3、费用与激励**：每笔交易收取一定比例（如0.3%）的手续费，这部分费用会按比例分配给该池的所有LP，作为提供流动性的回报。

总的来说，Uniswap通过AMM机制重塑了交易模式。

# **Flash Loan（闪电贷）**

闪电贷是DeFi领域一项突破性的金融工具，它允许用户在**无需提供任何抵押品**的情况下，**瞬间借出巨额资金**。其核心前提是：**所有借款和操作必须在同一笔区块链交易（一个区块）内完成并归还，否则整个交易将被撤销，就像从未发生过一样。**

一次完整的闪电贷在智能合约层面遵循以下步骤：

**1、发起**：用户将复杂的操作指令封装进一个自定义的智能合约，并向闪电贷平台（如Aave、dYdX）发起调用。

**2、放款与执行**：平台合约在**同一笔交易内**将资金打入用户合约，并立即执行用户合约中预设的所有操作（如兑换、套利）。

**3、验证与归还**：在交易结束前，平台合约会**校验**用户合约中的资金是否足够归还本金和利息。如果**是**，交易成功；如果**否**，整个交易回滚，资金归零，平台无损失。

整个过程由区块链的 **“原子性”** 保障，确保“要么全部成功，要么全部失败”。

**对用户的风险**：主要是**智能合约风险**。如果用户合约代码存在漏洞，导致还款失败，虽然借款会回滚，但已支付的Gas费将无法退回。

**对DeFi生态的争议与影响**：

-   **“攻击放大器”**：它极大降低了发动大规模金融攻击的门槛，攻击者无需自有资金即可尝试，导致了许多著名的DeFi安全事件。
    
-   **市场效率**：从积极角度看，它促进了跨市场价格的快速平衡，让套利机会转瞬即逝，提高了市场整体效率。
    
-   **创新推动**：它催生了更复杂的金融策略和产品，也倒逼DeFi协议提升自身的安全设计与抗攻击能力。
    

总而言之，闪电贷是一把**双刃剑**，它体现了DeFi的可编程金融与无许可创新的极致，但也暴露了其在安全与监管层面的巨大挑战。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->











# Challenge #0 - Tokenization

### 源码解析：

Tokenization挑战最核心的就是NFT元数据的上传与获取CID，原代码里在nftsMetadata.ts里设置好了5个NFT元数据，所以我们只需要把这些数据打包上传到IPFS上，然后从IPFS上获取上传的数据url显示到本地。其中：

**nextjs/app/api/ipfs**文件夹下是路由，其中**add**是上传NFT到IPFS的路由，**get-metadata**是从IPFS上获取NFT的元数据路由；

**nextjs/app/myNFTs/\_components**文件夹下是NFT的一个代码组件，用于设计NFT的组成结构；

**nextjs/app/myNFTs/page.tsx**是NFT展示页面的前端代码组件，用于展示所拥有的NFT；

**nextjs/app/utils/tokenization**是工具组件，用于NFT上传至IPFS和获取元数据的代码实现逻辑；

以上文件大致构成NFT的整个铸造逻辑。

### **问题：**

但是从源代码中并不能从前端页面完整显示NFT，原因是IPFS公有链接有问题，不能上传和读取NFT数据，所以我们可以换一个，这里通过Pinata完成NFT铸造的一整个流程。

### 过程：

1、进入官网[https://app.pinata.cloud/](https://app.pinata.cloud/)注册生成一个自己的API密钥，记住生成的API密钥信息。这里我们需要用上其中的访问令牌和网关地址，然后我们将这些信息放在新建的环境变量里，从而在使用时通过环境变量来访问pinata，这样可以防止这些关键隐私信息泄露。

2、修改上传路由将NFT元数据转至pinata，以下是部分代码逻辑：

```tsx
const PINATA_JWT = process.env.PINATA_JWT;
const PINATA_PIN_JSON_ENDPOINT = "<https://api.pinata.cloud/pinning/pinJSONToIPFS>"; 
export async function POST(request: Request) {
  try {
    if (!PINATA_JWT) {
      throw new Error("Missing env var: PINATA_JWT");
    }
    const body = await request.json();
  
    const pinataRes = await fetch(PINATA_PIN_JSON_ENDPOINT, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${PINATA_JWT}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        pinataOptions: { cidVersion: 1 },
        pinataMetadata: { name: "metadata.json" },
        pinataContent: body,
      }),
    });
    if (!pinataRes.ok) {
      const text = await pinataRes.text();
      throw new Error(`Pinata upload failed: ${pinataRes.status}${text}`);
    }
    const data: {
      IpfsHash: string;
      PinSize: number;
      Timestamp: string;
      isDuplicate?: boolean;
    } = await pinataRes.json();

    return Response.json({
      path: data.IpfsHash,
      cid: data.IpfsHash,
      size: data.PinSize,
      timestamp: data.Timestamp,
      isDuplicate: data.isDuplicate ?? false,
    });
```

3、解析上传IPFS上NFT元数据的CID，以下是部分代码逻辑：

```tsx
export async function getNFTMetadataFromIPFS(ipfsHash: string) {
  const cid = ipfsHash
    .replace(/^ipfs:\\/\\//, "")
    .replace(/^ipfs\\//, "")
    .split("/ipfs/").pop()!
    .split("?")[0]
    .split("#")[0];
  const url = `https://gateway.pinata.cloud/ipfs/${cid}`;

  const r = await fetch(url, { cache: "no-store" });

  if (!r.ok) return undefined;
  return await r.json();
}
```

这样我们就可以完成整个NFT的铸造流程，前端页面也能够显示铸造的NFT。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->













### 一、零知识证明（ZK）核心定义与价值

零知识证明是一种密码学技术，核心目标是：**证明者（Prover）能向验证者（Verifier）证明某个陈述为真，且不泄露任何与陈述相关的秘密信息**。

在区块链场景中，其核心价值是解决「可验证性」与「隐私性」的矛盾 —— 既保证操作（如投票、交易）的合法性可公开验证，又不暴露操作主体的身份、具体选择等隐私数据。

### 二、ZK 基础核心要素

1.  **角色分工**：
    
    -   证明者（Prover）：掌握秘密（如身份密钥、投票选项），生成证明；
        
    -   验证者（Verifier）：如链上智能合约，仅验证证明有效性，不获取秘密。
        
2.  **核心概念**：
    
    -   陈述（Statement）：需证明的合法性断言（如 “我是合法选民，且投票选项合规”）；
        
    -   见证（Witness）：证明者掌握的秘密数据（如身份秘密、Merkle 路径、投票选项）。
        
3.  **三大必满足性质**：
    
    -   完备性：合法证明者的真实陈述一定能通过验证；
        
    -   可靠性：虚假陈述无法伪造有效证明欺骗验证者；
        
    -   零知识性：验证者仅能确认 “陈述为真”，无法还原任何秘密信息。
        

### 三、区块链适配：非交互式零知识证明（NIZK）

传统 ZK 是「交互式」（证明者与验证者需多轮问答），不适合链上一次性验证场景。因此区块链采用「非交互式零知识证明（NIZK）」—— 证明者生成单个结构化证明文件，提交链上后合约可直接验证，无需交互。

### 四、两大核心 NIZK 方案：zk-SNARK 与 zk-STARK

区块链场景中最主流的两类 ZK 实现，核心差异集中在「可信初始化」「性能特性」「适用场景」：

| 特性 | zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge） | zk-STARK（Zero-Knowledge Scalable Transparent Argument of Knowledge） |
| --- | --- | --- |
| 核心定位 | 简洁型 NIZK，主打 “证明小、验证快” | 透明可扩展型 NIZK，主打 “无需可信初始化、适配大规模计算” |
| 可信初始化（Trusted Setup） | 必需：需通过多参与方仪式生成证明密钥（PK）和验证密钥（VK），多余秘密需销毁 | 无需：无初始秘密参数，避免可信初始化风险 |
| 证明大小 | 极小（KB 级），链上存储和传输成本低 | 较大（MB 级），随计算规模增长但增速平缓 |
| 验证速度 | 极快，验证开销与原始计算规模无关 | 较快，但验证时间随计算规模略有增长 |
| 抗量子性 | 不抗量子攻击 | 天生抗量子攻击（基于哈希和信息论，非数论假设） |
| 典型应用场景 | 隐私交易（如 Zcash）、ZK 投票、小型 zk-Rollup、简单逻辑验证 | 大规模 zk-Rollup（如 StarkNet）、复杂电路证明、高安全性隐私场景 |

### 五、ZK 核心应用流程（以 ZK 投票为例）

1.  **电路编写**：将 “合法选民验证 + 投票选项合规 + 防重复投票” 等逻辑，转化为算术电路或 R1CS 约束；
    
2.  **密钥生成（Setup）**：
    
    -   zk-SNARK：需执行可信初始化仪式，生成 PK（证明密钥）和 VK（验证密钥，存储于链上合约）；
        
    -   zk-STARK：无需可信初始化，直接基于公开参数生成证明相关资源；
        
3.  **证明生成**：证明者（选民）本地输入「私有见证」（身份秘密、Merkle 路径、投票选项）和「公开输入」（Merkle 根、投票 ID），调用 ZK 库生成证明；
    
4.  **链上验证**：合约使用 VK（zk-SNARK）或公开参数（zk-STARK）验证证明有效性，通过后执行核心逻辑（如计票、标记防重复投票标识）。
    

### 六、核心结论

zk-SNARK 与 zk-STARK 是区块链隐私场景的两大核心工具：前者以 “简洁性” 适配轻量场景，后者以 “透明性 + 可扩展性” 适配复杂、高安全需求场景。两者均通过零知识证明的核心特性，实现了「隐私操作 + 公开验证」的平衡，成为区块链投票、隐私交易、Rollup 等场景的关键技术支撑。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->














# 一周知识学习简要总结

本周学习主要围绕以太坊核心概念、开发理论与工具链展开系统学习，核心要点如下：

### 一、核心基础概念

1、以太坊定位：区别于比特币 “数字黄金”，是支持智能合约的 “世界计算机”，可构建 DeFi、NFT 等去中心化应用。

2、核心机制：2022 年转向 PoS 共识，通过质押 32 ETH 成为验证者，能耗降低 99% 以上，区块生成时间 12 秒左右。

3、底层核心：EVM（以太坊虚拟机）是链上代码执行引擎，支持 256 位操作码，通过 Gas 机制量化计算资源消耗。

4、账户体系：包含私钥控制的外部账户（EOA）和代码驱动的合约账户，两类账户通过交易实现交互。

### 二、智能合约Solidity

1、开发语言：Solidity，支持状态变量、函数、事件、修饰符等核心语法。

2、核心标准：掌握 ERC-20、ERC-721标准的核心函数与事件，理解其生态兼容性价值。

3、安全原则：遵循 Checks-Effects-Interactions 模式防范重入攻击，通过访问控制限制敏感操作。

### 三、开发测试工具链

1、主流框架：使用 Hardhat（JS/TS 生态，插件丰富、上手快）和 Foundry（Solidity 原生测试，性能快 10 倍 +，支持模糊测试）。

2、测试体系：掌握单元测试、集成测试、主网分叉测试的核心逻辑，理解 Hardhat 的 Mocha/Chai 断言与 Foundry 的 Cheatcodes 工具用法。

3、部署流程：熟悉 Sepolia 等测试网使用，了解本地节点调试与链上部署的关键步骤。

### 四、了解Challenge0中的挑战以及其中代码运转的逻辑

1、Challenge0中让人了解以太坊环境下NFT的所有权产生到交易的一个完整的流转过程，其中在nftsMetadata.ts中提供了三个固定的NFT数据，用户在铸造的过程中，用户mint前三个是固定这三个NFT，而NFT通过IPFS进行一个数据上传，再返回这个数据的CID进行数据绑定及定位。

2、正在尝试进阶自己上传数据到自己的一个IPFS节点，深度理解IPFS的一个数据传递的逻辑。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->
















# Hardhat & Foundry 智能合约测试总结

## 一、Hardhat

Hardhat 是基于 Node.js 的以太坊智能合约开发框架，其测试体系以**模块化、可扩展、贴近生产环境**为核心，支持单元测试、集成测试、主网分叉测试等全维度测试场景，工程化结构覆盖 “配置 - 编码 - 执行 - 分析” 全流程，是目前 Web3 开发中最主流的测试工程化方案。

### 1、测试文件命名规则

-   单元测试：`[合约名].test.ts`（如`MyERC20.test.ts`）；
    
-   集成测试：`[场景名]-integration.test.ts`（如`token-dao-integration.test.ts`）；
    
-   分叉测试：`[场景名]-fork.test.ts`（如`uniswap-fork.test.ts`）。
    

### 2、测试用例结构（Mocha+Chai）

每个测试文件遵循 “前置准备→测试用例→后置清理” 的结构，核心模板如下：

```
import { ethers } from "hardhat";
import { expect } from "chai";
import { MyERC20 } from "../typechain-types/contracts/token/MyERC20"; // TypeChain生成的类型
import { deployMyERC20 } from "../utils/deploy-helpers"; // 复用部署函数

// 测试套件（对应单个合约）
describe("MyERC20 (Unit Tests)", function () {
// 全局变量
let myERC20: MyERC20;
let deployer: SignerWithAddress;
let user1: SignerWithAddress;
let user2: SignerWithAddress;
const TOTAL_SUPPLY = ethers.parseEther("1000000"); // 总供应量

// 前置准备（每个测试用例执行前运行）
beforeEach(async function () {
// 1. 获取测试账户
[deployer, user1, user2] = await ethers.getSigners();
// 2. 部署合约
myERC20 = await deployMyERC20(deployer, TOTAL_SUPPLY);
});

// 测试用例1：
it("should set correct total supply after deployment", async function () {
const totalSupply = await myERC20.totalSupply();
expect(totalSupply).to.equal(TOTAL_SUPPLY);
});

// 测试用例2：
it("should mint all supply to deployer", async function () {
const deployerBalance = await myERC20.balanceOf(deployer.address);
expect(deployerBalance).to.equal(TOTAL_SUPPLY);
});

// 测试用例3：
it("should transfer tokens between users", async function () {
const transferAmount = ethers.parseEther("1000");
// 部署者转账给user1
await myERC20.connect(deployer).transfer(user1.address, transferAmount);
// 验证余额
expect(await myERC20.balanceOf(user1.address)).to.equal(transferAmount);
expect(await myERC20.balanceOf(deployer.address)).to.equal(
TOTAL_SUPPLY - transferAmount
);
});

// 测试用例4：
it("should revert when transferring more than balance", async function () {
const invalidAmount = ethers.parseEther("1000001"); // 超过总供应量
// 验证交易回滚，并包含指定错误信息
await expect(
myERC20.connect(deployer).transfer(user1.address, invalidAmount)
).to.be.revertedWithCustomError(myERC20, "InsufficientBalance");
});
});
```

总之，Hardhat 测试工程化遵循 “目录对齐、测试分层、配置统一” 的原则，`test`目录按 “单元→集成→分叉” 划分，与`contracts`一一对应。用例遵循原子性、独立性原则，覆盖正常 / 异常 / 边界场景，通过 TypeChain 实现类型安全。

## 二、Foundry

Foundry 是基于 Rust 开发的高性能智能合约开发测试框架，核心优势在于**Solidity 原生测试（无需 JS/TS 中转）、极速模糊测试、轻量主网分叉、精准 Gas 分析**，其测试体系以 “贴近 EVM、高性能、原生安全” 为核心，工程化结构覆盖 “配置 - 编码 - 执行 - 分析” 全流程，是 Web3 进阶开发中主流的测试工程化方案。

### 1、测试文件命名与结构规则

-   文件名：`[合约名/场景名].t.sol`（如`MyERC20.t.sol`、`UniswapIntegration.t.sol`）；
    
-   测试合约：每个测试文件对应一个 / 多个测试合约，命名为`[被测合约名]Test`（如`MyERC20Test`）；
    
-   测试函数：必须以`test`开头（如`testTotalSupplyAfterDeployment`），失败场景以`testFail`开头或用`vm.expectRevert`验证。
    

### 2、测试合约核心模板（Solidity 原生）

Foundry 测试合约需继承`Test`合约（Foundry 内置，提供 Cheatcodes 和断言），核心结构如下：

```
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

// 导入Foundry核心测试合约
import "forge-std/Test.sol";
// 导入被测合约
import "../../src/token/MyERC20.sol";
// 导入测试工具
import "../utils/TestSetup.sol";

// 测试合约
contract MyERC20Test is Test {
// 1. 全局变量
MyERC20 public myERC20;
address public deployer = makeAddr("deployer"); // 生成测试账户
address public user1 = makeAddr("user1");
address public user2 = makeAddr("user2");
uint256 public constant TOTAL_SUPPLY = 1_000_000 ether;
// 2. 前置准备（每个测试用例执行前运行，类似Hardhat的beforeEach）
function setUp() public {
    // 给测试账户转账ETH（用于支付Gas）
    vm.deal(deployer, 100 ether);
    vm.deal(user1, 100 ether);
    vm.deal(user2, 100 ether);

    // 切换到deployer账户部署合约（模拟真实部署）
    vm.prank(deployer);
    myERC20 = new MyERC20(TOTAL_SUPPLY);
}

// 3. 基础测试用例：
function testTotalSupplyAfterDeployment() public view {
    // Foundry内置断言（无需Chai，原生Solidity）
    assertEq(myERC20.totalSupply(), TOTAL_SUPPLY);
}

// 4. 基础测试用例：
function testMintAllSupplyToDeployer() public view {
    assertEq(myERC20.balanceOf(deployer), TOTAL_SUPPLY);
}

// 5. 正常流程测试：
function testTransferTokensBetweenUsers() public {
    uint256 transferAmount = 1000 ether;

    // 模拟deployer发起转账（vm.prank切换调用者）
    vm.prank(deployer);
    myERC20.transfer(user1, transferAmount);

    // 验证余额
    assertEq(myERC20.balanceOf(user1), transferAmount);
    assertEq(myERC20.balanceOf(deployer), TOTAL_SUPPLY - transferAmount);
}

// 6. 异常流程测试：转账金额超过余额
function testRevertWhenTransferMoreThanBalance() public {
    uint256 invalidAmount = 1_000_001 ether;
    // 预期回滚，并验证自定义错误
    vm.expectRevert(abi.encodeWithSignature("InsufficientBalance(uint256,uint256)", TOTAL_SUPPLY, invalidAmount));
    vm.prank(deployer);
    myERC20.transfer(user1, invalidAmount);
}
}
```

Foundry 测试工程化遵循 “Solidity 原生、约定优于配置” 的原则，目录按 “单元→集成→分叉” 划分，Cheatcodes 是 Foundry 测试的灵魂，通过`vm.*`系列函数操控 EVM 环境、模拟链上行为。Cheatcodes（`vm.*`）操控 EVM 环境，原生模糊测试 / 不变式测试可自动发现边界漏洞，测试速度远快于 Hardhat。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->


















## Solidity 实战：

### 1\. 核心代币标准（EVM 生态的基础协议）

代币标准定义了统一的交互接口，确保不同合约 / 钱包 / 交易所兼容，是实战开发的核心场景：

| 标准 | 类型 | 核心功能 | 关键接口 | 典型场景 |
| --- | --- | --- | --- | --- |
| ERC20 | 同质化代币 | 转账、授权、余额查询 | transfer、approve、transferFrom、balanceOf | 稳定币、治理代币 |
| ERC721 | 非同质化代币（NFT） | 唯一资产确权、转移 | safeTransferFrom、ownerOf、tokenURI | 数字艺术品、游戏道具 |
| ERC1155 | 多代币标准 | 兼容同质化 / 非同质化，批量转账 | safeTransferFrom、balanceOf、batchTransfer | 游戏资产、多类型 NFT |

-   开发准则：优先基于 OpenZeppelin 实现（如`contract MyERC20 is ERC20 {}`），避免重复造轮子。
    

### 2\. 签名标准：EIP-712

-   解决问题：原生 ecrecover 仅支持哈希签名，用户无法直观验证签名内容（易 “盲签”）；
    
-   核心价值：定义结构化数据签名标准，将数据结构化后签名，前端可解析并展示具体内容（如 NFT 铸造参数、DeFi 授权信息）；
    
-   适用场景：NFT 白名单铸造、DeFi 权限授权、DAO 投票。
    

### 3\. 经典设计模式

| 设计模式 | 核心解决问题 | 实现思路 |
| --- | --- | --- |
| MultiCall | 多次调用 Gas 成本高 | 批量调用多个合约函数，一次交易完成，降低 Gas 成本 |
| Merkle 树 | 批量数据验证（如白名单） | 链上存储根哈希，链下验证叶子节点，大幅降低存储成本 |
| 状态机模式 | 合约状态管理（如众筹） | 将状态划分为 Pending/Active/Closed 等，限制状态转换逻辑 |
| 支付模式（PullPayment） | 主动转账失败（如接收方是合约） | 用户主动提现，替代合约主动转账，避免重入攻击 |

### 4\. OpenZeppelin 库：安全高效的开发工具

OpenZeppelin 是经过社区审计的开源库，提供核心合约模板，是实战开发的首选：

-   核心模块：ERC20/721/1155 代币、Ownable（权限控制）、ReentrancyGuard（防重入）、UUPSUpgradeable（可升级合约）；
    
-   使用流程：安装（`npm install @openzeppelin/contracts`）→ 导入 → 继承 → 定制化开发；
    
-   核心优势：修复了已知漏洞，通过社区审计，大幅降低安全风险。
    

## 智能合约安全：

### 1\. 安全概述

-   历史事件：The DAO 攻击（2016 年，重入攻击损失 6000 万美元 ETH）、Parity 钱包冻结（2017 年，权限漏洞冻结 3 亿美元 ETH）、FTX 崩盘（2022 年，中心化管理漏洞）；
    
-   安全挑战：EVM 不可逆性、代码透明性（开源）、跨合约交互复杂性、Gas 限制（逻辑中断）；
    
-   最佳实践：代码审计、形式化验证、安全测试、权限最小化、升级机制。
    

### 2\. 常见攻击模式（核心风险点）

| 攻击类型 | 核心原理 | 防护方案 |
| --- | --- | --- |
| 重入攻击 | 恶意合约在转账回调中重复调用目标函数，窃取资产 | 使用 ReentrancyGuard 修饰器、CEI 模式（Checks→Effects→Interactions）、PullPayment 模式 |
| 访问控制漏洞 | 权限校验缺失（如未检查 msg.sender 是否为管理员） | 使用 Ownable/AccessControl、避免 tx.origin 鉴权、关键操作多签验证 |
| 抢跑攻击（MEV） | 监控内存池交易，高价打包抢先执行（如 DEX 套利） | 限制滑点、隐私交易、闪电贷防护 |
| DoS 攻击 | 耗尽 Gas（无上限循环）、锁定合约状态（恶意抵押） | 限制循环次数、使用 PullPayment、避免依赖外部合约状态 |

### 3\. 输入验证和数据校验

-   **核心原则：**“所有外部输入都是不可信的”，必须校验参数合法性；
    
-   **常用方法：**
    
    -   数值校验：`require(amount > 0, "Amount must be positive");`；
        
    -   地址校验：`require(to != address(0), "Invalid zero address");`；
        
    -   权限校验：`require(role.hasRole(ADMIN, msg.sender), "Not admin");`。
        

### 4\. 安全开发工具

-   Slither：静态分析工具，自动检测重入、溢出、权限等常见漏洞；
    
-   Foundry：开发测试框架，支持模糊测试（Fuzzing），随机生成输入验证合约鲁棒性；
    
-   Echidna：形式化验证工具，自动检测合约逻辑漏洞；
    
-   审计平台：CertiK、OpenZeppelin Audit，专业团队人工审计（高价值合约必备）。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->




















## 一、Solidity 基础：

基础阶段聚焦 “能写、能部署、能运行”，掌握合约开发的核心语法、工程化规范与入门工具，是后续进阶的核心前提。

### 1\. Remix IDE：入门级全流程开发工具

Remix IDE 是浏览器端一站式 Solidity 开发环境，无需本地配置即可完成合约开发全生命周期，是新手入门的首选：

核心能力：代码编写（语法高亮、自动补全、错误提示）、编译（自定义 Solc 版本、开启优化）、部署（内置 VM / 测试网 / 主网）、调试（断点、步过、查看栈 / 内存 / 存储状态）；

入门实操流程：创建`.sol`文件 → 编写最简合约（如 HelloWorld） → 编译生成字节码 / ABI → 部署至 Remix VM → 调用函数验证执行结果；

实用技巧：通过 “Deployed Contracts” 面板管理已部署合约，利用 “Console” 面板执行自定义交互指令，通过 “Files” 面板管理多文件项目（如导入开源库）。

### 2\. Solidity 程序核心结构

一个完整的 Solidity 合约遵循固定工程化结构，核心组成如下：

```
// 1. 版本声明（指定兼容的Solc版本） 
pragma solidity ^0.8.20;

// 2. 导入外部合约/库（复用开源代码） 
import "@openzeppelin/contracts/access/Ownable.sol";

// 3. 合约定义（核心，支持继承/接口实现） 
contract MyFirstContract is Ownable { 

// 4. 状态变量（链上持久化存储） 
uint256 public totalCount;

// public自动生成getter函数 
string public contractName;
// 5. 构造函数（部署时执行一次，初始化状态）
constructor(string memory _name) {
    contractName = _name;
    totalCount = 0;
}

// 6. 核心函数（业务逻辑载体）
function incrementCount() public onlyOwner { // onlyOwner是权限修饰器
    totalCount += 1;
    emit CountIncremented(totalCount); // 触发事件
}

// 7. 事件（记录链上日志，供链下查询）
event CountIncremented(uint256 newCount);

}
```

**版本声明：**`^0.8.20` 表示兼容 0.8.20 至 0.9.0 前的所有版本，避免编译兼容问题；

核心规则：状态变量持久化存储在链上，函数是逻辑执行单元，事件用于链下状态追踪。

### 3\. 核心数据类型（值类型 + 引用类型）

Solidity 数据类型决定了合约数据的存储方式与操作逻辑，是语法的核心基础：

| 类型分类 | 具体类型 | 核心特性与使用场景 |   |
| --- | --- | --- | --- |
| 基础值类型 | 整数（uint/int） | uint8~uint256（无符号）、int8~int256（有符号），默认 uint=uint256；0.8 + 版本默认检查溢出，无需手动引入 SafeMath |   |
|   | 布尔（bool） | 取值 true/false，支持 &&、 | 、! 逻辑运算，常用于条件判断 |
|   | 地址（address） | 20 字节以太坊账户标识；address payable 支持 ETH 转账（transfer/send/call），普通 address 仅可查询余额 |   |
|   | 字节（bytes） | bytes1~bytes32（固定长度，Gas 成本低）、bytes（动态长度），适合存储二进制数据（如哈希、签名） |   |
|   | 字符串（string） | 动态长度 UTF-8 字符串，本质是 bytes 封装，Gas 成本高于固定长度 bytes |   |
| 引用类型 | 数组（array） | 固定数组（uint [5]）、动态数组（uint []）；支持 push/pop/ 长度获取，越界访问会触发异常 |   |
|   | 映射（mapping） | key-value 键值对（如mapping(address => uint256) balanceOf），仅支持值查询，无原生遍历功能（需额外维护索引） |   |
|   | 结构体（struct） | 自定义复合类型（如struct User { address addr; uint256 score; }），可嵌套使用，适合封装关联数据 |   |
| 特殊类型 | 枚举（enum） | 自定义枚举值（如enum Status { Pending, Completed }），默认从 0 索引，提升代码可读性 |   |

### 4\. 函数：合约逻辑的核心执行单元

函数是 Solidity 合约的交互入口，定义了合约的可执行逻辑：

**基本格式：**`function 函数名(参数类型 参数名) 可见性 修饰器 returns (返回类型) { 逻辑 }`；

**可见性控制（核心）：**

-   public：内部 / 外部均可调用（自动生成 getter 函数）；
    
-   private：仅当前合约内部调用；
    
-   internal：当前合约 + 继承合约调用；
    
-   external：仅外部账户 / 合约调用（Gas 成本更低）；
    
-   修饰器（modifier）：复用通用逻辑（如权限校验），示例：
    
    `modifier onlyAdmin() { require(msg.sender == admin, "Not admin"); _; // "_"表示执行函数主体逻辑 }`
    

**特殊函数：**

-   receive：仅接收 ETH 时触发（`receive() external payable {}`），无参数、无返回值；
    
-   fallback：调用不存在的函数 / 接收 ETH 且无 receive 时触发，处理非常规交互。
    

### 5\. 合约基础特性

状态变量：链上持久化存储，修饰符包括 **public/private/internal、constant**（编译期定值）、**immutable**（部署期定值）；

事件（event）：记录链上日志（Gas 成本低），支持`indexed`关键字（最多 3 个）实现日志过滤，供前端 / 链下系统查询；

错误处理：0.8 + 推荐自定义错误（`error InsufficientBalance(uint256 balance, uint256 required)`）替代 require 字符串，大幅降低 Gas 成本；

**核心指令：**

-   require：校验业务条件，失败则回滚并退还剩余 Gas；
    
-   revert：主动触发回滚，可配合自定义错误；
    
-   assert：仅用于内部逻辑校验，失败则消耗全部 Gas。
    

### 6\. 面向对象特性与 0.8 + 新特性

**继承：通过is**关键字实现，支持单继承 / 多继承，**super**关键字解决多继承歧义；

接口（interface）：仅定义函数签名，无实现（如`interface IERC20 { function transfer(address to, uint256 amount) external returns (bool); }`），用于标准化交互；

库（library）：无状态变量的可复用代码模块，支持`using Library for Type`语法（如`using SafeMath for uint256`）；

瞬态存储（transient）：0.8.18 + 新增，标记的变量仅在当前交易执行期间保留，交易结束后重置，不占用持久化存储，降低 Gas 成本（适用于临时计算数据）。

## 二、Solidity 进阶：

进阶阶段聚焦 “理解为什么”，穿透语法表层，掌握合约在 EVM 中的运行逻辑、底层交互机制与性能优化方法，是从 “会写” 到 “写好” 的核心跨越。

### 1\. 事件和日志机制

-   核心作用：EVM 将事件写入区块链日志（Log），不影响合约状态，但可永久存储且 Gas 成本低；用于前端状态更新、链下审计、合规溯源；
    
-   日志结构：包含主题（topics，`indexed`参数）和数据（data，非 indexed 参数），topics 支持快速过滤，data Gas 成本低但不可过滤；
    
-   实战价值：合约中触发事件 → 前端通过 Ethers.js/Web3.js 监听 → 实时更新 UI（如转账后刷新余额）。
    

### 2\. ABI 编码和解码

ABI（Application Binary Interface）是合约与外部交互的标准格式，定义了函数签名、参数 / 返回值的编码规则：

-   **编码函数：**
    
    -   abi.encode：标准编码（保留类型信息），适合合约间调用；
        
    -   abi.encodePacked：紧凑编码（无类型信息，Gas 成本低），易产生哈希碰撞；
        
    -   abi.encodeWithSignature：按函数签名编码（如`transfer(address,uint256)`），简化调用；
        
-   **解码函数：**`abi.decode`将二进制数据解码为 Solidity 类型，示例：
    
    `(address to, uint256 amount) = abi.decode(data, (address, uint256));`
    
-   核心用途：合约间调用传参、离线签名数据解析、链下系统交互。
    

### 3\. 合约间调用：call/delegatecall/staticcall

合约间调用是 EVM 生态的核心交互方式，三种方式差异显著（决定了调用的安全性与适用场景）：

| 调用方式 | 核心逻辑 | Gas 控制 | 核心风险 | 适用场景 |
| --- | --- | --- | --- | --- |
| call | 调用目标合约函数，使用目标合约的存储 /msg.sender/msg.value | 手动指定（target.call{gas: 100000, value: 1 ether}(data)） | 重入攻击、返回值未检查 | 通用合约调用、ETH 转账 |
| delegatecall | 调用目标合约代码，使用当前合约的存储 /msg.sender/msg.value | 同 call | 存储布局不匹配导致逻辑错误、重入攻击 | 代理合约、库函数调用 |
| staticcall | 只读调用，不修改合约状态 | 同 call | 无（只读操作） | 查询目标合约状态（如余额、持仓） |

-   关键准则：call/delegatecall 必须检查返回值（`(bool success, ...) = target.call(...); require(success, "Call failed");`）。
    

### 4\. 合约创建：create 和 create2

-   **create**（常规创建）：通过`new Contract(参数)`创建，地址由部署者地址 + nonce 计算（`address = keccak256(rlp.encode(deployer, nonce))[-20:]`）；
    
-   **create2**（确定性创建）：通过`CREATE2` opcode 创建，地址由部署者地址 + salt + 初始化代码哈希计算，可**预计算地址**（未部署也能确定地址）；
    
-   **核心场景**：create2 适用于闪电贷、原子交换、代理合约升级等需要地址确定性的场景。
    

### 5\. 存储布局与 Gas 优化

EVM 存储按 “槽（slot）” 划分（每个 slot 32 字节），Gas 成本：存储写入（~20000 Gas）> 内存操作（~3 Gas）> 栈操作（~0 Gas），优化核心是减少存储操作：

-   存储布局规则：状态变量按声明顺序填充 slot，小类型可打包（如 uint128+uint128 占用 1 个 slot）；mapping / 动态数组的实际数据存储在独立 slot；
    
-   **Gas 优化技巧：**
    
    1.  打包存储变量（减少 slot 占用）；
        
    2.  用`calldata`（只读）替代`memory`（复制）作为函数参数；
        
    3.  用事件替代非必要存储；
        
    4.  避免无上限循环（易触发 Gas 耗尽）。
        

### 6\. 代理合约模式（可升级合约）

代理合约实现 “存储与逻辑分离”，解决合约部署后不可篡改的问题：

-   透明代理：管理员调用逻辑合约，普通用户调用代理合约，避免函数签名冲突；
    
-   UUPS 代理：逻辑合约内置升级函数，代理合约无升级逻辑，Gas 成本更低（当前主流）；
    
-   核心风险：升级权限需严格控制（多签 / 时间锁），升级后逻辑合约不可修改存储变量顺序 / 类型。
    

### 7\. 数字签名和验证

基于椭圆曲线加密（ECDSA）实现 “链下签名、链上验证”，避免私钥暴露：

-   核心流程：用户私钥签名数据 → 合约通过`ecrecover`恢复签名者地址 → 验证身份；
    
-   **示例代码：**
    
    `function verify(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s, address signer) public pure returns (bool) { address recovered = ecrecover(msgHash, v, r, s); return recovered == signer; }`
    

学习笔记链接：[https://www.notion.so/Solidity-2e912f0b8b278059bf6dca570db765fd?source=copy\_link](https://www.notion.so/Solidity-2e912f0b8b278059bf6dca570db765fd?source=copy_link)
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->

























## 一、EVM 与 Gas 机制

### 核心结论

EVM（以太坊虚拟机）是以太坊的执行引擎，负责解析执行智能合约字节码，维护链上状态；Gas 机制通过计算资源计价与限额防止网络滥用，是保障网络安全、效率与经济可持续性的核心，两者共同支撑以太坊 “世界计算机” 的稳定运行。

### 关键知识点

**1、EVM 核心构成**

①全局状态（World State）：记录所有账户的 nonce、balance、codeHash、storageRoot，以 Merkle-Patricia Trie 组织。

②执行环境：栈（Stack，深度上限 1024，用于算术运算）、内存（Memory，临时数据存储，执行后销毁）、存储（Storage，永久状态存储，Gas 成本最高）。

③操作码（Opcodes）：EVM 指令集，如 ADD（加法）、SSTORE（写入存储）、CALL（外部调用），每条指令有固定 Gas 成本。

④执行上下文：包含 msg.sender（调用者）、msg.value（附带 ETH）、gasLeft（剩余 Gas）等，决定合约执行权限与资源限额。

**2、EVM 执行流程**

①部署阶段：EOA 发起创建交易→EVM 执行 init code→初始化 storage→写入 runtime code→生成合约账户。

②调用阶段：接收 calldata（函数选择器 + 参数）→解析函数→执行字节码→操作栈 / 内存 / 存储→触发事件→返回结果。

③异常处理：执行失败（如 Gas 耗尽、revert）时，状态全部回滚，已消耗 Gas 不退还，防止资源滥用。

**3、Gas 机制细节**

①Gas 定义：计算资源计量单位，用于衡量交易 / 合约调用的资源消耗，避免无限循环与 DoS 攻击。

②费用构成（EIP-1559 后）：实际费用 = GasUsed×(BaseFee+PriorityFee)，BaseFee 由协议自动调整并销毁，PriorityFee 为验证者小费。

③单位换算：1 ETH=10¹⁸ Wei，1 Gwei=10⁹ Wei，Gas 价格通常以 Gwei/Gas 表示，如 20 Gwei/Gas 即 20×10⁹ Wei/Gas。

④opcode Gas 成本：算术运算（如 ADD）约 3 Gas，内存操作（如 MLOAD）约 3-300 Gas，存储写入（SSTORE）约 20000 Gas，外部调用（CALL）约 700 Gas 起步。

**4、Gas 优化策略**

①存储优化：合并存储写入（先在内存计算再批量写入）、打包小变量到同一存储槽（如 uint128+uint64+bool）、用事件替代非关键存储。

②数据位置：外部函数参数用 calldata（只读不复制），重复读取的 storage 变量缓存到 memory。

③代码优化：使用 constant/immutable 变量（不占存储）、避免无上限循环、采用库合约复用逻辑、开启编译器优化（Solc optimizer）。

④链上链下分工：将遍历、统计等重计算移至链下，链上仅验证结果（如 Merkle 证明）。

⑤网络选择：优先在 L2（如 Arbitrum、Optimism）部署，利用 blob 交易降低数据成本。

**5、关键升级影响**

①London 升级（EIP-1559）：引入 BaseFee 销毁机制，费用可预测性提升，ETH 具备通缩潜力。

②Dencun 升级（EIP-4844）：引入 blob 交易，降低 L2 数据存储成本，间接减少 L2 合约调用 Gas 费。

③EIP-6780：限制 SELFDESTRUCT 功能，仅在合约创建同交易中生效，避免状态滥用。

## 二、共识机制与生态展望

### 核心结论

以太坊历经 PoW 到 PoS 的共识转型，通过合并、Dencun 等升级构建 “Rollup 为中心” 的扩容路线，生态聚焦 DeFi、NFT、Layer2 三大核心赛道，未来将通过 Danksharding、Verkle 树进一步提升扩展性，ETH 经济模型趋向通缩，机构参与度与跨链互操作性持续提升。

### 关键知识点

**1、共识机制演进**

①PoW（工作量证明）：早期共识，矿工通过算力竞争出块，能耗高，2022 年合并后停用，Ethash 算法为内存密集型，抑制 ASIC 垄断。

②The Merge（合并）：2022 年 9 月实施，将执行层（主网）与共识层（信标链）合并，PoS 取代 PoW，能耗降 99.95%，为扩容铺路。

③PoS（权益证明）：验证者质押≥32 ETH 参与出块，通过 Slashing 惩罚双签、环绕投票等作恶行为，奖励包括共识层 ETH 增发 + 执行层小费 + MEV。

④最终性（Finality）：通过 Casper FFG 机制，区块经足够验证者投票后达成最终确认，不可回滚。

**2、扩容路线图**

①Rollup 为中心：Optimistic Rollup（乐观式，如 Optimism）与 ZK Rollup（零知识，如 zkSync）承接大部分交易，L1 负责结算与数据可用性。

②Proto-Danksharding（EIP-4844）：2024 年 Dencun 升级引入，支持 blob 交易，为 L2 提供廉价临时数据空间，L2 交易费降低 90%。

③Danksharding：未来升级方向，引入数据可用性采样（DAS），验证者随机抽样验证 blob 数据，无需下载全部数据，进一步提升 L2 数据容量。

④Verkle 树：替换当前的 Merkle-Patricia Trie，缩小状态证明体积，支撑无状态客户端，降低节点存储压力。

**3、生态核心亮点**

①DeFi：流动质押（Lido）、再质押（EigenLayer）、RWA（国债代币化）成为增长动力，BlackRock 等传统机构入局发行链上基金。

②NFT：从 PFP 投机转向实用场景，包括游戏资产（Axie Infinity）、品牌会员（奢侈品牌数字藏品）、凭证化资产（POAP 出席凭证）。

③Layer2：Arbitrum、Optimism、Base 等 Rollup 日活与交易量持续增长，Dencun 升级后费用进一步降低，成为应用部署首选。

④社交与 DAO：去中心化社交协议（Lens Protocol、Farcaster）、DAO 治理（Uniswap DAO）、公共物品资助（Gitcoin Grants）生态成熟。

**4、ETH 经济模型**

①发行机制：PoS 下年增发约 60-70 万 ETH，通胀率 0.5% 左右，远低于 PoW 时代的 4-4.6%。

②销毁机制：EIP-1559 下 BaseFee 销毁，高链上活动时销毁量超过发行量，呈现净通缩。

③价值支撑：Gas 费收入、质押收益、生态应用需求构成 ETH 核心价值，机构质押与 RWA 上链提升长期需求。

**5、未来发展方向**

①技术升级：Pectra 升级（2025 年）将推进账户抽象、EOF（EVM 对象格式）、验证者质押上限提升（从 32 ETH 到 2048 ETH）。

②生态扩展：跨链互操作性（LayerZero、CCIP）、隐私保护（零知识证明）、AI+DeFi（智能策略代理）成为创新方向。

③治理与合规：EIP 流程优化、机构合规工具完善、RWA 监管框架落地，推动以太坊生态规范化。

学习笔记链接：[https://www.notion.so/Week1Day3-2e712f0b8b2780f192aeff6d6a5eb4b7?source=copy\_link](https://www.notion.so/Week1Day3-2e712f0b8b2780f192aeff6d6a5eb4b7?source=copy_link)
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



























# 基础概念了解回顾——Week1Day2

## 一、网络结构与节点类型

### 核心结论

以太坊网络由分布式节点通过 P2P 协议构成，节点需同时运行执行客户端与共识客户端（合并后），按功能分为全节点、轻节点、归档节点，通过节点发现、加密通信、数据同步机制保障去中心化与数据一致性，是以太坊安全与抗审查性的基础。

### 关键知识点

**1、节点与客户端软件**

①节点定义：运行以太坊客户端并连接其他节点的计算机，是网络的核心组成单元。

②客户端分类：合并后需同时运行执行客户端（EL，如 Geth、Nethermind）和共识客户端（CL，如 Lighthouse、Prysm），通过 Engine API 协同。

③执行客户端功能：处理交易、执行 EVM 逻辑、维护账户状态、提供 JSON-RPC 接口（eth\_\*）。

④共识客户端功能：管理 PoS 共识、区块提议与投票、跟踪验证者状态、维护信标链视图。

⑤验证者客户端：作为共识客户端插件，管理验证者密钥，参与区块提议与投票，需质押≥32 ETH。

**2、节点间通信机制**

①节点发现：基于 UDP+Kademlia 协议，新节点通过引导节点（boot nodes）获取邻居列表，通过 Ping/Pong 确认在线状态，FindNode 请求邻居地址。

②连接建立：通过 TCP 建立稳定连接，RLPx 协议实现加密通信与多路复用，在单一 TCP 通道上承载区块同步、交易传播等子协议。

③数据传播：采用 Gossip 协议，节点收到新交易 / 区块后随机转发给少数邻居，实现秒级全网扩散；历史数据通过点对点请求 - 响应模式按需拉取。

**3、节点同步模式**

①Full Sync（全同步）：从创世块逐块执行所有交易，重建状态，最安全但耗时数天，适合审计场景。

②Snap Sync（快照同步）：下载最新区块头 + 状态快照，并发填充状态数据，数小时到 1 天完成，为全节点默认模式。

③Light Sync（轻同步）：仅下载区块头，依赖全节点提供数据证明，适合资源受限设备。

**4、关键技术细节**

①合并后客户端协同：共识客户端通过 Engine API 向执行客户端请求区块 payload，执行客户端执行交易后返回结果，共识客户端打包并广播区块。

②Gossip 协议价值：去中心化传播，容错性强，单个节点离线不影响全网同步，传播延迟低（秒级）。

③节点搭建流程：选择节点类型→配置硬件（全节点需 1TB SSD+16GB 内存）→安装 EL+CL 客户端→选择同步模式→开启 RPC 接口→配置防火墙与监控。

## 二、账户类型与结构

### 核心结论

以太坊账户分为 EOA（外部拥有账户）和合约账户两类，EOA 由私钥控制，可主动发起交易；合约账户由代码驱动，被动响应调用，两者通过地址（0x 开头 20 字节）标识，共同支撑链上资产流转与逻辑执行。

### 关键知识点

**1、EOA（外部拥有账户）**

①定义：由公私钥对控制的账户，无内置代码，可主动发起交易（转账、调用合约），持有 ETH 与各类代币。

②核心字段：地址（公钥派生）、nonce（交易计数器，防止重放攻击）、balance（ETH 余额，以 wei 为单位）、code/storage（均为空）。

③控制方式：私钥签名交易，验证者通过公钥验证签名合法性；助记词（BIP-39）派生私钥，支持多地址管理；MetaMask 等钱包通过本地加密存储私钥 / 助记词。

④安全要点：私钥 / 助记词泄露即资产丢失，无找回机制；硬件钱包可提升私钥安全性，避免联网暴露。

**2、合约账户**

①定义：无私钥，由部署的 EVM 字节码决定行为，有独立地址、balance、code（运行时代码）、storage（状态变量存储）。

②创建流程：EOA 或工厂合约发起创建交易（to 字段为空，data 字段为 init code + 构造函数参数）→EVM 执行 init code→生成 runtime code 并写入链上→初始化 storage→生成合约地址。

③地址计算：CREATE 方式由 “部署者地址 + nonce” 决定，公式为 keccak256 (RLP (\[sender, nonce\])) 后 20 字节；CREATE2 方式由 “部署者地址 + salt+keccak256 (init code)” 决定，支持地址预计算。

④核心限制：不能主动发起交易，仅能被 EOA 或其他合约调用；代码默认不可篡改，可通过代理模式实现升级。

**3、地址与账户交互**

①地址格式：以 “0x” 开头的 40 位十六进制字符串（20 字节），0x 前缀为十六进制标识，符合编程界传统。

②EIP-55 校验和：混合大小写标识地址，通过大小写模式校验输入正确性，降低手动输入错误风险。

③账户交互机制：EOA 通过交易调用合约（指定 to 地址 + calldata）→EVM 加载合约代码→执行函数逻辑→更新 storage / 余额→触发事件；合约间通过 call/delegatecall/staticcall 实现内部调用，共享同一交易的 Gas 限额。

**4、代币与账户的关系**

①ERC-20 代币：通过合约账户的 mapping 存储余额（mapping (address=>uint256)）与授权额度，转账本质是调用合约 transfer/transferFrom 函数，更新存储状态。

②ERC-721 代币：通过 mapping (uint256=>address) 记录 tokenId 与所有者映射，支持唯一资产确权（如数字艺术品）。

③代币操作流程：EOA 发起交易→调用代币合约函数→合约验证权限 / 余额→更新存储→触发 Transfer 事件→区块浏览器记录交易。

## 三、智能合约理论基础

### 核心结论

智能合约是部署在链上的 “代码 + 状态” 组合，通过 Solidity 等语言编写、EVM 执行，具备自动执行、公开透明、不可篡改特性，是以太坊应用生态的核心载体，开发流程涵盖编写、编译、部署、调用，需重点关注安全漏洞防范。

### 关键知识点

**1、智能合约核心特性**

①自动执行：满足预设条件（if…then… 逻辑）即触发，无需第三方干预，如时间锁账户（满 18 岁可提取资金）。

②结果确定性：相同输入在任意节点执行结果一致，保障共识一致性。

③公开透明：代码与执行记录全网可见，支持链上审计与验证。

④不可篡改：部署后代码默认不可修改，可通过代理模式（Proxy）实现功能升级。

⑤假名性：交易绑定地址而非实名，链上行为可追踪，隐私需额外设计（如零知识证明）。

**2、Solidity 语言特性**

①适配 EVM：专为 EVM 设计，编译后生成字节码，支持所有链上资源操作（存储、Gas、事件）。

②核心特性：静态类型、面向对象（继承、接口、抽象合约）、支持结构体 / 映射 / 枚举、图灵完备。

③生态支持：配套 Hardhat/Foundry 开发框架、OpenZeppelin 安全库、Remix 浏览器 IDE，工具链成熟。

④安全增强：0.8.0 + 版本默认整数溢出检查，支持自定义错误（error 类型），降低漏洞风险。

⑤学习路径：基础概念→官方文档 + Remix 实操→Hardhat/Foundry 工具使用→安全漏洞学习→项目实战（如 ERC-20 代币开发）。

**3、合约编译与部署**

①编译产物：init code（部署时执行，含构造函数）、runtime code（链上运行代码）、ABI（JSON 格式接口描述，含函数 / 事件参数）、metadata（编译器版本、源码哈希）。

②部署流程：编写代码→编译生成字节码 + ABI→EOA 发起创建交易（支付 Gas）→EVM 执行 init code→写入 runtime code 与初始 storage→返回合约地址。

③部署成本：Gas 消耗 = 基础交易成本（21000 Gas）+CREATE 指令成本（32000 Gas）+ 字节码存储成本（200 Gas / 字节）+ 构造函数执行成本，总费用 = GasUsed×(BaseFee+PriorityFee)。

**4、常见安全漏洞与防范**

①重入攻击：通过 CEI 模式（Checks→Effects→Interactions）、ReentrancyGuard 修饰符、Pull-Payment 提现模式防范。

②整数溢出 / 下溢：使用 Solidity 0.8.0 + 版本（默认检查），必要时用 unchecked 块优化 Gas。

③访问控制错误：采用 Ownable/AccessControl 管理权限，禁止使用 tx.origin 鉴权，关键操作搭配多签 + 时间锁。

④预言机操控：使用 Chainlink 等去中心化预言机，采用 TWAP（时间加权平均价格），设置滑点限制。

**⑤**Gas 耗尽攻击：避免无上限循环，使用 call 而非 transfer/send 发送 ETH，检查返回值。

⑥可升级合约风险：采用 OpenZeppelin Proxy 模板，严格遵守存储布局规则，升级权限交由多签 + 时间锁控制。

**5、部署与调试工具**

①Remix IDE：浏览器端 IDE，支持编写、编译、部署、调试，适合入门与快速原型。

②Hardhat：Node.js 开发框架，支持脚本化部署、主网 fork 测试、Gas 报告，插件生态丰富。

③Foundry：Rust 编写的开发工具链，支持 Solidity 原生测试、模糊测试（fuzzing）、高速编译，适合协议级开发。

④Tenderly：云端调试平台，支持交易回放、断点调试、主网 fork 模拟，适合复杂合约调试。  
学习笔记链接：[https://www.notion.so/Week1Day2-2e712f0b8b27806b811ffe871e854f1b?source=copy\_link](https://www.notion.so/Week1Day2-2e712f0b8b27806b811ffe871e854f1b?source=copy_link)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


































# 基础概念了解回顾——Week1Day1

## 一、Web3的历史与发展：

Web1.0：静态网页时代，网页主要是HTML构成，网站的内容由服务器生成，浏览器负责展示，内容是静态的，用户交互有限；

Web2.0：随着JavaScript的普及和Ajax技术的发展，Web应用开始变得更加动态和交互性强，内容是动态的，但是数据都集中在一个平台的数据库中，用户并不拥有这些数据。这个时代的特点是用户参与度高，社交网络、博客和论坛等应用兴起。

Web3.0：第三代互联网可以说是Web 1.0和Web 2.0相结合，就形成了Web3的数字化生态，在其中用户可以真正拥有自己的数据，并且交易受到了加密技术保障。

### **解决疑惑：**

**1、什么是Web3**

在Web3中，互联网应用和服务不再依赖于中心化的服务器和数据库，而是通过区块链、去中心化存储、智能合约等技术，赋予用户对数据、身份和价值交换的完全控制权。可以理解为去中心化和数据所有权回归用户。

**2、Web2和Web3的区别**

**①所有权上**，Web2是你的所有数据存储在第三方平台上，用户隐私存在一定风险，而Web3利用区块链的加密和分布式账本技术，用户数据归个人所有，只有在用户授权的情况下才能被使用，极大地保障了用户的隐私和数据主权。

**②中心化程度上**，Web2高度中心化，平台拥有绝对的控制权和规则制定权。Web3去中心化的架构，减少了对中心化机构的依赖，平台规则由社区共同制定和维护。

**3、如何理解去中心化**

去中心化是指将原本由单一中心化机构或个人控制和管理的权力、资源和决策权，分散到更多的节点或个体中，实现权力的分权和资源的分散。通俗地讲，在“去中心化”的世界里，每一个人都会是一个节点，任何人也都有可能成为一个中心。

## 二、区块链的基础概念

区块链是一种去中心化的分布式账本技术，具有不可篡改、安全透明等特点，在金融、供应链、医疗等多个领域有着广泛的应用前景。

### **1、分布式账本**

定义：分布式账本是区块链的核心概念之一，它是一种在多个节点之间共享、复制和同步的账本，而非存储在单一的中心化服务器上。网络中的每个节点都拥有完整或部分的账本副本，所有副本在经过共识机制验证后保持一致。

**特点：**

①去中心化：没有单一的控制中心，所有节点地位平等，共同参与账本的维护和管理，降低了因单点故障或中心化机构出现问题带来的风险。

②不可篡改：一旦数据被记录在分布式账本上，要想篡改就需要控制网络中大部分节点，成本极高，几乎不可能实现，保证了数据的真实性和完整性。

③透明性：网络中的所有节点都可以查看账本上的交易记录，数据对所有人公开，使得交易过程可追溯、可审计，增加了信任度。

### **2、共识机制**

定义：共识机制是区块链网络中节点之间就区块数据的有效性和顺序达成共识的规则和算法。它确保了分布式账本的一致性和安全性，使得不同节点能够在没有中心化机构协调的情况下，对区块链的状态达成一致意见。

**常见类型：**

①工作量证明（PoW）：节点需要通过进行复杂的数学运算来竞争记账权，谁先找到符合条件的解，谁就可以将新的区块添加到链上。比特币就采用了 PoW 机制，这种方式虽然保证了安全性，但能耗较高。

②权益证明（PoS）：根据节点持有的加密货币数量和时间来分配记账权，持有权益越多、时间越长的节点，获得记账权的概率越大。与 PoW 相比，PoS 能耗较低，且效率相对较高。

### **3、节点**

定义：节点是区块链网络中的参与主体，可以是个人电脑、服务器等设备。每个节点都具有独立的运算和存储能力，它们通过网络连接在一起，共同构成了区块链网络。

**分类：**

①全节点：存储了区块链的完整账本数据，能够独立验证交易和区块的合法性，参与共识过程，对区块链网络的安全和稳定起着重要作用。

②轻节点：只存储了区块链的部分数据，通常依赖全节点来获取完整的区块链信息，进行交易验证等操作。轻节点占用的存储空间较小，适用于资源有限的设备，如手机等。

③矿工节点：主要负责参与区块链的共识过程，通过计算来竞争记账权，将新的交易记录打包成区块添加到区块链上，并获得相应的奖励。在采用 PoW 等共识机制的区块链网络中，矿工节点是保证网络安全和运行的关键力量。

### 4、比特币（BTC）

定义：总的来说，比特币是一种奖励网络节点服务提供商的代币激励，因比特币的设计、有限的供应量和能够自由转账交易而具备货币的属性，成为了一种加密货币。

### 5、行业赛道

**分类：**

**①DeFi，全称为 Decentralized Finance（去中心化金融）。**

DeFi是基于区块链技术建立的金融体系，目标是提供不依赖传统银行或金融中介的服务，比如借贷、交易、支付等，让每个人都可以自由参与，无需审批、无需信任中介机构。

**②NFT，本质是数字资产的唯一性和所有权。**

NFT 通过区块链技术解决了“所有权”模糊这一问题。每个 NFT 代表一个唯一的数字资产，并且在区块链上存有不可篡改的记录。**区块链技术**的核心特点是，它是一种去中心化、公开透明的账本，所有交易和所有权信息都被记录在上面。

**③DAO，（Decentralized Autonomous Organization，去中心化自治组织）。**

DAO不依赖传统的公司架构，而是通过智能合约和社区投票来做决策。它不需要一个管理层，所有事情都由持有代币的社区成员共同治理，公开透明。

**④MEME 原意为“迷因”，即网络文化中的梗、表情包、搞笑段子等。**

在加密圈，MEME 通常指那些以网络文化为基础的代币，比如 DOGE（狗狗币）、PEPE（青蛙币）、SHIB（柴犬币）等。

MEME 币的特点通常是“有趣、搞怪、社区驱动”，它们往往缺乏明确的技术价值，但通过强大的社区共识和文化认同获得价值。2024-2025 年，MEME 币市场出现了新的特点：**公平发射**（Fair Launch）、**社区自治**和**实用性整合**成为新趋势。

**⑤交叉创新领域。**

随着 Web3 技术的发展，各个细分领域开始相互融合，产生了许多创新应用。这些跨领域的组合不仅拓展了单一技术的应用边界，还创造了全新的商业模式和用户体验。如“**DeFi + NFT”推动数字资产金融化；“DAO + MEME”形成社区文化与治理融合；“AI + DeFi”提供智能化金融服务；“WEB3 + 乡建”催生南塘 DAO 的探索。**

## 三、以太坊的基础概念

### 1、什么是以太坊

以太坊是一个去中心化、开源、具备智能合约功能的公共区块链平台。其核心是以太坊虚拟机（EVM），这是一个图灵完备的虚拟机，能够执行智能合约代码，使区块链不仅是“记账系统”，更是“可编程的全球结算与应用平台”。

**特点：**

全球性：节点分布全球，无单一控制中心。

可编程性：支持智能合约，可实现复杂业务逻辑。

去中心化：由全球节点共同维护，抗审查、抗单点故障。

### 2、以太坊的核心机制

**①智能合约**

智能合约是存储在以太坊区块链上的一段程序代码，由全网节点共同验证和执行。它是以太坊从“记账系统”升级为“可编程全球结算平台”的关键。

**特点：**

**自动执行**：一旦部署，只要满足触发条件，代码将无条件执行。

**不可篡改**：部署后的合约代码默认不可修改，确保了规则的公正性。

**公开可验证**：所有执行逻辑和状态变更都记录在链上，任何人可以审计。

**②共识机制：权益证明（PoS）**

自2022年“合并”（The Merge）后，以太坊从工作量证明（PoW）完全转向PoS，验证者需质押≥32 ETH，通过投票机制出块，恶意行为会被惩罚（Slashing），能耗相比PoW降低约99.95%。

**③Gas 机制**

Gas是以太坊用于衡量和支付计算与存储资源的单位。所有链上操作（转账、调用合约等）都会消耗Gas，以防止网络资源被滥用。

**④账户模型**

EOA（外部拥有账户）：由私钥控制，可主动发起交易。

合约账户：由代码控制，不可主动发起交易，只能被调用。

### 3、以太坊的生态概览

**①DeFi（去中心化金融）**

在各类借贷协议（如抵押 ETH 借稳定币）、衍生品协议、流动性池（AMM/LP）、RWA里，ETH 都是使用最广泛、信用最好、流动性最强的底层资产之一；

**②NFT（非同质化代币）**

绝大多数 NFT （艺术、收藏品、游戏道具、虚拟土地等）的铸造与交易，仍主要以 ETH 计价与结算；

**③DAO（去中心化自治组织）**

DAO已成为Web3项目标准的治理框架。重点从“是否去中心化”转向治理效率、参与度、法律合规与抗攻击能力的优化。如Uniswap DAO、Aave DAO，负责管理协议参数、国库资金（数亿至数十亿美元规模）和升级决策，实现了“协议即组织”。

**④Layer 2 扩容方案**

以太坊确立了“以Rollup为中心”的扩容路线图，L2负责执行，L1负责安全和数据可用性。现在绝大多数用户交易已迁移至L2。L2的TPS总和已达到每秒数万笔，费用低廉，已成为新应用部署的首选。以太坊主网正在成为“结算层”和“数据可用性层”。

### 4、以太坊的价值观

**核心价值观：**

**①去中心化治理（Decentralization）**

**②无需许可与开放性（Permissionless & Open）**

**③抗审查性（Censorship Resistance）**

**④密码朋克精神（Cypherpunk Ethos）**

**⑤公共物品导向（Public Goods Orientation）**

**⑥可持续发展理念**

这些价值观不仅塑造了以太坊的技术发展方向，也形成了独特的社区文化，吸引了全球开发者、研究者和用户的参与。

学习笔记链接：[https://www.notion.so/Week1Day1-2e612f0b8b2780339d5fcbca60cc0b11?source=copy\_link](https://www.notion.so/Week1Day1-2e612f0b8b2780339d5fcbca60cc0b11?source=copy_link)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
