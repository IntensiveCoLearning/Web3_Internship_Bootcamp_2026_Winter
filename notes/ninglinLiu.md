---
timezone: UTC+8
---

# NingLin Liu

**GitHub ID:** ninglinLiu

**Telegram:** @duanqiangushifei

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->
下面是你**今天的学习内容汇总（可直接当日志/上交版）**，我按“学了什么 → 关键点 → 可执行动作”整理。

* * *

# 今日学习内容汇总（2026-01-18）

## 1) Web3 安全与交易机制：MEV（最大可提取价值）

**学了什么：**  
理解 MEV（Maximal Extractable Value）的本质：**区块里交易排序权带来的“额外利润空间”**，以及它如何在 DEX 交易中“吃掉”普通用户的滑点与成本。

**关键点：**

-   **MEV 的核心**：交易在进入区块前存在“可观察 + 可插队 + 可重排”的空间，因此有人能通过排序/插队/重组来赚钱。
    
-   **典型 MEV 形式**：
    
    -   **抢跑（Front-run）**：先你一步成交，让你用更差价格成交。
        
    -   **尾随（Back-run）**：在你交易后立刻跟进吃价差。
        
    -   **三明治攻击（Sandwich）**：前后夹击，把你的滑点当利润来源。
        
    -   **套利（Arb）**：跨池/跨交易所价差套利（相对“中性/健康”的一种）。
        
-   **对普通用户的影响**：滑点异常、成交价被“系统性变差”、gas 战争、拥堵。
    
-   **缓解思路**（不是消灭，而是降低被吃）：
    
    -   使用**私有交易通道/私有 RPC**避免交易暴露在公共 mempool
        
    -   **严格设置滑点**、拆分大单、避免一笔梭哈
        
    -   理解 **MEV-Boost / PBS** 等把 MEV 从“暗抢”转为“可控分配”的路线
        

**今日可执行动作：**

-   以后做大额 swap：优先考虑私有通道（不把交易裸露在公共 mempool）
    
-   复盘自己过去遇到的“成交价异常差”是否可能是 sandwich
    
-   给自己的交易 SOP 加一条：**“滑点不合理 = 立刻停手检查”**
    

* * *

## 2) 平台生态观察：AI × Web3 × Quant 信息摄取（日报式）

**学了什么：**  
从“信息 → 判断价值 → 转化为行动”的角度，训练自己快速抓重点。

**关键点：**

-   关注到 **Claude Code** 类工具在“长任务执行效率”上的改进方向（例如更利于遵守计划、减少上下文干扰）。
    
-   关注到 **Solana 生态**在“资产购买便利性/支付与互联网资本市场叙事”上的持续扩张趋势。
    

**今日可执行动作：**

-   你的工具流（Cursor/Freqtrade/研究工作台）也可以借鉴一个思路：  
    **把长任务拆成短周期、可复盘的“清晰上下文窗口”**（减少脑内切换成本）
    
-   对生态类信息：用“**能否转化成策略/产品/交易框架**”作为筛选标准
    

* * *

## 3) 互联网黑灰产识别意识（刷粉黑产语境）

**学了什么：**  
对刷粉/涨粉相关“黑话”与其被称为黑产的原因建立基本判断框架：这类行为往往涉及平台规则对抗、虚假交易链路、账号安全与法律/合规风险。

**今日可执行动作：**

-   遇到“快速涨粉/代运营/矩阵”类说辞：先做风险判断（封号/资金/个人信息/灰链路牵连）
    
-   把“增长”拆成可持续的替代方案：内容质量、转化路径、互动结构，而不是数据造假
    

* * *

# 今日一句话总结

今天把“链上交易为什么会被吃滑点（MEV）”这件事从现象拉回到机制层理解，同时也在训练“信息摄取→策略化”的能力，并补上了对平台黑灰产的基础风控意识。

* * *
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->

# 今日 Web3 学习报告：ZK × Monad 并行批量验证与 zkKYC Gate 落地

## 1\. 今日目标与产出

今天的学习主线是把“ZK 证明验证”从概念层面落地成**可部署、可验收、可演示**的完整闭环系统，并围绕 Monad 的并行执行叙事构建一个真实需求场景：**批量 zkKYC 合规门禁**。

最终产出：

-   [https://github.com/ninglinLiu/zkhahaha](https://github.com/ninglinLiu/zkhahaha)
    
-   已部署到 Vercel 的前端可访问站点（评委可直接打开验收）：[https://zk-parallel-web666.vercel.app](https://zk-parallel-web666.vercel.app)
    
-   Monad Testnet 上的两类合约：
    
    -   `ParallelZKPlayground`（批量验证引擎）
        
    -   `KycPass`（ERC721 SBT Pass，门禁凭证）
        
-   完整演示动线：`/kyc → Verify 50 → Mint Pass → /gate`
    
-   关键页面与功能：Upload Proof / Batch Verify / View Receipt / Batch zk-KYC / Gate
    

* * *

## 2\. 核心认知升级：ZK “验证”到底在系统里扮演什么角色？

今天最大的理解变化是：  
**ZK 不只是密码学证明，而是一种“可信计算结果的凭证系统”**。

在应用层，用户/机构最需要的不是“我能不能验一个 proof”，而是：

-   能不能一次性处理很多用户（规模化）
    
-   能不能把验证结果直接变成权限（可用性）
    
-   能不能不引入隐私数据存储（合规性）
    

因此我把系统拆成两层：

-   **验证引擎层**：负责批量验证、产出回执（Playground）
    
-   **业务凭证层**：把回执映射为可消费的权限（KycPass + Gate）
    

这让项目从“验证器轮子”升级为“解决真实需求的工作流”。

* * *

## 3\. 并行执行视角：为什么 Monad 对这类系统有优势？

今天明确了一个很关键的工程点：  
并行不是靠口号，而是靠**存储布局**与**写冲突控制**。

我在合约层采用：

-   `mapping(bytes32 => Result)` 作为结果存储  
    让每个 `proofId` 写入独立存储槽，避免全局共享写热点
    
-   避免 `totalVerified++` 等全局累加器  
    统计指标（通过率、gas/proof 等）由前端从事件/回执聚合
    

这对应 Monad 的并行执行叙事：  
**当写入目标是独立槽位时，同一笔交易内的多个写入更容易并行化处理**，批量验证才能成为“系统设计的一等公民”。

* * *

## 4\. zkKYC Gate 场景：从“验证”到“准入”的闭环

今天把 zkKYC 的产品逻辑跑通：

### /kyc（Issuer 视角）

-   一键生成 50 个 Applicants（含 claims：country / over18 / notSanctioned）
    
-   批量验证（Verify 50）→ 前端展示关键指标：
    
    -   Gas Used、Gas / Proof、Latency、Success Rate、Verified Count
        
-   对通过地址批量发放 Pass（Mint Pass）
    

### /gate（用户视角）

-   连接钱包 → 调用 `hasPass(address)` 判断是否持证
    
-   持证显示 Access Granted（解锁内容）
    
-   未持证显示 Not Verified 并引导回 /kyc
    

这条动线解决了一个“评委验收很现实”的问题：  
**不是你能不能证明你会写合约，而是评委打开链接能不能三步点出一个能用的结果。**

* * *

## 5\. 工程层面的收获：黑客松交付思维

今天的工程学习不止是写代码，更是“怎么交付”：

-   **公网可用**比“本地能跑”重要：Vercel + Monad Testnet 的可访问闭环是获奖门槛
    
-   **可演示动线**比“技术细节”重要：把功能按评委行为路径组织（/kyc → /gate）
    
-   **指标可视化**很加分：gas/proof、延迟、通过率让“高性能叙事”变得可验证
    
-   **模块化叙事**更容易扩展：验证引擎（Playground）未来可复用到 zkAML、隐私验资、抗女巫等场景
    

* * *

## 6\. 仍需补强与下一步计划

接下来可以进一步增强“像真实系统”的部分（不影响现有演示）：

1.  **Pass 元数据与视觉强化**
    
    -   KYC Pass 加入更完整的 tokenURI（徽章/等级/issuer 标识）
        
2.  **Receipt 体验强化**
    
    -   /receipt 页面做更直观的 proofId → status → txHash → explorer 的展示链路
        
3.  **Demo 稳定性增强**
    
    -   自动检测网络 / 自动切换 Monad Testnet
        
    -   为评委准备“无脑按钮”：一键生成、一键验证、一键 mint、一键 gate
        
4.  **扩展叙事**
    
    -   在同一验证引擎上扩展第二个场景：Proof-of-Assets / Sybil Shield（保持系统不是单点 demo）
        

* * *

## 7\. 今日一句话总结

今天把 ZK 从“概念”推进到“产品级闭环”：  
**在 Monad 并行执行模型上实现批量 proof 验证，并把验证结果铸造成 SBT Pass，用于合规门禁与访问控制——评委打开链接即可验证。**
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->


# Checkpoint 3 学习总结：部署 NFT 合约到以太坊测试网（Sepolia）

## 一、学习目标回顾

本阶段（Checkpoint 3）的目标是将本地开发完成的 NFT 智能合约，从 **Hardhat 本地网络** 部署到 **以太坊公共测试网 Sepolia**，并理解以下核心问题：

-   合约部署账户（deployer）的来源与安全性
    
-   测试网与本地网络的区别
    
-   钱包、地址、合约三者之间的关系
    
-   Hardhat + Scaffold-ETH 2 的完整部署流程
    

* * *

## 二、关键操作与实践过程

### 1️⃣ 切换 Hardhat 默认网络为 Sepolia

在 `packages/hardhat/hardhat.config.ts` 中完成以下配置修改：

-   将 `defaultNetwork` 从 `localhost` 修改为 `sepolia`
    
-   确认 `networks.sepolia` 配置正确（RPC + deployer 私钥）
    

这一步明确了：**后续** `yarn deploy` **默认就是向 Sepolia 测试网发交易**。

* * *

### 2️⃣ 使用 CLI 生成部署钱包（Deployer）

通过命令：

```
yarn generate
```

完成了以下工作：

-   生成一个新的 **以太坊标准 EOA 钱包**
    
-   私钥被加密后存储在 `packages/hardhat/.env`
    
-   该钱包专门用于部署合约（而不是日常交互）
    

关键理解：

-   该钱包 **不依赖 MetaMask**
    
-   是专业开发中常见的“部署账户（deployer）”模式
    
-   可选地导入到 MetaMask，但不是必须
    

* * *

### 3️⃣ 查询账户状态并理解多网络余额

通过：

```
yarn account
```

学会查看同一地址在不同网络上的状态：

-   localhost
    
-   mainnet
    
-   sepolia
    

理解到：

-   **同一个地址，在不同网络上是“独立存在”的**
    
-   Sepolia 测试币 ≠ 主网 ETH
    
-   主网余额为 0 并不影响测试网部署
    

* * *

### 4️⃣ 测试币（Sepolia ETH）获取与问题排查

实践中发现：

-   **Alchemy Faucet 要求主网 ≥ 0.001 ETH**，对新开发者不友好
    
-   最终通过 **Google Cloud Sepolia Faucet** 成功获取测试币
    

学习到：

-   Faucet 有不同门槛设计
    
-   测试网 ETH 仅用于 gas，不具备真实价值
    

* * *

### 5️⃣ 成功部署 NFT 合约到 Sepolia

在测试币到账后，通过：

```
yarn deploy --network sepolia
```

成功完成：

-   NFT 合约 `YourCollectible` 部署
    
-   获得 **Sepolia 链上的真实合约地址**
    
-   前端 `deployedContracts.ts` 自动更新
    

这标志着：

> 合约已经不再是“本地模拟”，而是真正存在于以太坊公共测试网络上。

* * *

## 三、关键概念理解（本阶段最重要）

### ✅ 钱包 / 地址 / 合约 的关系

-   **钱包（Wallet）**：控制私钥的工具（CLI / MetaMask / 硬件）
    
-   **地址（Address）**：钱包在链上的身份
    
-   **合约（Contract）**：由地址发起交易创建，部署后有独立地址
    

📌 合约 ≠ 钱包  
📌 合约“属于”部署者，但不等同于部署者

* * *

### ✅ 为什么前端右上角仍显示 `Hardhat`

这是一个重要的认知点：

-   Hardhat config 决定的是 **合约部署用的网络**
    
-   前端右上角显示的是 **浏览器钱包当前连接的网络**
    
-   二者是**两套系统**
    

➡️ 只有当 MetaMask 切换到 Sepolia，前端才会显示 Sepolia  
➡️ 但即使不切，合约依然已经正确部署在 Sepolia

* * *

## 四、遇到的问题与解决方式

### 问题 1：`yarn deploy` 报错 TS 编译失败

原因：

-   在 `hardhat.config.ts` 中误加了 `arbitrum / optimism` 网络配置
    
-   类型定义与当前 Hardhat 模板不匹配
    

解决：

-   回退配置
    
-   只保留 `sepolia` 网络
    
-   成功重新部署
    

* * *

### 问题 2：不知道如何用命令行打开配置文件

解决方式：

```
code packages/hardhat/hardhat.config.ts
```

并理解：

-   `code` 是 VS Code 的 CLI 命令
    
-   必须在已安装并启用 VS Code 的前提下使用
    

* * *

## 五、阶段性总结

通过本次 Checkpoint 3，我已经：

-   ✅ 掌握了 **本地 → 公共测试网** 的完整部署流程
    
-   ✅ 理解了 **开发者钱包 ≠ 浏览器钱包**
    
-   ✅ 成功将 NFT 合约部署到 **Ethereum Sepolia**
    
-   ✅ 能独立排查 faucet、网络、Hardhat 配置问题
    

为后续步骤（合约验证、前端接入、NFT 交互）打下了完整基础。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->



# 今日学习笔记：以太坊 Fusaka 升级（🦓）梳理

**学习主题**：Fusaka 网络升级内容与影响  
**核心结论**：Fusaka 的主线是 **L2 数据扩容（blobs）** + **L1 抗 DoS/为提升 gas limit 铺路** + **用户体验与开发体验补齐**。升级不会直接降低 L1 gas，但会显著增强 rollup 扩容能力与长期可持续性。

* * *

## 1\. Fusaka 是什么

-   Fusaka 主网上线时间：**2025/12/03**。
    
-   升级覆盖以太坊两层：
    
    -   执行层（EL）：**Osaka**
        
    -   共识层（CL）：**Fulu**
        
-   定位：Pectra 之后的下一次关键升级，是以太坊长期路线图中的一环。
    

* * *

## 2\. Scale blobs（面向 L2 扩容的关键改动）

### 2.1 PeerDAS（核心头牌）

-   背景：L2 将数据发布到以太坊的 **blobs**。升级前每个全节点都需要存储全部 blob 数据，随着 blob 吞吐上升会导致节点资源不可持续。
    
-   机制：引入 **数据可用性采样（DAS）**，节点只负责 blob 的一部分数据。
    
    -   全节点典型只需持有约 **1/8** blob 数据
        
    -   理论上可带来约 **8×** 的 blob 扩展空间
        
-   影响：降低节点硬件/带宽压力，同时释放 blob 容量 → rollup 数据成本更低、吞吐更高。
    

### 2.2 Blob-Parameter-Only forks（BPO）

-   痛点：以前提高 blob 数量需要等待“大硬分叉”，协调成本高、节奏慢。
    
-   方案：引入“只调 blob 目标/上限”的小型升级机制，使 blob 参数可以在大升级之间更快调整，逐步、安全地提升 blob 供给。
    

### 2.3 Blob base-fee 与执行成本绑定

-   痛点：L2 发布数据除了 blob fee，还会消耗执行层验证的 gas；当执行成本主导时，blob fee 可能跌到 **1 wei** 丧失价格信号。
    
-   方案：为 blob base fee 设定与执行成本相关的“保底”，保证：
    
    -   blob 市场能对拥堵做出反应
        
    -   L2 至少支付其迫使节点承担的计算成本的一部分
        
    -   避免 blob 费率长期失真
        

* * *

## 3\. Scale L1（为提高 L1 gas limit 做安全与稳定铺垫）

### 3.1 History expiry（历史裁剪要求）

-   客户端需要支持部分历史过期/裁剪以降低长期磁盘压力，方便随着链增长保持节点运行成本可控。
    

### 3.2 MODEXP 上限与计价调整

-   过去：MODEXP 预编译可接受极大输入，难测、易滥用、存在稳定性风险。
    
-   改动：
    
    -   **输入规模设硬上限**（超出拒绝执行）
        
    -   **提高 MODEXP gas 成本**使其更贴近真实计算成本
        
-   目标：减少 DoS 面、避免单笔交易拖慢整块验证。
    

### 3.3 单笔交易 Gas 上限（16,777,216 = 2^24）

-   给单笔交易设置明确上限，属于“主动 DoS 硬化”，便于未来提高区块 gas limit 时控制最坏情况。
    

### 3.4 执行层区块体积上限（RLP block size limit）

-   设置执行层区块在网络传播层面的体积上限（约 **10 MiB**，并预留安全边际），避免传播/验证时间过长导致共识异常或 DoS 风险。
    

### 3.5 默认 gas limit 提升目标（~60M）

-   推动客户端与测试网对更高默认 gas limit 进行压测与收敛，强调与“单笔交易 gas 上限”配套，从工程上为 L1 进一步扩容铺路。
    

* * *

## 4\. Improve UX（用户与开发体验改进）

### 4.1 确定性 proposer lookahead

-   信标链可提前获知下个 epoch 的提议者信息，为 **预确认（preconfirmations）**等更快交易体验提供基础，并减少调度操纵的边缘风险。
    

### 4.2 新增 CLZ（Count Leading Zeros）opcode

-   增加常用位运算指令，减少手写 bit-scan 逻辑，降低字节码复杂度并节省 gas，提升合约层开发体验。
    

### 4.3 原生 secp256r1（P-256）验签预编译

-   直接支持 passkey/WebAuthn 风格签名验证，使钱包可利用设备安全模块（如手机安全芯片）实现更顺滑的登录与恢复体验，利好账户抽象与大规模用户 onboarding。
    

* * *

## 5\. Meta：eth\_config JSON-RPC

-   新增 RPC 用于查询节点的 fork 配置状态（当前/下次/上次），方便验证者、监控工具与测试团队在升级前后进行一致性检查，降低因配置偏差导致网络异常的风险。
    

* * *

## 6\. 我的总结与启发

1.  **扩容主战场在 blobs**：PeerDAS 把“每个节点存全量”改成“抽样+分片”，让 rollup 扩容变得可持续。
    
2.  **L1 扩容必须先钉死最坏情况**：单 tx gas cap、区块体积 cap、MODEXP 硬化都是为未来提高 gas limit 的工程前置条件。
    
3.  **UX 进化是下一轮 adoption 的关键**：P-256 预编译把 passkey 生态带入 L1，是“更像 Web2 应用”的关键拼图。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->




今天Web3运营学习经验总结（2026年1月13日）

作为Web3 builder，我的运营重点围绕AI+Web3项目（如AI狼人杀竞技场带NFT角色），今天的学习主要从社交平台增长、社区构建和变现路径入手。基于我们讨论的策略和AI产品建议，以下是关键经验提炼，强调实战性和低成本执行。核心逻辑：Web3运营不是烧钱，而是通过价值互动构建忠实社区，转化成可持续收入。1. 粉丝增长起步：从小基数（40粉丝）到1k的实战框架

-   第一周重点是高强度互动而非盲目发帖。优化Profile突出项目（如Bio加“Building AI Werewolf Arena with NFT Roles”），每天发1-2帖分享进度/价值（如项目更新或AI tips）。
    

回复大V策略：选AI/Web3领袖如@VitalikButerin、@AndrewYNg

，提供深度见解（e.g., 链接你的NFT项目补充他们的区块链/AI帖），目标吸他们的观众。

-   构建连接：DM同niche小号聊帖（e.g., “爱你的AI NFT想法，跟我的狼人杀项目类似，分享经验？”）；参与Spaces讨论Web3热点；跑抽奖帖（如“评论AI Web3想法，抽NFT角色”）增互动。
    
-   监控调整：用X Analytics追踪印象高帖，复制模式。经验：复合增长靠一致（周增50-100起步），Premium账号已解锁工具，无需升级。
    

2\. 跨平台扩展：LinkedIn作为B2B补充

-   LinkedIn适合Web3专业连接，优化Profile/Headline强调NFT/AI专长。每天1-2帖混价值分享和项目demo，互动评论大V帖建DM关系。
    
-   经验：Web3运营需多平台联动（X引流到LinkedIn），焦点thought leadership而非病毒。垂直niche（如Web3游戏）能快速到1k粉丝。
    

3\. AI产品运营启发：从验证到变现的Web3应用

-   卖空气（Smoke Test）：建假落地页测试NFT角色需求，别先写代码。适用于你的项目—先测用户是否点“Buy NFT Role”。
    
-   找吐槽用户：在Reddit/X挖掘Web3痛点（如NFT工具难用），用AI工具（如n8n雷达）自动化商机监控，转成运营机会。
    
-   转向Agentic Workflow：Web3产品别做聊天套壳，卖“结果”（e.g., AI自动生成NFT游戏角色），建护城河。
    
-   高价定价&垂直切入：按价值收（如省企业成本的10%），专注不性感行业（如游戏物流）。经验：看行动非口头，问用户过去为Web3问题付多少钱。
    
-   本地化隐私&ROI量化：B2B Web3卖安全感（本地AI跑NFT数据），产品介绍用数字（e.g., “快3倍生成NFT”）。
    
-   渠道验证优先：确保CAC < LTV，别假设好项目自带流量。先找Web3社区（如Discord）低成本获客。
    

整体经验反思

-   最大坑避免：Web3运营别伪创新，先验证需求/渠道。AI化一切（如用Claude分析评论加速调研），专注Outcome而非技术。
    
-   变现路径：到1k粉丝后，用X Subscriptions/Affiliate推NFT；1万后，品牌deal或付费社区。你的AI狼人杀是钩子—分享进度建忠诚。
    
-   行动建议：今天发第一帖总结这些（如我生成的推文模板），鼓励评论互动。坚持1-2小时/天，一周见效。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->





## 今日 Web3 防钓鱼总结日志（D-Log）

**日期**：2026.1.12  
**链/环境**：Ethereum Sepolia（演示）→ 迁移到主网时风险极高  
**主题**：Permit / Approvals / Punycode 同形域名钓鱼

* * *

### 1) 今日学到的三个核心结论

**① 签名不是“无害确认”，它可能是“离线授权”。**  
Permit（EIP-2612）允许用签名直接授权 `spender`，攻击者拿到签名后可在链上 `permit → transferFrom`，用户不需要再发起交易或二次确认。

**② Approve 弹窗里最危险的不是 Gas，而是“Spend Limit”。**  
看到超大额度（常见为 `115792089…`，即 `2^256-1`）= “无限授权”。这不是质押，不是存入，而是把 USDC 的支出权交给对方合约。

**③ 域名长得像 ≠ 真域名。**  
Punycode / 同形字符可以做“视觉欺骗”，例如把某个字母替换成长得一样的 Unicode 字符，最终域名底层会变成 `xn--...`。肉眼看不出，但 DNS 完全不同。

* * *

### 2) 今日见到的典型钓鱼剧本（复盘）

**剧本 A：空投诱导 + Permit 签名**

-   页面看似“领取 UNI / 资格验证”
    
-   实际请求签名 Permit：`spender` 是攻击者，`value` 常为 MAX，`deadline` 设很久
    
-   结果：攻击者可在有效期内随时花光你钱包里的 USDC
    

**剧本 B：高收益质押诱导 + Approve 无限授权**

-   “USDC 质押池，日收益 50%”这类文案
    
-   钱包弹窗提示：approve spend limit
    
-   Spend limit 出现超大数（MAX）
    
-   结果：一旦主网同套路，授权后资金可被直接转走
    

**剧本 C：Punycode 假官网 + 复制 UI**

-   假域名视觉上与真官网几乎一致
    
-   用户误以为在官方页面操作
    
-   下一步永远是：Sign / Permit / Approve
    

* * *

### 3) 今日形成的“3 秒拒绝规则”（随手可用）

只要出现 **Sign / Approve / Permit**，立刻扫这 4 项：

-   **额度**：是不是 MAX / 超大数？（是 → 拒绝）
    
-   **对象**：spender/contract 地址你是否明确认识？（不认识 → 拒绝）
    
-   **动机**：是不是“空投/高收益/补贴/资格验证”？（是 → 拒绝）
    
-   **入口**：是不是邮件/Telegram/广告链接点进去的？（是 → 拒绝）
    

> 任何一条命中：**Reject + 关页面**。

* * *

### 4) 今日行动清单

-   主网钱包与交互钱包分离：交互钱包只放小额
    
-   只用书签/手输官方域名，不点外链
    
-   遇到 `xn--` 域名直接拉黑
    
-   将“授权额度默认改为本次用量”（能改就改）
    
-   每周一次检查授权：清掉不认识的 spender（approve 设 0 或 revoke）
    

* * *

### 5) 一句话心法（写给未来的自己）

> **交易是“我现在给你钱”，Permit/Approve 是“我允许你随时拿走钱”。**  
> **看名字没用，看合约地址才有用。**
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
