---
timezone: UTC+8
---

# YanXiao

**GitHub ID:** yanxiao610

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->
请个假
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->

1\. **EVM 四大执行区**

\- Stack：指令与计算用栈

\- Storage：链上永久数据，最耗 gas

\- Memory：函数执行期间的临时内存

\- Calldata：函数参数区，只读

\- 核心优化思想：\*\*尽量减少 Storage 访问\*\*

2\. **Gas 成本与优化原则**

\- 写入 storage ≈ 20,000 gas

\- 修改 storage ≈ 5,000 gas

\- 原则：少存、少改、避免无意义的链上读写

3\. **Solidity 数据类型**

\- 值类型（uint / bool / address）：更省 gas

\- 引用类型（string / array / mapping）：更费 gas

\- 链上账本设计的核心结构是 **mapping**

4\. **ERC20 基本结构**

\- 两本账：余额账本 + 授权账本

\- transfer：校验 → 更新余额 → 触发事件

\- approve：修改授权账本 + Approval 事件

5\. **函数与可见性**

\- external / public / internal / private

\- view：只读链上数据

\- pure：不读也不改链上状态

6\. **modifier 修饰符**

\- 抽象前置条件（权限、参数校验）

\- 作用：代码复用、统一权限、Gas 优化

\- 常见：onlyOwner、nonReentrant

7\. **安全要点**

\- EVM 无并发，但存在重入风险

\- 防护：检查-生效-交互 + 重入锁

\- Mint 通常设为 internal，防止随意铸币

8\. **开发与调试**

\- Remix 可编译、部署、调试合约

\- 读操作不消耗 gas，写操作必须发交易

\- 错误处理优先级：custom error > revert > require
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->


今天没学多少东西，主要就是试着在remix中写了些东西

这个是进行转账操作

```
function withdraw(uint256 amount) public {
    // 重入锁第一步：检查当前函数是否正在被执行
    // 如果 locked == true，说明已经有人在执行 withdraw，直接拒绝
    require(!locked);

    //  上锁：从现在开始，任何再次进入 withdraw 的尝试都会失败
    locked = true;

    //  校验余额是否足够
    // 防止用户取超过自己余额的钱
    require(balances[msg.sender] >= amount);

    //  先扣余额（Effects）
    // 这是安全的核心：先更新链上状态，保证余额不会被重复使用
    balances[msg.sender] -= amount;

    //  外部调用：把 ETH 转给调用者
    // 使用 call 而不是 transfer，更通用，但也更危险
    // 所以必须放在“扣余额”之后
    (bool ok, ) = payable(msg.sender).call{value: amount}("");

    //  检查转账是否成功
    // 如果失败，整个交易回滚，上面的扣余额也会一起回滚
    require(ok);

    //  解锁：函数执行完毕，允许下一次调用 withdraw
    locked = false;
}
```

这个是看教程中的例题

```
contract SimpleStorage {
    // 这个变量用来存一个数字
    uint256 public myNumber;

    // 写入函数：把数字存进去 (要花 Gas)
    function store(uint256 _num) public {
        myNumber = _num + 1;//数字加1
    }

    // 读取函数：把数字读出来 (免费)
    function retrieve() public view returns (uint256) {
        return myNumber;
    }
}
```

因为我有编写代码的经历。所以相对来讲还是比较容易接受这个编译器和语法的
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->



# **Solidity 转账与重入安全**

## **一、重入**

-   当合约向 **合约地址** 转账 ETH 时
    
-   对方合约在接收 ETH 的过程中
    
-   **可能再次调用你正在执行的函数**
    

本质： **外部调用打断了当前函数的执行流程**

* * *

## **二、要先扣余额**

### **危险顺序（先转钱，后改状态）**

```
payable(msg.sender).transfer(amount);
balances[msg.sender] -= amount;
```

问题：

-   状态还没更新
    
-   同一份余额可能被多次使用
    
-   合约可能多转钱
    

* * *

### **安全顺序（先改状态，再转钱）**

```
balances[msg.sender] -= amount;
payable(msg.sender).transfer(amount);
```

结论：

-   不能阻止再次调用
    
-   保证 **每次调用都会真实扣余额**
    
-   防止“同一余额被重复使用”
    

**先扣余额不是防重入，而是保证状态正确**

* * *

## **三、重入锁**

```
bool locked;
​
require(!locked);
locked = true;
​
// 函数逻辑
​
locked = false;
```

作用：

-   防止 **同一次执行过程中** 再次进入函数
    
-   属于 **执行期保护**
    

* * *

## **四、先扣余额 和 重入锁**

| 手段 | 解决的问题 |
| --- | --- |
| 先扣余额 | 状态是否正确（余额不会被重复使用） |
| 重入锁 | 函数是否被重复进入（同一执行过程） |

结论：

> **解决的是不同层次的问题，通常必须一起使用**

* * *

## **五、transfer 和 call**

### **1\. transfer**

```
payable(to).transfer(amount);
```

特点：

-   给对方的 gas 很少
    
-   兼容性差（对方逻辑复杂时可能失败）
    
-   失败会直接 revert
    

* * *

### **2\. call**

```
(bool ok, ) = payable(to).call{value: amount}("");
require(ok);
```

特点：

-   gas 更多，兼容性更好
    
-   更容易触发重入 → **必须配合防护**
    

* * *
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






## 1 Solidity 是干嘛的

Solidity 不是普通程序语言， 它是用来 **写链上规则的**。

合约一旦部署：

-   代码基本不变
    
-   所有节点按同样规则执行
    
-   改数据 = 上链 = 要钱（gas）
    

* * *

## **2 合约长什么样**

```
contract A {
    uint256 public x;
​
    function set(uint256 y) public {
        x = y;
    }
}
```

我现在能看懂：

-   `contract`：一个链上的“东西”
    
-   写在里面的变量（`x`）是 **链上数据**
    
-   函数是别人调用合约的入口
    

* * *

## **3 改链上数据**

**只有一种情况：**

```
合约里的变量 = 新的值;
```

比如：

```
x = y;
```

函数里算的东西、临时变量，都不算改链。

* * *

## **4 mapping 是什么**

```
mapping(address => uint256) balances;
```

可以理解成一句话：

> 一张账本： 每个地址（address）对应一个数字（uint256）

名字叫 `balances` 只是为了好读， 叫别的也一样。

* * *

## **5 msg.sender 是谁**

`msg.sender` 表示：

> **真正发起这次调用的人**

不是参数传进来的， 是系统自动给的，**不能伪造**。

* * *

## **6 谁的钱记在谁名下**

```
balances[msg.sender]
```

意思是：

> 用“调用者的地址”当账本的 key

所以：

-   用 `msg.sender` → 只能改自己的
    
-   用参数里的 address → 可能改别人（危险）
    

* * *

## **7 最基础的权限控制**

```
require(msg.sender == owner);
```

一句话理解：

> **只有合约主人才能继续执行**

参数传什么都没用， 绕不过 `msg.sender`。

* * *
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->








今天有点事，请假一天
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->










# **以太坊状态树**

## **1\. 状态树是什么**

**状态树（State Trie）** 是以太坊用来保存「整个世界当前状态」的数据结构。

-   key：账户地址（address）
    
-   value：账户状态
    
    -   balance（余额）
        
    -   nonce（交易次数）
        
    -   storageRoot（合约存储根）
        
    -   codeHash（合约代码哈希）
        

本质：**一个全局状态字典（Map）**

* * *

## **2\. 为什么需要状态树**

如果每个区块都存所有账户状态：

-   大多数账户没有变化
    
-   会重复存储大量相同数据
    
-   空间开销巨大
    

状态树的做法：

-   只更新发生变化的账户路径
    
-   未变化的节点直接复用
    
-   每个区块只新增“变化部分”
    

* * *

## **3\. 什么是 stateRoot**

**stateRoot** 是状态树的根哈希，表示「当前整个世界状态的加密承诺」。

-   存在于区块头中
    
-   区块不直接存账户数据
    
-   只存一个哈希值
    

规则：

-   状态变 → stateRoot 必然变化
    
-   状态不变 → stateRoot 必然相同
    

* * *

## **4\. Merkle Tree 的作用**

Merkle Tree 的核心作用只有一件事：

> **将大量数据压缩为一个可验证的哈希摘要（root）**

特性：

-   任意一个节点变化，root 都会变化（防篡改）
    
-   给出一条数据 + 哈希路径即可验证其真实性（Merkle Proof）
    

* * *

## **5\. 为什么普通 Merkle Tree 不够**

普通 Merkle Tree：

-   适合「按顺序的数据集合」
    
-   擅长证明“整体没被改”
    
-   不擅长按 key（地址）查找数据，**就无法快速查找到数据，此时我们就希望能引入一个新数据结构来快速查找**
    

但以太坊的状态是：

地址 → 状态

这是一个 **字典 / Map 查询问题**。

* * *

## **6\. Trie（字典树）解决了什么**

Trie 的特点：

-   专门为「按 key 查 value」设计
    
-   可以通过地址逐层查找到账户状态
    
-   本身不具备防篡改能力
    

* * *

## **7\. Merkle Patricia Trie 是什么**

**Merkle Patricia Trie（MPT） = Trie + Merkle Tree**

它同时满足以太坊的三个核心需求：

NaN. 按地址快速查状态（Trie）

NaN. 用一个 root 哈希承诺整体状态（Merkle）

NaN. 更新时只修改少量节点（增量更新）

NaN. **将这两个数据结构结合起来就能实现一个良好的数据结构**

* * *

今天去看了下肖臻老师的关于eth的数据结构的课程，发现视频中有一些东西听不懂，然后直接去问ai了，ai的教学模式还是比较好用的，去提问了一段时间，终于算是差不多理解了
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->












## **一、为什么 Web3 必须谈「合规」**

### **1 合规的真实含义**

-   合规 ≠ 合法创新
    
-   合规的前提是：**有规可合**
    
-   Web3 是新兴行业，而法律具有 **滞后性**
    

### **2 中国大陆 vs 海外**

-   大陆：强中心化、风险前置
    
-   海外：法无禁止即可为
    

* * *

## **二、大陆 Web3 的三条高压红线**

### **1\. ICO / 发币 + 公开融资**

-   发币本身不一定违法,律师在分享中讲到 如果只是觉得有趣现在发meme币，没有公开集资的话，是不涉及违法的
    
-   风险点在于：
    
    -   向不特定对象募资
        
    -   变相融资
        
-   常见定性：
    
    -   非法吸收公众存款
        
    -   集资诈骗
        

* * *

### **2\. Meme 币 / Rug Pull**

-   社区喊单、拉盘、撤流动性
    
-   极易被定性为：
    
    -   **诈骗罪**
        
-   司法关注点：
    
    -   是否存在信息不对称
        
    -   是否诱导公众参与
        

* * *

### **3\. 交易所 & 永续合约**

-   实务中常被认定为：
    
    -   赌博
        
    -   开设赌场
        
-   技术人员风险：
    
    -   “技术中立”通常不被采信(即开发人员也会违法)
        

* * *

## **三、为什么合规仍然值得做？**

-   合规 ≠ 绝对安全
    
-   合规 = **谈判筹码**
    
-   现实效果：
    
    -   钱可能被冻结
        
    -   **但是关键人可以出来**
        

* * *

## **四、挖矿业务的合规变形路径**

### **核心思路**

-   不谈挖矿
    
-   谈「算力服务」
    

### **可行模式**

-   AI 超算中心
    
-   政府合作
    
-   算力作为服务出口（外贸）
    

* * *

## **五、去中心化理念的现实落地**

-   Web3 强调去中心化
    
-   大陆法律强调责任主体
    
-   结论：
    
    尽量不要接触大陆的去中心化项目
    

* * *

## **六、个人层面：出金 / 入金风险**

### **当前最大风险来源**

-   出金被冻结
    
-   税务补缴通知
    

* * *

### **新型风险：路径攻击**

-   表现形式：
    
    -   莫名收到大额资金
        
-   实质：
    
    -   洗钱路径转嫁
        
-   建议：
    
    -   不动资金
        
    -   留存证据
        
    -   必要时主动报备
        

* * *

## **七、U 商 / U 卡风险总结**

### **大陆是否还能做 U 商？**

-   结论：基本不可持续
    
-   常见罪名：
    
    -   非法经营
        
    -   非法买卖外汇
        

* * *

### **使用 U 卡的两类高危模式**

**1挂靠公司员工模式**

-   发卡方虚构雇佣关系
    
-   风险：
    
    -   卡被冻结
        
    -   资金取回困难
        

**2 私人多签钱包模式**

-   发卡方掌控钱包
    
-   风险：
    
    -   内讧
        
    -   冻结
        
    -   卷款跑路
        

* * *

## **八、项目方刑事风险速览**

| 行为 | 可能罪名 |
| --- | --- |
| 融资 | 非法吸收公众存款 / 集资诈骗 |
| 法币对敲 | 非法经营 |
| 拉人头 / 积分 | 传销 |
| 推广合约交易所 | 帮助信息网络犯罪 |

> 大陆司法特点： **不看模型设计，看最终效果**

* * *

## **九、衍生风险：KOL / 资讯平台 / 推广者**

-   接受交易所推广
    
-   收佣金、引流
    
-   在交易所被定性为违法时：
    
    -   推广方可能被认定为共犯
        

* * *

今天主要就是看了下昨天晚上的分享会的回放，接触这个行业的第一课应该就是要有安全意识和合规意识，在大陆不能什么项目都敢去做，要注意是否合规，不对劲直接跑路。也看了下之前的知识，然后看网上推荐说北大臻老师《区块链技术与应用》讲的很好，我也准备去看了，争取这周结束看完ETH部分，这周还是主要补下eth相关基础知识吧，下周开始正式学习solidity
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->














# **Web3 安全与合规**

* * *

由于web3行业的特殊性，技术可能不违法，但是相关操作很容易触犯法律，因此刚接触这个行业就要有风险意识，了解其中安全与合法问题。

* * *

## **1.国内 Web3 的监管**

-   禁止 ICO / IEO / IDO 等公开融资
    
-   虚拟货币不是法定货币
    
-   禁止虚拟货币作为支付工具
    
-   境外交易平台不得向中国用户提供服务
    

* * *

## **2.Web3 常见法律风险分类**

* * *

### **1\. 代币发行与交易风险**

-   任何 **具有融资性质的 Token** 都可能违法
    

-   即使只是写代码的实习生也不可以免责
    

* * *

### **2\. 赌博、传销类经济模型风险**

**常见高危模式：**

| 模式 | 风险 |
| --- | --- |
| 充值 → 抽奖 → 提现 | 开设赌场罪 |
| 多级推广返利 | 组织、领导传销活动罪 |
| 拉人头 + 层级奖励 | 刑事风险极高 |

* * *

### **3\. 场外交易（OTC）与洗钱风险**

**可能涉及：**

-   规避外汇管制
    
-   非法跨境资金流转
    
-   代收代付 USDT
    

**法律风险：**

-   非法经营罪
    
-   洗钱罪
    
-   掩饰、隐瞒犯罪所得罪
    

**即使“不知情”也可能被追责**

* * *

### **4\. 民事与合同风险**

**常见问题：**

-   虚拟货币买卖合同 → **可能被认定无效**(国内不承认虚拟货币,虚拟货币不能作为货币在市场上流通)
    
-   委托投资、代操作 → 易引发纠纷
    
-   项目跑路 → 维权困难
    

* * *

## **5.全球 Web3 合规趋势**

虽然国内监管严格，但全球并非完全禁止：

大部分地区都有相关政策监管着这个行业，不像大陆地区的严格管控

* * *

## **6.Web3 合规实践**

### **在参与任何项目之前，请确定：**

-   项目是否有合法注册主体
    

-   经济模型是否类似资金盘
    

-   是否要求拉人头、刷流水
    

-   是否涉及 OTC / 代收代付
    

> 只碰「技术 / 开源 / 非金融属性」,在接触项目之前一定要确保这个项目不会违反到法律，否则一切都是空谈

* * *

今天有事，看的东西不是特别多，只看了合法相关内容，明天继续补下今天的**web3合规和安全**两个分享会，继续补下基础内容，争取后天开始学习solidity
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->















## **1\. Solidity与EVM**

-   Solidity：**只是一种语言，不运行**
    
-   真正运行的是：**EVM 字节码**
    
-   **每个以太坊节点**里都有一个 EVM
    

所有节点执行同一字节码，结果必须一致（共识）

* * *

## **2.L1 EVM vs L2 EVM区别**

| 对比点 | L1 EVM | L2 EVM |
| --- | --- | --- |
| 是否参与共识 | 不是 | 是 |
| 执行结果 | 直接生效 | 候选结果 |
| 谁裁决 | 全网共识 | L1 |

也就是说会在L2执行，L1裁决

* * *

## **3\. 什么是 L2（Layer 2）？**

**定义**： L2 是构建在以太坊之上的扩容层，用来高效执行交易，并把结果提交给 L1。

**模式**：

-   L2：执行交易、算状态
    
-   L1：不重算，只验证结果是否合法
    

* * *

## **4\. 什么是 Blob？**

**Blob 是给 Rollup 用的、EVM 看不到的临时数据区。**

-   不进入 EVM state
    
-   Solidity 合约 **不能读取**
    
-   大体积、低成本、会过期
    
-   作用：**数据可用性（DA）**
    

总的来说Blob会过期，不同于像BTC那种一直保存在链上

* * *

## **5\. 为什么 Blob 不能进 EVM？**

那也就是说Blob 可被合约读取,会导致：

-   合约逻辑依赖 Blob
    
-   节点必须永久保存 Blob
    
-   Blob 变成廉价 storage
    
-   节点负担爆炸
    

**所以 Blob 被刻意隔离在 EVM 之外**

* * *

## **6\. 不保存计算过程，安全吗？**

**关键认知**：

-   安全 并不需要 永久保存全过程
    
-   安全 = **在可挑战窗口内无法造假成功**
    

**时间窗口模型**：

-   窗口内：
    
    -   Blob 可用
        
    -   任何人可重算、可挑战
        
-   窗口后：
    
    -   状态已确认
        
    -   过程不再重要
        

* * *

## **7\. 不保存计算过程是否安全**

这里抛出一个问题：就是如果在窗口期中没有人对你的造假进行验证，那么是否会导致这次造假完成

**理论上：会**

**但是不能只从理论上来研究，就像BTC必须要控制51%的节点才能实现伪造，这里的Blob也是有着差不多的设计哲学，理论存在，实际很难存在** **设计假设：至少 1 个诚实验证者**

为什么现实中几乎不会没人验证？

-   验证成本低
    
-   挑战成功有奖励
    

也就是说**验证几乎没有成本，成功能获得作恶者的保证金(同PoS类似)**

* * *

## **8\. 为什么删掉过程就无法溯源？**

**数学必然**：

-   结果 → 过程 (不可能只有一个过程)
    
-   不存中间步骤
    
-   无法唯一还原历史
    

**但是 不可溯源 不等于 不安全**

* * *

## **9\. 分片（Sharding）**

**思想**： 让不同节点只负责一部分数据，降低单节点负担。

**问题**（传统分片）：

-   执行复杂
    
-   跨分片通信难
    
-   合约模型崩溃
    

故以太坊放弃“执行分片”

* * *

## **10\. Danksharding**

作用：

-   并行接收大量 Rollup 数据
    
-   节点不需保存全部数据
    
-   共识和裁决仍统一
    

* * *

**今天还是看了相关概念,明天看下 安全和合规相关内容**
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
















## 区块链

**区块链是一种是一种去中心化的分布式账本技术**

**有以下特点:**

-   不可篡改
    
-   公开匿名
    
-   快速交易
    

其中很关键的一点就是如何确保"不可篡改"真的成立呢

对其进行解释

-   区块链网络中存在非常多的节点，并且这些节点都存储着相同的信息
    
-   如果要进行修改，必须修改其中至少51%中的节点内容，否则的话，改动的内容无法得到认可
    
-   故而也不是真的就直接在理论上没有人能改
    
-   但是这样操作的成本极高，几乎不可能有人能同时操作这么多的节点
    

* * *

## BTC和ETH

### 1.BTC想解决的问题

-   不用银行
    
-   不可随意增发
    
-   不可被篡改
    
-   不可被单一机构冻结
    

### 2.ETH想解决的问题

让代码可以在链上自动，不可篡改的进行下去

### 3.二者对比

| 对比 | BTC | ETH |
| --- | --- | --- |
| 核心定位 | 去中心化数字货币 / 价值存储 | 去中心化应用平台 / 全球计算机 |
| 设计目标 | 安全、稳定、抗审查 | 可编程、灵活、支持复杂应用 |
| 共识机制 | PoW（工作量证明） | PoS（权益证明） |
| 智能合约 | 不支持图灵完备 | 支持图灵完备 |
| 总量机制 | 总量固定 2100 万 | 无固定上限，但是可能通缩 |
| 手续费含义 | 交易矿工费 | Gas |

**对ETH的gas进行说明:**

因为链上可以用代码进行操作,这时不妨设想一个简单的场景：当有人的代码中有一个死循环，链上所有节点都会运行这段代码，如果没有限制的话，那么这段代码会一直进行下去，整个网络都会瘫痪。我们并不想要这样的结局，故而引入gas，每条指令都要使用掉一点gas，当gas用完就会强制中止，保证了安全。

**对PoW和PoS进行说明:**

一开始BTC和ETH都是使用的PoW，也就是工作量证明，当有人解决难题时就会给代币进行奖励，但是之后ETH转向了另一种方式PoS,简单来说就是 : 谁把币“押”在链上、并愿意为作恶承担被罚没的风险，谁就有资格参与记账。二者实现了不同的安全

-   PoW通过对物理世界中算力的局限，保证了安全
    
-   PoS则是通过“作恶者惩罚”这一机制，使得作恶者会被没收自己的代币，使得不敢去作恶
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
