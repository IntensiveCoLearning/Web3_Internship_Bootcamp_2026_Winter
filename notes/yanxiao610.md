---
timezone: UTC+8
---

# YanXiao

**GitHub ID:** yanxiao610

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
## **1\. Solidity与EVM**

-   Solidity：**只是一种语言，不运行**
    
-   真正运行的是：**EVM 字节码**
    
-   **每个以太坊节点**里都有一个 EVM
    

所有节点执行同一字节码，结果必须一致（共识）

* * *

## **2.L1 EVM vs L2 EVM区别**

| 对比点 | L1 EVM | L2 EVM |
| --- | --- | --- |
| 是否参与共识 | 不是 | 是 |
| 执行结果 | 直接生效 | 候选结果 |
| 谁裁决 | 全网共识 | L1 |

也就是说会在L2执行，L1裁决

* * *

## **3\. 什么是 L2（Layer 2）？**

**定义**： L2 是构建在以太坊之上的扩容层，用来高效执行交易，并把结果提交给 L1。

**模式**：

-   L2：执行交易、算状态
    
-   L1：不重算，只验证结果是否合法
    

* * *

## **4\. 什么是 Blob？**

**Blob 是给 Rollup 用的、EVM 看不到的临时数据区。**

-   不进入 EVM state
    
-   Solidity 合约 **不能读取**
    
-   大体积、低成本、会过期
    
-   作用：**数据可用性（DA）**
    

总的来说Blob会过期，不同于像BTC那种一直保存在链上

* * *

## **5\. 为什么 Blob 不能进 EVM？**

那也就是说Blob 可被合约读取,会导致：

-   合约逻辑依赖 Blob
    
-   节点必须永久保存 Blob
    
-   Blob 变成廉价 storage
    
-   节点负担爆炸
    

**所以 Blob 被刻意隔离在 EVM 之外**

* * *

## **6\. 不保存计算过程，安全吗？**

**关键认知**：

-   安全 并不需要 永久保存全过程
    
-   安全 = **在可挑战窗口内无法造假成功**
    

**时间窗口模型**：

-   窗口内：
    
    -   Blob 可用
        
    -   任何人可重算、可挑战
        
-   窗口后：
    
    -   状态已确认
        
    -   过程不再重要
        

* * *

## **7\. 不保存计算过程是否安全**

这里抛出一个问题：就是如果在窗口期中没有人对你的造假进行验证，那么是否会导致这次造假完成

**理论上：会**

**但是不能只从理论上来研究，就像BTC必须要控制51%的节点才能实现伪造，这里的Blob也是有着差不多的设计哲学，理论存在，实际很难存在** **设计假设：至少 1 个诚实验证者**

为什么现实中几乎不会没人验证？

-   验证成本低
    
-   挑战成功有奖励
    

也就是说**验证几乎没有成本，成功能获得作恶者的保证金(同PoS类似)**

* * *

## **8\. 为什么删掉过程就无法溯源？**

**数学必然**：

-   结果 → 过程 (不可能只有一个过程)
    
-   不存中间步骤
    
-   无法唯一还原历史
    

**但是 不可溯源 不等于 不安全**

* * *

## **9\. 分片（Sharding）**

**思想**： 让不同节点只负责一部分数据，降低单节点负担。

**问题**（传统分片）：

-   执行复杂
    
-   跨分片通信难
    
-   合约模型崩溃
    

故以太坊放弃“执行分片”

* * *

## **10\. Danksharding**

作用：

-   并行接收大量 Rollup 数据
    
-   节点不需保存全部数据
    
-   共识和裁决仍统一
    

* * *

**今天还是看了相关概念,明天看下 安全和合规相关内容**
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->

## 区块链

**区块链是一种是一种去中心化的分布式账本技术**

**有以下特点:**

-   不可篡改
    
-   公开匿名
    
-   快速交易
    

其中很关键的一点就是如何确保"不可篡改"真的成立呢

对其进行解释

-   区块链网络中存在非常多的节点，并且这些节点都存储着相同的信息
    
-   如果要进行修改，必须修改其中至少51%中的节点内容，否则的话，改动的内容无法得到认可
    
-   故而也不是真的就直接在理论上没有人能改
    
-   但是这样操作的成本极高，几乎不可能有人能同时操作这么多的节点
    

* * *

## BTC和ETH

### 1.BTC想解决的问题

-   不用银行
    
-   不可随意增发
    
-   不可被篡改
    
-   不可被单一机构冻结
    

### 2.ETH想解决的问题

让代码可以在链上自动，不可篡改的进行下去

### 3.二者对比

| 对比 | BTC | ETH |
| --- | --- | --- |
| 核心定位 | 去中心化数字货币 / 价值存储 | 去中心化应用平台 / 全球计算机 |
| 设计目标 | 安全、稳定、抗审查 | 可编程、灵活、支持复杂应用 |
| 共识机制 | PoW（工作量证明） | PoS（权益证明） |
| 智能合约 | 不支持图灵完备 | 支持图灵完备 |
| 总量机制 | 总量固定 2100 万 | 无固定上限，但是可能通缩 |
| 手续费含义 | 交易矿工费 | Gas |

**对ETH的gas进行说明:**

因为链上可以用代码进行操作,这时不妨设想一个简单的场景：当有人的代码中有一个死循环，链上所有节点都会运行这段代码，如果没有限制的话，那么这段代码会一直进行下去，整个网络都会瘫痪。我们并不想要这样的结局，故而引入gas，每条指令都要使用掉一点gas，当gas用完就会强制中止，保证了安全。

**对PoW和PoS进行说明:**

一开始BTC和ETH都是使用的PoW，也就是工作量证明，当有人解决难题时就会给代币进行奖励，但是之后ETH转向了另一种方式PoS,简单来说就是 : 谁把币“押”在链上、并愿意为作恶承担被罚没的风险，谁就有资格参与记账。二者实现了不同的安全

-   PoW通过对物理世界中算力的局限，保证了安全
    
-   PoS则是通过“作恶者惩罚”这一机制，使得作恶者会被没收自己的代币，使得不敢去作恶
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
