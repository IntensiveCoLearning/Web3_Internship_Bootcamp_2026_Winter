---
timezone: UTC+8
---

# shun12306

**GitHub ID:** shun12306

**Telegram:** @ztensoon

## Self-introduction

Web2-Javaer一枚，对Defi和Agent生态感兴趣。

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
## **一、Video Coding 里：怎么判断 AI 已经「跑偏了」**

一句话判断法：

> **它还在解决你“当前这个问题”吗，还是在解决它“自己脑补的问题”？**

具体有几个**强信号**，你可以当成“红灯”：

### **🚨 1. 接口 / 数据结构开始“自创”**

-   你没改 DTO / interface，它却：
    
    -   新加字段
        
    -   改字段含义
        
    -   用一个“看起来更优雅”的结构替代现有的
        
    
-   特别常见于：
    
    -   Java / Spring
        
    -   前端 state / props
        
    -   合约 struct / mapping
        
    

👉 **这是最危险的跑偏**，因为会污染你已经 accept 的代码。

* * *

### **🚨 2. 开始引入“你没提过的抽象层”**

比如你只是：

> “补一个校验逻辑 / 修个 bug”

它却开始：

-   新建 xxxManager / xxxService / xxxUtil
    
-   抽象一个“通用框架”
    
-   说“为了更 extensible”
    

👉 **Video coding 场景下 80% 是跑偏**

（AI 在优化“世界”，不是优化“任务”）

* * *

### **🚨 3. 代码看起来“很对”，但你解释不清它在干嘛**

这是**高手最该警惕的信号**。

自测问题：

-   ❓ 我能不能 **不用看代码**，用一句话说出它这段在干嘛？
    
-   ❓ 这段逻辑是不是解决了我刚才 verbalize 的那个问题？
    

如果你只能说：

> “嗯……大概是做了点处理”

👉 停，已经偏了。

* * *

### **🚨 4. 修一个 bug，引入 2–3 个新假设**

比如：

-   增加了隐式前置条件
    
-   假设“上游一定如何”
    
-   假设“这个方法不会被并发调用”
    

👉 这是 **LLM 的“合理脑补病”**，尤其在长上下文里。

* * *

## **二、已经 Accept 了一部分代码，发现跑偏了，怎么“止损 + 修复”**

重点：**不要推倒重来**，要“局部止血”。

### **Step 1️⃣：立刻冻结 scope（非常关键）**

你要对 AI 明确说类似：

> **“不要再新增任何类 / 接口 / 字段，只在已存在代码内修复逻辑。”**

这一步的目的不是改代码，是**收紧 AI 的行动空间**。

* * *

### **Step 2️⃣：让 AI「解释它刚写的代码」（反向校准）**

别急着让它改，先来一句：

> “逐行解释你刚才新增的这段代码，每一行的业务意图。”

你会发现两种情况：

1.  **它解释得通顺** → 多半还能救
    
2.  **开始含糊其辞 / 泛泛而谈** → 说明它自己也不清楚
    

👉 第 2 种直接进入 Step 3

* * *

### **Step 3️⃣：用“意图重写”而不是“代码重写”**

你不要说：

> “这段不对，重写”

而是说：

> “我们当前只需要实现 **X 行为**，请在不改变现有结构的前提下，把逻辑改成只做这件事。”

这是一个**高效纠偏句式**：

```
目标行为 + 结构不变 + 最小修改
```

* * *

### **Step 4️⃣：必要时，人工回滚一小块**

现实建议（真经验）：

-   删除 **最后 1–2 次 accept 的代码**
    
-   回到“最后一个你完全理解的状态”
    
-   再让 AI 继续
    

👉 比让 AI 在错误地基上“修修补补”快得多。

* * *

## **三、Context 快满了怎么办？「总结阶段文档」是不是正解？**

结论先给你：

**是正解，但要“工程化地总结”，不是聊天式总结。**

### **❌ 错误总结方式**

> “我们刚才实现了登录逻辑，然后加了校验，修了一些 bug…”

这种总结对 AI **几乎没用**。

* * *

### **✅ 正确的「阶段文档」长这样**

你可以让 AI 帮你生成，但你要**控制结构**：

**🧱 1. 系统当前状态（事实）**

-   已有类 / 模块
    
-   核心数据结构（字段 + 含义）
    
-   不允许改的接口（⚠️）
    

**🎯 2. 已确认的设计决策**

-   为什么这么设计
    
-   明确 **哪些方案被否定过**
    

**🚧 3. 当前未完成的问题**

-   明确剩余 TODO
    
-   哪些地方**不要碰**
    

**🧭 4. 编码约束（给 AI 看的）**

-   不新增抽象
    
-   不改 public 接口
    
-   优先最小 diff
    

👉 这个文档的作用是：

**当 context 重置时，它就是你的“新系统提示词”**

* * *

### **实操建议（你这种 Video coding 场景）**

**每 30–60 分钟一个 checkpoint：**

1.  让 AI 生成「阶段总结文档」
    
2.  你快速扫一遍（30 秒）
    
3.  新开对话 / 清空 context
    
4.  把这个文档贴进去，再继续
    

这是**把 LLM 当“可恢复进程”在用**，非常工程化。

* * *

## **四、一句“老兵建议”（很重要）**

> **不要把 AI 当“结对程序员”，要当“受限但超快的实习生”。**

-   它适合：
    
    -   写模板
        
    -   填逻辑
        
    -   枚举 case
        
    
-   不适合：
    
    -   默默主导架构
        
    -   自动扩展 scope
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

# **How Uniswap works**

![](https://docs.uniswap.org/assets/images/anatomy-d22fb7ab46013a1195f086ee672468c7.jpg)

**Uniswap is an _automated liquidity protocol_ powered by a** [**constant product formula**](https://docs.uniswap.org/contracts/v2/concepts/protocol-overview/glossary#constant-product-formula) **and implemented in a system of non-upgradeable smart contracts on the** [**Ethereum**](https://ethereum.org/) **blockchain. It obviates the need for trusted intermediaries, prioritizing decentralization, censorship resistance, and security. Uniswap is open-source software licensed under the** [**GPL**](https://en.wikipedia.org/wiki/GNU_General_Public_License)**.**

**Each Uniswap smart contract, or pair, manages a liquidity pool made up of reserves of two** [**ERC-20**](https://eips.ethereum.org/EIPS/eip-20) **tokens.**

**Anyone can become a liquidity provider (LP) for a pool by depositing an equivalent value of each underlying token in return for pool tokens. These tokens track pro-rata LP shares of the total reserves, and can be redeemed for the underlying assets at any time.**

![](https://docs.uniswap.org/assets/images/lp-c0b1b03ef921f1325971fa8ab6e9a4f1.jpg)

**Pairs act as automated market makers, standing ready to accept one token for the other as long as the “constant product” formula is preserved. This formula, most simply expressed as** `x * y = k`**, states that trades must not change the product (**`k`**) of a pair’s reserve balances (**`x` **and** `y`**). Because** `k` **remains unchanged from the reference frame of a trade, it is often referred to as the invariant. This formula has the desirable property that larger trades (relative to reserves) execute at exponentially worse rates than smaller ones.**

**In practice, Uniswap applies a 0.30% fee to trades, which is added to reserves. As a result, each trade actually increases** `k`**. This functions as a payout to LPs, which is realized when they burn their pool tokens to withdraw their portion of total reserves. In the future, this fee may be reduced to 0.25%, with the remaining 0.05% withheld as a protocol-wide charge.**

![](https://docs.uniswap.org/assets/images/trade-b19a05be2c43a62708ab498766dc6d13.jpg)

**Because the relative price of the two pair assets can only be changed through trading, divergences between the Uniswap price and external prices create arbitrage opportunities. This mechanism ensures that Uniswap prices always trend toward the market-clearing price.**
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->


## **一、什么是三明治攻击（一句话版）**

**三明治攻击 = 利用区块内交易排序（MEV），在你的一笔交易前后各插一笔交易，从价格波动中榨走你的钱。**

结构像这样：

```
攻击者买  →  你买  →  攻击者卖
```

你 = 中间的“肉”

攻击者 = 上下两片“面包”

* * *

## **二、三明治攻击发生的前提条件（很关键）**

不是所有交易都会被三明治，必须满足几个条件：

### **1️⃣ 你在** 

### **AMM（如 Uniswap）**

###  **上交易**

-   没有订单簿
    
-   价格由池子余额决定
    

### **2️⃣ 你的交易是** 

### **公开可见的**

-   进入 mempool（内存池）
    
-   机器人可以提前看到
    

### **3️⃣ 你设置了** 

### **较大的滑点（slippage）**

-   比如 1%、3%、5%
    
-   给了攻击者“操作空间”
    

* * *

## **三、三明治攻击的完整流程（一步不跳）**

我们用 **ETH / USDC 池子** 来举例。

### **初始状态**

| 资产 | 数量 |
| --- | --- |
| ETH | 100 |
| USDC | 300,000 |

价格 ≈ 3000 USDC / ETH

* * *

### **🥪 第 0 步：攻击者“盯盘”**

-   MEV 机器人实时监听 mempool
    

发现你要：

-   用 **30,000 USDC 买 ETH**
    
-   滑点容忍：**3%**
    

攻击者立刻知道：

> 「这笔单子会把价格推高，而且你允许被坑 3%」

### **🥪 第 1 步：攻击者先买（Front-run）**

攻击者抢在你前面：

-   用 10,000 USDC 买 ETH
    
-   通过 **更高 gas 费** 排到你前面
    

结果：

-   ETH ↓
    
-   USDC ↑
    
-   价格上涨
    

* * *

### **🥪 第 2 步：你被夹在中间（Victim trade）**

你原本预期：

-   3000 买 1 ETH
    

实际成交：

-   可能变成 3060 / 3090
    
-   仍在你 3% 滑点容忍内 → 交易成功
    

📌 **你为攻击者“抬了轿子”**

* * *

### **🥪 第 3 步：攻击者再卖（Back-run）**

攻击者立刻：

-   把刚买的 ETH 全部卖回 USDC
    
-   同样加高 gas，排在你后面
    

结果：

-   吃掉你推高的价格
    
-   无风险套利完成
    

* * *

### **💰 攻击者赚什么？**

-   价差收益
    
-   扣掉 gas
    
-   **几乎零风险**
    

📌 这不是黑客，是**合法但不道德的套利**

* * *

## **四、为什么 AMM 天生容易被三明治？**

### **根本原因只有两个字：**

### **可预测**

**在 Uniswap：**

-   价格函数是确定的（x \* y = k）
    
-   交易对价格的影响是可计算的
    
-   滑点容忍 = 明示的最大可榨取空间
    

📌 对 MEV 机器人来说：

> 你这笔交易 **就是一份报价单**

* * *

## **五、三明治攻击 ≠ 漏洞（重点）**

这点很多人误解。

❌ 不是智能合约 bug

❌ 不是系统被 hack

✅ 是 **区块排序权 + 经济激励**

谁控制：

-   交易排序（矿工 / 验证者 / Builder）
    
-   谁就能榨取 MEV（Maximal Extractable Value）
    

* * *

## **六、三明治攻击和你熟悉的金融世界类比**

### **🏦 银行 / 交易所类比**

> **像什么？**

-   你在电话里告诉券商：
    
    > 「我要买 1000 手，能接受涨 3%」
    
-   券商先自己买
    
-   再帮你成交
    
-   最后自己卖
    

📌 在传统金融：**违法**

📌 在链上：**规则允许**

* * *

## **七、哪些交易最容易被夹？**

高危特征：

-   💸 交易金额大
    
-   📉 流动性小
    
-   🎯 滑点设得高
    
-   🕰 高波动时段
    
-   🪙 长尾 / Meme 币
    

* * *

## **八、如何防范三明治攻击？（实用）**

### **1️⃣ 把滑点设低（最重要）**

-   能 0.1% 就别 1%
    
-   能拆单就拆单
    

* * *

### **2️⃣ 使用** 

### **私有交易通道**

-   Flashbots / MEV-Blocker
    
-   钱包：
    
    -   MetaMask（部分网络）
        
    -   Rabby
        
    -   1inch Fusion
        
    

📌 交易不进公共 mempool

* * *

### **3️⃣ 使用** 

### **聚合器**

-   1inch / CowSwap
    
-   拆路径、混淆意图
    

* * *

### **4️⃣ 选深度好的池子**

-   大池子价格不容易被撬动
    

* * *

## **九、进阶一点：为什么说 MEV 是“链上的暗税”？**

因为：

-   你以为你付的是 gas
    
-   实际你还在 **隐形地付给 MEV 机器人**
    

📌 所以：

> MEV ≈ 看不见的交易税

* * *

## **十、你下一步如果继续深挖，可以这样走**

结合你现在在学 **Uniswap / Aave / ERC**，我很建议你接着看：

1️⃣ **MEV、Flashbots、PBS（Builder/Proposer 分离）**

2️⃣ **为什么 CowSwap 可以天然防三明治**

3️⃣ **Uniswap v3 为什么更容易被夹**

4️⃣ **DeFi 设计中如何“抗 MEV”**
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->



## **一、Aave 是什么？**

**Aave** 是一个部署在区块链（主要是以太坊）上的 **去中心化借贷协议**，允许用户：

-   🟢 **存钱（Lending）**：把资产存进协议，赚取利息
    
-   🔵 **借钱（Borrowing）**：用抵押物借出其他资产
    
-   ❌ **不需要银行、不需要身份认证**
    

> Aave ≈ 区块链世界的「自动化、无人工干预的银行借贷系统」

目前 Aave 是：

-   DeFi 借贷 TVL 常年排名前 1～2
    
-   多链部署（Ethereum、Arbitrum、Polygon、Avalanche 等）
    

* * *

## **二、Aave 的核心参与者**

### **1️⃣ 存款人（Lender）**

-   把资产（如 ETH、USDC、DAI）存入 Aave
    
-   获得：
    
    -   利息
        
    -   **aToken**（如 aETH、aUSDC）
        
    

👉 aToken 的特点：

-   1:1 锚定原资产
    
-   **余额会自动增长**（利息实时累积）
    
-   可转账、可用于 DeFi 组合
    

* * *

### **2️⃣ 借款人（Borrower）**

-   必须 **超额抵押**
    
-   举例：
    
    -   抵押 $150 的 ETH
        
    -   借出 $100 的 USDC
        
    

不能：

-   无抵押借款（除闪电贷）
    

* * *

## **三、Aave 借贷是怎么运作的？**

### **🔁 资金池模式（Pool-based）**

Aave 不是点对点借贷，而是：

```
所有人的存款 → 一个资金池
借款人 → 从池子里借
```

优点：

-   不需要撮合
    
-   流动性高
    
-   利率自动调节
    

* * *

### **📈 利率机制（核心）**

利率由 **资金利用率** 决定：

```
Utilization Rate = 已借出资金 / 总存款
```

-   借的人多 → 利率上升
    
-   借的人少 → 利率下降
    

Aave 支持：

-   **浮动利率（Variable）**
    
-   **稳定利率（Stable）**（不是绝对固定）
    

* * *

## **四、风控机制（非常关键）**

### **1️⃣ 超额抵押**

每种资产都有：

-   LTV（Loan To Value）
    
-   Liquidation Threshold（清算阈值）
    

例如：

-   ETH 的清算阈值：80%
    
-   当借款 / 抵押 ≥ 80% → 可被清算
    

* * *

### **2️⃣ 清算（Liquidation）**

当仓位不安全时：

-   清算人帮你还一部分债
    
-   拿走你的抵押物
    
-   并获得 **清算奖励（5%～10%）**
    

👉 这是 Aave 能 **无需人工风控也不爆雷** 的关键

* * *

## **五、Aave 的杀手级创新**

### **⭐ 1. 闪电贷（Flash Loan）**

这是 Aave 最有名的创新：

**特点**：

-   无抵押
    
-   借款 → 操作 → 还款
    
-   必须在 **同一个区块内完成**
    

用途：

-   套利
    
-   清算
    
-   债务重组
    
-   DeFi 乐高组合
    

⚠️ 也是很多 DeFi 攻击的技术基础（但不是漏洞）

* * *

### **⭐ 2. aToken 设计**

-   利息自动体现在 token 数量变化中
    
-   非常适合组合进其他 DeFi 协议
    

* * *

### **⭐ 3. AAVE 治理机制**

-   AAVE 是治理代币
    
-   可投票决定：
    
    -   新资产上线
        
    -   风控参数
        
    -   协议升级
        
    

* * *

## **六、Aave 和 Uniswap 的本质区别（你之前问过 Uniswap）**

| 对比项 | Aave | Uniswap |
| --- | --- | --- |
| 类型 | 借贷协议 | 交易所 |
| 核心行为 | 存 / 借 | 交易 |
| 定价机制 | 利率模型 | AMM 曲线 |
| 风险 | 清算风险 | 无常损失 |

👉 **Aave 管“时间价值”，Uniswap 管“价格交换”**

* * *

## **七、Aave 的主要风险（真实世界角度）**

1️⃣ **清算风险**

价格剧烈波动 → 抵押物被清算

2️⃣ **智能合约风险**

虽然 Aave 审计极多，但仍是代码

3️⃣ **预言机风险**

价格来源（Chainlink）异常会影响清算

4️⃣ **治理风险**

极端情况下治理被攻击（概率很低）

* * *

## **八、你如果继续学 Aave，建议的进阶路径**

结合你现在 **Web3 + DeFi + 产品理解** 的背景，我建议你下一步可以学：

1.  **Aave v2 vs v3 区别**
    
    -   Isolation Mode
        
    -   E-Mode（效率模式）
        
    
2.  **Aave 在稳定币体系中的作用**
    
    -   USDC / DAI 利率锚定
        
    
3.  **真实案例**
    
    -   抵押 ETH → 借 USDC → 再投资
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->




## **一、Uniswap 是什么？（一句话版）**

**Uniswap 是一个去中心化交易所（DEX），用智能合约自动完成代币兑换，不需要订单簿，也不需要中介。**

关键词：

-   去中心化（没有券商 / 交易所托管）
    
-   自动做市商（AMM）
    
-   链上智能合约
    
-   无需撮合对手方
    

* * *

## **二、Uniswap 解决了什么问题？**

### **1️⃣ 传统中心化交易所（CEX）的问题**

-   需要托管资产（跑路风险）
    
-   有准入门槛（KYC、开户）
    
-   撮合、做市是“黑箱”
    
-   交易暂停、拔网线风险
    

### **2️⃣ Uniswap 的核心理念**

> **“让流动性像一个自动售货机，而不是靠人报价”**

任何人：

-   都可以**直接钱包交易**
    
-   都可以**提供流动性赚手续费**
    
-   都可以**部署交易对**
    

* * *

## **三、Uniswap 的核心机制：AMM（自动做市商**

### **❌ 传统交易所：订单簿模式**

```
买单：98 / 97 / 96
卖单：100 / 101 / 102
```

需要：

-   买家
    
-   卖家
    
-   做市商
    

* * *

### **✅ Uniswap：AMM 模式（重点）**

Uniswap **没有订单簿**，只有一个公式：

**x × y = k**

**含义：**

-   x：池子里 Token A 的数量
    
-   y：池子里 Token B 的数量
    
-   k：常数（交易前后保持不变）
    

* * *

### **🌰 举个最经典的例子**

一个 ETH / USDC 池子：

| 资产 | 数量 |
| --- | --- |
| ETH | 100 |
| USDC | 300,000 |

价格 ≈ 3000 USDC / ETH

k = 100 × 300,000 = 30,000,000

* * *

### **💱 你来买 1 ETH 会发生什么？**

你往池子里：

-   **付出 USDC**
    
-   **拿走 ETH**
    

结果：

-   ETH ↓
    
-   USDC ↑
    
-   价格自动变贵（防止被掏空）
    

📌 **价格不是人为决定的，而是由池子里资产比例决定的**

* * *

## **四、Uniswap 的三类核心角**

### **1️⃣ 交易者（Trader）**

-   用钱包直接 swap
    
-   不需要对手盘
    
-   即时成交
    

* * *

### **2️⃣ 流动性提供者（LP）**

-   往池子里**存两种资产**
    
-   获得 **LP Token**
    
-   赚取交易手续费（如 0.3%）
    

📌 类似银行里的：

「我提供资金 → 系统自动帮我赚钱」

* * *

### **3️⃣ 智能合约**

-   自动定价
    
-   自动结算
    
-   不可篡改
    

📌 **代码即规则**

* * *

## **五、Uniswap 的手续费和激励机制**

### **💰 手续费来源**

-   每笔交易收取 0.05% / 0.3% / 1%（v3 可选）
    

### **📊 手续费分配**

-   全部给 LP
    
-   协议层目前几乎不抽成（治理可调）
    

* * *

## **六、Uniswap V1 / V2 / V3 的演进（非常重要**

### **🔹 V1（2018）**

-   ETH ↔ ERC20
    
-   机制简单
    
-   已淘汰
    

* * *

### **🔹 V2（2020）**

-   任意 ERC20 ↔ ERC20
    
-   引入闪电兑换（Flash Swap）
    
-   经典 x\*y=k
    

* * *

### **🔹 V3（2021，**

### **最重要**

### **）**

🚀 **核心创新：集中流动性（Concentrated Liquidity）**

**传统问题：**

> LP 的资金大部分“闲置”

**V3 解决方案：**

-   LP 可以指定价格区间
    
-   资金利用率 ↑ 10~100 倍
    
-   手续费分档（0.05% / 0.3% / 1%）
    

📌 技术上：

-   LP 头寸变成 **NFT**
    
-   每个 LP 头寸是一个独立策略
    

* * *

## **七、Uniswap 的价格从哪来？（常见误区）**

❌ Uniswap 不“决定价格”

✅ Uniswap **反映市场行为**

价格来源于：

-   套利者
    
-   跨交易所套利
    
-   MEV 搜索者
    

📌 如果 Uniswap 价格 ≠ Binance：

> 套利机器人会瞬间拉回

* * *

## **八、Uniswap 在 DeFi 里的地位**

可以把它看成 **DeFi 的“央行级基础设施”**：

-   几乎所有 DeFi 项目依赖它定价
    
-   稳定币、衍生品、借贷都用它做价格参考
    
-   是流动性“底座”
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->





## 第五章一句话总结

> **本章系统讲清楚：以太坊虚拟机（EVM）是如何执行智能合约的、Gas 是如何衡量计算与存储成本的，以及以太坊如何用 Gas 机制在“安全、去中心化、资源有限”之间取得平衡。**

如果第四章解决的是 **“链上程序怎么写、怎么部署”**，  
那第五章解决的就是：

> **“这些程序是怎么被全网执行的？为什么每一步都要钱？”**

* * *

## 第五章的核心主线（非常重要）

这一章围绕 **3 个核心问题**展开：

1️⃣ EVM 到底是什么、负责什么  
2️⃣ Gas 是如何计费的、为什么必须存在  
3️⃣ Gas 机制如何影响合约设计与用户体验

* * *

## 一、EVM 是什么？（世界计算机的“CPU”）

### 1️⃣ EVM 的本质

-   **Ethereum Virtual Machine**
    
-   是一个：
    
    -   确定性
        
    -   沙盒化
        
    -   图灵完备  
        的虚拟机
        

每一个以太坊全节点都会运行 EVM，用来：

-   执行交易
    
-   执行智能合约
    
-   计算新的链上状态
    

👉 **同一笔交易，在全世界节点上执行，结果必须完全一致**

* * *

### 2️⃣ 为什么必须是“虚拟机”？

-   屏蔽底层硬件差异
    
-   防止恶意代码破坏节点
    
-   保证执行结果可验证
    

你可以把 EVM 理解为：

> **“全球统一版本的、只为区块链服务的 JVM”**

* * *

## 二、EVM 执行的是什么？——Opcode 与指令模型

### 1️⃣ 合约最终都会变成 Opcode

-   Solidity → 编译 → Bytecode
    
-   Bytecode 由一条条 **EVM Opcode** 组成
    
-   每条 Opcode：
    
    -   执行一个最小操作
        
    -   都有固定 Gas 成本
        

例如：

-   ADD
    
-   MUL
    
-   SLOAD
    
-   SSTORE
    
-   CALL
    

👉 **Gas 的最小计费单位就在这里**

* * *

### 2️⃣ 为什么 Opcode 要定价？

因为它们消耗的是：

-   CPU 计算
    
-   内存
    
-   磁盘（状态存储）
    
-   网络安全成本
    

* * *

## 三、Gas 是什么？（全章最重要概念）

### 1️⃣ Gas 的本质

> **Gas 是“链上计算与存储资源的定价单位”**

它不是 ETH，但：

-   **最终要用 ETH 支付**
    
-   是 EVM 执行的“油量表”
    

* * *

### 2️⃣ 为什么不用“执行一次多少钱”？

因为：

-   每笔交易复杂度不同
    
-   合约逻辑千差万别
    
-   必须精确限制“最多能跑多少步”
    

👉 **Gas 防止无限循环与 DoS 攻击**

* * *

## 四、一笔交易的 Gas 是怎么算的？

### 1️⃣ 三个核心概念

-   **Gas Limit**：你最多愿意给多少 Gas
    
-   **Gas Used**：实际消耗多少
    
-   **Gas Price / Fee**：每单位 Gas 的价格
    

最终费用：

```
交易费 = Gas Used × Gas 单价
```

* * *

### 2️⃣ 为什么会“Gas 不够失败但还扣钱”？

-   EVM 是“先执行、再判断是否完成”
    
-   执行过程已经消耗了资源
    
-   所以：
    
    -   状态回滚
        
    -   Gas 不退
        

👉 **这是新手最痛的一点，但非常合理**

* * *

## 五、存储为什么这么贵？（状态是核心成本）

### 1️⃣ 计算便宜，存储昂贵

-   CPU：可复用
    
-   存储状态：**要被所有节点永久保存**
    

特别是：

-   SSTORE
    
-   写入新 storage slot
    

👉 **状态膨胀是区块链的“系统性风险”**

* * *

### 2️⃣ 本章强调的设计思想

> **让“滥用状态”的合约付出更高成本**

这直接影响：

-   合约结构设计
    
-   是否存链上
    
-   是否可用事件（event）代替 storage
    

* * *

## 六、区块 Gas 上限：网络吞吐的“硬天花板”

### 1️⃣ 每个区块有 Gas 上限

-   限制一个区块能执行的总计算量
    
-   防止：
    
    -   区块过大
        
    -   节点无法同步
        

* * *

### 2️⃣ 拥堵的本质

-   区块 Gas 容量有限
    
-   用户争抢区块空间
    
-   费用自然上升
    

👉 **这是“链上贵”的根本原因**

* * *

## 七、EIP-1559：费用机制的重大变化（重点认知）

### 1️⃣ 引入 Base Fee

-   每个区块有一个基础费用
    
-   自动随拥堵调整
    
-   **被直接销毁（Burn）**
    

### 2️⃣ Tip（Priority Fee）

-   给验证者的小费
    
-   激励优先打包
    

* * *

### 3️⃣ 带来的长期影响

-   费用更可预测
    
-   ETH 具备“通缩机制”
    
-   用户体验改善
    

👉 **这是 ETH 价值逻辑的重要组成部分**

* * *

## 八、EVM 的限制与后果

### 1️⃣ 单线程、同步执行

-   没有并发
    
-   没有多线程
    
-   一切按顺序执行
    

### 2️⃣ 没有浮点数、没有随机数

-   为了确定性
    
-   所有节点结果必须一致
    

👉 **这些限制不是“落后”，而是“安全换来的代价”**

* * *

## 九、这一章对开发者的现实指导意义

### 你应该形成的 5 个直觉：

1.  **每一行 Solidity 最终都会变成 Gas**
    
2.  **存储是最贵的操作**
    
3.  **失败 ≠ 免费**
    
4.  **Gas 设计直接影响用户体验**
    
5.  **EVM 不是为复杂计算而生的**
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->






# 第四章一句话总结

> **本章系统讲清楚：什么是智能合约、它是如何被编译和部署到链上的、为什么“不可篡改”、以及开发者在现实中必须面对的安全、成本与升级问题。**

如果说前三章解决的是 **“链是什么 / 网络怎么跑 / 账户是什么”**，  
那第四章正式进入 **“链上程序是怎么写、怎么活、怎么出事的”**。

这是你从“理解以太坊”迈向“真正写 Web3 应用”的**分水岭章节**。

* * *

## 一、智能合约到底是什么（本章的理论地基）

### 1️⃣ 智能合约的本质

-   **部署在区块链上的程序**
    
-   由 **EVM** 执行
    
-   运行结果：
    
    -   自动
        
    -   可验证
        
    -   不依赖中心化后台
        

关键点不是“智能”，而是：

> **规则一旦上链，任何人都无法单方面更改执行结果**

* * *

### 2️⃣ 智能合约 ≠ 普通后端代码

和你熟悉的 Java / Spring 后端最大区别：

| 维度 | 传统后端 | 智能合约 |
| --- | --- | --- |
| 可修改性 | 随时改 | 默认不可改 |
| 运行环境 | 自己服务器 | 全网节点 |
| 执行成本 | 固定服务器成本 | 按 Gas 付费 |
| 出错后果 | 回滚/修复 | 可能直接损失资产 |

👉 **这就是为什么“合约安全”如此重要**

* * *

## 二、Solidity：为什么是它？

### 1️⃣ Solidity 的定位

-   以太坊最主流的合约语言
    
-   语法接近 JavaScript / C++
    
-   专为 **EVM + Gas 计费模型**设计
    

### 2️⃣ 本章强调的不是语法，而是：

-   **状态变量**
    
-   **函数可见性**
    
-   **合约结构**
    
-   **调用方式**
    

👉 目的是让你理解：  
**合约 = 状态 + 规则，而不是一堆函数**

* * *

## 三、合约“从源码到上链”发生了什么（非常关键）

这是第四章的**核心流程认知**。

* * *

### 1️⃣ 编译阶段会生成什么？

Solidity 编译后至少得到三样东西：

1.  **Bytecode（字节码）**
    
    -   真正部署到链上的内容
        
    -   EVM 执行对象
        
2.  **ABI**
    
    -   合约“对外说明书”
        
    -   前端 / 脚本 / 其他合约靠它来调用
        
3.  **元数据**
    
    -   编译器版本
        
    -   源码校验信息
        

👉 **链上只有字节码，源码是“人类可读附加品”**

* * *

### 2️⃣ 部署合约 = 一笔特殊交易

-   合约地址不是“随便来的”
    
-   由：
    
    -   部署者地址
        
    -   nonce
        
    -   CREATE / CREATE2  
        共同决定
        

👉 这解释了：

-   为什么合约地址可预测
    
-   为什么“同样代码，地址不同”
    

* * *

## 四、成本问题：为什么部署和调用都要钱？

### 1️⃣ 合约部署为什么贵？

-   部署时：
    
    -   写入大量字节码
        
    -   初始化 storage
        
-   本质是 **往全网状态里写数据**
    

👉 **状态是最昂贵的资源**

* * *

### 2️⃣ Gas 成本贯穿整个生命周期

-   部署成本
    
-   调用成本
    
-   状态修改成本
    

本章为下一章 **EVM & Gas** 做了铺垫。

* * *

## 五、智能合约为什么“危险”？——安全问题总览

这是第四章**最现实的一部分**。

* * *

### 1️⃣ 常见安全风险（不深挖原理，但建立警觉）

-   重入攻击
    
-   权限控制错误
    
-   整数溢出（历史）
    
-   外部调用风险
    
-   逻辑漏洞 ≠ 语法错误
    

👉 **合约“能跑”不等于“安全”**

* * *

### 2️⃣ 核心思想

> **链上世界没有“事后补丁”**

所以必须：

-   设计时就考虑攻击面
    
-   使用成熟库（OpenZeppelin）
    
-   限制权限
    
-   尽量简化逻辑
    

* * *

## 六、工具链：你不是“手撸合约”

### 1️⃣ Remix

-   浏览器 IDE
    
-   适合：
    
    -   入门
        
    -   教学
        
    -   快速实验
        

### 2️⃣ Hardhat / Truffle

-   工程化工具
    
-   支持：
    
    -   本地测试链
        
    -   自动化部署
        
    -   单元测试
        
    -   Gas 分析
        

👉 **这是“写玩具合约”和“做真实项目”的分界线**

* * *

## 七、公开性与不可篡改性：优点也是枷锁

### 1️⃣ 合约是“公开资产”

-   任何人都能：
    
    -   看字节码
        
    -   调用函数
        
    -   分析行为
        

### 2️⃣ 不可篡改带来的现实问题

-   Bug 永久存在
    
-   逻辑错误无法修复
    
-   升级极其困难
    

* * *

## 八、升级问题：智能合约怎么“打补丁”？

这是第四章的**高级但极其重要的结尾**。

### 1️⃣ 为什么需要升级方案？

-   业务变化
    
-   安全漏洞
    
-   协议迭代
    

### 2️⃣ 常见思路（不深讲实现）

-   Proxy（代理模式）
    
-   数据与逻辑分离
    
-   新合约 + 迁移
    

👉 本质是：

> **在“不可篡改”的前提下，模拟“可升级”**
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->










## 第三章的核心主线

这一章主要围绕 **3 个关键问题**展开：

1️⃣ 以太坊里有哪些账户类型  
2️⃣ 它们如何被控制、能做什么、不能做什么  
3️⃣ 钱包、代币、合约，本质上和账户是什么关系

* * *

## 一、以太坊账户模型：与比特币完全不同

### 1️⃣ 账户模型（Account Model）

-   以太坊使用的是 **账户模型**
    
-   每个账户都有：
    
    -   地址（address）
        
    -   余额（balance）
        
    -   状态（state）
        
-   所有账户共同构成一个 **全局状态机**
    

👉 这是和比特币 **UTXO 模型** 的根本差异  
👉 也是以太坊能“跑程序”的前提

* * *

## 二、两大账户类型（全章最重要）

以太坊只有 **两种账户**，但非常关键：

* * *

### 1️⃣ 外部拥有账户（EOA, Externally Owned Account）

**核心特征**

-   由 **私钥控制**
    
-   可以：
    
    -   主动发起交易
        
    -   转账 ETH
        
    -   调用合约
        
-   没有代码，只有：
    
    -   nonce
        
    -   balance
        

**典型代表**

-   你的 MetaMask 钱包地址
    
-   交易所给你的充值地址
    

👉 **EOA = 人类 / 钱包的“入口身份”**

* * *

### 2️⃣ 合约账户（Contract Account）

**核心特征**

-   由 **代码控制**
    
-   不能主动发起交易
    
-   只能：
    
    -   被调用
        
    -   在调用过程中“被动执行”
        
-   有：
    
    -   代码（bytecode）
        
    -   storage（状态变量）
        

**典型代表**

-   ERC20 合约
    
-   NFT 合约
    
-   DeFi 协议合约
    

👉 **合约账户 = 程序本身**

* * *

## 三、EOA vs 合约账户（必须形成对比认知）

| 对比点 | EOA | 合约账户 |
| --- | --- | --- |
| 是否有私钥 | ✅ | ❌ |
| 是否有代码 | ❌ | ✅ |
| 能否主动发交易 | ✅ | ❌ |
| 控制方式 | 私钥签名 | 合约逻辑 |
| 典型用途 | 钱包 / 用户 | 协议 / 规则 |

**关键结论：**

> **只有 EOA 才能“点火”发起交易**  
> 合约只能在交易执行过程中被触发

这是理解一切交互的底层规则。

* * *

## 四、地址为什么都是 0x 开头？

这一节帮你消除“看起来很神秘，其实很工程”的误解。

### 1️⃣ 地址的本质

-   以太坊地址是：
    
    -   公钥的 Keccak256 哈希
        
    -   取后 20 字节
        
-   用 **16 进制表示**
    
-   所以以 `0x` 开头
    

👉 **地址不是“账户本身”，而是账户的标识**

* * *

## 五、谁能发起交易？（考试级重点）

书中专门强调了一点：

> **只有 EOA 可以主动发起交易**

原因：

-   交易必须签名
    
-   签名只能来自私钥
    
-   合约没有私钥
    

所以你看到的：

-   合约转账
    
-   合约调用合约
    

本质上都是：

> **EOA → 合约 → 合约**

* * *

## 六、合约账户里的“钱”和“状态”

### 1️⃣ 合约账户也可以有余额

-   可以持有 ETH
    
-   可以持有 ERC20 / NFT（逻辑上）
    

### 2️⃣ 合约的“状态”存在哪？

-   存在 **storage**
    
-   属于全局状态的一部分
    
-   每次修改都要消耗 Gas
    

👉 这为后面：

-   Gas
    
-   状态成本
    
-   合约设计  
    埋下伏笔
    

* * *

## 七、EOA 与合约之间如何交互？

这一章解释了最常见、但新手最容易混乱的事情：

### 1️⃣ EOA → 合约

-   最常见
    
-   例如：
    
    -   转账代币
        
    -   调用 DeFi
        
    -   Mint NFT
        

### 2️⃣ 合约 → 合约

-   合约内部逻辑调用
    
-   用于：
    
    -   组合 DeFi
        
    -   协议嵌套
        

### 3️⃣ 合约不能“自己醒来”

-   没有定时器
    
-   没有线程
    
-   必须被外部交易触发
    

👉 **区块链不是后台任务系统**

* * *

## 八、钱包（MetaMask）到底在管理什么？

这是第三章和“现实使用”连接最紧的一部分。

### MetaMask 本质上在做三件事：

1.  管理 **EOA 私钥**
    
2.  帮你 **构造交易**
    
3.  用 JSON-RPC 把交易发给节点
    

钱包 ≠ 存币软件  
钱包 = **私钥 + 交易签名工具**

* * *

## 九、代币（ERC20 / ERC721）和账户的关系

### 1️⃣ 代币不是“账户”

-   代币 = 合约里的数据结构
    
-   余额记录在合约 storage 中
    

### 2️⃣ “我有 100 个 USDT”是什么意思？

> USDT 合约里有一条记录：  
> `balances[你的地址] = 100`

👉 这对理解：

-   授权（approve）
    
-   合约安全
    
-   资产风险  
    非常重要
    

* * *

## 十、合约部署后的不可篡改性

### 1️⃣ 合约一旦部署：

-   地址固定
    
-   代码不可修改
    

### 2️⃣ 为什么这么设计？

-   防止“后门改规则”
    
-   保证用户信任
    

### 3️⃣ 那升级怎么办？

-   代理模式（后面章节会讲）
    
-   新合约 + 迁移
    

👉 **不可篡改 = 信任的代价**
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->











# 1.15 帐户体系
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->












# 1.14

## 一、Web3 合规性要求与法律风险（重点是「别碰刑事红线」）

### 1️⃣ 中国监管总体态度

-   **技术本身不禁止，但金融属性高度敏感**
    
-   明确禁止：
    
    -   ICO / IEO / IDO 等代币融资
        
    -   虚拟货币交易所运营与撮合
        
    -   虚拟货币作为支付工具
        
    -   境外交易平台向中国居民提供服务
        
-   核心基调：  
    👉 **“封堵金融属性 + 有限容忍技术创新”**
    

* * *

### 2️⃣ Web3 常见高风险行为（个人也可能被追责）

**⚠️ 非常重要的一点：程序员、产品、运营都可能是“共犯”**

-   **代币发行 / 空投 / Token 设计**
    
    -   即使叫“积分”“治理 Token”，只要可流通或具融资属性，就可能构成非法金融活动
        
-   **链游 / 抽奖 / 盲盒**
    
    -   “充值 → 随机收益 → 提现”极易被认定为赌博
        
-   **邀请返利 / 多级推广**
    
    -   DAO、矿机、NFT 项目中的层级返利 → 传销风险
        
-   **OTC / 出金 / 换汇**
    
    -   虚拟币作为“桥梁资产” → 非法经营、洗钱、帮信罪风险
        
-   **代投 / 帮人操作账户**
    
    -   民事纠纷 + 刑事风险并存
        

* * *

### 3️⃣ 全球监管趋势（不是放松，而是更清晰）

-   **FATF（反洗钱）**：Travel Rule、KYC、交易监控
    
-   **美国**：SEC / CFTC / 稳定币立法
    
-   **欧盟**：MiCA（全球首个全面监管框架）
    
-   **香港**：VASP 牌照 + 稳定币监管
    

👉 趋势总结：

-   监管 **趋严、趋同**
    
-   合规成本上升
    
-   **长期利好正规项目和从业者**
    

* * *

### 4️⃣ Web3 入职阶段的特殊风险（非常贴近你这种背景）

-   **劳动关系不清晰**
    
    -   境外主体、无劳动合同、无五险一金
        
-   **薪资结构风险**
    
    -   Token / USDT 发工资 ≠ 合法工资
        
-   **出金风险**
    
    -   银行卡冻结、涉诈资金、刑事追责
        
-   **项目合法性**
    
    -   即便是“普通员工”，也可能被牵连调查
        

* * *

### 5️⃣ 典型刑事风险与真实判例

重点提醒：  
👉 **“我只是写代码 / 做产品”并不能免责**

-   开设赌场罪（链游、投注平台）
    
-   非法经营罪（虚拟币换汇、跨境支付）
    
-   非法吸收公众存款罪（矿机、返利）
    
-   组织领导传销罪（多级返佣）
    
-   洗钱罪（虚拟币跨境转移）
    

* * *

## 二、Web3 常见网络安全风险（新手最容易中招）

### 1️⃣ 攻击方式

-   **钓鱼**
    
    -   假面试、假奖学金、假空投
        
-   **木马 / 恶意软件**
    
    -   面试软件、学习资料、破解工具
        
-   **社交工程**
    
    -   冒充 HR、学长、管理员
        
-   **插件 / 供应链攻击**
    
-   **剪贴板劫持**
    
-   **账号劫持（邮箱是核心）**
    

* * *

### 2️⃣ 攻击后果

-   钱包资产被盗（几乎不可追回）
    
-   邮箱 / 社交 / 交易所“全盘沦陷”
    
-   电脑被远控、长期监控
    

* * *

### 3️⃣ 学生版安全防护清单（非常实用）

-   不安装“专用面试软件”
    
-   钱包分级（测试钱包 ≠ 主钱包）
    
-   助记词永不联网
    
-   插件只用官方
    
-   开启 2FA
    
-   转账前核对地址
    
-   定期撤销授权（[Revoke.cash](http://Revoke.cash)）
    

* * *

## 三、真实骗局与高级攻击案例

-   Office 文档木马
    
-   Punycode 域名钓鱼（看起来一模一样）
    
-   假官方邮件 / 假客服
    
-   内部人员作恶
    

核心结论一句话：

> **Web3 是“黑暗森林”，暴露即意味着风险**
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->













## 1.13第二章一句话总结

> **本章系统讲清楚：以太坊这张“全球网络”是如何由不同类型节点组成、彼此通信、同步数据，并在 PoS 之后由执行层与共识层协作来维持去中心化与安全性的。**

如果第一章是在回答「**以太坊是什么**」，  
那第二章回答的就是：「**以太坊这台世界计算机是怎么联网跑起来的**」。

* * *

## 第二章的核心主线（非常重要）

这一章其实围绕 **3 条主线**展开：

1️⃣ **节点是什么 & 为什么要有节点**  
2️⃣ **不同节点类型的分工与取舍**  
3️⃣ **PoS 合并后：执行层 + 共识层如何协作**

* * *

## 一、以太坊网络的本质：P2P 节点网络

### 1️⃣ 以太坊不是“服务器”，而是“节点网络”

-   网络由**成千上万节点**组成
    
-   没有中心服务器
    
-   节点之间通过 **P2P 网络 + Gossip 协议**通信
    
-   每个节点：
    
    -   验证数据
        
    -   同步区块
        
    -   传播交易
        

👉 **这是去中心化的技术根基**

* * *

### 2️⃣ 客户端 ≠ 节点（这是新手容易混的）

-   **客户端软件**：Geth、Erigon、Nethermind、Besu、Prysm 等
    
-   **节点**：运行这些客户端后的实例
    

就像：

> JVM ≠ Java 程序  
> Geth ≠ 节点本身

* * *

## 二、节点类型：为什么要分全节点 / 轻节点 / 归档节点

这是本章的**重点认知模型**。

* * *

### 1️⃣ 全节点（Full Node）

**特点**

-   保存当前完整状态
    
-   验证所有新区块
    
-   可以独立验证链的正确性
    

**用途**

-   钱包
    
-   dApp 后端
    
-   普通开发者最常用
    

👉 **安全与资源消耗的平衡点**

* * *

### 2️⃣ 轻节点（Light Node / Light Client）

**特点**

-   只保存区块头
    
-   不保存完整状态
    
-   依赖全节点提供证明
    

**用途**

-   钱包
    
-   移动设备
    
-   低资源环境
    

👉 **信任假设稍多，但极轻量**

* * *

### 3️⃣ 归档节点（Archive Node）

**特点**

-   保存 **历史上每一个区块的完整状态**
    
-   数据量极大（几十 TB）
    

**用途**

-   区块浏览器
    
-   链上数据分析
    
-   DeFi/NFT 历史查询
    

👉 **“时间机器级节点”**

* * *

### 4️⃣ 为什么不是所有人都跑归档节点？

-   成本极高
    
-   对普通验证与交易并非必须
    

👉 所以生态中自然形成了**节点分工**

* * *

## 三、为什么开发者 / 机构要自己跑节点？

这一节是在回答一个现实问题：

> **“我直接用 Infura / Alchemy 不香吗？”**

### 1️⃣ 自建节点的核心价值

-   **去信任**
    
-   **抗审查**
    
-   **更稳定、可控**
    
-   **避免 RPC 限流 / 封禁**
    
-   **满足合规或风控要求（机构）**
    

👉 对银行 / 交易所 / 基础设施来说非常重要

* * *

### 2️⃣ 不跑节点也能开发吗？

可以。

所以本章最后专门提到：

-   不跑节点的数据分析方式
    
-   公共 RPC
    
-   索引服务（The Graph 等）
    

👉 **这是现实世界的折中方案**

* * *

## 四、PoS 合并后的关键变化：执行层 vs 共识层

这是第二章**最 Web3-native 的部分**。

* * *

### 1️⃣ 合并之后：一个节点 ≠ 一个程序

以太坊节点拆成了两大模块：

🔹 执行客户端（Execution Client）

负责：

-   EVM 执行
    
-   交易处理
    
-   状态变更
    
-   Gas 计算
    

例如：

-   Geth
    
-   Erigon
    
-   Nethermind
    
-   Besu
    

🔹 共识客户端（Consensus Client）

负责：

-   PoS 共识
    
-   验证者管理
    
-   出块 / 投票
    
-   最终性
    

例如：

-   Prysm
    
-   Lighthouse
    
-   Teku
    
-   Nimbus
    

* * *

### 2️⃣ 两者必须“成对运行”

-   执行层：**怎么执行**
    
-   共识层：**谁来执行、执行是否有效**
    

它们通过标准接口通信（Engine API）

👉 **这是 PoS 架构下的模块化设计**

* * *

## 五、节点同步：为什么“同步”本身就是一件大事

### 1️⃣ 节点同步的目标

-   获得正确的链状态
    
-   不信任第三方
    
-   独立验证历史
    

### 2️⃣ 常见同步模式

-   全同步（Full Sync）
    
-   快照同步（Snap Sync）
    
-   轻同步（Light Sync）
    

👉 同步速度 vs 安全性取舍

* * *

## 六、Gossip 协议：网络如何“活起来”

### 1️⃣ Gossip 的作用

-   节点之间快速扩散信息
    
-   交易、区块像“传谣言”一样传播
    
-   无需中心路由
    

### 2️⃣ 为什么不用“集中广播”？

-   抗审查
    
-   抗故障
    
-   网络自然扩展
    

👉 **这是去中心化网络的生命线**

* * *

## 七、去中心化的“量化保障”：节点数量

-   节点越多 → 越难攻击
    
-   地理分布越分散 → 越抗审查
    
-   多客户端 → 防止单点实现 Bug
    

👉 **以太坊非常强调“客户端多样性”**
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->















## 第一章核心要点总结

### 1️⃣ 以太坊的诞生背景与发展脉络

-   以太坊由 **Vitalik Buterin** 于 2013 年提出，2015 年主网上线
    
-   初衷：**解决比特币“只能转账、不可通用编程”的局限**
    
-   通过白皮书、众筹、基金会等方式发展，逐步形成全球开源社区
    
-   技术路线经历：
    
    -   PoW → PoS（The Merge）
        
    -   多次重要升级（London、Merge、Dencun 等）
        
-   长期愿景：**高安全 + 高去中心化 + 可扩展的通用区块链基础设施**
    

👉 这是在回答：**以太坊不是一蹴而就的，而是一个持续演进的系统**

* * *

### 2️⃣ 以太坊的平台定位：不只是“区块链”，而是“平台”

-   以太坊是：
    
    -   去中心化
        
    -   开源
        
    -   支持 **智能合约**
        
-   核心在于 **EVM（以太坊虚拟机）**
    
    -   让区块链具备“运行程序”的能力
        
-   从“记账系统”升级为：
    
    > **全球共享、可编程的结算与计算平台**
    

👉 这是与比特币最本质的差异之一

* * *

### 3️⃣ ETH（以太币）的三重角色

ETH 并不只是“币价资产”，而是系统内的**核心生产要素**：

1.  **Gas 燃料**
    
    -   所有交易和合约执行都必须消耗 ETH
        
2.  **共识安全保证金**
    
    -   PoS 下质押 ETH 成为验证者，维护网络安全
        
3.  **DeFi / Web3 的基础资产**
    
    -   抵押、计价、结算、流动性核心
        

👉 ETH 是“用得越多、网络越安全、价值捕获越强”的资产设计

* * *

### 4️⃣ 为什么叫“全球可编程区块链”

这个称号拆开看：

-   **区块链**：去中心化、不可篡改、可验证
    
-   **可编程**：
    
    -   智能合约
        
    -   图灵完备的 EVM
        
    -   可以构建无限复杂的逻辑
        
-   **全球性**：
    
    -   无国界、无许可
        
    -   任何人都能部署合约、调用应用
        

最终形成一个概念：

> **以太坊是一台“世界计算机（World Computer）”**

* * *

### 5️⃣ dApp：以太坊上真正“跑起来”的应用形态

-   dApp = **链上智能合约（后端）+ 链下前端**
    
-   典型应用：
    
    -   DeFi（DEX、借贷、衍生品）
        
    -   NFT / 游戏 / 内容
        
    -   DAO / 治理
        
-   优势：
    
    -   抗审查
        
    -   无需信任
        
    -   永久在线
        
-   代价：
    
    -   Gas 成本
        
    -   性能受限
        
    -   用户体验门槛高（钱包、私钥）
        

👉 这章为后面理解 DeFi、NFT、L2 做铺垫

* * *

### 6️⃣ 以太坊 vs 比特币：清晰的角色分工

-   **比特币**：
    
    -   数字黄金
        
    -   价值储存
        
    -   极简、保守、安全
        
-   **以太坊**：
    
    -   应用平台
        
    -   可编程资产和金融系统
        
    -   快速迭代、功能复杂
        

一句话总结：

> **比特币是价值锚，以太坊是应用发动机**
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
