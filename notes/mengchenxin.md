---
timezone: UTC+8
---

# mengchenxin

**GitHub ID:** mengchenxin

**Telegram:** @RangZhouOrddust

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
1
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

\# Solidity & Web3 开发学习周总结（2026.01.19-01.24）

本周核心围绕 **Solidity 基础语法、智能合约开发实战、Gas 优化、Web3 核心机制** 展开学习，从理论认知逐步落地到代码实操，完成了积分系统智能合约的开发与优化，以下是核心学习成果：

\## 一、核心知识点梳理

\### 1. Solidity 基础语法与核心特性

\- **合约结构**：掌握许可证声明（SPDX）、编译器版本（pragma）、合约定义（contract）的基础规范，理解状态变量（永久存储）、函数（业务逻辑）、构造函数（初始化）的核心作用。

\- **数据类型**：

\- 基础类型：uint/int（数值）、address（地址）、bool（布尔），重点掌握 `payable address` 可接收以太币的特性；

\- 复合类型：结构体（Struct，自定义数据集合）、映射（Mapping，Key-Value 存储，不可遍历）、数组（固定/动态长度）；

\- 数据位置：Storage（链上永久存储，Gas 成本高）、Memory（函数内临时存储，低成本）、Calldata（只读参数存储）。

\- **函数与修饰符**：

\- 可见性：public（内外均可调用）、external（仅外部调用，更省 Gas）、internal（当前/子合约）、private（仅当前合约）；

\- 状态修饰符：view（只读状态）、pure（不读写状态）、payable（可接收以太）；

\- 自定义修饰符：如 `onlyOwner` 实现权限控制，核心语法 `require(条件, 错误提示)`（条件不满足则报错）。

\### 2. Web3 核心机制认知

\- **以太坊账户模型**：区分 EOA 外部账户（私钥控制、可发起交易）和合约账户（代码控制、仅被触发）；

\- **Gas 机制**：Gas 是 EVM 执行指令的工作量单位，核心优化逻辑是「减少链上存储操作、降低不必要计算」；

\- **交易生命周期**：签名构造 → 广播到 mempool → 验证者打包 → EVM 执行 → 区块共识确认，理解 Gas Limit、Base Fee、Priority Fee 等关键参数。

\- **特殊标准**：ERC-7962（基于密钥哈希的代币标准），核心优势是原生隐私保护（UTXO 模型、一次性密钥）、支持 Gas 代付，区别于传统 ERC-20/721 的公开地址所有权逻辑。

\### 3. Gas 优化实战技巧

1\. 减少 Storage 操作：多次访问的存储变量先缓存到 Memory；

2\. 位压缩：将小类型变量（如 uint128）相邻排列，节省存储空间；

3\. 变量常量化：用 `constant/immutable` 替代全局 Storage 变量；

4\. 循环优化：缓存数组长度、使用 `++i` 替代 `i++`；

5\. unchecked 块：关闭不必要的溢出检查（Solidity 0.8+ 自动检查，无风险场景可关闭）；

6\. 函数可见性：外部调用优先用 `external` 而非 `public`。

\### 4. 实战开发：积分系统合约

从基础版本迭代到带「签到、转账、锁仓、解锁」的完整版本，核心功能与优化点：

\- 核心功能：每日签到（限制 1 天 1 次，通过 `block.timestamp` 时间戳判断）、积分转账/销毁、管理员增发积分、积分锁仓（Deposit）与解锁（Withdrawal，到期返还双倍积分）；

\- 关键修复：纠正 `require` 逻辑理解（条件不满足才触发错误提示）、移除冗余的 `getUserPoints` 函数（public 映射自带查询功能）；

\- 核心逻辑：用 Mapping 存储「地址-积分」「地址-最后签到时间」「地址-锁仓信息」，通过结构体 `Deposit` 管理锁仓金额与解锁时间。

\## 二、学习痛点与解决

1\. **概念混淆**：初期误解 `require` 逻辑（以为条件成立触发提示），通过实操调试明确「条件不满足则报错」的核心逻辑；

2\. **Gas 成本感知**：初期未关注存储成本，通过对比「Storage/Memory 操作的 Gas 差异」理解优化必要性；

3\. **时间单位使用**：掌握 Solidity 内置时间单位（1 days = 86400 秒），无需手动换算，简化时间判断逻辑。

\## 三、后续学习方向

1\. 完善积分合约：增加利息计算逻辑、支持多笔锁仓（当前仅支持一笔）、引入 OpenZeppelin 标准库（如 Ownable）替代自定义权限；

2\. 拓展实战场景：实现代币（ERC-20）的发行、转账功能，理解代币标准的核心逻辑；

3\. 结合前端：用 Rainbow + wagmi 框架实现合约交互，完成 DApp 全流程开发；

4\. 深入隐私与安全：学习 ERC-7962 落地场景、智能合约安全审计基础（如重入攻击、溢出风险）。

\### 总结

本周学习实现了「从理论到实操」的落地，核心掌握 Solidity 基础语法、Gas 优化核心逻辑、智能合约权限与状态管理，通过积分合约的迭代加深了对「链上存储、时间判断、权限控制」的理解。后续需重点强化「标准库使用、前端交互、合约安全」，进一步衔接实际开发场景。
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->



参与 cryptotalk,x space 会议

参加LXDAO周会
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->





今天太忙了,没学但是卡一定要打
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->







![57de7c2c-70ce-4254-b65f-8aca72f2ad3a.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/mengchenxin/images/2026-01-22-1769086070938-57de7c2c-70ce-4254-b65f-8aca72f2ad3a.png)

学完前四节内容,完成
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->









![7274bef1-f130-4ae9-b7f4-071d40cc8b2d.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/mengchenxin/images/2026-01-21-1769001449300-7274bef1-f130-4ae9-b7f4-071d40cc8b2d.png)

坦白说今天啥也没干,主要是去搞这些活动了
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->











# ZKVote 学习报告：基于零知识证明的区块链投票系统实践

## 一、学习背景与目标

### 1\. 背景

传统电子投票系统依赖中心化服务器，存在数据篡改风险、审计依赖专业人员等问题；而基础区块链投票虽实现公开透明与可验证，但投票记录完全公开，地址与投票偏好易被关联，隐私保护不足。ZKVote 平台以 “实践体验 + 原理拆解” 的方式，结合零知识证明（ZKP）技术，构建了隐私友好型区块链投票系统，为解决 “可验证” 与 “匿名性” 的矛盾提供了实操方案。

### 2\. 学习目标

-   亲身体验公开链上投票与 ZK 匿名投票的差异，理解区块链投票的核心优势与隐私痛点；
    
-   掌握零知识证明在投票场景中的应用逻辑，包括证明生成、交易提交、链上验证的全流程；
    
-   理解 ZKVote 系统的核心设计（身份管理、选民集合、防重复投票等），明确零知识证明的技术价值。
    

## 二、核心知识与技术原理

### 1\. 区块链投票的核心特性与隐私困境

（1）区块链投票的优势

-   透明可审计：每笔投票交易记录在链，任何人可查询、复核投票结果，无需依赖第三方；
    
-   不可篡改：区块确认后，投票数据难以被恶意修改，确保投票结果的真实性；
    
-   自动化执行：智能合约自动完成投票计数与结果公示，减少人为干预。
    

（2）传统链上投票的隐私问题

基础链上投票的交易信息（发起地址、投票合约地址、输入数据）完全公开，通过区块浏览器可追溯：

-   某地址的投票次数、参与的提案、具体投票选项；
    
-   若地址与真实身份（交易所账户、社交账号、ENS 等）关联，投票偏好将被泄露，侵犯选民隐私。
    

### 2\. 零知识证明（ZKP）基础

（1）核心定义

零知识证明允许 “证明者” 在不泄露核心秘密（私有输入）的前提下，向 “验证者” 证明某一陈述为真。在投票场景中，陈述为 “我是本次投票的合格选民，且仅投票一次”。

（2）核心角色与概念

-   证明者（Prover）：持有私有秘密（如身份密钥 `identitySecret`），生成零知识证明；
    
-   验证者（Verifier）：通过公开输入与证明，验证陈述真实性，不获取任何私有信息；
    
-   陈述（Statement）：公开可验证的声明（如 “我属于授权选民集合”）；
    
-   见证者（Witness）：使陈述成立的私有输入（如 `identitySecret`、Merkle 路径、投票选项）。
    

（3）三大核心性质

-   完备性：诚实的证明者（合格选民）生成的证明能被成功验证；
    
-   可靠性：恶意证明者（非合格选民或重复投票者）无法伪造有效证明；
    
-   零知识性：验证者仅能确认 “陈述为真”，无法获取任何私有信息（如选民身份、投票选项）。
    

（4）主流方案对比（zk-SNARK vs zk-STARK）

| 维度 | zk-SNARK | zk-STARK |
| --- | --- | --- |
| 证明大小 | 通常更小 | 通常更大 |
| 验证成本 | 通常更低 | 取决于具体实现 |
| 可信初始化 | 通常需要 | 通常不需要（透明化） |
| 典型应用场景 | 适配链上验证 | 大规模复杂计算、对透明性要求高的场景 |

### 3\. ZKVote 系统核心设计

（1）身份管理：身份密钥与身份承诺

-   选民本地生成 `identitySecret`（身份密钥），仅保存在浏览器本地，不上传至链上；
    
-   通过哈希运算将 `identitySecret` 转换为 `identityCommitment`（身份承诺），作为选民在链上的匿名标识，避免真实身份泄露。
    

（2）选民集合：Merkle 树组织

-   所有合格选民的 `identityCommitment` 构成 Merkle 树，Merkle 根存储在智能合约中；
    
-   选民投票时，需提供 Merkle 路径作为 “合格选民” 的证明，确保仅授权用户可参与投票。
    

（3）防重复投票：Nullifier 机制

-   Nullifier（无效化器）由 `identitySecret` 与投票 ID（`electionId`）通过哈希运算生成，公式为：`nullifier = Hash(identitySecret, electionId)`；
    
-   投票后，Nullifier 会被记录在链上，再次投票时，合约将检测到重复的 Nullifier 并拒绝交易，确保 “一人一票”。
    

## 三、ZKVote 实操流程

### 1\. 环境准备

-   连接支持以太坊生态的钱包（如 MetaMask）；
    
-   切换网络至 Sepolia 测试网，并确保钱包内有足够测试 ETH 用于支付 Gas 费。
    

### 2\. 步骤一：体验公开链上投票

-   连接钱包后选择投票选项，提交交易；
    
-   交易公开信息包括：发起地址（`from`）、投票合约地址（`to`）、投票选项（通过输入数据解码可得）；
    
-   核心体验：通过区块浏览器可直接查询到地址与投票偏好的关联，理解传统链上投票的隐私缺陷。
    

### 3\. 步骤二：完成 ZK 匿名投票

（1）生成匿名身份

点击 “Generate anonymous identity”，本地生成 `identitySecret` 与 `identityCommitment`，无需上传链上。

（2）加入投票提案

点击 “Join proposal”，将 `identityCommitment` 注册至选民集合（Merkle 树），完成授权。

（3）生成 ZK 证明与提交投票

-   选择投票选项后，浏览器本地执行证明生成逻辑，输入包括：
    
    -   公开输入：`electionId`（投票 ID）、Merkle 根、Nullifier 哈希；
        
    -   私有输入：`identitySecret`、Merkle 路径、投票选项；
        
-   生成证明后提交交易，链上合约仅验证证明有效性与 Nullifier 唯一性，不解析私有输入。
    

（4）交易确认与结果查看

-   交易上链后，仅公开证明、Merkle 根、Nullifier 等信息，无法还原选民身份与投票选项；
    
-   任何人可验证交易是否成功、Nullifier 是否被标记为已使用，确保投票过程可审计。
    

### 4\. 关键注意事项

-   证明生成在本地执行，耗时 2-5 秒（取决于设备性能），期间需保持页面不刷新，避免丢失本地身份信息；
    
-   若交易长时间未确认，需检查网络是否为 Sepolia、测试 ETH 是否充足，可通过钱包加速或替换交易；
    
-   常见故障排查：页面刷新导致身份丢失、选民数据未同步、设备内存不足等，可通过重新生成身份或刷新同步数据解决。
    

## 四、学习收获与核心结论

### 1\. 核心收获

（1）技术层面

-   明确了 “可验证” 与 “匿名性” 的平衡逻辑：零知识证明让区块链投票在保留 “公开审计” 优势的同时，通过私有输入隐藏选民身份与投票偏好；
    
-   掌握了 ZK 投票的全流程：身份生成→授权加入→本地证明→链上验证→结果审计，理解各环节的核心作用；
    
-   区分了 zk-SNARK 与 zk-STARK 的技术差异，明确不同场景下的方案选择逻辑。
    

（2）实践层面

-   亲身体验了公开投票与匿名投票的差异，直观感受零知识证明的隐私保护价值；
    
-   理解了 ZKVote 系统的工程设计考量，如本地存储身份密钥、Merkle 树管理选民、Nullifier 防重复投票等，为后续相关系统开发提供参考。
    

### 2\. 核心结论

-   区块链投票的核心优势在于透明可验证与不可篡改，但基础方案存在隐私泄露风险，零知识证明是解决该问题的关键技术；
    
-   ZKVote 系统通过 “身份承诺 + Merkle 树 + Nullifier” 的组合设计，实现了 “合格选民验证、防重复投票、隐私保护” 三大核心目标；
    
-   零知识证明的 “零知识性” 确保验证者仅获取 “陈述为真” 的结论，不泄露任何私有信息，为需要隐私保护的场景（如投票、身份验证）提供了可靠解决方案。
    

### 3\. 未来展望

-   ZK 投票技术可进一步应用于 DAO 治理、选举投票等场景，平衡治理透明度与选民隐私；
    
-   未来需优化证明生成效率、降低设备性能要求，同时简化用户操作流程，推动技术规模化落地；
    
-   针对 zk-SNARK 的可信初始化问题，可探索采用 zk-STARK 等透明化方案，提升系统安全性与去中心化程度。
    

## 五、总结

通过 ZKVote 平台的实操学习，不仅深入理解了区块链投票与零知识证明的核心原理，更掌握了 “理论 + 实践” 的技术学习方法。零知识证明作为 Web3 领域的核心隐私保护技术，在投票、身份验证、数据共享等场景具有广泛应用前景。后续需持续关注技术迭代，结合更多实际项目，深化对零知识证明工程化应用的理解。

接下来是小红书版的

# Web3 小白必试！零知识证明投票也太酷了吧✨

作为刚入圈的 Web3 萌新，一直听说零知识证明（ZKP）很牛，但总觉得抽象到看不懂… 直到发现了这个神仙实操平台！手把手体验匿名投票，终于搞懂 ZKP 到底在干嘛了🤯

先吐槽下传统链上投票！之前试过公开投票，交易记录全在链上裸奔，地址和投票选项一眼就能查到，要是地址关联了社交账号，隐私直接归零😱 但 ZK 投票完全不一样！匿名还能验证，安全感拉满～

💻实操流程超简单（小白友好到哭）

1.  连接钱包切换到 Sepolia 测试网，先体验一把公开投票，直观感受隐私泄露的问题
    
2.  生成匿名身份（本地创建 identitySecret，不上链超安全）
    
3.  加入投票提案，把身份承诺注册进选民集合
    
4.  选好选项，本地生成 ZK 证明（也就 2-5 秒，耐心等下～）
    
5.  提交交易，等着区块确认就好啦！
    

✨最神奇的点来了！

交易上链后，别人只能看到证明、Merkle 根这些看不懂的东西，完全猜不到你是谁、投了啥！但又能随时验证投票没被篡改，这就是 “可验证的匿名” 吧👏

终于搞懂 ZKP 的核心逻辑了：

✔️ 证明者：就是我们自己，拿着私密信息生成证明

✔️ 验证者：智能合约，只确认 “你是合格选民 + 没重复投票”，看不到任何隐私

✔️ 三大特性：完备性（合法投票不会被拒）、可靠性（作弊者伪造不了证明）、零知识性（隐私绝不泄露）

还 get 了 zk-SNARK 和 zk-STARK 的区别，前者证明小验证快但需要可信初始化，后者透明化但证明大，各有各的优势～

真心推荐所有 Web3 小白试试！不用写代码，跟着界面点一点，就能直观理解零知识证明的魅力，比看 10 篇理论文都有用！看完终于能跟朋友吹 ZKP 了 hhh

🔗平台地址：[zkvote.0xtmp.xyz](http://zkvote.0xtmp.xyz)

（记得提前准备 Sepolia 测试网 ETH 哦，不然付不了 Gas～）

#Web3 学习 #零知识证明 #ZKP #区块链投票 #Web3 小白教程 #技术实操 #加密货币
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->













# [https://www.wtf.academy/zh/course/solidity101/Function](https://www.wtf.academy/zh/course/solidity101/Function)的二三章

Solidity中的变量类型主要分为值类型、引用类型和映射类型，其中值类型在赋值时直接传递数值，是合约开发的基础。常见值类型包括五大类，各有其特性与适用场景。

布尔型为二值变量，取值仅为true或false，支持逻辑非、与、或及相等性判断等运算符，且逻辑与（&&）和逻辑或（||）遵循短路规则，可优化运算效率。整型分为带符号（int）和无符号（uint）两类，常用uint256类型，支持加减乘除、取余、幂运算及比较运算符，满足数值计算需求。地址类型含普通地址（address）和可支付地址（payable address），后者额外具备转账和查询余额的方法，是ETH转账场景的核心类型。定长字节数组（如bytes1、bytes32）长度不可变，最多存储32字节数据，可通过下标访问单个字节。枚举（enum）为用户自定义类型，本质是为uint值分配名称，提升代码可读性，但实际应用中较为冷门。

函数是Solidity实现复杂操作的核心，其声明格式包含多种关键字，需明确可见性、功能权限等属性。函数可见性分为四类：public内外均可见，private仅本合约可访问，external仅外部可访问（_内部需通过this调用_），internal可在本合约及继承合约中使用，且合约函数必须显式指定可见性。

**pure和view关键字是Solidity的特色，核心作用是减少Gas消耗，二者均不修改链上状态，用户直接调用无需支付Gas。**其中view函数可读取但不能改写状态变量，类似“看客”；pure函数既不能读取也不能改写状态变量，仅可处理输入参数的纯计算。payable关键字标识可接收ETH的函数，支持在调用时向合约转入ETH，常用于支付相关场景。此外，virtual关键字允许函数被继承合约重写，override关键字则标识重写父合约的函数，适配面向对象开发需求。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->














# 今天刚刚接触solidity语言,以下是我的主要两点感受

-   **入门友好但进阶有门槛**：Solidity 语法贴近 JavaScript/TypeScript，对有前端或后端基础的开发者来说，写简单合约（如计数器、转账）很容易上手；但一旦涉及链上安全、gas 优化、底层原理（如存储布局、ABI 编码），就需要深入理解区块链特性，进阶门槛明显高于普通编程语言。
    
-   **安全是核心生命线**：不同于传统代码，Solidity 合约部署后无法修改，一个微小的漏洞（如溢出、重入、权限问题）可能导致资产损失，这让编写时必须极度谨慎 —— 既要依赖语言本身的安全特性（如 0.8.x 自动溢出检查），也要掌握审计思维，这是 Solidity 最独特也最考验开发者的点。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->















# 区块链核心基础与关键原理

1.  区块链的诞生源于对分布式系统难题的突破。CAP 定理指出，分布式系统需在一致性、可用性、分区容错性中三选二，而区块链需优先保障分区容错性。同时，拜占庭将军问题揭示了恶意参与者存在时的共识困境，而中本聪 2008 年推出的比特币，通过创新组合技术，首次实现了拜占庭容错、无许可、去中心化的系统。
    
2.  区块链的核心是共识机制与加密原语的结合。共识机制方面，工作量证明（POW）要求矿工通过算力竞争生成区块，权益证明（POS）则以代币质押为核心，两者均通过经济成本遏制恶意行为。加密原语包括哈希函数（保证数据完整性，具有确定性、不可逆性和雪崩效应）、数字签名（实现无秘密共享的身份验证）、默克尔树（高效验证交易存在性），三者协同构建可信数据体系。
    
3.  区块链面临 “三难问题”，需在安全性、可扩展性、去中心化中权衡，比特币优先保障前两者。其核心价值在于创建无需信任的系统：哈希防篡改、签名验授权、默克尔树提效，结合共识机制，让每个参与者可独立验证系统历史，无需依赖中心化权威，成为数字经济的重要基础设施。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
















# 比特币白皮书一

## 诞生背景

## 2008 年全球金融危机后，传统金融的问题暴露无遗：

-   转账要靠银行、支付宝这些 “中介”，手续费高还可能被冻结
    
-   交易可被篡改（比如银行协调退款），商家怕欺诈、买家怕跑路
    
-   小额支付不划算（手续费比金额还高），跨境转账要等好几天
    

## 核心困难与突破

### 最核心的突破：解决 “双重支付” 难题

数字钱最麻烦的就是 “一笔钱花两次”（比如复制文件一样复制比特币），白皮书用两大设计搞定：

1.  **分布式账本（区块链）**
    
    所有交易公开广播，全球节点一起记账，形成唯一的交易历史。想改记录？得同步改全网所有节点的账本，几乎不可能。
    
2.  **时间戳 + 工作量证明（PoW）**
    

-   每 10 分钟把交易打包成 “区块”，打上时间戳，还包含上一个区块的哈希值，像锁链一样串起来
    
-   矿工要算复杂数学题（找满足条件的哈希值）才能打包区块，算出来才能拿奖励。想篡改旧区块？得重算这个区块 + 后面所有区块的题，成本高到离谱。
    

## 比特币怎么交易？

比特币没有 “账户余额”，而是用 “未花费交易输出（UTXO）” 记录：

-   比如你收到 1 个 BTC，这就是 1 个 UTXO；你转账 0.5 个 BTC，就把这个 UTXO 拆成 “0.5 给对方 + 0.5 找零给自己”
    
-   每笔交易都要私钥签名，证明你是 UTXO 的合法拥有者，别人没法冒领
    
-   所有 UTXO 都在链上可查，确保没人重复花同一笔钱
    

## 矿工

矿工是网络的 “守护者”，白皮书设计了明确奖励：

-   **区块奖励**：每挖出一个区块给新比特币，初始 50 BTC，每 4 年减半（2024 年已减到 3.125 BTC），总发行量固定 2100 万，永远不会通胀
    
-   **交易手续费**：用户转账时自愿加手续费，手续费高的交易优先被打包，矿工也能赚这笔钱
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

















[https://www.bilibili.com/video/BV1gCJ8zNELv/?spm\_id\_from=333.788.top\_right\_bar\_window\_history.content.click&vd\_source=b65fb6471899fe6858fba22e46841906](https://www.bilibili.com/video/BV1gCJ8zNELv/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=b65fb6471899fe6858fba22e46841906)

今天看了ETHpanda Talk,原来都是布老师的系列阿.布老师可以的,一个人撑着一个系列

以下就是我对内容的总结

1.  以太坊核心工作与技术相关：合并过程中最大挑战是整合多参与者与客户端；Deposit Contract 部署有防欺诈的地址彩蛋，合并命名灵感源自《七龙珠》融合形象；路线图由核心团队提出并结合社区反馈调整，EIP 需经 ACDC 会议讨论与社区共识推进，其中 EIP7702 意义重大，解锁 AA 账户抽象设计但需平衡创新与安全；分片旨在解决扩展性问题，Layer2 网络层测试与优化是当前重要挑战。
    
2.  生态与社区发展：亚洲开发者社区在产品打造、用户体验及新人推广上具优势，欧美则在研究底蕴上更深厚；身份认证、社会图谱、RWA 等领域有望成为应用爆发点；成功社群需具备持续吸纳新人、传递开放合作精神的特质。
    
3.  以太坊基金会运营：近期进行组织架构调整，成立董事会、管理层及多个事业集群，设 Communication 部门负责对外宣传而非独立营销团队；ESP 支持范围广泛，注重社会影响力相关倡议；通过引入外部专家咨询、举办互动活动等聆听社区声音；资金运营拟探索借贷、Staking、RWA 等多元收益方式，减少公开卖币对市场的影响，未来若有替代实体出现可能收缩角色。
    
4.  个人感悟与建议：认为选择比努力重要，建议新人加入以太坊等社群活跃、互助性强的生态；推荐《原则》一书，强调建立个人行事准则的重要性；工作之余喜欢宅家看剧、下西洋棋，因工作繁忙休闲时间大幅减少。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->


















# unphishable

今天主要是刷题

了解各种钓鱼攻击 坦白说感觉挺有意思的,感觉就像魔术一样,虽然过程是假的,但是结果是真的
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



















# 开头来个自白,坦白说今天没怎么学文档,主要是去了解了RWA是什么东西

## 核心逻辑:现实资产→链上代币

比如一套 100 万的房子，通过 RWA 能拆成 10000 个代币，每个代币 100 元！你买 10 个就能拥有房子 0.1% 的所有权，每月还能按比例拿租金，想卖随时在链上交易，再也不用等几个月找买家

-   **核心目标**：打破传统资产 “高门槛、低流动” 的痛点，让全球资产能跨地域、全天候流通
    
-   **覆盖资产**：超广！从房地产、美国国债、大宗商品，到知识产权、应收账款、艺术品都能做
    

## 为什么 RWA 火了？3 大优势太香了

1.  **投资门槛直接砍半**
    
    传统买写字楼要几百万，RWA 拆分后几百块就能上车（比如 RealT 平台的美国房产代币，最低 50 美元起投），学生党、小白也能参与优质资产
    
2.  **流动性直接拉满**
    
    房产交易从 3 个月缩短到几小时，国债、债券能 7×24 小时链上交易，再也不用 “急用钱却卖不掉”
    
3.  **透明又省心**
    
    资产确权、交易记录全在区块链上，不可篡改还能实时查；租金、利息靠智能合约自动发放，不用盯中介、催回款
    

## 但是凡是都是有风险的

-   **合规是红线**：国内明确禁止未经批准的代币发行，参与海外项目要查监管资质（比如香港、欧盟的合规平台）
    
-   **价值锚定要盯紧**：代币价值靠现实资产支撑，要是资产估值不准、托管机构跑路，代币可能变 “空气”
    
-   **流动性≠万能**：小众资产（比如单个艺术品）就算代币化，没人买还是卖不掉，优先选国债、热门房产这类高需求资产
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->




















了解了区块链是什么,什么是比特币,以及相关的核心组成运转逻辑

公联私链联盟链的区别

![10296bad-d877-48e3-9eea-ee1c927d100d.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/mengchenxin/images/2026-01-12-1768223884618-10296bad-d877-48e3-9eea-ee1c927d100d.png)

以太坊概览,layer1和layer2之间的区别

我想了解web3需要学习的相关技术是哪些

然后对于运营技术双修的同学有什么需要注意的事项
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
