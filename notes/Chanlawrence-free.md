---
timezone: UTC+8
---

# Chanlawrence-free

**GitHub ID:** Chanlawrence-free

**Telegram:** @CharlieChan_hi

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->
## Introduction｜今天完成了什么 (Overview)

你今天的成果可以拆成 3 条主线（three tracks）：

1.  **宣发海报设计（Promo Poster Design）**：完成了活动/项目宣发海报的视觉输出。
    
2.  **小组讨论赛道与方向（Track Ideation Discussion）**：围绕黑客松三个指定赛道，讨论最基础但可落地的项目想法。
    
3.  **写出一个“极强可执行的 Prompt”（Execution-ready Prompt）**：核心目标是让 AI 输出 **2–3 天内可做出 Demo 的项目 idea**，并且每个 idea 必须有完整**逻辑闭环（logic loop）+ 产品闭环（growth loop）**，哪怕是“伪需求（pseudo-demand）”也没问题，只要**评委一眼懂、能演示、能交付**。
    

此外，你还补充了一条现实进展：

-   你用 **Google AI Studio** 做了一个小 demo（mini demo / prototype），说明你们具备最小 AI 工作流跑通的能力（minimum AI workflow capability）。
    

* * *

## Foundations｜基础篇：你的团队背景与目标边界 (Team Context & Constraints)

你写得非常明确：团队不是“高端开发者（advanced devs）”，时间也很紧（tight timeline）。因此你要的不是“改变世界的刚需”，而是：

-   **低门槛（low barrier）**
    
-   **技术难度低（low technical complexity）**
    
-   **2–3 天能做出可演示 Demo（demo-able in 2–3 days）**
    
-   **有逻辑闭环 + 产品闭环（logic loop + product loop）**
    
-   **创意新颖（novelty / wow factor），评委眼前一亮（judge-friendly）**
    
-   **即使是好玩/伪需求也可（fun / pseudo-demand acceptable）**
    

这其实是一种非常成熟的黑客松策略（Hackathon strategy）：

> **宁愿做小而完整（small but complete），不要大而空（big but vague）。**

* * *

## Core Concepts｜进阶篇：你这段 Prompt 的“核心要求”拆解 (Core Requirements)

你列了 5 条重点要求（must-have requirements），每条都很“可验收（testable）”。

### 1) 不追求完美真实需求（Don’t chase “real-world perfection”）

-   你明确拒绝“我们普通人根本解决不了”的大需求（huge hard problems）。
    
-   要求 **想法新颖（novel）**、**年轻人脑洞（youthful creativity）**、评委看了“哇”（wow moment）。
    

### 2) 必须是完整可落地产品（Must be shippable）

-   必须“看得见摸得着”（tangible）
    
-   有明确意义（clear meaning）
    
-   有完整使用逻辑和操作流程（clear user journey / flow）
    
-   不能做一半卡壳（no half-baked / stuck mid-way）
    

### 3) 拒绝不切实际的宏大叙事（No “save the world” fantasies）

-   低门槛、易实现（easy to build）
    
-   普通团队短时间能搞定（small team, short time）
    

### 4) 贴合 Web3 核心特性 + 紧扣赛道（Web3-native + track-aligned）

-   Web3 功能要 **简单易懂（simple & explainable）**
    
-   合约尽量简化（minimal smart contract）
    
-   必须紧扣主办方赛道要求（track compliance）
    

### 5) 每个 idea 必须“完善到可直接开工”（Detailed, actionable)

你要求每个 idea 必须写清楚：

-   **产品核心玩法（core gameplay / flow）**
    
-   **Web3 结合点（Web3 integration point）**
    
-   **逻辑闭环（logic loop）**
    
-   **产品闭环（product loop / growth loop）**
    
-   **实现步骤（implementation steps）**
    
-   **所需技术（tech stack）**
    
-   **演示亮点（demo highlights）**
    
-   **MVP 范围（MVP scope）**
    
-   **风险与备选方案（risks & fallback plan）**
    

这等于把“灵感”强制落到“交付工程（delivery engineering）”。

* * *

## Core Concepts｜进阶篇：指定赛道（Tracks）你要 AI 结合生成

你要求 AI 输出时必须结合这 3 个指定赛道（specified tracks）：

1.  **Kite AI - 支付（Payment Track）**
    
    -   核心关键词：payment / stablecoin / checkout / 收款支付 / on-chain settlement
        
2.  **SpoonOS - LLM 应用（LLM Application Track）**
    
    -   核心关键词：LLM workflow / agent / tool use / prompt pipeline / 应用链路跑通
        
3.  **OGBC × ScalingX - 预测市场（Prediction Market Track）**
    
    -   核心关键词：prediction / market / odds / outcome / 结算 / 可视化 / 轻索引
        

你同时强调：

-   Web3 部分要“最小上链（minimum on-chain proof）”
    
-   AI 部分要“最小可用（minimum viable AI）”，只要能跑通一个 workflow/agent 链路即可。
    

* * *

## Advanced Applications｜高阶篇：你规定的“输出格式模板”其实是任务拆解器 (Output Format as Task Decomposer)

你要求输出**必须严格按这个格式**，这点非常关键，因为它让 AI 输出可以直接变成你们的 team task board（任务板 / backlog）。

### A) 先给一个总览表（Overview Table）

字段必须包含：

-   **idea名称｜适配赛道｜一句话亮点｜预计完成时间（1天/2天/3天）**
    

这个表的作用是：先做 **scope estimation（范围评估）** 与优先级排序（prioritization）。

### B) 每个 idea 必须包含 9 个小标题（9 Required Sections）

你要求“一个都不能少”，我按你的原意列出并补充英文对照（中英穿插）：

1.  **产品核心玩法（Core Gameplay）**
    
    -   用户打开后怎么玩，**3–6 步**写清楚（clear steps）
        
2.  **Web3 结合点（Minimal Web3 Hook）**
    
    -   最小链上功能：发 NFT / 链上记录 / 链上支付 / 查询链上数据等
        
    -   要求：越简单越好（keep it simple）
        
3.  **逻辑闭环（Logic Loop）**
    
    -   为什么用户会一直玩/一直用（why repeat usage happens）
        
4.  **产品闭环（Product Loop / Growth Loop）**
    
    -   从获客 → 使用 → 留存/分享 → 再回来（acquisition → activation → retention/sharing → return）
        
5.  **实现步骤（Implementation Checklist）**
    
    -   按模块拆：**前端/后端/链上/数据源/AI 模块**
        
    -   给到可执行清单（actionable checklist）
        
6.  **所需技术（Tech Stack, beginner-friendly）**
    
    -   你倾向：Next.js/React、钱包连接、现成 SDK、测试网、托管平台
        
    -   目标：新手友好（beginner-friendly）
        
7.  **演示亮点（Demo Highlights）**
    
    -   Demo Day 5 分钟怎么秀
        
    -   最抓眼球的 1–3 个镜头（1–3 wow shots）
        
8.  **最小可行版本 MVP 范围（MVP Scope）**
    
    -   必须做什么 / 可以不做什么（must-have vs nice-to-have）
        
    -   目的：避免踩坑（avoid scope creep）
        
9.  **风险与备选方案（Risks & Fallback Plan）**
    
    -   链上/支付/数据源卡住如何降级（degrade gracefully）
        

* * *

## Advanced Applications｜高阶篇：额外限制（Hard Constraints）= 你们的“生存策略”

你写的额外限制非常像“交付护城河（delivery guardrails）”，我逐条保留：

-   每个 idea 保证 **2–3 天内能做出可演示 Demo**
    
-   链上部分尽量 **最小上链**：能证明用到 Web3 即可（proof-of-web3）
    
-   AI 部分 **最小可用**：能跑通一个 workflow/Agent 链路即可（no training / no heavy infra）
    
-   要“年轻人脑洞 + 可见可摸 + 有趣 + 评委一眼懂”
    
-   禁止抽象空谈，必须给“照着做就能做”的落地细节（no hand-wavy ideas）
    

* * *

## Practical Note｜你已经做出的进展：Google AI Studio 小 Demo

你最后补了一句：“用 Google AI studio 做了一个小 demo”。这句信息很重要，因为它意味着：

-   你们已经完成至少一次 **prompt → model output** 的最小闭环（minimum inference loop）
    
-   后续只需要把这个能力“嵌入产品流程（embed into product workflow）”，就能满足 SpoonOS/LLM Track 的“最小可用 AI”要求
    
-   对你们这种时间紧的团队来说，这是非常关键的“确定性（certainty）”
    

* * *

## Summary & Vocabulary｜关键术语回顾（中英穿插）

### 一句话总结（One-liner）

你今天把黑客松最关键的一步做对了：不是先做大，而是先把“**可交付的 idea 输出模板（deliverable idea template）**”写出来，强制每个想法具备 **闭环（loop）+ 可落地（buildable）+ 可演示（demo-able）**。

### Vocabulary（你这段素材里的高频词）

-   宣发海报：Promo Poster
    
-   赛道：Track
    
-   想法：Idea / Concept
    
-   可落地：Shippable / Buildable
    
-   逻辑闭环：Logic Loop
    
-   产品闭环：Product Loop / Growth Loop
    
-   最小上链：Minimum On-chain Proof
    
-   最小可用 AI：Minimum Viable AI (MVA)
    
-   任务拆解：Task Breakdown / Checklist
    
-   风险降级：Fallback / Degradation Plan
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->

一、今日完成核心任务

1\. 小组海报设计：成功完成组内海报设计工作，成果获得认可，个人收获强烈的成就感，进一步激发了学习与实践的动力。

二、工具学习与核心感悟

1\. Figma工具深度应用：

◦ 本次设计让我深刻意识到熟练掌握Figma的重要性，其功能丰富且实用，需持续深入学习。

◦ 重点关注到的Figma功能：Draft（草稿）模式、Figma Make（生成的二维码可直接扫描，实用性强）、Figma Site、Figma Bots等，后续需系统梳理各功能的应用场景，强化实操熟练度。

2\. 核心感悟：工具是提升设计效率与成果质量的关键，深耕Figma的各类功能，能为后续设计工作赋能，需持续投入时间打磨工具使用技能。

三、知识输入与积累

1\. 黑客松相关分享学习：今日聆听多场分享，其中Hard Man老师关于Web Coding与黑客松的经验分享极具价值。

2\. 后续计划：将回看该分享的回放，深入吸收核心知识点，为即将参与的黑客松做好知识储备。

四、明日规划与动力

1\. 正式启动黑客松相关工作，以今日的成就感为动力，延续积极的学习状态。

2\. 带着Figma的实操经验与分享会的知识积累，高效推进黑客松任务，继续加油！
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->



今天忙着搬家特别忙碌，没来得及好好静下心学习，晚上7点多忙完回来，第一时间跟进同步了设计相关进度，目前已经完成了GitHub头图（banner图）的设计，还有kick off的海报设计也顺利搞定。

今天也有特别深的感悟和收获，选定一个行业之前一定要看清楚、了解透彻，一旦做出选择就要坚定坚守、深耕下去，不能因为累了就轻易放弃或者换来换去，既然我选择了Web3这条赛道，今后就会坚定的一直走下去。

还有一段很实在的感悟想记录下来，千万不要在金钱面前考验人性，尤其是当下的现实社会，没有人能经得起这样的考验；也尽量不要和亲近的人，比如家人、朋友之间发生利益相关的冲突，一旦牵扯到利益，很容易翻脸不认人，珍惜身边纯粹的关系才最难得。
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->




今日角色

担任设计组协调小组长，主要负责设计组的协调对接工作。

核心工作内容

1\. 黑客松搭建运营流程梳理：和团队一起在 Notion 里把黑客松搭建、运营的全流程理清楚了，流程更清晰可控。

2\. 设计需求管理：专门整理了一份设计需求列表，把要做的设计相关工作列得明明白白，包含这些信息：

◦ 物料名称

◦ 优先级

◦ 负责人

◦ 截止时间

◦ 使用场景

◦ 尺寸格式

◦ 必要的信息链接

今日感悟

进度可视化真的太重要了！现在工作推进起来更有方向，后续继续努力学习协调和管理相关的技巧。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->





1:今天主要学习了figma；然后做了两个海报，

2:听了Speedrun Basic wrokshop

3:在co-learning问了echo老师有关Web3问题
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->






## Introduction｜这张图到底在讲什么 (Overview)

你要理解的核心，你原文已经给了一句非常到位的总结：

> 这不是“一个系统”，而是 两条数据世界同时存在（two data worlds co-exist）：
> 
> **Off-chain（链下）**：数据库 + 后端服务
> 
> **On-chain（链上）**：区块链状态 + 合约

再用 First Principles（第一性原理）再压缩一句（保留你原意）：

> dApp = Web2 App（前后端 + DB） + Web3 Gateway（Wallet + RPC + Blockchain）
> 
> 前端负责 **User Interaction + Wallet Signing**，后端负责 **Business Logic + DB + Verification**，RPC 负责 **forward requests to nodes**。

* * *

## Foundations｜基础篇：先把“图里有哪些东西”一一对上号 (Element Map)

你读图列出的元素我按“从左到右”整理，并保留你给的例子与技术栈：

### 1) 左边：Relational Database（关系型数据库）

-   你图里写的是 **relational database（关系型数据库）**
    
-   有 `users(table)`，你举的 SQL 例子是：
    
    `select name from users where id=2 => luna`
    

这告诉我们数据库负责的是典型 Web2 数据：

-   用户系统（users）
    
-   配置、偏好（preferences）
    
-   任务记录、积分（points）
    
-   任何“不想上链/不适合上链”的数据
    

✅ 关键点（你也强调了）：数据库的优势是 **query 快（fast query）、成本低（low cost）、可修改（mutable）**。

* * *

### 2) 中间：Server（服务器）= Backend（后端服务）

你图里写得很明确：

-   框架：`nextjs / hono`
    
-   部署环境：`Vercel / VPS etc.`
    
-   服务器里有 **backend（后端）**
    
-   后端用 `viem / ethersjs` 去做链上交互（on-chain interaction）
    

这意味着：你这套 dApp 不只是“前端直连链”，而是一个典型的 **hybrid architecture（混合架构）**。

* * *

### 3) 右边：User Browser（用户浏览器）= Frontend（前端应用）

你图里写：

-   框架：`react / tanstack router / nextjs`
    
-   Web3 库：`viem / wagmi` 做钱包连接与链交互（wallet connection + chain interaction）
    

✅ 关键点：Web3 前端和 Web2 前端技术栈“几乎一样”，区别在于：多了 **Wallet（Signer）** 和链交互 SDK。

* * *

### 4) 中间下方：RPC（JSON-RPC Provider）

你图里标注：

-   `jsonrpc: nodereal/ankr/infura`
    

这意味着 RPC 在这里特指：

-   以太坊生态最常见的 **JSON-RPC endpoint（节点接口地址）**
    
-   这些（NodeReal/Ankr/Infura）是 **RPC Provider（节点服务商）**
    

* * *

### 5) 最下：Blockchain（区块链）

-   你图里写的 **blockchain**
    
-   这是“真正执行 EVM（EVM execution）并维护状态（state）”的地方：
    
    -   合约代码（contract code）
        
    -   合约状态（contract state）
        
    -   交易与事件（transactions & events/logs）
        

* * *

## Core Concepts｜进阶篇：两条管道（Two Pipelines）= HTTP vs JSON-RPC

你原文有一个非常强的结构：

-   **HTTP 管道**：Browser ⇄ Backend（传统 Web2）
    
-   **JSON-RPC 管道**：Frontend/Backend ⇄ RPC ⇄ Blockchain（Web3）
    

我把它写成“你看图就能复述”的版本：

### Pipeline A：HTTP（Web2 Data Plane）

-   **前端 ↔ 后端**：`http`
    
-   典型内容：
    
    -   登录、用户信息（auth + user profile）
        
    -   读取数据库（SQL/ORM）
        
    -   产品业务逻辑（business logic）
        

### Pipeline B：JSON-RPC（Web3 Chain Plane）

-   **前端/后端 ↔ RPC**：`jsonrpc`
    
-   **RPC ↔ blockchain**：节点执行并返回
    
-   典型内容：
    
    -   读链：`eth_call / eth_getBalance / eth_getLogs ...`
        
    -   写链：`eth_sendRawTransaction`（发送已签名交易）
        

* * *

## Core Mechanism｜核心机制：RPC 到底是什么 (RPC Explained Properly)

你素材里已经给了很准确的定义，我保留并补全它“概念层 + Web3 具体层”：

### 1) RPC 的概念（General RPC）

**RPC = Remote Procedure Call（远程过程调用）**

意思是：你在本地想“调用远程机器上的一个函数（procedure）”，通过 RPC 发请求、拿结果。

### 2) Web3 里常说的 RPC（Ethereum JSON-RPC）

在 Web3，远程机器通常是 **区块链节点 Node**，调用的函数是一套标准方法（methods）：

-   `eth_call`：只读模拟执行（read-only simulation）
    
-   `eth_getBalance`：查余额
    
-   `eth_getBlockByNumber`：查区块
    
-   `eth_getLogs`：查事件 logs
    
-   `eth_sendRawTransaction`：发送已签名交易
    
-   `eth_getTransactionReceipt`：查回执（receipt）
    

因此你原文这句话很关键：

> RPC 不是区块链本身（RPC ≠ blockchain），它是“通往链的门（Gateway / Endpoint）”。

### 3) RPC 通常长什么样（What it looks like）

它往往就是一个 URL：

-   `https://...`（HTTP endpoint）
    
-   `wss://...`（WebSocket endpoint）
    

前端或后端拿着这个 URL，通过 JSON-RPC 标准发请求。

### 4) 一个超关键点（你也点到了）

> RPC 不替你签名（RPC doesn’t sign for you）。
> 
> 签名（Sign）发生在：

-   用户钱包（MetaMask 等）
    
-   或服务器的 signer（如果你做 relayer/admin tx）
    

RPC 只是：

-   转发（forward）
    
-   查询（query）
    
-   返回结果（return response）
    

* * *

## Advanced Applications｜高阶篇：每个盒子“到底负责什么”（Role Map）

你原文已经写了 Role Map，我完整保留并按学习路径做更系统的落地化：

### A) Frontend（浏览器前端）— 用户体验层 (UX Layer)

-   框架：`React / Next.js / TanStack Router`
    
-   Web3 库：`wagmi / viem`
    
-   职责（你原文关键词 + 英文术语保留）：
    
    -   UI/状态管理（**UI State**）
        
    -   连接钱包（**Wallet Connection**）
        
    -   发起只读查询（**Read Call / eth\_call**）
        
    -   发起交易请求（**Send Transaction**）→ 让钱包签名（**Sign**）
        

✅ 你强调的关键点我原样保留：

**Private Key（私钥）只应该在钱包里**。前端只能“请求签名（request signature）”，不能拿私钥。

* * *

### B) Backend（服务器后端）— 业务与数据层 (Business + Data Layer)

-   框架：`Next.js API routes / Hono`
    
-   Web3 库：`ethers.js / viem`
    
-   职责（你原文列的我全部保留）：
    
    -   业务逻辑（**Business Logic**）
        
    -   数据库 CRUD（**CRUD / SQL**）
        
    -   服务器侧读链（**Server-side Read**）
        
    -   校验（**Verify Tx / Verify Signature**）
        
    -   可选：用服务器 key 发系统级交易（**Admin Tx / Relayer**）
        
    -   适合存：API keys、RPC keys、DB 密码（secrets）
        
    -   适合做：风控/权限/限流（**Rate Limit**）、缓存（**Cache**）
        

✅ 你那句“很产品”的总结我也保留：

**链负责可信状态（trust），后端负责可用体验（usable product experience）。**

* * *

### C) Relational DB（关系型数据库）— 链下存储 (Off-chain Storage)

你原文强调：

-   不是所有数据都要上链（not everything should be on-chain）
    
-   上链贵、慢、不可随意改（expensive/slow/immutable-ish）
    
-   DB 便宜、快、灵活（cheap/fast/flexible）
    

这就是典型的 **On-chain minimalism（链上极简）** 思路：

只把“必须可验证（verifiable）”的放上链，其余留在 off-chain。

* * *

### D) RPC（JSON-RPC Gateway）— 节点入口

你图里例子：`nodereal / ankr / infura`

它提供现成节点能力，你不用自建 full node。

* * *

### E) Blockchain（链）— 状态机与共识执行 (State Machine + Consensus)

-   执行 EVM（EVM Execution）
    
-   存合约代码与状态（Contract Code & State）
    
-   打包确认交易（Validation / Finality）
    

* * *

## Advanced Applications｜高阶篇：两条“生命线”用户路径（Read vs Write）

你原文说“读和写是 dApp 的生命线”，我完全同意，也按你的写法保留：

### Path 1：Read / Call（只读查询）—— 通常不花 gas

例子：用户读 `retrieve()` 值：

**Frontend → RPC → Blockchain → RPC → Frontend**

-   前端 `viem` 发 `eth_call`
    
-   RPC 去节点模拟执行（simulate）
    
-   返回结果给前端显示
    

📌 你补充的关键点保留：很多 dApp 读链不一定需要后端（frontend can read directly）。

* * *

### Path 2：Write / Transaction（写入交易）—— 签名 + gas

例子：用户执行 `store(123)`：

**Frontend → Wallet（Sign）→ RPC → Blockchain → Receipt → Frontend**

-   wagmi 发起 `writeContract`
    
-   钱包弹窗确认（Approve/Confirm）
    
-   钱包签名（sign tx）
    
-   RPC 发送 signed tx
    
-   链执行后返回 tx hash / receipt / events
    

📌 关键点（你原文保留）：写入必须签名（Sign），通常由用户钱包完成。

* * *

## Why Backend?｜为什么还要后端？（你原文的“很产品答案”）

你写得非常全面，我把它结构化成“链做不了/不适合做的事”：

Backend 适合做（你原文 1~6 全保留）：

1.  用户系统：登录、资料、偏好（DB）
    
2.  权限/风控：Auth / RBAC
    
3.  聚合数据：链上 + 链下合并（Aggregation）
    
4.  验证：
    
    -   Signature Verification
        
    -   Tx Receipt Check
        
5.  性能：缓存 RPC 结果（Cache），降低 RPC 成本
    
6.  索引/事件同步：监听 events 写入 DB（Indexing）
    

✅ 你那句总结非常强：

**链负责可信状态（trust），后端负责可用体验（product usability）。**

* * *

## Libraries｜viem / ethers.js / wagmi 各自做什么（按你图里写法整理）

你原文写：

-   **viem / ethers.js**：链交互 SDK（读写合约、ABI 编码、解析 logs）
    
-   可在前端/后端都用（works on both sides）
    
-   **wagmi**：更偏前端的钱包交互层（wallet UX layer）
    
    -   connect wallet / switch network / sign message / write contract
        
-   底层常配合 viem（wagmi + viem pairing）
    

* * *

## Self-Debug Checklist｜看到任何 dApp 图都能自检的 6 问（你原文保留）

你给的 6 个词自检非常好，我原样保留：

1.  **Where is the User?**（Browser / App）
    
2.  **Where is the Wallet?**（Signer 在哪里）
    
3.  **Where is the RPC?**（链入口是谁）
    
4.  **What is On-chain?**（必须上链的数据/逻辑）
    
5.  **What is Off-chain?**（数据库、业务、权限、缓存）
    
6.  **Read vs Write**（call 不签名/不改状态；tx 要签名/改状态/花 gas）
    

* * *

## Summary & Vocabulary｜总结与术语表 (Key Terms Review)

### 一句话总结（One-liner）

这张图告诉你：一个 dApp 同时活在 **Off-chain（DB+Backend）** 和 **On-chain（Contract+State）** 两个世界里，用户既会走 **HTTP** 管道（Web2），也会走 **JSON-RPC** 管道（Web3），而 RPC Provider（NodeReal/Ankr/Infura）是你连接区块链节点的“门”。

### 术语表（Vocabulary）

| 中文 | English | 你在图里对应的位置 |
| --- | --- | --- |
| 关系型数据库 | Relational Database | 左侧 users(table), SQL |
| 服务器 | Server | 中间 nextjs/hono, Vercel/VPS |
| 后端 | Backend | Server 内部，viem/ethersjs |
| 浏览器 | User Browser | 右侧，React/TanStack/Next |
| 钱包连接 | Wallet Connection | 前端 wagmi/viem |
| 远程过程调用 | RPC (Remote Procedure Call) | 中下，jsonrpc providers |
| JSON-RPC | JSON-RPC Methods | eth_call / sendRawTx 等 |
| 区块链 | Blockchain | 最下，EVM 执行与状态 |
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->







## Introduction｜今天学到的核心是什么 (Overview)

你今天的学习可以浓缩成一句话：

> 你跑通了 DApp 的最小闭环（minimum viable loop）：
> 
> **写合约（Solidity）→ 编译（Compile）→ 部署（Deploy）→ 生成合约地址（Contract Address）→ 用不同账户调用（Call/Tx）→ 理解它和 API/ABI 的差异**

更具体一点，你重点掌握了：

-   Remix 部署面板里 **Environment / Account** 到底在控制什么
    
-   “部署会生成合约地址”到底意味着什么（what actually happens)
    
-   合约地址与钱包地址虽然长得像（都 `0x...`），但“物种不同”（different entities）
    
-   API / ABI 在 Web2 vs Web3 里为什么不一样（why the interface differs）
    

* * *

## Foundations｜基础篇：今天你在 Remix 里做的到底是什么 (What you actually did)

### 1) 你学的不是“点按钮”，而是“链上执行模型 (on-chain execution model)”

Remix 里看似只是几个按钮：Compile、Deploy、store、retrieve。

但每一步都对应链上真实概念：

-   **Compile（编译）**：Solidity → **Bytecode（字节码）+ ABI（接口说明）**
    
-   **Deploy（部署）**：发送一笔 **Transaction（交易）**，把 bytecode 写到链上 → 生成 **Contract Address（合约地址）**
    
-   **Interact（交互）**：
    
    -   `store()`：写入 → transaction（上链、改状态、花 gas）
        
    -   `retrieve()`：读取 → call（通常不改状态、可本地模拟）
        

> 你今天“主要学习 Remix 的部署原理”，本质就是在理解“代码怎么从编辑器变成链上的可执行实体（from source to on-chain instance）”。

* * *

## Core Concepts｜进阶篇：Remix 部署面板三要素（Environment / Account / Contract）

你提到“部署的环境啊、账号啊”，我把它们按\*\*控制变量（control variables）\*\*来解释：你在 Deploy 面板上其实在选择“谁在什么地方做什么事”。

### 1) Environment（环境）= 你把合约部署到哪里 (Where you deploy)

在 Remix 里常见两类：

### A) Remix VM（JavaScript VM / Remix VM Osaka 等）

-   本质：Remix 在浏览器里模拟的一条“本地区块链（local simulated chain）”
    
-   特点：
    
    -   快（fast）
        
    -   免费（free）
        
    -   用假币（fake ETH）
        
    -   适合学习与调试（learning/debugging）
        

你今天学到的“部署原理”用 VM 就足够，因为链上规则是同一套，只是环境不是真实主网。

### B) Injected Provider（MetaMask）

-   本质：连到真实链或测试网（real chain/testnet）
    
-   特点：
    
    -   真实签名（real signing）
        
    -   真实费用（real fee / testnet fee）
        
    -   全世界可见（publicly visible）
        

> 所以 Environment 决定：你在“单机练习模式（offline sandbox）”还是“联网真实世界（live network）”。

* * *

### 2) Account（账号）= 谁来发起部署与调用 (Who initiates)

你提到“账号”，这里的核心是：

-   **在区块链里，只有账户（EOA）能主动发起交易（initiate transactions）**
    
-   所以你在 Remix 选 Account，本质是在选“发起者（sender / msg.sender）”
    

Remix VM 给你很多账户，其目的就是让你模拟多人场景（multi-actor simulation）：

-   账户 A 存
    
-   账户 B 再存（可能覆盖/累加）
    
-   账户 C 尝试攻击/捣乱（如果合约没权限控制）
    

* * *

### 3) Deploy（部署）= 这不是“连接”，而是“创建新实例 (create a new instance)”

你今天学到的关键点之一是：

-   **Deploy = 创建一个全新的合约实例（new contract instance）**
    
-   **每点一次 Deploy 就会生成一个新的合约地址（new contract address）**
    
-   它像“盖一栋新楼”，不是“进旧楼”
    

这也是你后面理解 **At Address** 的前提：

-   Deploy = create
    
-   At Address = connect/load
    

* * *

## Core Mechanism｜核心原理：部署合约会发生什么 (What happens during Deploy)

你说“部署合约会生成一个合约地址”，这句话背后可以拆成 5 步（这就是你“等等等等”的展开）：

1.  **Compile** 后得到 **Bytecode**
    
2.  你点 **Deploy**，Remix 构造一笔 **contract creation transaction（创建合约交易）**
    
3.  用你选的 **Account** 对交易签名（sign）并支付 gas（in VM 是假币）
    
4.  EVM 执行这笔交易，把 bytecode 写入链的状态（state）
    
5.  链返回一个新地址：**Contract Address**（合约地址），你在 Deployed Contracts 区域看到它
    

> 一句话：Deploy 不是“把代码发给某台服务器”，而是“通过交易把程序写进全网共识状态（write program into consensus state）”。

* * *

## Core Concepts｜进阶篇：合约地址 vs 钱包地址（你今天的关键疑问）

你提到“它跟钱包地转关系”，这里我们把“关系”拆成三层：**外观、能力、生成方式**。

### 1) 外观：长得像 (They look the same)

-   都是 `0x...` 的 20 字节地址（20-byte Ethereum address）
    
-   所以初学者最容易误会：“它们是不是一类东西？”
    

### 2) 能力：完全不同 (Capabilities differ)

### 钱包地址 Wallet Address（EOA, Externally Owned Account）

-   有私钥（private key）
    
-   能主动发交易（can initiate transactions）
    
-   人的身份（human-controlled account）
    

### 合约地址 Contract Address

-   没私钥（no private key）
    
-   不能主动发交易（cannot initiate on its own）
    
-   只能被动响应调用（responds to calls/tx per code）
    

你今天学到的要点可以浓缩成一句“物种差异”：

> 钱包地址像“人（actor）”，合约地址像“机器（program）”。

### 3) 关系：创造者与被创造者 (Creator relationship)

-   合约地址是由某个钱包地址发起部署交易“创造出来”的（created by a deployment tx)
    
-   一旦创建，它就独立存在（independent entity），除非链回滚（通常不会发生）
    

* * *

## Advanced Applications｜高阶篇：At Address 的意义（为什么你今天会反复提到它）

你今天的理解链路里隐含着一个很重要的能力：**连接已有合约**。

-   **At Address = load/connect existing contract by address**
    
-   作用：当你刷新 Remix 或换设备，界面没了，但链上合约还在
    
    你不必重新 Deploy（否则地址变了、状态也不是原来的）
    

并且你学到了一个关键安全直觉（security intuition）：

-   **知道地址 ≠ 能篡改代码**
    
-   能不能改状态，取决于合约逻辑是否允许（require / access control）
    

> 这也是 Web3 的现实：合约是公开的（publicly accessible），权限必须写进代码（permissions are coded, not assumed）。

* * *

## API 是什么？以及它今天为什么会出现在你的学习里 (API vs ABI Bridge)

你最后说“以及 API 是什么东西相关的”。这里我把它和你今天的 Remix 部署串起来讲：

### 1) Web2 的 API（你熟悉的）

-   API（Application Programming Interface）常见形态是 HTTP 接口：
    
    -   `GET /users/123`
        
    -   `POST /login`
        
-   背后有 server（后端）来处理逻辑与数据库
    

### 2) Web3 里为什么变成 ABI（你今天在 Remix 里隐约学到的）

当你写合约并编译时，会生成 **ABI**：

-   ABI（Application Binary Interface）不是 URL 接口
    
-   它是“函数怎么编码进交易数据（calldata）”的说明书
    
    让前端（JS）/工具知道：
    
    -   合约有哪些函数
        
    -   输入参数类型
        
    -   返回值怎么解码
        

> 所以你今天在 Remix 里看到的那些自动生成按钮，其实就是 Remix 读了 ABI 后自动画出来的（ABI-driven UI）。

* * *

## Edge Cases｜边缘案例：你今天“等等”等的那些常见坑（补全）

你提到“等等等等之类的”，在今天这节课里最常出现的坑通常是：

1.  **把 Deploy 当成 connect**：其实 Deploy 会生成新地址，状态全新
    
2.  **不知道换 Account 意味着换身份**：同一个合约，换账户调用，`msg.sender` 就变了
    
3.  **以为 At Address 能覆盖别人合约**：它只是加载 UI 指向某地址，不会改链上代码
    
4.  **函数 public 默认谁都能调用**：如果没权限控制，任何人都能调用写入函数（potentially dangerous）
    

* * *

## Summary & Vocabulary｜总结与术语表 (Key Terms Review)

### 今日一句话复盘（One-sentence recap）

你今天学到：在 Remix 中选择 **Environment（链）+ Account（身份）**，通过 **Deploy（交易）**把 **Bytecode** 写上链，生成独立的 **Contract Address**，并理解它与 **Wallet Address (EOA)** 的本质区别，同时把 Web2 的 **API** 视角迁移到 Web3 的 **ABI** 视角。

### 关键术语表（Vocabulary）

| 中文 | English | 记忆点 |
| --- | --- | --- |
| 环境 | Environment | 部署到哪条链/哪种模拟链 |
| 账户 | Account / EOA | 有私钥，能主动发交易 |
| 合约地址 | Contract Address | 没私钥，只能被动执行代码 |
| 编译 | Compile | 生成 ABI + Bytecode |
| 字节码 | Bytecode | EVM 执行/部署用机器码 |
| ABI | Application Binary Interface | 合约调用说明书（前端靠它交互） |
| API | Application Programming Interface | Web2 HTTP 接口（URL/服务器） |
| 部署 | Deploy | 发交易创建合约实例/地址 |
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->








今天还在啃remix的compile编译&deploy部署。

* * *

## 🔍 问题诊断 Diagnosis：Remix 里你到底在干什么？

Remix 的核心工作流只有两步：

1.  **Compile（编译）**：把 Solidity 源码变成
    
    -   **Bytecode（字节码）**：给 EVM 执行/部署用
        
    -   **ABI（接口说明）**：给 Remix/前端 JS 生成“按钮”、编码参数、解码返回值用
        
2.  **Deploy & Run Transactions（部署与运行）**：用你编译出来的 ABI/Bytecode
    
    -   **Deploy（部署）**：发一笔“创建合约交易”，得到一个 **contract address（合约地址）**
        
    -   **Call / Transaction（调用）**：对合约地址执行“只读调用”或“写入交易”
        

你觉得难的点在于：Web3 把一次操作拆成了**网络、签名者、gas、value、合约**这些参数（像驾驶舱）。

* * *

## 🧠 解题思路 Thinking：用第一性原理看 Remix

只记一句话就通：

> **Deploy & Run Transactions = 一个“交易构造器 Transaction Builder” + “合约启动器 Contract Launcher”。**

你在这里做任何事，都在回答 5 个根问题：

1.  我把请求发给谁？→ **Environment（Provider/Network）**
    
2.  我用谁的身份做？→ **Account（Signer）**
    
3.  我要执行什么？→ **Deploy / Function Call**
    
4.  我允许它烧多少资源？→ **Gas Limit**
    
5.  我要不要顺便转钱？→ **Value（ETH）**
    

* * *

## 🛠️ 操作指南 Actionable Steps：调试 + 部署（最短闭环）

### Part A：编译 Compile（调试入口）

A1. 版本匹配（Version Compatibility）

-   看 `pragma solidity ...`
    
-   看左侧编译器版本 `COMPILER`
    

✅ 规则：编译器版本要落在 pragma 的范围里，否则会报错（常见 pitfall）。

A2. 编译失败时怎么 Debug（读 Error Log）

Remix 常见报错类型（你一眼分类）：

-   **ParserError**：语法/导入路径问题（比如 missing semicolon、import 找不到）
    
-   **TypeError**：类型不匹配/函数签名不对
    
-   **DocstringParsingError**：注释 NatSpec tag 不合法（你之前遇到的 `@custom:...`）
    

✅ Debug 小流程（必背）：

1.  先看报错类型（Error Type）
    
2.  看定位：`file:line:col`（文件/行/列）
    
3.  看关键字：`not found / invalid / expected / mismatch`
    
4.  修复后再 Compile
    

* * *

### Part B：部署 Deploy（Deploy & Run Transactions 驾驶舱拆解）

你在 Deploy 页面看到的每一块，分别对应 Web3 的真实概念：

B1. Environment（环境 / 网络 / Provider）

-   ✅ **Remix VM**：内置模拟链（推荐学习用，不花真钱）
    
-   **Browser extension**：MetaMask（可能连测试网/主网，会花 gas）
    
-   **WalletConnect**：手机钱包
    
-   **Custom External Http Provider**：你填 RPC（连真实节点）
    

> 新手铁律：先用 Remix VM，闭环跑通再连钱包。

B2. Account（账户 / 签名者 Signer）

这里选的是**谁来发交易**：

-   Deploy / store 这种写入行为都需要 signer（签名）
    
-   Remix VM 里的 100 ETH 是模拟余额
    

B3. Gas Limit（资源上限）

-   **Estimated Gas**：自动估算（新手用这个）
    
-   **Custom**：手动上限（只在 out-of-gas 才用）
    

> Gas Limit 不是“你一定花这么多”，是“最多允许烧到这里”。

B4. Value（随交易转账的 ETH）

-   默认 `0 Wei`（不带钱）
    
-   只有函数是 **payable** 才需要填 Value
    
-   单位：`1 ETH = 10^18 Wei`
    

B5. Contract（选要部署的合约）

从你刚编译出的合约里选：比如 `Storage`

* * *

### Part C：一键跑通闭环（Deploy → Write → Read）

下面是你“真正理解这页”的最短实验：

C1. Deploy（创建合约交易）

1.  Environment 选 `Remix VM`
    
2.  Account 任意
    
3.  Contract 选 `Storage`
    
4.  Value = 0
    
5.  点 **Deploy**
    

✅ 成功标志：

-   `Transactions recorded` 会从 0 变成 1
    
-   `Deployed Contracts` 会出现 `Storage at 0x...`（合约地址）
    

C2. Call vs Transaction（读写差异）

展开 `Deployed Contracts` 里的 `Storage`，你会看到函数按钮：

-   `retrieve()`（`view`）：**Call（只读调用）**
    
    -   不改链上状态
        
    -   通常不产生交易（或不计入交易记录）
        
-   `store(uint256)`：**Transaction（写入交易）**
    
    -   改链上状态
        
    -   一定会产生交易记录，需要 gas
        

C3. 读-写-读（验证状态变化）

1.  点 `retrieve()` → 初始多半是 `0`
    
2.  在 `store` 输入 `123` → 点 `store`（发交易）
    
3.  再点 `retrieve()` → 应该变成 `123`
    

> 你能做出这三步，就说明你已经掌握了“部署与调用”。

* * *

### Part D：调试部署阶段常见坑（Deployment Debug Checklist）

✅ 1) 点 Deploy 没反应？

-   先确认你已经成功编译（没有红色 error）
    
-   Contract 下拉里能选到合约名
    

✅ 2) out of gas？

-   切到 `Custom`，把 gas limit 调大（比如 3,000,000）
    
-   但对 Storage 这种简单合约通常不会发生，除非你改了复杂逻辑
    

✅ 3) 函数点了没改变？

-   你点的是 `retrieve()`（只读）当然不会改变
    
-   你要点 `store()` 这种写入函数才会改变状态
    

✅ 4) Value 填了但报错？

-   你调用的函数不是 `payable`，不能带 ETH
    
-   把 Value 改回 `0 Wei`
    

* * *

## 📚 举一反三 Learning Point：你要带走的核心模型

### 1) Web3 最核心的两类“调用”

-   **Call（只读）**：`view/pure`，不改状态
    
-   **Transaction（写入）**：改状态，要签名，要 gas
    

### 2) Deploy 的本质

-   Deploy = 发一笔**创建合约交易**
    
-   结果 = 产生 **合约地址**，链上保存代码（bytecode）
    

### 3) Remix 这页就是“交易构造器”

你每次卡住，就按这句自检：

> 我选对链了吗（Environment）？我选对身份了吗（Account）？我是在读还是在写（Call/Tx）？gas/value 合理吗？

* * *

![截屏2026-01-20 20.28.17.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Chanlawrence-free/images/2026-01-20-1768912299398-__2026-01-20_20.28.17.png)![截屏2026-01-20 20.28.24.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Chanlawrence-free/images/2026-01-20-1768912286890-__2026-01-20_20.28.24.png)
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->









## 1/19 学习笔记

今天主要做了两件事：  
1）从 **Remix** 入门 Web3 合约开发（编译 / 部署 / 调试 / 运行）  
2）把 **本地开发环境**的基础概念补齐（IDE、终端、Git、日志、断点，以及 AI 编程 / vibe coding 的使用方式）

* * *

### Q1：什么是 IDE？什么是终端？什么是语言？

**IDE（集成开发环境）**

-   写代码 + 管理文件 + 运行/调试 + 版本管理（Git）等功能的集合。
    
-   例子：VS Code、Remix（偏智能合约 IDE）。
    

**终端（Terminal）**

-   一个“输入命令的窗口”，你通过命令让电脑做事：安装依赖、运行项目、查看日志、用 git 管理版本等。
    
-   它不是“编程语言”，它是和系统/工具对话的入口。
    

**语言（Language）**

-   你写给机器看的规则体系。
    
-   例子：Solidity（写合约）、JavaScript/TypeScript（前端/脚本）、Python（数据/脚本）
    
-   语言要靠“编译器/解释器”执行：Solidity 靠 solc 编译成 bytecode + ABI 才能上链。
    

* * *

### Q2：日志是什么？

**日志（Log）**就是“系统运行过程的记录”。

-   用来回答：**发生了什么？卡在哪里？为什么报错？**
    
-   常见类型：
    
    -   运行日志（server started / connected）
        
    -   错误日志（error stack / revert reason）
        
    -   调试信息（变量值、执行到哪一步）
        

在 Web3 里你会看到两类“日志感”的东西：

-   **交易记录 / 执行结果**（成功失败、gas、revert）
    
-   **Event logs（事件）**：合约主动“发广播”，给前端/区块浏览器看的（后面会学到）
    

* * *

### Q3：在 IDE 里点行号出现一个点（断点）是干什么的？

**断点（Breakpoint）的作用：让程序运行到这一行时暂停**，方便你观察：

-   当前变量是什么值
    
-   代码执行到哪一步
    
-   为什么走了这个分支
    
-   哪里开始出错
    

一句话：断点是“暂停键”，用来定位 bug。  
（Remix 里更多会用交易执行的 Debugger；VS Code 是常规程序调试断点。）

* * *

## Remix 相关

**1）编译器版本列表 = solc 版本**

-   合约顶部的 `pragma solidity ...` 决定你应该选哪一个编译器版本。
    
-   版本不匹配就会红线/报错。
    

**2）Deploy & Run 页面在做什么**

-   选择环境（Remix VM / Injected Provider 等）
    
-   选择账号（谁来部署）
    
-   点 Deploy：发一笔“创建合约”的交易，得到合约地址
    
-   部署后在 Deployed Contracts 里调用函数：
    
    -   写入（会发交易，花 gas）
        
    -   读取（通常不发交易）
        

**3）注释怎么写（Solidity）**

-   单行注释：`// ...`
    
-   多行注释：
    
    ```solidity
    /*
      ...
    */
    ```
    
-   文档注释（常用来生成说明）：
    
    ```solidity
    /**
     * @notice ...
     * @dev ...
     */
    ```
    

* * *

## 最小工作流

1.  在 Remix 打开/写合约
    
2.  看 `pragma` → 选匹配的 solc 版本
    
3.  Compile 生成 ABI + Bytecode
    
4.  Deploy（VM 里部署）
    
5.  调用函数（写/读）
    
6.  出问题就看交易结果 + Debugger（或日志）
    

* * *
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->










这周 Web3 实习营给我最大的感受是：Web3 真的很开放、包容、多元。老师们的分享很真诚，不是那种“讲完就结束”的输出，而是会把自己踩过的坑、理解的路径、甚至一些判断依据都摊开来聊。对一个刚系统入门的人来说，这种氛围特别珍贵。

同时我也意识到一个很现实的问题：我这周主要在“输入”，但“输出”明显不够。于是就出现了很尴尬的情况——我听了很多、记了很多，但朋友问我“Web3 到底是什么？”我脑子里是一堆点，却很难在短时间内讲清楚。归根结底是我缺少把信息重新组织成“自己的表达”。所以接下来我会刻意逼自己多输出，也会多看看朋友们是怎么写总结、怎么讲概念的，把输入转成稳定的理解。

这周我收获最大的一块是**钱包与身份体系**。我以前对钱包的理解很模糊，但现在更能抓住 Web2 和 Web3 的核心差异：  
在 Web2 里，我们用手机号/邮箱登录，用微信/支付宝支付，本质上是中心化账号系统+中心化服务器在替我们处理请求。平台会掌握账户体系、数据、权限甚至资金链路，我们很多时候更像是在“租用”平台提供的能力。  
而在 Web3 里，**钱包更像是你的身份本体**：它既是账号、登录凭证，也是支付入口，是你和区块链交互的唯一“钥匙”。没有人替你保管权限，也没有人能在你不授权的情况下直接控制你的资产——你对自己拥有更直接的掌控感。

钱包内部结构我也终于理顺了一遍：助记词、私钥、公钥、地址、签名之间的关系。大概理解是：一组钱包通常遵循行业标准（比如 BIP39/BIP44 这类），一套助记词可以派生出多个账户；每个账户都有自己的私钥/公钥/地址。你在转账、支付、mint 等操作时，钱包会用**私钥**对交易内容做签名（本质是数学运算）；外界不需要知道你的私钥，只需要用你的**公钥**去验证签名是否匹配交易内容，就能确认这笔操作确实来自对应私钥。地址可以理解为公钥经过一定处理后的“更短标识”。这一套机制让我第一次比较直观地理解了：为什么私钥必须永远保密，以及为什么“签名验证”可以证明是你本人发起。

另外一个让我建立框架感的是区块链的“不可能三角”：安全性、去中心化、可扩展性（效率）很难同时拉满。很多 L1 更偏向安全和去中心化，但成本高、速度慢，于是才有 L2 扩容层，把大量交易搬到二层处理，再把结果提交回主链，在成本和效率上做优化。Rollup 也分两大派：Optimistic Rollup 和 ZK Rollup，这块我后面会继续深入梳理差异和直觉。

DeFi 这周也算把几个高频词对上了号：TVL（锁仓总价值）是衡量公链或协议资金体量/活跃度的常用指标；“锁仓”大概就是资产被智能合约托管或抵押，用于特定用途；流动性池（比如 ETH/USDT）是资金池，AMM（自动做市）像 Uniswap 通过算法自动报价。参与方式之一是作为 LP 同时提供两种资产，赚交易手续费分成（当然也伴随风险，比如无常损失等，这部分我还在继续补）。

还有几个概念我也做了初步建立：图灵完备（以太坊/EVM 这类能表达更复杂的通用计算）、质押（把资产质押给网络/协议参与运行或安全，获得奖励）。以及更重要的一点：越学越觉得**安全与合规是底线**。安全上要警惕钓鱼、恶意签名、授权陷阱；合规上也要在法律边界内理解行业，尤其在国内语境下更要保持敬畏。

总结一句：这周对我来说是“开眼界 + 建框架”的一周，但我下一步必须把“输入”转成“输出”。明天我会开始预习下周课程，同时把这周内容做一次系统复盘，尽量把 Web3 讲得更清楚、更像我自己的话，
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->











今天基本没怎么产出学习笔记，更多是在做“整理与进入状态”的事情。

我先把自己的个人空间重新梳理了一遍：推特账号、小红书账号都做了统一调整。包括头像和背景封面的选择、整体风格的对齐、以及标签的补全。这个过程看起来是“外部包装”，但对我来说其实是在确认我接下来想以什么样的形象和关键词被别人认识，也是在给自己做一个更清晰的定位——我希望表达的是更稳定、更长期的方向，而不是零散的碎片更新。

然后今天早上参加了我们 LX DAO 的每周周会，这部分反而是今天最触动我的。因为在会上能明显感受到：大家很多人彼此并不熟，甚至来自完全不同的背景，但大家是围绕同一个信仰和目标聚在一起的。更重要的是那种组织方式——不是传统意义上“上级安排任务、下级执行”，而是更像一种去中心化的共建：有人主动站出来推进，有人自发补位协作，有人持续做长期的事情让组织变得更稳、更强。那一刻我会觉得，这不是单纯在“开会”，而是一个真实在运转的组织生态，而且它的动力来自认同感和责任感，而不是外部强制。

这种氛围让我很受触动：原来陌生人之间也可以因为共同的信念，形成强连接，并且愿意为一个更大的目标去投入、去奉献、去长期坚持。我也因此更明确了自己想参与其中的意愿——我希望自己不只是旁观者，而是可以逐步加入到这个 DAO 的共建里，在真实协作中学习、输出，也把自己的能力慢慢嵌进去。

明天我会开始对下一周课程做预习和学习，把节奏拉回到稳定推进的状态：先把该学的内容过一遍，整理出重点和问题，然后再结合 DAO 的实际协作，看看自己能从哪些具体的小事开始参与。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->












今天主要往回学习了区块链的基础概念

### 1\. 区块链是什么？

-   分布式账本：交易被打包成“区块”，区块按顺序相连成“链”。
    
-   核心价值：**可验证、可追溯、难篡改**（不是“没人能改”，而是改动会被全网发现且成本高）。
    

### 2\. 比特币（BTC）是什么？

-   区块链的典型应用：用公开账本实现点对点转账与价值存储。
    
-   关键点：交易签名 + 共识确认 + 固定发行/手续费机制。
    

### 3\. 区块链的核心组成

-   交易：一次状态变更。
    
-   区块：交易集合 + 哈希等信息。
    
-   链：区块用哈希串起来。
    
-   共识：决定谁能写入新区块、全网如何统一结果。
    
-   运行流程：发交易→广播→校验→打包→共识确认→全网同步。
    

### 4\. 公链 vs 私链 vs 联盟链

-   公链：开放参与，透明强、抗审查强，但成本/性能压力更大。
    
-   联盟链：多机构共同维护，准入受控，适合跨机构协作。
    
-   私链：单机构控制，性能好但更中心化。
    
-   选型本质：**开放与透明 vs 可控与性能**。
    

### 5\. Web3 vs Web3.0 vs Web2

-   Web2：平台中心化，数据与分发在平台。
    
-   Web3：资产与身份可自持，靠链上规则协作与结算。
    
-   Web3.0：偏语义网/智能信息组织（概念来源不同，别混为一谈）。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->













# 📘 Web3 安全与合规学习笔记

## 一、 区块链作恶图谱 (Risk Landscape)

区块链领域的风险主要分为直接攻击、诈骗及黑灰产活动三大类。

### 1\. 盗币与诈骗 (Theft & Scams)

-   **钓鱼攻击 (Phishing)：**
    
    -   **Punycode 域名：** 极具欺骗性，如使用 `trẹzor.com` (编码为 `xn--trzor-o51b`) 模拟官方域名。
        
    -   **手段：** 伪造官方推特活动、虚假 App 引导授权、克隆官网。
        
-   **杀猪盘 (Pig Butchering)：** 利用社交媒体建立信任，诱导至虚假平台投资。
    
-   **智能合约漏洞：**
    
    -   **ETH：** 重入漏洞 (Reentrancy)、权限过大、溢出、Fallback 漏洞、拒绝服务,。
        
    -   **EOS：** 随机数安全、假转账通知、回滚攻击。
        

### 2\. 基础设施与协议层攻击 (Infrastructure)

-   **节点攻击：** 51% 攻击、日蚀攻击 (Eclipse Attack)。
    
-   **供应链攻击：** 代码库 (GitHub) 劫持、恶意第三方包（如 **event-stream** 漏洞）、DNS 劫持。
    

### 3\. 黑灰产产业链 (Black/Grey Industry)

-   **恶意挖矿：** 通过浏览器脚本或木马进行“隐匿挖矿”。
    
-   **勒索软件：** 如 WannaCry 病毒，要求以 BTC 或 XMR 支付赎金。
    
-   **暗网与洗钱：** 涉及非法商品买卖、利用混币器 (Mixers) 或 DEX 进行资金洗白,。
    

## 二、 安全合规管理体系 (Compliance Framework)

为了防范上述作恶行为，机构和个人需建立多层防御机制。

### 1\. 机构内控与合规,

-   **人员风控：** 防范内部操作风险。
    
-   **资金管理：** 建立严格的**提现限额**审批流程。
    
-   **反洗钱 (AML)：** 监控跨链转账、混币服务等可疑资金流向。
    

### 2\. 资产存储安全,

-   **硬件安全：** 使用硬件加密模块 (HSM)，确保护件固件安全。
    
-   **隔离机制：** 实施**冷热钱包隔离**。冷钱包放主要资金，不联网
    
-   **多方授权：** 采用多重签名 (Multi-sig) 或阈值签名技术。
    

* * *

## 三、 中国境内禁止及严监管行为 (Regulatory Context)

根据来源中定义的“作恶”行为，以下类别在中国属于非法活动或受严格监管：

-   **非法集资 (ICO)：** 来源将\*\*“大多 ICO”\*\*直接归为资金盘。在中国，任何形式的代币融资（ICO）均被禁止。
    
-   **传销币与资金盘：** 承诺高回报的传销币、中心化跑路平台属于刑事打击重点。
    
-   **链上博彩：** 来源中提到的所有 **ETH/EOS/TRX 博彩 DApp**，在中国境内运营或参与均属违法。
    
-   **非法挖矿：** 虽然来源侧重于恶意木马挖矿，但中国已全面禁止境内任何形式的虚拟货币挖矿。
    
-   **跨境洗钱：** 利用区块链匿名性规避外汇监管或掩盖犯罪所得的行为受严格法律追究。
    

* * *

## 四、 关键安全意识 (Practical Tips)

-   **识别 Punycode：** 登录钱包官网时，仔细检查地址栏中是否存在看似正常但编码异常的字符（如 `ẹ`）。
    
-   **合约审计：** 开发者需针对重入攻击、权限限制等常见漏洞进行严格代码审计,。
    
-   **官方验证：** 绝不相信私聊中的官方活动，所有 App 下载需通过官方认证渠道。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->














### Web3 安全 & 合规（简要笔记）

**安全**

-   私钥/助记词严格离线保存，不截图、不云同步、不转发。
    
-   钱包分层：日常交互用热钱包，大额资产用冷钱包或独立主钱包。
    
-   重点关注“授权（Approve）”：避免无限额度，用后及时撤销；不明合约不授权。
    
-   任何链接与 DApp 先核验来源与域名；对空投、客服私聊、插件下载保持警惕。
    
-   转账先小额验证，确认链、地址、币种一致；交易卡住多与 gas/nonce 设置相关。
    
-   重要资金与团队金库优先采用多签，降低单点风险。
    

**合规**

-   避免涉及明显灰产与违规行为（洗钱、资金盘、虚假承诺收益等）。
    
-   产品表达避免“保本/固定收益”等承诺；风险提示与用户授权需清晰可见。
    
-   关注地区差异与合规边界，尤其涉及资金、收益、身份与数据收集的功能。
    

备注：明天开始我会把前段时间的学习内容系统复盘一遍，并据此调整后续学习计划与节奏。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->















最近这几天事情有点多，我先把这四块用“提纲式”记一下占个坑，后面空下来我再补细节/案例。

-   **区块链基础概念**：去中心化记账；地址/私钥/钱包；交易+区块+状态；Gas 手续费；合约=链上程序；安全第一（别乱签名/别乱授权）。
    
-   **以太坊概览**：可编程链；EVM 生态大；ETH=资产+燃料；L2 用来降成本提速度；主网更偏最终安全与结算。
    
-   **行业赛道全览**：Infra（钱包/预言机/跨链/数据）；公链&L2；DeFi（交易/借贷/稳定币）；NFT/数字资产；DAO；RWA；安全是底层刚需。
    
-   **Web3 工作方式**：远程异步+文档沟通；社区驱动；开源协作（GitHub）；迭代快但更要重视安全与风控。
    

后续我会再把每块补成“我自己的理解 + 典型项目例子”。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
















# 打卡｜ETH 中文周会 + 每日 Co-learning + 胡老师课堂

## 今日参与

-   参加 **ETH 中文周会**
    
-   参加 **每日 1 小时线上 Co-learning / Co-landing**
    
-   参加 **胡老师课堂**
    

## ETH 中文周会

今天周会内容偏技术/生态资讯，我**目前还没完全听懂**，先把参与记录下来；后续会按课程要求把相关概念再自己琢磨、消化整理。

## 胡老师课堂

-   **多链接 Web3 的人**：主动认识、持续联系
    
-   建一个自己的 **Web3 人员/资源数据库**（方便长期积累与复盘）
    
-   **联系上后留痕**：比如合照/记录（强化连接）
    
-   **多社交**：信息很多在圈子里流动，不能只闷头学
    
-   **最快 MVP 跑闭环**：先完成一个项目闭环，再迭代优化
    
-   **补行业黑话/术语**：降低沟通成本，更快进入语境
    

## 后续计划

后续我会**按照要求**把今天的内容继续补全整理，并完成对应任务/输出。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
