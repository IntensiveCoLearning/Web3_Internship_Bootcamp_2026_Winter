---
timezone: UTC+8
---

# renziqi0429-vivi

**GitHub ID:** renziqi0429-vivi

**Telegram:** @Ren Ziqi

## Self-introduction

4年互联网产品经理工作经验，现数字游民状态，数字遗产方向创业中

## Notes

<!-- Content_START -->
# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->
## **《021 学习以太坊》第八章学习笔记**

**主题：智能合约的测试、审计与工程化安全实践**

### **一、为什么“能跑 ≠ 安全”**

第八章首先明确一个现实判断：

> **绝大多数合约事故，不是因为功能没写完，而是因为“以为没问题”。**

在以太坊环境中：

-   合约是公开的
    
-   调用是无限次、低成本的
    
-   攻击者可以系统性遍历边界情况
    

因此，安全不能依赖：

-   人的直觉
    
-   少量手动测试
    
-   或“上线后再看”
    

而必须进入**工程化验证阶段**。

### **二、测试在以太坊中的特殊地位**

合约测试的目标不是“证明代码没 bug”，而是：

> **尽可能早地暴露假设错误与边界失效情况。**

与 Web2 不同，合约测试必须重点关注：

-   状态演化是否符合不变量
    
-   失败路径是否被正确回滚
    
-   多次调用、顺序变化下是否仍成立
    

### **三、测试的基本类型与侧重点**

第八章将合约测试拆成不同层次，每一层关注的问题不同。

**1\. 单元测试（Unit Test）**

-   针对单个函数或最小逻辑单元
    
-   验证输入 → 输出是否符合预期
    

特别关注：

-   边界值
    
-   异常输入
    
-   权限限制
    

单元测试解决的是：

> “这段逻辑在理想情况下是否正确”

**2\. 集成测试（Integration Test）**

-   多合约、多函数组合执行
    
-   模拟真实使用路径
    
-   检查状态在多步操作后的整体一致性
    

它回答的是：

> “这些模块组合起来，会不会出现意外行为”

**3\. 失败路径测试（Revert / Failure Case）**

以太坊中特别重要的一类测试。

必须验证：

-   不满足条件时是否 **必然 revert**
    
-   revert 是否发生在**正确的位置**
    
-   状态是否被完整回滚
    

这是因为：

> 很多漏洞不是“成功路径错误”，而是“失败路径没挡住”。

### **四、属性测试与不变量思维**

第八章强调一种比“例子测试”更重要的思路：

> **不要只测试几个场景，而要测试规则是否始终成立。**

典型不变量包括：

-   资产总量不变
    
-   权限角色不可被绕过
    
-   状态迁移只能按规定路径发生
    

属性测试的目标不是枚举所有情况，而是：

> 在随机输入、随机顺序下反复挑战合约的不变量。

### **五、常见测试盲区**

教材特别指出了一些新手容易忽略的地方：

-   只测试成功路径，不测失败
    
-   假设调用顺序固定
    
-   假设调用者是“正常用户”
    
-   忽略极端 Gas 情况
    
-   忽略重入、并发与状态竞争
    

这些盲区，往往正是攻击者最先利用的地方。

### **六、审计的真正意义：独立视角**

第八章澄清了一个常见误解：

> **审计不是“帮你找 bug”，而是“挑战你的假设”。**

审计方通常会：

-   从攻击者视角阅读代码
    
-   假设最坏的调用顺序与组合
    
-   检查是否存在违反不变量的路径
    

即使代码“看起来没问题”，也可能在：

-   极端顺序
    
-   未预期组合
    
-   非典型输入
    
    下崩溃。
    

### **七、形式化验证的边界与现实**

形式化验证试图用数学方式证明：

-   在给定假设下
    
-   合约行为永远符合某些性质
    

第八章对它的态度是克制而现实的：

-   它很强
    
-   但成本高、适用范围有限
    
-   且验证的前提本身也可能是错的
    

因此，形式化验证是：

> **安全工具箱中的一部分，而不是万能解法**

### **八、安全工程的现实取舍**

教材在这一章反复传达一个工程共识：

> **安全不是“零风险”，而是“风险可控”。**

现实中的取舍包括：

-   合约复杂度 vs 可验证性
    
-   功能灵活性 vs 攻击面
    
-   开发速度 vs 测试覆盖
    

成熟项目通常会：

-   从最小可用逻辑开始
    
-   逐步扩展
    
-   每一步都重新验证安全边界
    

### **九、从“写合约”到“维护系统”**

第八章的一个隐含转变是：

-   合约不是“一次性交付”
    
-   而是长期运行的公共基础设施
    

因此需要：

-   版本管理意识
    
-   升级与迁移方案
    
-   监控、告警与应急预案
    

这标志着从“程序员思维”走向：

> **协议与系统工程思维**

### **十、第八章的整体认知价值**

第八章完成的是安全认知的最后一跳：

-   从“避免明显漏洞”
    
-   到“系统性降低未知风险”
    

它强调：

-   测试不是补救
    
-   审计不是免责
    
-   安全是一种持续的工程实践
    

一句话总结第八章：

> **在不可逆的系统中，安全只能靠工程化验证逐步逼近，而不能靠信心保证。**
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->

## **《021 学习以太坊》第七章学习笔记**

**主题：智能合约安全模型与常见漏洞的底层成因**

### **一、为什么“合约安全”在以太坊中格外重要**

第七章一开始就确立了一个前提：

> **智能合约的安全问题，本质上是“不可逆系统中的错误设计问题”。**

原因在于：

-   合约一旦部署，代码不可修改
    
-   状态变更一旦发生，无法回滚历史
    
-   攻击不需要“入侵服务器”，只需**合法调用合约**
    

因此，以太坊中的安全问题：

-   很少是“黑客突破权限”
    
-   更多是**合约按设计逻辑，合法地被“用坏”**
    

### **二、以太坊安全模型的底层假设**

智能合约安全并不建立在“相信调用者”的基础上，而是基于几个冷酷前提：

1.  **所有外部输入都是不可信的**
    
2.  **所有外部合约都是潜在恶意的**
    
3.  **区块链是并发、异步、可被抢跑的环境**
    
4.  **攻击者可以无限次、低成本地尝试调用路径**
    

第七章的所有漏洞，几乎都来自**忽视其中某一条前提**。

### **三、最经典漏洞：重入攻击（Reentrancy）**

重入攻击并非“黑魔法”，而是执行顺序错误的直接结果。

典型模式：

1.  合约向外部地址转账 ETH
    
2.  在**状态尚未更新**前
    
3.  被对方合约回调再次进入函数
    
4.  重复提取资产
    

根因不是“调用了外部合约”，而是：

> **在状态更新之前，把控制权交给了不可信对象**

核心原则（本章反复强调）：

**Checks → Effects → Interactions**

-   先检查条件
    
-   再更新状态
    
-   最后再与外部交互
    

### **四、权限与身份相关漏洞**

第七章指出，很多“看似低级”的漏洞，其实源于对权限模型的误解。

常见问题包括：

-   使用 tx.origin 进行身份判断
    
-   忘记限制关键函数的调用者
    
-   将“是否能调用函数”与“是否能改变状态”混淆
    

关键认知在于：

> Solidity 的可见性修饰符不是权限系统

> 真正的权限，必须由逻辑显式控制。

### **五、算术与数值相关问题（溢出 / 下溢）**

在早期 Solidity 中：

-   整数溢出不会报错
    
-   数值会在最大值处“绕回”
    

这类问题导致：

-   余额被绕成极大值
    
-   权限计数失效
    
-   状态约束被绕过
    

虽然新版本 Solidity 已默认检查溢出，但第七章强调：

> **不要假设语言特性能替你兜底所有安全问题**

### **六、DoS（拒绝服务）类漏洞的合约形态**

在以太坊中，DoS 并不一定是“把服务器打挂”，而可能表现为：

-   循环中包含外部调用
    
-   依赖某个地址“必须成功接收 ETH”
    
-   遍历动态数组，Gas 成本不可控
    

攻击方式往往是：

> **让某个步骤“合法失败”，从而阻塞整个流程**

这类漏洞的本质是：

-   把合约的可用性，绑定到不可控对象上
    

### **七、时间、随机数与区块依赖问题**

合约无法获得真正的随机数，也无法精确控制时间。

风险来源包括：

-   依赖 block.timestamp 做关键判断
    
-   使用区块哈希作为随机源
    
-   假设矿工 / 验证者“不会作恶”
    

第七章强调：

> 区块相关字段只是“弱随机、弱时间信号”，而非可信源

真正需要随机性或现实世界数据时，必须：

-   使用预言机
    
-   或将不确定性放在链下处理
    

### **八、外部调用与可组合性的双刃剑**

以太坊的强大之处在于**合约可自由组合**，但安全风险也随之放大。

问题包括：

-   被意外合约调用
    
-   与未来尚不存在的合约交互
    
-   与假设不一致的合约组合
    

因此第七章反复传达一个设计观：

> **永远不要假设“调用你的合约的人是善意的”**

### **九、防御思维：从“写对代码”到“假设最坏情况”**

这一章并不追求列完所有漏洞，而是建立一种思维方式：

-   把合约看成“暴露在公网的接口”
    
-   把每个外部调用当作攻击入口
    
-   把每条状态不变量当作必须被证明的假设
    

安全不是靠“多写 require”，而是靠：

> **在设计阶段就消灭脆弱路径**

### **十、第七章的整体认知价值**

第七章真正完成的是一次认知转向：

-   从“功能是否实现”
    
-   转向“在最坏对手下是否仍然成立”
    

它让人意识到：

> 在以太坊中，**攻击往往不是破坏规则，而是利用规则本身**。

一句话总结第七章：

> **智能合约安全的核心，不是防黑客，而是防错误假设。**
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->


## **《021 学习以太坊》第六章学习笔记**

**主题：Solidity 与智能合约的基本结构与运行逻辑**

### **一、从 EVM 到 Solidity：抽象层的变化**

前一章讨论的是 **EVM 如何执行字节码**，而第六章转向一个现实问题：

> 人类不可能直接用 OpCode 写合约，那该用什么？

答案是 **Solidity**。

Solidity 是一种：

-   面向合约的高级语言
    
-   编译后生成 EVM 可执行的字节码
    
-   目标不是“通用编程”，而是**安全地描述链上状态变化规则**
    

它的设计从一开始就服务于三个约束：

-   确定性执行
    
-   Gas 成本可控
    
-   状态可验证、可回滚
    

### **二、智能合约的本质：一组受限的规则集合**

第六章强调一个容易被忽略的事实：

> **智能合约不是“自动化脚本”，而是“受法律式约束的状态机规则”。**

合约能做的事非常有限：

-   读 / 写链上状态
    
-   接收交易或合约调用
    
-   在满足条件时更新状态
    

它不能：

-   主动运行
    
-   定时执行
    
-   访问外部世界
    

所有逻辑都必须通过：

一笔交易或另一个合约的调用来触发。

### **三、合约的基本结构**

一个标准 Solidity 合约通常包含以下要素：

**状态变量（State Variables）**

-   永久存储在链上
    
-   每次写入都会消耗大量 Gas
    
-   是合约最“昂贵”的部分
    

**函数（Functions）**

-   对外或对内暴露的行为入口
    
-   通过可见性（public / external / internal / private）限制调用范围
    

**构造函数（Constructor）**

-   只在部署时执行一次
    
-   用于初始化状态
    
-   其成本直接影响合约部署 Gas
    

**事件（Events）**

-   不改变状态
    
-   主要供链下监听与索引
    
-   是合约与前端/后端交互的桥梁
    

### **四、函数调用与执行语义**

函数调用在 Solidity 中并不等价于传统程序调用。

关键区别在于：

**每次外部调用都是一次“交易语义”**

-   有 Gas
    
-   可能失败
    
-   会影响链上状态
    

函数执行要么：

-   完整成功并提交状态
    
-   要么失败并全部回滚
    

这也是为什么 Solidity 中：

-   require / revert 被大量使用
    
-   错误处理优先于“异常捕获”
    

### **五、可见性与访问控制的底层意义**

第六章并未把“访问控制”当成语法点，而是强调其安全意义。

external：

-   只能被外部调用
    
-   calldata 直接使用，Gas 更省
    

public：

-   内外都可调用
    
-   会生成 getter
    

internal / private：

-   编译期限制
    
-   不是运行时权限系统
    

重要结论是：

> Solidity 的可见性 ≠ 权限系统

> 真正的权限控制，必须显式写在逻辑里。

### **六、状态变量与存储成本意识**

第六章再次强化一个核心原则：

> **写 storage 是最昂贵、最不可逆的操作。**

因此在设计合约时：

-   能算出来的，不存
    
-   只在函数中使用的，用 memory
    
-   外部传参优先 calldata
    

这一章开始让“Gas 成本”成为编程时的第一等约束，而不是事后优化。

### **七、事件（Event）的角色定位**

事件不是“日志装饰”，而是链上系统设计的重要组成部分。

事件的特点：

-   不参与状态
    
-   成本远低于 storage
    
-   可被链下高效索引
    

典型用途包括：

-   前端更新 UI
    
-   记录关键行为轨迹
    
-   为审计与分析提供数据源
    

在很多协议中：

> **状态是给合约看的，事件是给人和系统看的。**

### **八、合约部署与不可变性**

一旦合约部署完成：

-   代码不可更改
    
-   状态只能按既定规则演化
    

这意味着：

-   部署即“立法”
    
-   Bug 等同于永久规则漏洞
    

第六章虽未深入升级模式，但已经隐含一个重要前提：

> 合约设计要以“不可修改”为默认假设。

### **九、第六章的整体认知价值**

这一章完成了一个关键过渡：

-   从“以太坊如何运行”
    
-   到“我如何在这种系统里写规则”
    

它要求建立三种意识：

1.  合约是状态机，不是脚本
    
2.  每一行代码都有 Gas 与安全含义
    
3.  链上代码一旦部署，后果长期存在
    

一句话总结第六章：

> **Solidity 是一种被经济成本和确定性强约束的规则语言。**
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->



## **《021 学习以太坊》第五章学习笔记**

**主题：EVM 如何安全执行任意代码，以及 Gas 如何把算力变成成本**

### **一、EVM 的根本约束：确定性与沙盒**

第五章首先回答一个常见疑问：

**为什么智能合约不能访问外部网络、时间或本地文件？**

原因在于 EVM 的两条硬约束：

**确定性（Deterministic）**

-   所有节点在任意时间、任意地点执行同一笔交易
    
-   必须得到**完全相同的结果**
    
-   因此合约不能依赖外部不稳定信息（真实时间、HTTP 返回值、随机 API）
    

**沙盒隔离（Sandboxed Runtime）**

-   合约无法访问操作系统、磁盘或网络
    
-   只能通过 EVM 暴露的上下文（block.\*、msg.\*）
    
-   以及与其他合约的 CALL 进行交互
    

这解释了两个常见现象：

-   真随机数必须通过 **预言机（Oracle）** 写入链上
    
-   合约“读现实世界数据”，本质是**先把数据上链**
    

### **二、EVM 是“世界计算机”，但资源必须受控**

以太坊是一个**开放、无需许可、图灵完备**的执行环境。

问题在于：如果不限制资源，任何人都可以写死循环或滥用算力。

解决方案就是 **Gas 机制**。

### **三、Gas 的核心思想：每一步计算都要付费**

EVM 会把合约执行拆解为最小操作单元：**OpCode**。

不同操作的 Gas 成本不同：

-   算术运算（ADD、MUL）：Gas 很低
    
-   读取存储（SLOAD）：较贵
    
-   写入存储（SSTORE）：非常贵
    
-   跨合约调用（CALL）：不便宜
    

本质逻辑是：

> **越消耗稀缺资源（算力、存储、I/O），就越贵**

这样做的直接效果：

-   DoS 攻击在经济上变得不可持续
    
-   无限循环无法“白嫖算力”
    
-   节点执行计算有明确经济激励
    

Gas 定价并非一成不变，历史上曾多次通过升级调整 OpCode 成本来修复安全问题。

### **四、Gas Limit：单笔交易的“安全闸门”**

每一笔交易都必须指定 **Gas Limit**，表示：

> “我最多愿意为这次执行烧多少 Gas”

EVM 执行时：

-   每一步扣除对应 Gas
    

一旦 Gas 用尽：

-   立即 revert
    
-   所有状态修改回滚
    
-   已消耗的 Gas 不退
    

这保证了两件事：

-   单笔交易无法无限拖垮节点
    
-   状态具有**原子性**（要么全成功，要么全失败）
    

### **五、Gas 价格机制：EIP-1559 之后发生了什么**

London 升级（EIP-1559）引入新的 Gas 定价结构：

**Base Fee（基础费）**

-   协议自动调节
    
-   随区块拥堵程度变化
    
-   **直接销毁（burn）**
    

**Priority Fee / Tip（小费）**

-   用户给出块者的激励
    
-   决定交易优先级
    

**Max Fee**

-   用户可接受的最高单价上限
    

实际支付价格 ≈ Base Fee + Tip，但不会超过 Max Fee。

设计效果是：

-   垃圾交易越多 → Base Fee 越高
    
-   攻击者不仅要付高价，还在不断“烧掉”ETH
    
-   Spam 行为在经济上自我惩罚
    

### **六、Gas 的单位关系：Gas ≠ ETH**

关键区分：

-   **Gas**：抽象的“工作量单位”
    
-   **ETH / Gwei**：为 Gas 付的钱
    

经典公式在直觉上仍成立：

> 总费用 ≈ GasUsed × 有效 Gas 单价

只是单价不再由用户单独决定，而是由协议动态调节。

### **七、合约设计中的 Gas 现实约束**

第五章后半部分强调：**Gas 不只是费用问题，而是设计问题**。

高优先级原则包括：

-   尽量减少 SSTORE（写 storage 是最大黑洞）
    
-   多用 memory / calldata，少用 storage
    
-   避免链上大循环、全表扫描
    
-   用合适的数据结构（mapping + 索引）
    
-   用工具量化每一次优化，而非凭感觉
    

核心思想：

> 把“昂贵、不可撤销的链上操作”压缩到最少

### **八、第五章的整体认知价值**

这一章回答的是一个底层问题：

> **以太坊如何在一个任何人都能写代码的环境中，避免系统被滥用？**

答案不是权限控制，而是：

-   确定性执行
    
-   沙盒隔离
    
-   用 Gas 把资源消耗变成可计价成本
    

一句话总结第五章：

> **EVM 用经济学约束，保证了去中心化计算的安全与秩序。**
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->




## **《021学习以太坊》第四章学习笔记**

**主题：状态、Merkle 树与以太坊如何实现“可验证的世界状态”**

### **一、以太坊的核心不是“转账”，而是“状态机”**

第四章首先明确一个重要结论：

> **以太坊不是简单的记账系统，而是一台分布式状态机（State Machine）。**

在任何一个区块高度，以太坊都维护着一个**全局状态（World State）**，它记录了：

-   所有账户的余额
    
-   所有账户的 nonce
    
-   所有合约的代码
    
-   所有合约的存储数据
    

每一笔交易的本质不是“记一行账”，而是：

> **对世界状态的一次确定性变更**

### **二、什么是“状态”？为什么它很难存**

在以太坊中，状态并不是一张简单表格，而是一个高度结构化的数据集合：

-   账户 → 属性（余额、nonce、代码、存储）
    
-   合约 → 存储槽（slot） → key-value 映射
    

问题在于：

-   状态规模巨大
    
-   每个区块都会更新状态
    
-   节点必须能验证“某个状态是否真的存在”
    

这就引出了第四章的核心技术结构。

### **三、Merkle 树的作用：让“信任”变成“验证”**

以太坊大量使用 **Merkle Tree（默克尔树）**，其核心价值不是“存数据”，而是：

> **用一个哈希值，代表一整棵数据结构的完整性**

Merkle 树的特性：

-   任意一个叶子节点发生变化
    
-   会一路影响到根哈希（Merkle Root）
    
-   根哈希可以作为“状态的指纹”
    

这使得节点可以：

-   不下载全部数据
    
-   只通过哈希证明，验证某个数据是否属于某个状态
    

### **四、以太坊中的“三棵核心树”**

**一个区块并不是只对应一棵 Merkle 树，而是三类核心结构。**

**1\. State Trie（状态树）**

-   描述整个以太坊的世界状态
    
-   每个账户是一个叶子
    
-   区块头中的 stateRoot 指向它
    

这是以太坊最重要的一棵树。

**2\. Transaction Trie（交易树）**

-   记录该区块中所有交易
    
-   用于证明“某笔交易是否被包含在这个区块里”
    

**3\. Receipt Trie（收据树）**

-   记录交易执行结果
    
-   包含日志（events）、gas 使用情况等
    
-   为链下索引和应用提供基础
    

这三棵树共同保证：

> 区块内容 + 执行结果 + 世界状态，都可被独立验证

### **五、为什么以太坊使用 Trie，而不是普通 Merkle Tree**

以太坊使用的是 **Merkle Patricia Trie（MPT）**，原因在于：

-   普通 Merkle Tree 更适合静态列表
    
-   以太坊状态是动态、可增删改的键值结构
    

MPT 的优势：

-   支持高效的 key-value 更新
    
-   路径可压缩，减少存储冗余
    
-   同时具备 Merkle Tree 的可验证性
    

可以理解为：

> **为“长期变化的数据”量身定制的可验证结构**

### **六、状态如何随交易发生变化**

一笔交易进入区块后，会触发以下流程：

1.  验证交易合法性（签名、nonce、余额）
    
2.  在 EVM 中执行交易
    
3.  修改相关账户或合约的状态
    
4.  生成新的状态树
    
5.  新的 stateRoot 写入区块头
    

关键点在于：

-   所有节点执行同一笔交易
    
-   在相同初始状态下
    
-   **必然得到相同的新状态**
    

这就是“确定性执行”的意义。

### **七、为什么状态设计决定了节点成本**

第四章也隐含回答了一个现实问题：

**为什么跑全节点这么贵？**

因为全节点需要：

-   存储完整状态
    
-   不断更新状态树
    
-   验证每一次状态变更
    

而：

-   轻节点只验证证明
    
-   归档节点保存所有历史状态，成本指数级上升
    

状态结构的设计，直接决定了：

> 去中心化的门槛与安全边界
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->





## **《021学习以太坊》第二、三章学习笔记**

**主题：以太坊网络如何运行，以及交易如何在链上完成**

### **一、以太坊不是“一个程序”，而是一张长期在线的网络**

第二章的核心在于：**以太坊是一张由大量节点组成的 P2P 网络**，而不是某个中心服务器。

这些节点在现实世界中分散在不同：

-   地理位置
    
-   软件实现（不同客户端）
    
-   运营主体（个人、公司、机构）
    

正是这种多重分散，使以太坊在工程上尽量接近：

> 无需许可、抗审查、可自行验证的公共网络

### **二、节点的角色分工与现实意义**

以太坊节点并非“人人做所有事”，而是存在不同层级和用途：

**全节点（Full Node）**

-   验证区块和交易
    
-   保存并维护当前链上状态
    
-   是网络的“事实来源”
    

**归档节点（Archive Node）**

-   保存所有历史状态
    
-   成本极高，主要用于数据分析、研究、审计
    

**轻节点（Light Client）**

-   不保存完整数据
    
-   通过向全节点查询来验证信息
    
-   面向普通用户或移动端场景
    

节点的存在不是“为了快”，而是为了：

> 把验证权分散给尽可能多的独立参与者

### **三、节点如何“认识彼此”：发现机制**

新节点加入网络时，并不知道其他节点在哪里，因此需要 **节点发现协议（Discovery Protocol）**。

核心机制包括：

-   Ping / Pong：确认对方是否在线
    
-   FindNode / Neighbors：获取更多节点地址
    

底层使用 **Kademlia 风格的 DHT（分布式哈希表）**：

-   用逻辑距离而非物理距离
    
-   每一跳都把搜索范围逼近目标
    
-   避免全网广播，提高效率
    

可以把它理解为：

> 一个去中心化的“通讯录扩散系统”

### **四、信息如何在全网传播：Gossip 协议**

节点之间的数据传播，主要依赖 **Gossip（流言）协议**。

工作方式：

-   每个节点只把新消息随机转发给少数邻居
    
-   邻居继续转发
    
-   信息像“八卦”一样扩散到全网
    

Gossip 负责传播：

-   交易
    
-   区块
    
-   共识层的投票与证明信息
    

它的目标不是“最短路径”，而是：

> 在不依赖中心节点的情况下，快速且容错地让全网看到同一批信息

### **五、第三章核心：交易是如何被打包进区块的**

第三章开始进入更“链内”的结构问题。

一个区块由两部分组成：

**1\. 区块头（Block Header）**

类似“目录 + 摘要”，包含：

-   父区块哈希（连接链条）
    
-   时间戳
    
-   Merkle Root（本区块所有交易的加密摘要）
    
-   与共识相关的字段
    

区块头的作用是：

> 用最小的信息，证明“这一整块内容确实存在且未被篡改”

**2\. 区块体（Block Body）**

真正“干活”的部分，包含：

-   所有交易的完整信息
    
-   交易执行结果（日志、收据）
    
-   状态变更数据
    
-   智能合约代码（如有）
    

### **六、节点之间交换的不是“钱”，而是数据**

链上运行依赖多种数据在节点间流动，包括：

-   **交易数据**：谁给谁做了什么操作
    
-   **区块数据**：已确认的交易集合
    
-   **账户状态**：余额、nonce、合约存储
    
-   **加密哈希**：作为唯一标识与防篡改手段
    
-   **日志 / 事件**：供链下系统监听和索引
    

其中关键在于：

> 所有资产变化，本质都是状态数据的更新

### **七、账户模型：EOA 与合约账户的区分**

以太坊账户分为两类：

**EOA（外部拥有账户）**

-   由私钥控制
    
-   人使用的钱包账户
    

**合约账户**

-   没有私钥
    
-   由代码控制
    
-   只能被交易或合约调用触发
    

这一区分决定了：

-   谁可以主动发起交易
    
-   哪些行为必须通过代码执行
    

### **八、区块链同步：为什么“跑节点”很慢**

节点首次运行需要同步链数据，不同模式差异巨大：

**Snap Sync（推荐）**

-   快速同步当前状态
    
-   开发者最常用
    

**Full Sync**

-   从创世区块完整执行
    
-   验证最严格，耗时极长
    

**Archive Sync**

-   保存所有历史状态
    
-   成本最高，只适合特定用途
    

这说明：

> 去中心化的代价之一，是用时间和资源换取可验证性

### **九、第二、三章的整体认知收获**

这两章并不要求“记住所有协议细节”，而是建立三个关键理解：

1.  以太坊是一张长期运行的去中心化网络
    
2.  节点通过发现、Gossip 和共识维持全网一致
    
3.  区块与交易的结构，服务于“可验证而非高效”
    

它们回答的不是“怎么用以太坊”，而是：

> **为什么以太坊可以在没有中心的情况下持续运作**
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->






## **《Web3实习手册》合规与网络安全**

### **一、合规背景与核心要求**

Web3 技术本身作为一种去中心化技术栈不被全面禁止，但其涉及的实际行为（尤其在中国大陆及强监管地区）可能触及法律风险，因此合规为进入 Web3 实践前必须理解的底线。

**监管态势概览**

-   多国（包括中国）对虚拟货币和相关活动设有严格法律要求，例如禁止某些代币融资模式、明确虚拟币不具有法偿性、禁止未经许可的交易撮合与兑换服务等。
    
-   监管政策重点在于防止非法金融活动（非法集资、传销、洗钱、赌博等），而不是全面否定区块链技术。
    

## **二、合规风险识别**

### **1\. 代币发行与交易法律风险**

无论代币是否用“积分”“凭证”等术语包裹，只要具备可流通性或融资功能，都可能被认定为非法金融行为。

-   **ICO/IEO/IDO**：未经批准的代币发行可能构成非法公开融资行为；
    
-   **空投/白名单模式**：若实质上是向公众筹资，可能被认定非法吸收公众存款。
    
-   **技术参与者责任**：合约设计、空投逻辑配置等环节的技术人员可能被视为共同行为人，承担法律责任。
    

> 即使技术层面中立，只要参与的行为触及融资或筹资，本身也可能带来法律风险。

### **2\. 赌博、传销与洗钱风险**

项目经济模型会影响其法律属性：

-   **类似赌博设计**：例如充值→抽奖→提现的机制，可能被认为是开设赌场；
    
-   **返利/裂变模式**：多级返佣、算力挂靠等激励方式可能触犯组织传销活动罪；
    
-   **场外交易与洗钱**：跨境场外交易在没有监管许可条件下可能构成非法经营外汇业务或洗钱。
    

这些风险并非假设，而是法律实践中不断被界定的具体行为识别方式。

### **3\. 民商事合同效力与风险承担**

在当前政策环境下，链上资产买卖、委托投资等民事交易行为在司法审查实践中大概率被认定为无效或不受法律保护。

-   当交易发生损失时，参与者需自行承担风险，不会受到国家法律的强制保护；
    
-   与他人签订虚拟资产相关协议的有效性风险较高。
    

合规不是单纯“避开监管”，而是**理解现行法律框架下哪些行为受到允许、哪些行为具备高度风险**。

## **三、网络安全风险与防护意识**

网络安全对个人和团队都至关重要。实习手册强调，任何暴露在网络空间的身份、数据和资产都有可能被威胁。

### **1\. 常见网络安全攻击类型**

**🔹 钓鱼攻击（Phishing）**

攻击者伪造网站、邮件、社交账号等逼真信息，引导用户泄露私钥、助记词、密码等敏感数据。

-   常见诱饵包括“面试链接”“学习资料”“空投奖励”等伪装信息。
    
-   结果可能包括资产被盗、身份泄露、设备感染恶意软件等。
    

**🔹 恶意软件与木马**

伪装成常用软件（如面试软件、学习工具、插件等），一旦执行就可窃取数据、监听剪贴板、替换钱包地址等。

-   **剪贴板劫持**：当复制钱包地址时自动将其替换为攻击者地址；
    
-   **远程控制木马**：安装后窃取文件、密码、敏感数据。
    

**🔹 社交工程攻击**

攻击者冒充信任方（HR、导师、同学等），利用社交信任促使目标暴露信息或执行有风险操作。

**🔹 第三方组件供应链攻击**

恶意依赖库、插件后门等可能通过代码或插件扩散到真实项目中，引发大规模损失。

这些攻击手段体现了网络空间中**对信任的利用**和对人性弱点的攻击。

### **2\. 安全防护意识与基本措施**

虽然手册没有给出详细技术防护配置，但围绕行为层面的安全意识有明确提示：

-   **验证链接真实性**：不轻易点击陌生邮件/社交信息中的链接；
    
-   **保护密钥信息**：助记词、私钥不在任何在线表单、聊天窗口中输入；
    
-   **谨慎安装软件**：仅从官方可信渠道下载，必要时使用隔离环境/虚拟机测试；
    
-   **校验钱包地址**：手动核对地址前后字符，避免自动替换风险；
    
-   **避免泄露个人敏感信息**：包括手机号、邮箱、身份认证材料等。
    

此外，学习网络安全基本概念（如身份验证、多因素验证、防火墙等）有助于构建自我防护能力。

### **四、合规与安全之间的关系**

合规和网络安全虽然分别归类，但在 Web3 实践中密切相关：

-   不合规的行为本身可能伴随更高的安全风险（例如未经许可的交易活动可能被恶意利用）；
    
-   安全防护失效可能引发合规责任（如资产被盗后引发法律纠纷）。
    

因此，无论是技术贡献、产品设计还是日常参与 Web3 社区，都需要同时考虑**法律边界和安全边界**。

### **五、合规与安全在实习生行为中的实践要点**

1.  参与 Web3 活动前先评估当地法律环境；
    
2.  不参与未经许可的代币发行、交易撮合等高风险行为；
    
3.  使用安全的钱包管理策略（冷钱包、硬件钱包、多因素验证）；
    
4.  任何涉及私钥的操作，先在隔离环境测试确认来源可信；
    
5.  对社会工程类信息持怀疑态度，不轻易分享关键身份/账号信息；
    
6.  对第三方组件依赖保持谨慎，版本来源需验证。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->







## **《从零到一学习以太坊》第一章学习笔记**

**主题：区块链与 Web3 的基本认知框架**

### **一、区块链的核心定义与技术逻辑**

区块链本质是一种**去中心化的分布式账本系统**。

其核心不是“币”，而是**在没有中心机构的前提下，如何让一群互不信任的节点，就同一份数据达成一致**。

基本结构要点：

-   数据被打包成“区块”，按时间顺序相连
    
-   每个区块包含前一区块的哈希值，形成链式结构
    
-   数据一旦上链，几乎无法被单点篡改
    
-   账本由多个节点共同维护，而非中心服务器
    

### **二、去中心化的运行机制**

区块链系统依赖三套机制协同运作：

1.  **分布式网络**
    
    节点分布在全球，各自保存账本副本，避免单点失效。
    

**共识机制**

用算法决定“哪一份账本状态是全网认可的真相”，

常见机制包括：

-   PoW（工作量证明）
    
-   PoS（权益证明）
    

1.  **经济激励机制**
    
    节点参与验证、记账可以获得代币奖励，
    
    用户使用网络需要支付手续费（Gas），
    
    从而形成自我运转的经济闭环。
    

### **三、从比特币到以太坊：区块链能力的扩展**

比特币解决的是：

> 在没有银行的情况下，如何实现可信的点对点转账。

以太坊解决的是：

> 在没有公司的情况下，如何运行一套“可自动执行的规则系统”。

关键差异在于 **智能合约**：

-   智能合约是部署在链上的代码
    
-   一旦条件满足，自动执行
    
-   不依赖人工、机构或仲裁者
    

因此，以太坊不仅是货币系统，更是一个：

-   去中心化应用平台
    
-   全球共享的“计算机”
    
-   Web3 生态的基础设施
    

以太坊的升级（PoW → PoS）重点不在概念，而在：

-   能耗下降
    
-   安全性与可扩展性调整
    
-   为更复杂应用铺路
    

### **四、Web3 的核心行业赛道（整体认知）**

Web3 并不是单一行业，而是一组围绕区块链展开的应用方向：

**DeFi（去中心化金融）**

-   去中介借贷、交易、支付
    
-   规则由代码而非机构执行
    

**NFT**

-   用链上唯一性证明“所有权”
    
-   不等同于图片，而是资产确权方式
    

**DAO**

-   用智能合约与代币实现组织治理
    
-   决策权分散，不依赖传统公司结构
    

**社区经济 / Meme 文化**

-   强调共识、叙事与群体行动
    
-   高波动，高风险，也高情绪驱动
    

这些赛道的共同点不是“炒作”，而是：

> 尝试用去中心化方式，重构资产、组织与协作模式。

### **五、Web3 与 Web2 / Web3.0 的区别认知**

-   **Web2**：
    
    平台拥有数据与规则，用户是内容和行为的提供者。
    
-   **Web3.0（语义网）**：
    
    关注数据结构与机器理解，不等同于区块链。
    
-   **Web3（区块链语境）**：
    
    用户拥有资产、身份和部分治理权，
    
    平台更像协议而非公司。
    

Web3 的关键不在“技术更酷”，而在**权力结构的变化**。

### **六、Web3 的工作方式与协作形态**

Web3 项目多为：

-   远程分布式团队
    
-   跨时区、跨国协作
    
-   高度依赖线上工具
    

常见特征：

-   异步沟通而非强实时
    
-   Discord / Telegram 为主要协作场所
    
-   贡献形式多样（不只写代码）
    
-   更接近“项目制 + 社区制”而非传统雇佣制
    

在 Web3 中，“工作”往往表现为：

-   对协议、社区或产品的持续贡献
    
-   可被公开记录、评估与激励
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->








### **什么是区块链？它怎么工作？**

区块链是一种去中心化的分布式账本，用来把交易数据按时间顺序写入一个个“区块”，这些区块串成链，并由很多网络节点共同保存和验证。每个区块都包含交易数据和前一个区块的摘要（哈希），这使得历史记录**几乎无法被篡改**。所有交易对外公开透明，但和具体身份没有直接关联，所以可以实现**匿名性+可追溯性**。区块链通过激励机制（矿工或参与者获得代币奖励）来驱动系统运行。

区块链可以分为三类：

-   **公链（Public Blockchain）**：任何人都能加入，例如比特币、以太坊；
    
-   **联盟链（Consortium Blockchain）**：受限组织共同管理，例如企业间联盟链；
    
-   **私链（Private Blockchain）**：单一组织控制，例如企业内部链。
    

**Web3 与传统互联网的区别：**

-   Web2 是由中心化平台控制数据与服务；
    
-   Web3 是基于区块链的去中心化互联网，用户拥有数据所有权与资产控制权；
    
-   Web 3.0 通常指语义网，是 Web2 之后数据组织层面的升级，与区块链/去中心化不是同一概念。
    

### **以太坊概览：什么是以太坊？它能做什么？**

以太坊（Ethereum）是第二代区块链，被称为“区块链 2.0”，它不仅是一种加密货币（ETH），更是一个支持**智能合约**的去中心化计算平台。智能合约是储存在链上的代码片段，当满足预设条件时会自动执行，使得无需第三方中介即可开展交易或业务逻辑。

以太坊的核心组件包括：

-   **以太币（ETH）**：原生加密货币，用于支付交易费用（Gas）；
    
-   **以太虚拟机（EVM）**：运行智能合约的全球共享计算环境；
    
-   **智能合约**：自动执行的链上代码，用于构建去中心化应用（Dapps）、DeFi、NFT、DAO 等。
    

以太坊的一个重大升级是从 **工作量证明（PoW）转向权益证明（PoS）**（称为 _The Merge_），这极大降低了能耗，并为未来扩展性优化铺路。

**以太坊 vs 比特币：**

-   比特币主要是去中心化数字货币，强调价值储存与安全；
    
-   以太坊是去中心化计算平台，强调可编程性与生态扩展。
    

### **Web3 行业赛道全景（核心生态与趋势）**

区块链与 Web3 技术已经超越了单纯的加密货币支付，用于构建更广泛的去中心化经济与服务体系。主要赛道包括：

**1\. 去中心化金融（DeFi）**

DeFi 是一套不依赖传统金融机构的去中心化金融服务框架，包括借贷、交易、支付、流动性挖矿等，让任何人只要有加密钱包即可参与。

**2\. 非同质化代币（NFT）**

NFT 是具有唯一标识的数字资产，用于代表艺术品、收藏品、数字身份等，其价值来自链上所有权证明和稀缺性。

**3\. 去中心化自治组织（DAO）**

DAO 是基于智能合约的组织治理结构，通过代币持有者投票决策项目方向或资金使用，实现无中心化管理。

**4\. 模因币（MEME）与社区经济**

这类资产通常源于社区文化或热点话题，其价格波动大、风险高。了解链上数据透明性和市场机制有助于判断风险。

**5\. 跨界创新**

如 AI 与 DeFi 融合用于智能风险管理、自动化策略优化，以及 Web3 与实体行业（如乡村建设 DAO）的结合，这是技术与社会实践交叉的趋势。

### **Web3 的工作方式与日常协作模式**

Web3 行业的组织多为去中心化团队，成员可能跨时区、跨国协作，远程办公是常态。这要求掌握以下协作与工作方式：

**1\. 基础协作工具：**

-   **社交与发布平台**：Twitter（X）是生态动态与沟通核心渠道；
    
-   **即时通讯**：Telegram / Discord 是社区和团队日常沟通平台。
    

**2\. 远程协作特征：**

-   **异步沟通**：团队成员分布全球，不一定实时在线，信息通过留言、帖子、任务板等方式保持更新；
    
-   **去中心化标准流程**：任务与反馈在链外任务系统、协作工具上透明记录，提高协作效率；
    
-   **社区自治与开源文化**：很多 Web3 协作采取开放治理，任何人可以参与讨论、提案和开发。
    

**3\. 生产与贡献方式：**

在 Web3 里，贡献不是只写代码：产品设计、社区运营、市场传播、治理参与、法律合规等都能成为价值贡献路径。日常工作通常围绕协作工具、代码仓库、链上治理提案、文档输出等展开。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
