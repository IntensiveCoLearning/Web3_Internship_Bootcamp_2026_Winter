---
timezone: UTC+8
---

# liuw3679

**GitHub ID:** liuw3679

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->
加入时间锁

unix时间戳

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
​
//1.收款函数
//2.记录投资者并查看
//3.在锁定期内，达到目标款项，生产商可以进行提款
//4.在锁定期内，若没有达到，投资人可以在锁定期后退款
​
contract FundMe {
    mapping(address => uint256) public fundersToAmount;
​
    uint256 constant MINIMUM_VALUE = 100 * 10 ** 18; //单位是wei
    //USD
​
    AggregatorV3Interface internal dataFeed;
​
    uint256 constant TARGET_VALUE = 1000 * 10 **18; //设置常量
​
    address public owner;
​
    uint256 deploymentTimestamp; //合约开始时间，在构造器中赋值实现
    uint256 lockTime; //在构造器中赋值
​
    constructor(uint256 _lockTime) { //构造函数只会在合约部署的时候调用一次，之后就不会再调用了
        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306); //使用sepolia测试网
        owner = msg.sender;
        deploymentTimestamp = block.timestamp;
        lockTime = _lockTime;
    }
​
    function fund() external payable { //payable表示该函数能接收链上的原生token通证
        require(convertEthToUsd(msg.value) >= MINIMUM_VALUE, "send more ETH"); //condition是True时，交易才会正常进行，否则就会revert并返回""中的内容
        require(block.timestamp < deploymentTimestamp + lockTime, "wrong fund time");
        fundersToAmount[msg.sender] = msg.value;
    }    
​
     function getChainlinkDataFeedLatestAnswer() public view returns (int256) {
    // prettier-ignore
    (
      /* uint80 roundId */
      ,
      int256 answer,
      /*uint256 startedAt*/
      ,
      /*uint256 updatedAt*/
      ,
      /*uint80 answeredInRound*/
    ) = dataFeed.latestRoundData();
    return answer;
    }
​
    function convertEthToUsd(uint256 mum) internal view returns(uint256) {
        return mum * uint256(getChainlinkDataFeedLatestAnswer()) / 10 ** 8; // ETH/USD precision=10**8
    }
​
    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, "this function only be called by owner");
        owner = newOwner;
    }
​
    function getFund() external {
        require(convertEthToUsd(address(this).balance)/*wei*/ >= TARGET_VALUE, "Don't reach target value");
        require(msg.sender == owner, "this function only be called by owner");
        require(block.timestamp >= deploymentTimestamp + lockTime, "fund unstoped");
        // 有三种不同的转账方式，transfer(纯转账(由一个地址转向另一个地址)) send(纯转账,，return bool) call(纯转账和数据处理，可以返回值)
        //payable(msg.sender).transfer(address(this).balance);
        // bool success = payable(msg.sender).send(address(this).balance);
        // require(success, "tx failed");
        //(bool, result) = addr.call{value: value}("")
        bool success;
        (success, ) = payable(msg.sender).call{value: address(this).balance}("");
        require(success, "transfer tx failed");
        fundersToAmount[msg.sender] = 0;
    }
​
    function refund() external {
        require(convertEthToUsd(address(this).balance)/*wei*/ < TARGET_VALUE, "Reach target value");
        require(fundersToAmount[msg.sender] != 0, "There is no fund for you");
        require(block.timestamp >= deploymentTimestamp + lockTime, "fund unstoped");
        bool success;
        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}("");
        require(success, "transfer tx failed");
        fundersToAmount[msg.sender] = 0;
    }
}   
```

修改器

require的简便写法，写进修改器里面

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
​
//1.收款函数
//2.记录投资者并查看
//3.在锁定期内，达到目标款项，生产商可以进行提款
//4.在锁定期内，若没有达到，投资人可以在锁定期后退款
​
contract FundMe {
    mapping(address => uint256) public fundersToAmount;
​
    uint256 constant MINIMUM_VALUE = 100 * 10 ** 18; //单位是wei
    //USD
​
    AggregatorV3Interface internal dataFeed;
​
    uint256 constant TARGET_VALUE = 1000 * 10 **18; //设置常量
​
    address public owner;
​
    uint256 deploymentTimestamp; //合约开始时间，在构造器中赋值实现
    uint256 lockTime; //在构造器中赋值
​
    constructor(uint256 _lockTime) { //构造函数只会在合约部署的时候调用一次，之后就不会再调用了
        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306); //使用sepolia测试网
        owner = msg.sender;
        deploymentTimestamp = block.timestamp;
        lockTime = _lockTime;
    }
​
    function fund() external payable { //payable表示该函数能接收链上的原生token通证
        require(convertEthToUsd(msg.value) >= MINIMUM_VALUE, "send more ETH"); //condition是True时，交易才会正常进行，否则就会revert并返回""中的内容
        require(block.timestamp < deploymentTimestamp + lockTime, "wrong fund time");
        fundersToAmount[msg.sender] = msg.value;
    }    
​
     function getChainlinkDataFeedLatestAnswer() public view returns (int256) {
    // prettier-ignore
    (
      /* uint80 roundId */
      ,
      int256 answer,
      /*uint256 startedAt*/
      ,
      /*uint256 updatedAt*/
      ,
      /*uint80 answeredInRound*/
    ) = dataFeed.latestRoundData();
    return answer;
    }
​
    function convertEthToUsd(uint256 mum) internal view returns(uint256) {
        return mum * uint256(getChainlinkDataFeedLatestAnswer()) / 10 ** 8; // ETH/USD precision=10**8
    }
​
    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
​
    function getFund() external windowClosed onlyOwner {
        require(convertEthToUsd(address(this).balance)/*wei*/ >= TARGET_VALUE, "Don't reach target value");
        // 有三种不同的转账方式，transfer(纯转账(由一个地址转向另一个地址)) send(纯转账,，return bool) call(纯转账和数据处理，可以返回值)
        //payable(msg.sender).transfer(address(this).balance);
        // bool success = payable(msg.sender).send(address(this).balance);
        // require(success, "tx failed");
        //(bool, result) = addr.call{value: value}("")
        bool success;
        (success, ) = payable(msg.sender).call{value: address(this).balance}("");
        require(success, "transfer tx failed");
        fundersToAmount[msg.sender] = 0;
    }
​
    function refund() external windowClosed {
        require(convertEthToUsd(address(this).balance)/*wei*/ < TARGET_VALUE, "Reach target value");
        require(fundersToAmount[msg.sender] != 0, "There is no fund for you");
        bool success;
        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}("");
        require(success, "transfer tx failed");
        fundersToAmount[msg.sender] = 0;
    }
​
    modifier windowClosed() { //修改器
        require(block.timestamp >= deploymentTimestamp + lockTime, "fund unstoped");
        _; // 继续引用函数中的剩下的其他操作，会代表一个先后次序
    }
​
    modifier onlyOwner() {
        require(msg.sender == owner, "this function only be called by owner");
        _;
    }
}   
```
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->

**solidity进阶 FundMe && ERC-20**

通过函数发送ETH

Wei\*\*9 -> Gwei

Gwei\*\*6 -> Finney

Finnery\*\*3 -> Ether

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
//1.收款函数
//2.记录投资者并查看
//3.在锁定期内，达到目标款项，生产商可以进行提款
//4.在锁定期内，若没有达到，投资人可以在锁定期后退款
​
contract FundMe {
    mapping(address => uint256) public fundersToAmount;
    function fund() external payable { //payable表示该函数能接收链上的原生token通证
        fundersToAmount[msg.sender] = msg.value;
    }       
}
```

设置最小额度

```
uint256 MINIMUM_VALUE = 1 * 10 ** 18;
require(msg.value >= MINIMUM_VALUE, "send more ETH"); 
​
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
//1.收款函数
//2.记录投资者并查看
//3.在锁定期内，达到目标款项，生产商可以进行提款
//4.在锁定期内，若没有达到，投资人可以在锁定期后退款
​
contract FundMe {
    mapping(address => uint256) public fundersToAmount;
​
    uint256 MINIMUM_VALUE = 1 * 10 ** 18; //wei
    //USD
​
    function fund() external payable { //payable表示该函数能接收链上的原生token通证
        require(msg.value >= MINIMUM_VALUE, "send more ETH"); //condition是True时，交易才会正常进行，否则就会revert并返回""中的内容
        fundersToAmount[msg.sender] = msg.value;
    }       
}
```

chainlink喂价

预言机

NaN.  问题 链上的smartcontract无法主动获取链下的任何数据
      
NaN.  consensus共识
      
NaN.  通过去中心化预言机网络decentralized oracle network(DON)实现多节点对各自的数据源获取数据，然后各个节点之间进行数据聚合，然后将聚合以后的数据写回到区块链上
      
NaN.  chainlink该服务上运营去中心化的预言机网络
      

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
​
//1.收款函数
//2.记录投资者并查看
//3.在锁定期内，达到目标款项，生产商可以进行提款
//4.在锁定期内，若没有达到，投资人可以在锁定期后退款
​
contract FundMe {
    mapping(address => uint256) public fundersToAmount;
​
    uint256 MINIMUM_VALUE = 100 * 10 ** 18; //wei
    //USD
​
    AggregatorV3Interface internal dataFeed;
​
    constructor() {
        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306); //使用sepolia测试网，这里预言机相当于告诉了我们汇率
    }
​
    function fund() external payable { //payable表示该函数能接收链上的原生token通证
        require(convertEthToUsd(msg.value) >= MINIMUM_VALUE, "send more ETH"); //condition是True时，交易才会正常进行，否则就会revert并返回""中的内容
        fundersToAmount[msg.sender] = msg.value;
    }    
​
     function getChainlinkDataFeedLatestAnswer() public view returns (int256) {
    // prettier-ignore
    (
      /* uint80 roundId */
      ,
      int256 answer,
      /*uint256 startedAt*/
      ,
      /*uint256 updatedAt*/
      ,
      /*uint80 answeredInRound*/
    ) = dataFeed.latestRoundData();
    return answer;
    }
​
    function convertEthToUsd(uint256 mum) internal view returns(uint256) {
        return mum * uint256(getChainlinkDataFeedLatestAnswer()) / 10 ** 8; // ETH/USD precision=10**8
    }
}   
```

从智能合约中提取ETH

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
​
//1.收款函数
//2.记录投资者并查看
//3.在锁定期内，达到目标款项，生产商可以进行提款
//4.在锁定期内，若没有达到，投资人可以在锁定期后退款
​
contract FundMe {
    mapping(address => uint256) public fundersToAmount;
​
    uint256 constant MINIMUM_VALUE = 100 * 10 ** 18; //单位是wei
    //USD
​
    AggregatorV3Interface internal dataFeed;
​
    uint256 constant TARGET_VALUE = 1000 * 10 **18; //设置常量
​
    address public owner;
​
    constructor() { //构造函数只会在合约部署的时候调用一次，之后就不会再调用了
        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306); //使用sepolia测试网
        owner = msg.sender;
    }
​
    function fund() external payable { //payable表示该函数能接收链上的原生token通证
        require(convertEthToUsd(msg.value) >= MINIMUM_VALUE, "send more ETH"); //condition是True时，交易才会正常进行，否则就会revert并返回""中的内容
        fundersToAmount[msg.sender] = msg.value;
    }    
​
     function getChainlinkDataFeedLatestAnswer() public view returns (int256) {
    // prettier-ignore
    (
      /* uint80 roundId */
      ,
      int256 answer,
      /*uint256 startedAt*/
      ,
      /*uint256 updatedAt*/
      ,
      /*uint80 answeredInRound*/
    ) = dataFeed.latestRoundData();
    return answer;
    }
​
    function convertEthToUsd(uint256 mum) internal view returns(uint256) {
        return mum * uint256(getChainlinkDataFeedLatestAnswer()) / 10 ** 8; // ETH/USD precision=10**8
    }
​
    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, "this function only be called by owner");
        owner = newOwner;
    }
​
    function getFund() external {
        require(convertEthToUsd(address(this).balance)/*wei*/ >= TARGET_VALUE, "Don't reach target value");
        require(msg.sender == owner, "this function only be called by owner");
        // 有三种不同的转账方式，transfer(纯转账(由一个地址转向另一个地址)) send(纯转账,，return bool) call(纯转账和数据处理，可以返回值)
        //payable(msg.sender).transfer(address(this).balance);
        // bool success = payable(msg.sender).send(address(this).balance);
        // require(success, "tx failed");
        //(bool, result) = addr.call{value: value}("")
        bool success;
        (success, ) = payable(msg.sender).call{value: address(this).balance}("");
        require(success, "transfer tx failed");
        fundersToAmount[msg.sender] = 0;
    }
​
    function refund() external {
        require(convertEthToUsd(address(this).balance)/*wei*/ < TARGET_VALUE, "Reach target value");
        require(fundersToAmount[msg.sender] != 0, "There is no fund for you");
        bool success;
        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}("");
        require(success, "transfer tx failed");
        fundersToAmount[msg.sender] = 0;
    }
}   
```
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->


**solidity基础**

哈希函数

常见使用在SHA256

作用：将一个任意长度的数据转化为一个固定长度的数据

特点：

NaN.  确定性：同样数据生成的哈希值相同
      
NaN.  单向高效：计算数据的哈希算法很高效，容易通过计算数据的哈希值，但很难反推出原始数据
      

公钥私钥

两种类型的密钥

-   对称加密（单个密钥
    
-   非对称加密（一对密钥，区块链中用的就是这个
    
    -   加密
        
        -   任何人都可以通过接受者的公钥对信息进行加密
            
        -   只有公钥对应的私钥持有人才能对加密信息进行解密
            

电子签名原理

验证：

NaN.  用户通过私钥签名/授权交易（电子签名）
      
NaN.  通过公钥验证电子签名，确保私钥持有人在发送交易
      

recovery phrase

![屏幕截图 2025-12-14 132509](file://C:\Users\%E8%B4%BE%E5%B1%95%E9%B9%8F\Pictures\%E9%A2%84%E8%A7%88\%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-12-14%20132509.png?lastModify=1768654315)

基础格式

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
contract HelloWorld {
    bool boolVar = true:
​
    uint256 uintVar = 1; //自带memory
​
    int256 intVar = -1;
​
    bytes32 bytesVar = "Hello World";
    string strVar = "Hello World"; //与前者类似，但不自带memory
​
    address addrVar = ...;
​
//标识符限制作用域，internal(within child) exterenal(outside external) public(within outside child external) private(within)
//view告诉编译器只对该函数变量进行读取，pure会对变量进行纯计算操作
//return声明返回值，memory代表string的存储状态
    function sayHello() public view returns(string memory) {
        return addinfo(strVar);
    }
//solidity编程语言中数据的存储模式，storage(永久性存储，在合约中声明的变量属于storage，不需要声明，因为编译器会自动识别为storage) memory(暂时性存储) calldata(暂时性存储，且在使用该变量时无法进行修改) stack codes logs
    function setHelloWorld(string memory newstring) public {
        strVar = newstring;
    }
​
    function addinfo(string memory helloWorldStr) internal pure returns(string memory) {
        return string.concat(helloWorldStr, " from Weiliu's contract."); 
    }
}
```

```
//完整示例
//helloworld.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
contract HelloWorld {
    string strVar = "Hello World";
​
    struct Info {
        string phrase;
        uint256 id;
        address addr;
    }
​
    Info[] infos; //存储相同数据类型的变量
​
    mapping(uint256 id => Info info) infoMapping;
  
    function sayHello(uint256 _id) public view returns(string memory) {
        if(infoMapping[_id].addr == address(0x0)){ //这里0x0指的是空地址
            return addinfo(strVar);
        } else {
            return addinfo(infoMapping[_id].phrase);
        }
        // for(uint256 i = 0; i < infos.length; i++) {
        //     if(infos[i].id == _id) {
        //         return addinfo(infos[i].phrase);
        //     }
        // }
        // return addinfo(strVar);
    }
​
    function setHelloWorld(string memory newString, uint256 _id) public {
        Info memory info = Info(newString, _id, msg.sender);
        // infos.push(info);
        infoMapping[_id] = info;
    }
​
    function addinfo(string memory helloWorldStr) internal pure returns(string memory) {
        return string.concat(helloWorldStr, " from Weiliu's contract."); 
    }
}
​
​
//HelloWorldFactory.sol，工厂模式的实现
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
​
import {HelloWorld} from "./helloworld.sol";
//import "the url a solidity have online";
​
contract HelloWorldFactory {
    HelloWorld[] hw;
​
    function createHelloWorld() public {
        HelloWorld helloworld = new HelloWorld();
        hw.push(helloworld);
    }
​
    function getHelloWorldIndex(uint256 _index) public view returns(HelloWorld) {
        return hw[_index];
    }
​
    function getSayHelloFromFactory(uint256 _index, uint256 _id) 
    public 
    view 
    returns(string memory) {
        return hw[_index].sayHello(_id);
    }
​
    function callSetHelloFromFactory(uint256 _index, string memory newStr, uint256 _id) 
    public {
        hw[_index].setHelloWorld(newStr, _id);
    }
}
```

数据结构

NaN.  结构体struct
      
NaN.  数组array
      
NaN.  映射mapping
      

工厂模式

NaN.  概念定义
      
      想法是拥有一个合约（工厂），该合约承担创建其他合约的任务
      
NaN.  使用工厂模式的原因
      
      NaN.  创建同一个合约的多个实例，寻找一种跟踪他们并且简化管理的方法
            
            ```
            contract Factory {
            Child[] children;
            function createChild(uint data) {
            Child child = new Child(data);
            children.push(child);
            }
            }
            contract Child {
            uint data;
            constructor(uint _data) {
            data = _data;
            }
            }
            ```
            
      NaN.  节省部署成本，可以先部署工厂再在后续使用中部署其他合约
            
      NaN.  遵守一些安全条约
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->



// 账户系统？

1.账户结构

EOA由64进制公私钥对产生

CA通过create/call产生，地址由创建者地址+创建次数得到

2.账户状态映射

所有活跃账号的状态都存在Merkle‑Patricia Trie

区块头中stateRoot定义了链顶层状态

3.状态变更流程

nonce递增防止重放

balance调整。发送方->value+gas\*fee，接收方<-value

若交易包含input(函数调用)或data(合约部署)，EVM代码会被执行，同时stroageRoot与codeHash更新

4.安全性

不可篡改。codeHash不可变，合约代码一旦部署就不可修改

可验证。链存储 stateRoot 与交易执行结果对应，任何节点都能以相同方式重算得到同一状态

经济激励。交易费（gas）与 block reward 保证节点投入算力得到相应回报

// optimistic rollup？

排程器sequencer

L1 Roll-up合约

Fraud-Proof机制

| 步骤 | 说明 | 需要在 L1 上做的事 | 需要在 L2 上做的事 |
| --- | --- | --- | --- |
| 1. 收到交易 | 用户把交易广播给 L2 Sequencer | 无 | L2 收到交易并验证签名 |
| 2. 区块打包 | Sequencer 把 N 条交易捆绑成 batch & 生成L2 区块 | 无 | 运行合约，得到新的 stateRoot |
| 3. 提交归档 | Sequencer 把 stateRoot + 批次摘要写入 L1 合约（commit(batches)） | 记录状态根、开启 challenge window | 交付 L2 区块后停止执行 |
| 4. 挑战周期 | 任意人观察 stateRoot 与本地执行状态是否一致 | 需要保留 L2 状态根 | 任何人可提交 Fraud-Proof （通常提供被质疑交易的 calldata、输入/输出等） |
| 5. Fraud‑Proof | L1 合约执行小量验证（一般是跑一小块 L2 代码或校验序列），若失败则 rollback 到上一有效状态并处罚 Sequencer | 验证Proof（如 “Merkle proof” + “验算”） | - |
| 6. 完成 | 如果没有 Fraud‑Proof，状态根被视为最终，用户可以随时在 L2 里继续交易；若用户想 退出，在 L1 提交 withdraw() → L2 计算 balance → L1 号回 | 记录退出请求 | 根据最新 stateRoot 计算可提现金额 |
| 7. 退出 | 用户从 L2 账户转出 Ether/Token 到 L1 | 合约把对应余额转账给用户 | - |
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->




// 点对点合约？

p2p合约的核心流程，关于合约的部署（create）与调用（transaction）的过程：

1.交易被任一个节点接收后先做签名、余额、nonce等信息校验，然后将交易广播到与其相连的邻居节点；

2.邻居节点运行后在将其转发到更多的节点，最终整个网络都能收到交易；

3.交易被打包进区块并被矿工验证时，每个节点会按照相同的EVM代码执行，得到同一条状态变更，并产生统一的状态根哈希。每个节点都跑一次就保证了去中心化和一致性。

总结就是：去中心化的、所有节点都能拉取和执行相同合约代码的交易关系网络。

// 区块链2.0？

区块链1.0是去中心化的分布式账本，主要用于数字货币支付

2.0除了账本功能之外，加入了可编程、可组合的执行层，支持更多更复杂的业务

升级路线是PoS -> Sharding -> Rolling-ups -> 生态多链

// 通过算力竞争记账权原理？

区块是链上交易的容器

只有合法区块才能被大家接受并加入链

合法取决于谁先把区块做出来

工作原理流程：

1.交易收集；

2.选取交易（按gas fee高低和时间先后挑选交易列表并打包为区块）；

3.区块头准备（需要一个随机数nonce和此前区块的prevHash等信息组成区块头）；

4.哈希碰撞（用sha256对区块头计算哈希，但是会要求前N位必须为零或低于某个阈值，这个要求就是难度目标）；

5.逃跑的碰撞（节点不断改变nonce并重新哈希直到满足上一步要求，所以说这是一个会投入电力和算力的无意义的、摸索的过程）：

6.完成打包并广播（一旦得到符合条件的哈希，节点会将整个区块发送给其他节点。其他节点会再验证一遍而同步该区块）。

总结说就是先把一个无意义的哈希计算到符合条件，就能得到记账权和区块奖励。

// 超声波效应

关键升级

EOP-1559 燃烧base fee，减少流通供应

the merge 发行量大幅下降，矿工每日发行量从13kETH降至1.7kETH

// 共识层管理验证者、确认区块顺序？

通过 validator registration (despos) 产生一致的验证者集合。

每一 slot 有 proposer 提议区块，所有验证者投票确认。

通过 LMD‑GHOST + Casper FFG 决定区块的链顺序与最终化。

违规的 validator 被罚或滑铁卢，进一步保障网络安全。

// PoS验证者获得新发行的ETH和交易费用?

协议每个 epoch 按 validator stake 挖掘和用户在交易时附加的“优先费用”

// PoW惩罚机制和经济安全性

| 场景 | 惩罚‑类效应 | 说明 |
| --- | --- | --- |
| 无效区块 | 失去奖励 | 产出的区块不被接受，矿工不拿到 block reward，且区块产生的交易也会流失 |
| 链分叉 | 舍弃收益 | 产生了 “孤儿区块（orphan block）”，算力投入但无回报 |
| 自我攻击（51%） | 无代币扣减，但 自由失去 | 攻击后会自己破坏链价值，导致自身矿池价值降低 |
| 作弊（无效交易） | 失去 ETH （被视为无效） | 你送出无效交易，矿工会验证失败，费用不报偿 |

攻击成本 ≈ 把算力转移到攻击所需 51%+ 的厂商成本。若攻击者一年耗电量与其潜在收益相当或更高，则攻击没经济意义
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->





### **以太坊核心机制**

账户系统、Gas模型、以太坊虚拟机

账户系统

-   含由私钥控制的外部账户EOA（私钥是控制账户的钥匙，公钥是由加密算法生成的一个唯一的地址）和由合约控制的合约账户CA（由智能合约生成的一个可用于查找该合约执行记录的唯一地址，很像由合约生成的一个实例）
    
-   每个账户都含有四个重要字段
    
    -   Nonce 防止重复交易的计数器
        
        -   EOA记录发送次数
            
        -   CA记录创建合约次数
            
    -   余额
        
    -   CodeHash
        
        -   EOA为空哈希
            
        -   CA存储合约字节码的哈希
            
    -   StorageRoot 记录账户数据的Merkle树根哈希
        
        ```
        // Merkle树根哈希
        ```
        

Gas模型

gas fee = gas limit \* (base fee + tip)

EVM

特定：图灵完备（可像一台真正的电脑一样处理各种逻辑）、全球同步（每个节点都会自己执行一遍代码保证结果一致）、隔离安全（不允许EVM访问用户的数据和网络）

### **交易一般流程**

NaN.  用户通过EOA发起交易
      
      ```
      // EOA？
      ```
      
NaN.  交易附带gas参数
      
NaN.  EVM执行合约代码，修改存储
      
NaN.  gas费用按gas fee扣除
      

## **安全与合规**

### **合规性要求和常见法律责任**

NaN.  核心法律风险梳理
      
      -   代币发行与交易行为的法律风险
          
      -   赌博、传销、洗钱等刑事风险
          
      -   场外交易中的洗钱与非法经营风险
          
      -   民商事争议
          
NaN.  全球的背景和趋势
      
      -   FATF（Financial Action Task Force，金融行动特别工作组）
          
      -   [稳定币监管的意义](https://web3intern.xyz/zh/security/#%E7%A8%B3%E5%AE%9A%E5%B8%81%E7%9B%91%E7%AE%A1%E7%9A%84%E6%84%8F%E4%B9%89)
          
          -   监管稳定币的影响
              
              -   对央行数字货币（CBDC）构成竞争
                  
              -   跨境支付可能绕过传统银行系统
                  
          -   监管目标
              
              保护投资者、维护金融稳定、反洗钱合规
              
      -   全球监管趋势
          
NaN.  入职防范
      
      -   雇佣新形态
          
          EOR（名义雇主模式）委托国内公司与员工签订合同
          
      -   薪资结构
          
          rmb+token
          
          usdt
          
      -   虚拟货币出金与合规风险
          
      -   项目合法要提前审查
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->






## **以太坊基础**

### **概述**

以太坊通过原生货币ETH来为EVM提供价值媒介，以处理点对点合约。其目标是以智能合约和可编程性为功能要点的“世界计算机”

```
// 点对点合约？
```

ETH不同于FT和NFT，它是以太坊的原生代币。其可用于支付去中心化服务商的交易打包费用

### **ETH和BTC**

|   | 定位 | 编程性 | 共识机制 | 交易速度 | 经济模型 | 使用场景 |
| --- | --- | --- | --- | --- | --- | --- |
| bitcoin | 去中心化数字货币，强调安全稳定和稀缺 | 仅支持简单交互逻辑 | proof of work，矿工通过算力竞争记账权 | 十分钟生成一区块，交易打包速度慢 | 总量有限具有抗通胀性 | DeFi交易、NFT数字艺术品、DAO |
| ethereum | 去中心化平台，定位是“区块链2.0” | 功能完备的solidity语言，可完成一些复杂逻辑 | proof of stake，权益证明，通过the merge实现能源效率优化 | 打包交易时间需约十二秒 | 供应灵活，通过EIP-1559等机制呈现通缩趋势，“超声波效应” | 存储价值 |

```
// 区块链2.0？
// 通过算力竞争记账权原理？
// 超声波效应
```

### **以太坊进步**

多次升级中最重要的是PoW向PoS的合并这个事件

NaN.  1.0PoW阶段
      
NaN.  2.0和the merge
      

将PoS共识机制在预先的信标链与PoW并行后插接到了信标链的Pos系统，合并后的新架构有两层分别是执行层（lay2，原主网，处理交易和智能合约）、共识层（lay1，信标链，管理验证者、确认区块顺序）

```
// 共识层管理验证者、确认区块顺序？
```

PoS机制和PoW对比

|   | 能耗 | 验证门槛 | 工作方式 | 奖励机制 | 惩罚机制 | 经济安全性 |
| --- | --- | --- | --- | --- | --- | --- |
| PoS | 能耗降低99% | 质押32ETH成为验证者 | 系统随机选择验证者来验证区块 | 验证者获得新发行的ETH和交易费用 | 作恶者质押的ETH被销毁slashing | 攻击成本约需控制全网三分之二的质押ETH |
| PoW | 耗费大量电力和硬件 | 耗费大量成本挖矿 | 通过计算竞争交易的打包权 | 交易者支付给打包者服务费用 | ? | ？ |

```
// PoS验证者获得新发行的ETH和交易费用?
// PoW惩罚机制和经济安全性
```

升级路线

NaN.  分片技术
      
      由执行分片向数据分片发展
      
      -   原来要将以太坊分成64条彼此独立处理交易的分片链
          
      -   而后转向数据分片来配合layer2实现扩容
          
      
      数据分片能为rollup（打包）提供更多更便宜的数据存储空间
      
      重点升级将是原型丹克分片
      
NaN.  EIP-4844的cancun升级
      
      layer2工作原理
      
      -   layer2在链下（执行层）处理大量交易
          
      -   定期打包交易数据到以太网主网
          
      -   主网（识别层）验证数据正确性
          
      
      EIP-4844突破在于
      
      -   原l2提交数据时使用常规交易，成本高昂
          
      -   现引用blob交易类型，数据存储成本大幅度降低。同时blob数据会在一定时间后自动删除，不会永久占用主网存储
          
NaN.  ZK-Rollup技术
      
      批量处理、零知识证明（生成一个简洁的“正确性证明”）、主网验证（仅验证这个零知识证明的合法性）
      
      优点：速度快、成本低、安全性高
      

### **以太坊生态**

由l1、l2、sidechains等构成

1.  layer1
    
    以太坊主网、核心区块链，负责安全性和共识；EVM执行智能合约代码；账户系统外部账户（EOA）和合约账户（CA）共同构成网络基础
    
    ```
    // 账户系统？
    ```
    
2.  layer2
    
    rollup、optinistic rollup假设交易合法，有问题时才验证处理；ZK rollup零知识证明验证交易
    
3.  侧链
    
    独立运行的链，通过桥接和主网交互
    
4.  以太坊生态分层架构
    
    -   应用层（用户直接交互的应用界面
        
    -   协议层
        
        共识层客户端、执行层客户端、核心协议
        
    -   拓展层
        
        rollups、侧链、状态通道
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->







# 实习手册

## **区块链基础**

### **区块链结构**

区块链由区块和链构成

-   区块由一些有限的含地址等信息的交易记录和之前的区块哈希组成
    
-   链可以连接两个区块；区块可由链顺次串联
    

由此可知的特性：不可篡改（区块哈希摘要使多个区块间是相互关联的，若改变一个区块，就要改变与之相关的全部区块）、公开可查且匿名（交易信息对外公开，但对外不会进行交易地址和个人信息的映射）、快速交易（交易会定时由区块链节点打包）、去中心化（区块链网络数据由所有节点共同组成）

### **BTC**

-   作为网络节点服务提供商对外提供服务的奖励
    
-   货币属性：限量，可流通
    

### **区块链的核心组成部分**

去中心化网络与区块链数据、维持网络服务的代币激励

### **公链私链联盟链对比**

|   | 成为节点的方法 | 数据管理模式 |
| --- | --- | --- |
| 公链 | 无需申请、自由进出 | 所有人可见、去中心化决策 |
| 联盟链 | 受邀或申请、权限分级（决策者和观察者） | 数据半公开、联合决策 |
| 私链 | 严格审批、人员固定 | 数据私有、老板决定重要事宜 |

### **Web3 Web3.0 Web2**

|   | 控制权 | 数据存储 | 技术栈 |
| --- | --- | --- | --- |
| Web2 | 平台巨头垄断 | 中心服务器 | react node.js mysql |
| Web3.0 | 部分开放 | 混合存储（相对于Web2的语义网升级） | python rdflib sparql |
| Web3 | 完全开放和自治 | 区块链 | react ethers.js solidity |
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
