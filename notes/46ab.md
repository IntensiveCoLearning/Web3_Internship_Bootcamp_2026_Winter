---
timezone: UTC+8
---

# 46ab

**GitHub ID:** 46ab

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-28
<!-- DAILY_CHECKIN_2026-01-28_START -->
AMM 交易对（Swap、流动性添加 / 移除）

AMM（自动做市商）的核心是恒定乘积公式 `x*y=k`，异常处理需校验交易金额、滑点、不变量：

solidity

```
pragma solidity ^0.8.20;

contract AMMPair {
    // 自定义错误
    error InsufficientLiquidity();
    error SlippageExceeded(uint256 expected, uint256 actual);
    error KConstantViolated(uint256 beforeK, uint256 afterK);

    uint256 public reserve0; // 代币0储备
    uint256 public reserve1; // 代币1储备
    uint256 public constant MIN_SLIPPAGE = 99; // 最大滑点1%（预期金额的99%）

    // 添加流动性：校验储备不变量
    function addLiquidity(uint256 amount0, uint256 amount1) public {
        require(amount0 > 0 && amount1 > 0, "Amounts must be > 0");

        // 记录添加前的k值（恒定乘积）
        uint256 beforeK = reserve0 * reserve1;

        // 更新储备
        reserve0 += amount0;
        reserve1 += amount1;

        // 校验k值是否正确（不变量校验，用assert）
        uint256 afterK = reserve0 * reserve1;
        assert(afterK >= beforeK); // 确保k值不减少（AMM核心不变量）
    }

    // 代币兑换：校验滑点
    function swap(uint256 amountIn, address tokenIn, uint256 minAmountOut) public returns (uint256 amountOut) {
        require(amountIn > 0, "Amount in must be > 0");
        require(reserve0 > 0 && reserve1 > 0, "Insufficient liquidity");

        // 计算预期输出金额（简化的恒定乘积公式）
        amountOut = (amountIn * (tokenIn == address(0) ? reserve1 : reserve0)) / (tokenIn == address(0) ? reserve0 + amountIn : reserve1 + amountIn);
        
        // 校验滑点：实际输出不低于最小预期（用户设置的滑点容忍度）
        uint256 minExpected = (amountOut * MIN_SLIPPAGE) / 100;
        if (amountOut < minExpected) {
            revert SlippageExceeded(minExpected, amountOut);
        }

        // 执行兑换逻辑（更新储备、转账代币）...

        // 最终校验k值（核心不变量）
        uint256 k = reserve0 * reserve1;
        assert(k > 0); // 确保k值不为0（避免流动性耗尽）
    }

    // 移除流动性：校验余额
    function removeLiquidity(uint256 liquidity) public {
        if (liquidity == 0 || liquidity > totalLiquidity()) {
            revert InsufficientLiquidity();
        }

        // 计算应提取的代币数量...
        // 执行移除逻辑...
    }

    function totalLiquidity() public view returns (uint256) {
        // 返回总流动性（简化示例）
        return 1000000;
    }
}
```
<!-- DAILY_CHECKIN_2026-01-28_END -->

# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->

借贷合约（清算、利率、抵押率校验）

借贷合约的核心风险点是「抵押不足清算」「利率计算错误」「还款金额校验」，异常处理需覆盖这些场景：

solidity

```
pragma solidity ^0.8.20;

contract LendingProtocol {
    // 自定义错误（覆盖借贷核心场景）
    error CollateralTooLow(address borrower, uint256 required, uint256 current);
    error RepaymentAmountExceedsDebt(uint256 repaid, uint256 debt);
    error LiquidationFailed(address borrower, address liquidator);
    error InvalidInterestRate(uint256 rate);

    // 状态变量：用户借款信息
    mapping(address => uint256) public userDebt; // 借款金额
    mapping(address => uint256) public userCollateral; // 抵押品价值
    uint256 public constant MIN_COLLATERAL_RATIO = 150; // 最低抵押率150%
    uint256 public interestRate = 5; // 利率（%）

    // 设置利率：仅管理员可操作，校验利率合理性
    function setInterestRate(uint256 newRate) public {
        // 校验利率范围（0-100%）
        if (newRate > 100 || newRate < 0) {
            revert InvalidInterestRate(newRate);
        }
        interestRate = newRate;
    }

    // 还款：校验还款金额不超过债务
    function repay(uint256 amount) public {
        uint256 debt = userDebt[msg.sender];
        require(debt > 0, "No debt to repay");
        
        // 校验还款金额不超过债务
        if (amount > debt) {
            revert RepaymentAmountExceedsDebt(amount, debt);
        }

        // 执行还款逻辑（扣减债务）
        userDebt[msg.sender] -= amount;
        // 转账代币（省略，参考场景1）...
    }

    // 清算：当抵押率不足时，清算人可接管抵押品
    function liquidate(address borrower) public {
        uint256 collateral = userCollateral[borrower];
        uint256 debt = userDebt[borrower];
        uint256 requiredCollateral = (debt * MIN_COLLATERAL_RATIO) / 100;

        // 校验抵押率是否不足（核心清算条件）
        if (collateral < requiredCollateral) {
            revert CollateralTooLow(borrower, requiredCollateral, collateral);
        }

        // 执行清算逻辑（简化示例）
        bool success = _executeLiquidation(borrower, msg.sender);
        if (!success) {
            revert LiquidationFailed(borrower, msg.sender);
        }
    }

    // 内部清算逻辑（private函数）
    function _executeLiquidation(address borrower, address liquidator) private returns (bool) {
        // 清算逻辑：转移抵押品、扣减债务...
        return true;
    }
}
```
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->


DeFi 常见场景的异常处理实践

ERC20 代币转账 / 授权

**错误示例**（未校验返回值）：

```
// 危险：transferFrom返回false时，合约不会抛异常，资产会被锁定
IERC20(token).transferFrom(msg.sender, address(this), amount);
```

**正确实践**（校验返回值 + 自定义错误）：

```
pragma solidity ^0.8.20;

// 导入ERC20接口
interface IERC20 {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function transfer(address to, uint256 value) external returns (bool);
}

contract DeFiTokenHandling {
    // 定义自定义错误（Gas 效率远高于字符串）
    error TokenTransferFailed(address token, address from, address to, uint256 amount);
    error InsufficientAllowance(address owner, uint256 allowance, uint256 required);

    // 存款函数：用户存入ERC20代币
    function deposit(address token, uint256 amount) public {
        // 1. 校验金额大于0（基础校验）
        require(amount > 0, "Amount must be > 0"); // 简单提示也可，或用自定义错误

        // 2. 执行转账并校验返回值
        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);
        if (!success) {
            revert TokenTransferFailed(token, msg.sender, address(this), amount);
        }

        // 后续逻辑：更新用户存款余额...
    }

    // 提现函数：合约向用户转账ERC20代币
    function withdraw(address token, uint256 amount) public {
        require(amount > 0, "Amount must be > 0");
        
        bool success = IERC20(token).transfer(msg.sender, amount);
        if (!success) {
            revert TokenTransferFailed(token, address(this), msg.sender, amount);
        }

        // 后续逻辑：扣减用户存款余额...
    }
}
```
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->



三种机制，核心对比表：

| 关键字 | Gas 消耗 | 适用场景 | 错误信息 |
| --- | --- | --- | --- |
| require() | 仅消耗执行到该语句的 Gas | 输入校验、权限校验、前置条件、用户操作校验 | 可选字符串提示 |
| revert() | 仅消耗执行到该语句的 Gas | 复杂逻辑判断、分支异常、自定义错误 | 支持自定义错误 |
| assert() | 消耗所有剩余 Gas | 内部逻辑 bug、不变量校验、严重错误 | 无自定义提示 |

**使用准则**：

1.  90% 的场景用 `require()`：处理用户输入、权限、状态等「预期可能失败」的情况。
    
2.  复杂逻辑用 `revert()`：尤其是 Solidity 0.8.4+ 推荐使用「自定义错误」（比字符串提示更省 Gas）。
    
3.  极少场景用 `assert()`：仅用于校验「绝对不能出错」的内部逻辑（如数学恒等式、状态不变性）。
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->




**学习revert ()：自定义 / 复杂逻辑异常**

`revert()` **用于「需要更复杂逻辑判断后触发异常」的场景，或在函数中间 / 分支中主动抛出异常，功能和** `require()` **类似，但更灵活。**

-   **语法：**
    
    -   **直接触发：**`revert("错误提示信息");`
        
    -   **自定义错误（Solidity 0.8.4+ 推荐）：**`revert 自定义错误名(参数);`
        
-   **特性：触发异常并回滚状态，返还未使用的 Gas，支持更复杂的触发逻辑。**
    
-   **典型场景：多条件组合判断后抛异常、循环中触发异常、自定义错误码等。**
    

**示例**

```
pragma solidity ^0.8.20;

contract RevertExample {
    // 定义自定义错误（更省 Gas，推荐使用）
    error InsufficientBalance(uint256 requested, uint256 available);
    error TransferFailed(address recipient);

    mapping(address => uint256) public balances;

    function transfer(address to, uint256 amount) public {
        // 复杂逻辑判断示例：先检查余额
        if (balances[msg.sender] < amount) {
            // 触发自定义错误（带参数）
            revert InsufficientBalance(amount, balances[msg.sender]);
        }

        // 扣减余额
        balances[msg.sender] -= amount;
        // 增加接收方余额（先加后转，防止重入，此处仅示例）
        balances[to] += amount;

        // 尝试转账ETH（若失败则回滚）
        (bool success, ) = payable(to).call{value: amount}("");
        if (!success) {
            // 回滚并提示转账失败
            revert TransferFailed(to);
        }
    }

    // 普通 revert 示例：手动触发异常
    function emergencyStop() public {
        // 模拟：仅特定时间前可调用
        if (block.timestamp > 1735689600) { // 2025-01-01 00:00:00
            revert("Function disabled after 2025-01-01");
        }
        // 执行紧急停止逻辑...
    }
}
```
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->





### **Solidity 异常处理核心机制**

**Solidity 中处理错误主要依赖 3 个关键字：**`require()`**、**`revert()` **和** `assert()`**，它们都会触发交易回滚（撤销本次交易的所有状态变更），但用途和行为有明确区分。**

**1\. require ()：输入 / 条件校验（最常用）**

`require()` **是最常用的异常处理方式，用于校验前置条件、输入参数、权限、状态等「预期可能失败」的场景。**

-   **语法：**`require(条件表达式, "错误提示信息");`
    
-   **特性：条件不满足时，触发异常并回滚状态，返还未使用的 Gas（仅消耗执行到该语句的 Gas）。**
    
-   **典型场景：权限校验、参数合法性检查、余额不足校验等。**
    

```
pragma solidity ^0.8.20;

contract RequireExample {
    address public owner;
    uint256 public minimumDeposit = 1 ether;

    constructor() {
        owner = msg.sender; // 部署者为合约所有者
    }

    // 存款函数：校验存款金额和调用者权限
    function deposit() public payable {
        // 校验存款金额不小于最小值
        require(msg.value >= minimumDeposit, "Deposit amount is too low");
        // 校验调用者不是空地址（示例）
        require(msg.sender != address(0), "Invalid sender address");
    }

    // 提现函数：仅所有者可调用
    function withdraw(uint256 amount) public {
        // 权限校验
        require(msg.sender == owner, "Only owner can withdraw");
        // 余额校验
        require(amount <= address(this).balance, "Insufficient contract balance");
        
        // 执行提现
        payable(msg.sender).transfer(amount);
    }
}
```

**今日学习**
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->






学习核心函数特性

1.函数可见性

| 修饰符 | 可调用方 | 说明 |
| --- | --- | --- |
| public | 外部账户 / 其他合约 / 内部调用 | 最常用，自动生成 getter（仅状态变量） |
| private | 仅当前合约内部 | 外部无法调用 |
| internal | 当前合约 / 继承合约 | 介于 public 和 private 之间 |
| external | 仅外部账户 / 其他合约 | 内部调用需加 this.函数名() |

2\. 函数状态修饰符

-   `view`：只读，不修改状态变量
    
-   `pure`：纯函数，既不读也不写状态变量
    
-   `payable`：可接收以太币（ETH），调用时可附带转账
    

```
pragma solidity ^0.8.20;

contract PayableExample {
    address payable public owner;

    constructor() {
        owner = payable(msg.sender); // 部署者地址转为可支付地址
    }

    // 接收ETH的函数（payable 修饰）
    function deposit() public payable {
        // msg.value 是调用函数时附带的ETH数量（单位：wei，1 ETH = 10^18 wei）
        require(msg.value > 0, "Deposit amount must be greater than 0");
    }

    // 提取合约中的ETH
    function withdraw() public {
        require(msg.sender == owner, "Only owner can withdraw");
        // 转账方式1：transfer（失败会回滚，有gas限制）
        owner.transfer(address(this).balance);
        // 转账方式2：send（失败返回false，无gas限制）
        // bool success = owner.send(address(this).balance);
        // require(success, "Transfer failed");
    }

    // 获取合约余额
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
```

常用全局变量有以下几种

Solidity 提供了内置的全局变量，用于获取区块链和交易的上下文信息：

-   `msg.sender`：当前调用者的地址
    
-   `msg.value`：调用函数时附带的 ETH 数量（wei）
    
-   `block.number`：当前区块号
    
-   `block.timestamp`：当前区块的时间戳（秒）
    
-   `address(this)`：当前合约的地址
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->







Solidity 的数据类型分为值类型和引用类型

1\. 值类型（Value Types）

值类型变量赋值时会拷贝数据，包括：

-   **布尔型**：`bool`（true/false）
    
-   **整型**：`int/uint`（int 是有符号，uint 是无符号，可指定位数如 uint256、int8）
    
-   **地址型**：`address`（存储以太坊账户地址，长度 20 字节；`address payable` 可转账）
    
-   **枚举型**：`enum`（自定义有限值集合）
    

```
pragma solidity ^0.8.20;

contract ValueTypes {
    // 布尔型
    bool public isActive = true;
    // 整型（uint256 是最常用的，默认uint等价于uint256）
    uint256 public count = 100;
    int8 public temperature = -20;
    // 地址型
    address public owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;
    // 枚举型
    enum Status { Pending, Completed, Cancelled }
    Status public orderStatus = Status.Pending;

    // 函数：修改枚举值
    function setCompleted() public {
        orderStatus = Status.Completed;
    }
}
```

2\. 引用类型（Reference Types）

引用类型赋值时传递的是引用，修改会影响原数据，需指定存储位置（memory/storage/calldata）：

-   **数组**：`array`（固定长度 `uint[5]` 或动态长度 `uint[]`）
    
-   **结构体**：`struct`（自定义复合数据类型）
    
-   **映射**：`mapping`（键值对存储，类似 Python 字典，仅支持 storage 存储）
    

```
pragma solidity ^0.8.20;

contract ReferenceTypes {
    // 结构体：定义用户信息
    struct User {
        string name;
        uint256 age;
        address wallet;
    }

    // 动态数组：存储多个User
    User[] public users;

    // 映射：用户地址 => 余额（区块链中常用作账户余额记录）
    mapping(address => uint256) public balances;

    // 函数：添加用户
    function addUser(string memory _name, uint256 _age) public {
        // 创建User结构体并添加到数组
        users.push(User({
            name: _name,
            age: _age,
            wallet: msg.sender // msg.sender 是调用者的地址（全局变量）
        }));
        // 给调用者设置余额
        balances[msg.sender] = 1000;
    }

    // 函数：获取用户余额
    function getBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}
```

今天学习的是核心数据类型
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->








```
// 指定 Solidity 编译器版本（^表示兼容0.8.20及以上，小于0.9.0）
pragma solidity ^0.8.20;

// 合约定义（类似面向对象的"类"）
contract HelloWorld {
    // 状态变量：存储在区块链上的持久化数据
    string public message;

    // 构造函数：合约部署时仅执行一次
    constructor(string memory initialMessage) {
        message = initialMessage;
    }

    // 公共函数：修改状态变量（写操作，消耗gas）
    function setMessage(string memory newMessage) public {
        message = newMessage;
    }

    // 公共函数：读取状态变量（读操作，不消耗gas）
    function getMessage() public view returns (string memory) {
        return message;
    }
}
```

**学习Solidity 合约，这是最简单的结构，类似于python的第一课，hello world，然后做解释**

-   `pragma solidity ^0.8.20;`**：指定编译器版本，避免因版本差异导致合约异常。**
    
-   `contract`**：定义智能合约的关键字，一个合约对应一个可部署到区块链的程序。**
    
-   **状态变量：**`message` **是存储在区块链上的变量，**`public` **修饰符会自动生成一个只读的 getter 函数（你可以直接调用** `message()` **获取值，无需手动写** `getMessage`**）。**
    
-   **构造函数：**`constructor` **在合约部署时执行，用于初始化状态变量。**
    
-   **函数修饰符：**
    
    -   `public`**：外部账户和其他合约都可调用。**
        
    -   `view`**：仅读取状态，不修改区块链数据，不消耗 gas。**
        
    -   `memory`**：指定变量存储位置（Solidity 中变量有 memory/storage/calldata 三种存储位置）。**
        

明天继续学习
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->









![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-19-1768834410025-image.png)

今天是运营的相关内容
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->










![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-18-1768749860792-image.png)

这是关于今天所上课的DAO有关的，我做了一个关于DAO的发展历程与演进方向的脑图，涵盖了发展到未来的演变
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->











![cdd.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-17-1768664159747-cdd.jpg)

最近在思考和了解一个Web3项目应该怎么进行，以上是我参考和主动学习做的脑图，不完全是，但是应该目前Web3项目主要流程。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->













![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-16-1768577238904-image.png)

今日脑图总结
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->














![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-15-1768484238212-image.png)
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->















![e5791950f4d7bf5d8017f2fa748a3a0d.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-14-1768402257188-e5791950f4d7bf5d8017f2fa748a3a0d.jpg)

安全和合规脑图
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
















## Web3 最核心的本质

Web3 的一切运行逻辑，都建立在一个核心上：**用「去中心化的区块链」替代 Web2 里的「中心化服务器」，成为整个网络的「核心账本 + 核心数据库 + 核心规则引擎」**。

> 一句话总结：Web2 是「平台说了算」，Web3 是「代码说了算、全网共识说了算」，没有任何一个人 / 公司能单方面控制。

## Web3 底层核心运行原理

Web3 把 Web2 里「中心化服务器」的所有核心职能，全部交给了**「区块链网络」+「智能合约」+「分布式节点」**，三者协同完成所有工作，这也是 Web3 的三大核心支柱，缺一不可，完整运行逻辑如下：

核心支柱 1：区块链（去中心化的「公共账本 + 数据库」）

区块链不是单一的服务器，而是由**全球无数台独立的计算机（节点）** 组成的「分布式网络」，每一台节点上，都完整同步了**一模一样的、不可篡改的全部数据账本**。

-   作用：替代 Web2 的「中心化数据库」，存储 Web3 网络里的所有核心数据（比如你的数字资产、交易记录、用户身份、内容确权信息、资产归属）；
    
-   核心特性：
    
    1.  去中心化：没有任何一台「主服务器」，所有节点地位平等，少了任何一个节点，网络照样运行。
        
    2.  数据不可篡改：账本里的任何一条数据，一旦写入，就会被全网所有节点同步记录，想改数据，必须同时修改全网 51% 以上的节点，技术和成本上几乎不可能实现。
        
    3.  公开透明：所有数据对全网可见，任何人都可以查询验证，没有暗箱操作。
        

核心支柱 2：智能合约（去中心化的「规则引擎 + 自动执行程序」）

智能合约是 **部署在区块链上的、用代码编写的、可自动执行的「数字化合约 / 规则」**，是 Web3 的「大脑」和「操作系统」。

-   核心作用：替代 Web2 里「平台制定的规则 + 人工审核 + 后台操作」，**所有业务逻辑、规则、奖惩机制，都用代码写死在智能合约里，一旦触发条件，就自动执行，没有任何人能干预、篡改、中止**；
    
    ✅ 举例：Web3 的去中心化交易所（DEX），没有平台方，所有交易规则（汇率、手续费、成交逻辑）都在智能合约里，你发起转账，合约自动匹配交易对手，完成资产划转，全程无人经手；
    
    ✅ 举例：Web3 的 NFT 铸造，你支付代币后，智能合约自动为你生成 NFT 资产，写入区块链，确权完成，没有平台能收回你的 NFT。
    
-   核心特性：**代码即法律**，智能合约的执行结果是全网公认的唯一结果，公平、透明、无信任成本。
    

核心支柱 3：分布式节点（去中心化的「算力支撑 + 共识验证」）

节点就是**接入区块链网络的每一台独立计算机 / 服务器**，可以是矿机、个人电脑、专业服务器，是 Web3 的「手脚」和「基础设施」。

-   核心作用：
    
    1.  提供算力支撑：区块链的记账、数据存储、智能合约执行，都需要全网节点的算力来完成，没有单一节点垄断算力；
        
    2.  共识验证：全网节点会通过「共识机制」（比如 PoW 工作量证明、PoS 权益证明）对每一笔交易、每一次数据写入、每一次合约执行进行**同步验证**，只有当「全网大多数节点都认可这个结果」时，数据才会被写入区块链，成为有效数据；
        
    3.  数据备份：每一个节点都存着完整的区块链账本，相当于全网有无数个「数据备份」，永远不会出现 Web2 里「服务器宕机→数据丢失 / 服务中断」的问题。
        

## 思考

Web3未来落地除了金融方面，更应该考虑与基础设施建设，如何能够与实体物质产生联系，我认为是一个非常严峻的问题，目前未来可能有的应用场景（除金融外）：

-   元宇宙（以游戏为主）：类似于电影的头号玩家，但这个需要极强的物质设施，头显等
    
-   供应链管理
    
-   知识产权保护
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->

















今天主要是了解行业知识

![7a1af4e7ce02332b4641c8e545e91b13.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/46ab/images/2026-01-12-1768233068392-7a1af4e7ce02332b4641c8e545e91b13.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
