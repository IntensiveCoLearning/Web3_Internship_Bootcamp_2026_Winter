---
timezone: UTC+8
---

# Wang

**GitHub ID:** ehowang

**Telegram:** @yancy12138

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
## 一月二十六日学习笔记

刚把 Application 这一章刷了一遍，作为一个还在习惯 Web3 的“传统程序员”，这感觉就像是把这几年的编程常识打碎了重组。

不仅是语法怪，更主要是那种每一行代码都在裸奔处理钱的紧张感。

随手记了几个比较颠覆认知的地方，去掉了那些教科书废话，主要记录真实体感：

### 1\. Ether Wallet：代码短到让人害怕

刚开始看我还在找“数据库连接”、“鉴权中间件”在哪。

结果发现就一个 `receive() external payable {}` ？

-   体感：在 Web2 里做一个支付宝存钱功能，后端起码得写几百行。在 Solidity 里，只要这行代码存在，这个合约就是个只有进钞口的保险箱。
    
-   取钱的逻辑：`require(msg.sender == owner)`。这就是全部的鉴权了。没有什么 Token、Session，拿着私钥签名的人就是 owner。简单粗暴，但也意味着私钥丢了就真的完了。
    

### 2\. Multi Sig Wallet（多签）：链上的“核按钮”

这个之前老听大家说项目方多签，看了代码才明白逻辑其实是\*\*“异步的投票系统”\*\*。

-   逻辑：不是一次性签完。是 A 提议 -> 链上记录；B 批准 -> 链上记录；C 批准 -> 凑够人数 -> 执行。
    
-   冲击：为了防重放（Replay）和防重复签名，代码里用了大量的 `mapping` 做状态标记。这比写业务逻辑麻烦多了，感觉写智能合约 80% 的精力都在防小人。
    

### 3\. ERC20：原来就是个 Excel 表

一直以为发币很高深，看了代码差点笑出声。去掉那些复杂的接口定义，核心其实就一个变量：

`mapping(address => uint256) public balanceOf;`

-   真相：所谓的“转账”，甚至没有数据在网线上传输，单纯就是把张三行里的数字减 10，李四行里的数字加 10。
    
-   那个反人类的 Approve：
    
    这是我最想吐槽的。我想让 Uniswap 帮我卖币，不能直接给它，必须先 `approve` 给它一个额度，然后它再伸手进来拿（`transferFrom`）。
    

### 4\. Iterable Mapping：为了省 Gas 憋出来的怪招

这要是放在 Python 或者 JS 里，遍历一个字典（Map）也就是 `for key in dict` 的事。但在 Solidity 里，`mapping` 居然是不能遍历的！你没法问合约“把所有用户列出来”。

-   为了实现这个功能，不得不搞一个 `keys` 数组同步存 Key。
    
-   代价：增删改查全变贵了。
    
-   领悟：在链上，“能遍历”是一种奢侈品。除非万不得已，绝对不在链上搞循环。
    

### 5\. 几个写在便利贴上的“保命常识”

-   Checks-Effects-Interactions：这个模式真的是用血换来的教训。
    
    1.  Check: 先查有没有资格/余额。
        
    2.  Effect: 先把余额扣了。
        
    3.  Interaction: 最后再把钱转出去。
        
    
    -   以前写代码习惯先转钱再记账，在 Web3 这么写会被“重入攻击”吸干。
        
-   Gas 焦虑：看这些 Example 的时候，我脑子里一直有个计算器在响。`storage` 能不用就不用，能用 `memory` 就凑合用。以前优化代码是为了快，现在优化代码是为了省真金白银。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

## 一月二十五日休息
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->


## 一月二十四日休息
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->



## 一月二十二日

因为我刚接触 Solidity，我先把整个学习过程拆成几个阶段。这个网站最大的特点是用真实合约示例来讲解各个语言特性，而不是纯理论。通过这些例子，我不仅记住语法，还理解了为什么要这么用。

1\. Solidity 是什么与基本语法

Solidity 是在以太坊上编写智能合约的主要语言，语法看起来像 JavaScript/Go，但它的行为会被部署到 EVM 上执行，而 每一句代码都有 Gas 成本，这是学习 Solidity 的基础前提。  
我从最简单的合约开始：声明版本、定义 `contract`、再写一些状态变量和函数。这些最基础的语法让代码可以在像 Remix 这样的 IDE 里编译和部署。虽然不是 solidity-by-example 的具体例子，它帮助我更快上手调试。

2\. 投票合约（Voting）理解合约设计模式

这个例子不是简单的”hello world“，它展示了 Solidity 语言几个核心的模式：状态变量、映射（mapping）、结构体、枚举、权限控制以及如何在链上存储和操作数据。

-   我意识到投票合约里的 权限管理（谁能分配投票权）是链上逻辑必须处理的核心问题。合约创建者（chairperson）需要控制赋权，这是权限控制模式的基础。
    
-   投票委托是常见的设计，它用 `struct` 和 `mapping` 把投票权委托给可信的地址，体现了 Solidity 在逻辑组合上的弹性。
    

这个例子让我理解：Solidity 合约不是简单存取数据，而是把业务逻辑表达成链上状态机。

3\. 安全远程购买（Safe Remote Purchase）

这个例子让我印象最深的是 合约中的经济激励设计——不仅是代码语法，更是如何通过合约规则设计让各方都有动机完成操作，并避免纠纷。

-   卖家和买家都要把价值押进合约，这样才激励双方履行义务，避免 Ether 永远被锁定在合约里。
    
-   我看到 `payable` 关键字是必须的，因为如果我要让合约收/发 Ether，我就必须声明可支付函数。
    
-   此外，流程里的每一步都通过条件和状态检查来控制合约行为，这教会我如何把现实商业逻辑翻译成链上代码。
    

4\. 支付通道 & 签名验证

在这一部分，我第一次接触到了 离线签名与链上验证 的交互模式。这不是基础语法，但它是 Web3 核心模式之一：链上最小化操作，链下处理高频数据，再通过签名上链结算。

-   Alice 可以在链外给 Bob 签名消息，而 Bob 在需要时才上链执行提款。
    
-   合约需要使用 Solidity 的签名验证能力（例如 `ecrecover`）来验证消息是否有效。
    
-   这种模式大量用于 Micropayment、Channel 和 Layer2 方案。
    

通过这个案例，我认识到：Solidity 不只是写简单的合约逻辑，它还要处理密码学数据和安全性边界。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->




## 一月二十一日学习笔记

一开始我最大的误区，是把 Uniswap 当成“去中心化版交易所”。真正理解后才发现，Uniswap V2 的核心不是撮合，而是 AMM（自动做市商）。交易价格不是由买卖双方决定，而是由一个简单但残酷的公式决定：`x * y = k`。我意识到，只要有人交易，池子里的两种资产比例就会变化，价格自然就被“挤”出来了。这里没有订单簿，只有流动性池；没有中间人，只有合约规则。这一步让我明白：理解 Uniswap，首先要放弃传统交易所的思维。

  
当我继续往下学时，才发现“提供流动性”并不是我最初想的那样“稳赚手续费”。作为 LP，我其实是把两种资产按当前价格存进池子里，换来 LP Token。交易产生的 0.3% 手续费会按份额分给我，但与此同时，我也在承担 无常损失（Impermanent Loss）。当价格剧烈波动时，我取回的资产组合，可能还不如我一开始什么都不做直接持币。这一刻我意识到，Uniswap V2 对 LP 非常诚实：收益和风险都写在数学里，没有任何“帮你兜底”的机制。

  
在理解机制之后，我再去看 Uniswap V2 的合约结构，才发现它其实非常克制。Factory 只负责创建交易对，Pair 合约才是真正的核心，所有交换、铸造、销毁 LP Token 都围绕 Pair 展开。V2 相比 V1 支持 ERC20-ERC20 交易、引入了价格累积器（为预言机服务）、也允许闪电贷的雏形出现。但我也能清楚看到它的局限：价格完全依赖池内资产，滑点控制粗糙，资本效率低。这让我理解了为什么 V3 一定会出现，也让我第一次从“Web3 使用者”的角度，走向“协议设计观察者”的视角。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->





## 一月二十日学习笔记

我一开始读《中文文案排版指北》时，最大的感受不是“学到了技巧”，而是意识到它为什么显得这么残酷。它并不关心我写得有没有文采，而是直接逼我面对一个事实：读者会在理解内容之前，先通过排版判断我是否专业。中英文不加空格、数字和单位黏在一起、标点乱用，这些问题会在第一眼就暴露出来。这套规范对我来说，更像是在纠正“个人习惯”，让我写出的东西看起来像是能被团队和陌生读者放心接手的文本。

在实际使用这些规则时，我发现最容易被抓出来的问题几乎都集中在空格和标点上。中文和英文、中文和数字之间不留空格，是我以前最自然、但现在最羞耻的习惯；可一旦多加了不该加的空格，版面又会立刻变得很怪。重复使用“！！”“？？”也是我以前觉得理所当然的表达方式，但在规范里，它们只会显得情绪化和不专业。另外，全角和半角的区分让我第一次意识到，中英文混排并不是“能看就行”，而是有明确边界的。

  
当我持续按照这套规范去写之后，态度反而发生了变化。它并没有让我写得更拘谨，而是让我不再纠结格式本身。专有名词的大小写、缩写是否标准、数字是否统一为半角，这些逐渐变成了下意识的动作。我开始明白，这份指南真正教我的不是排版技巧，而是一种职业视角：在专业语境里，排版本身就是信息的一部分，如果我连这一步都做不好，那我的内容很可能在被认真阅读之前，就已经被打了折。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->






## 一月十九日学习内容

## 智能合约开发

刚开始接触智能合约开发的时候，我最大的困惑就是：DApp到底跟普通APP有什么不同？读完这篇文章后，总算理清了思路。原来DApp就是去中心化应用，它的核心特点是应用的逻辑和数据不由一家公司控制，而是跑在区块链上，谁都改不了。

### DApp架构

从结构上来看，DApp主要由三部分组成。首先是前端界面，这部分跟传统网站没什么两样，还是用HTML、CSS和JavaScript搭建，用户看到的就是这一层。不同的是，前端不直接连接区块链，而是通过钱包注入的Provider或者RPC节点来跟链上交互。简单说就是，你想读取合约的状态或者发起一笔交易，都得经过这些中间层。

其次是智能合约，这是DApp的核心。合约里定义了所有的业务规则，比如谁能做什么、钱怎么流转，全都写在代码里。以太坊上通常用Solidity语言来写合约，然后部署到区块链上由EVM执行。一旦部署，合约就像公开的规则书，任何人都能看到也改不掉。

第三部分是数据检索器，也就是Indexer。因为智能合约会释放一些事件日志（比如NFT转移时会有Transfer事件），但直接从链上查这些数据很麻烦。所以我们会用检索器把这些事件抓下来，存到传统数据库里，前端需要展示数据时就可以方便地查询。举个例子，如果你想在NFT项目里展示用户持有的所有NFT，合约本身可能没提供这样的查询函数，这时候就得靠检索器把Transfer事件整理好存起来，前端再从数据库里拿数据。

### 开发流程是怎样的

开始做一个DApp项目之前，第一步当然是需求分析和规划。你得明确用户能做什么操作，比如转账、投票、查询余额这些，还要选择在哪条链上开发（以太坊、Polygon还是别的），这通常取决于你的用户群体和对交易成本、速度的要求。

接下来就是编写智能合约。用Solidity把业务逻辑写出来，然后一定要写测试用例，确保合约逻辑没问题。这一步千万不能偷懒，因为合约一旦上链就改不了了，有bug的话损失可能很大。写完还得做安全审计，检查有没有常见的漏洞，比如重入攻击、整数溢出这些。

如果你需要从链上获取复杂数据，就得开发检索器。先确定前端需要哪些数据，然后用TypeScript写检索器程序（现在主流框架像Ponder、Subgraph都支持），把事件数据清理好写进数据库。写完后可以用Docker部署到云服务器，当然也有一些SaaS服务可以直接用。

前端开发这块跟传统Web差不多，用React或Vue搭建界面。不同的是，你需要集成Web3钱包（比如MetaMask），让用户能连接钱包、授权交易。前端要能从区块链和检索器里获取数据展示出来，用户发起交易时还得跟钱包交互，获取用户签名后再发送到链上。

最后是部署上线。智能合约要先部署到测试网（比如Sepolia）试跑，没问题了再部署到主网。前端可以部署到去中心化平台（像IPFS）或者传统的托管服务（Vercel之类的）。上线后还要持续收集用户反馈，定期更新维护。

### 搭建开发环境

想要开发以太坊应用，首先得装好Node.js和npm（或者yarn），推荐用nvm管理Node版本。装完这些基础工具，你就可以选择本地开发链了。目前主流的有两种选择：一个是Foundry，这是用Rust实现的，速度特别快，提供了forge、anvil、cast这些工具，分别用来构建测试合约、启动本地节点和跟链上应用交互。另一个是Hardhat，这是目前最受欢迎的以太坊开发框架，文档齐全，社区活跃，适合新手入门。

如果只是想快速试试写合约的感觉，可以直接用Remix IDE，这是个在线工具，打开浏览器就能用，不需要安装任何东西。对于前端开发，推荐用Viem和Wagmi这两个库来跟区块链交互，它们的TypeScript支持更好，性能也更优。

### RPC节点：连接区块链的桥梁

刚开始学的时候，我一直搞不懂RPC是什么。后来才明白，RPC（远程过程调用）就像是ATM机，你通过它可以查余额、转账，它连接着后面的银行系统（也就是区块链网络）。在Web3开发里，RPC节点就是运行区块链客户端的服务器，它们保存着完整的区块链数据，并提供API接口让我们查询数据、发送交易。

前端应用要跟链上交互，都得通过RPC节点。比如你想查某个账户的余额，就得调用`eth_getBalance`这样的JSON-RPC方法。发送交易也一样，用户在钱包里签完名，交易数据就通过RPC节点广播到整个区块链网络。

对于大多数开发者来说，自己运行节点成本太高了（要服务器、要存储、要带宽），所以通常会用第三方RPC服务商。比如Alchemy、Infura、QuickNode这些，它们都提供免费额度，够开发测试用了。如果是正式上线的产品，建议选企业级服务，稳定性和速度更有保障。

用RPC的时候有几点要注意：一是要保护好你的API Key，别提交到GitHub这种公开地方；二是要做好错误处理，因为网络请求可能会失败；三是不要依赖单一节点，最好配置多个RPC端点作为备份。免费额度通常有速率限制，请求太频繁可能会被限流，所以要合理控制请求频率。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->







## 一月十八日休息
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->








## 一月十七日休息
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->









## 1月16日笔记

1\. 什么是 Remix？

可以把它理解为 “区块链版的在线代码编辑器”。

-   不用安装： 浏览器打开就能用，不用像装其他软件那样折腾环境。
    
-   专门写合约： 它是专门用来编写、编译和部署 Ethereum（以太坊）智能合约的工具。
    

2\. 核心功能

笔记里提到了 Remix 的几个核心板块，按操作顺序看最清晰：

-   第一步：写代码
    
    -   在左侧文件夹里新建.sol后缀的文件（这是 Solidity 语言的专属格式）。
        
    -   就像在 Word 里打字一样，把合约逻辑写进去。
        
-   第二步：编译
    
    -   代码写完后，机器看不懂，需要“翻译”一下。
        
    -   点一下那个像“小太阳”一样的图标进行编译。如果左侧出现绿色的勾，说明代码没写错！
        
-   第三步：部署与运行
    
    -   环境： 最关键的一步。
        
        -   如果是练手，选 Remix VM，它会给你分配几个虚拟的“发财账号”（里面有 100 个假 ETH），随便点部署，不用花真钱。
            
        -   如果要玩真的，就选 Injected Provider，这会连接你的 MetaMask 钱包。
            
    -   部署： 点一下，你的合约就正式跑到区块链（或者模拟环境）上去了。
        

3\. 几个实用的小细节

-   控制台： 屏幕最下方那个黑框。每做一次操作，它都会告诉你“成功”还是“报错”，报错了直接搜关键字就行。
    
-   交互面板： 部署成功后，下方会出现合约的名字。点开它，你会看到你写的函数变成了按钮。点点按钮，就能看到合约的运行结果，非常直观！
    

4\. 学习心得

-   容错率高： 刚开始千万别用真钱，先在 Remix 的模拟环境里随便折腾，账号里的假币用不完。
    
-   插件系统： Remix 像 Chrome 一样有很多插件，但刚开始保持简洁就好，默认的几个功能完全够用了。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->










## 1月15日学习内容

021学习以太坊第二章

这一章主要在讲：以太坊的网络是怎么连起来的，以及节点到底在干什么。在真正读之前，我对节点的理解非常模糊，只知道跑节点很厉害、很专业。读完之后，才发现节点更像是以太坊这张网络里的基础设施。

1\. 什么是以太坊节点？

节点其实就是一台运行以太坊客户端软件的电脑。  
它做的事情包括：

-   接收和验证交易
    
-   同步区块数据
    
-   和其他节点通信
    
-   对外提供 RPC 接口（给钱包、前端、程序用）
    

也就是说，只要你跑了客户端，你这台电脑就成了以太坊网络的一部分，而不是“连到某个中心服务器”。

2\. 节点是怎么互相通信的？

以太坊是一个 P2P（点对点）网络，没有“总服务器”。节点之间通过发现协议找到彼此，然后通过 Gossip 协议来传播信息。

我的理解是：

-   一条交易或区块出现后
    
-   一个节点先知道
    
-   然后“告诉邻居”
    
-   邻居再告诉更多邻居
    
-   最后全网都知道
    

听起来有点像“消息在群里传”，但这是靠协议自动完成的。

3\. 节点类型

之前我完全不知道节点还有这么多分类。

-   全节点（Full Node）
    
    -   会验证所有区块和交易
        
    -   保存当前完整状态
        
    -   不一定保存所有历史细节
        
    -   是最常见、也是最实用的一种节点
        
-   轻节点（Light Node）
    
    -   只保存区块头
        
    -   查询时依赖全节点提供证明
        
    -   占用资源少，但依赖别人
        
    -   更适合钱包或移动端
        
-   归档节点（Archive Node）
    
    -   保存所有历史状态
        
    -   可以查询“过去任意区块时某个地址的状态”
        
    -   占用存储巨大
        
    -   主要给数据分析、区块浏览器用
        

4\. 为什么有人要自己跑节点？

书里强调了对开发者或机构来说，跑节点并不是“为了炫技”，而是为了：

-   数据可信（不用完全相信第三方 RPC）
    
-   稳定性（不被公共 RPC 限流）
    
-   更接近真实链上行为（尤其是调试和分析）
    

以前我用钱包、用 RPC，默认一切“链上即可信”。现在才意识到：你信的其实是别人帮你维护的节点。

5\. The Merge 之后的新变化：执行层和共识层

以太坊合并之后：

-   执行客户端：
    
    -   负责交易执行、EVM、状态变化
        
-   共识客户端：
    
    -   负责 PoS 验证、出块、投票
        

现在一个完整的以太坊节点，通常需要 “执行 + 共识” 两个客户端配合运行。这让我意识到：以太坊已经不是一个“单一程序”，而是一个分层协作的系统。

6\. 节点同步是在同步什么？

同步不是简单“下载区块”，而是为了达到一个目标：

和全网对“当前状态”达成一致。

节点会同步：

-   区块
    
-   交易
    
-   状态数据
    
-   各种网络消息
    

而同步方式也有差别，比如快照同步比从创世块开始要快得多，这对普通人非常友好。

7\. 不跑节点也能做数据分析吗？

答案是：可以。书里提到了一些“不自己跑节点”的替代方案，比如使用现成的数据服务。这让我明白一件事，跑节点是一种能力，不是入门门槛。在学习和早期开发阶段，先理解原理，比硬上机器更重要。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->












## 1月14日学习目标

-   学习实习手册安全与合规部分
    
-   021以太坊第二章
    

## 1月14日学习内容

**Web3 合规与法律风险**

1\. 监管大逻辑：保技术，打金融

-   中国核心态度： 承认区块链技术，但全面封杀其“金融属性”。
    
-   禁止项： 发币融资（ICO/IEO）、开交易所、用虚拟币买东西。
    
-   记住一句话： 在境内，只要碰“钱”（募资、交易、换汇），风险就极高。
    

2\. 三个必须警惕的“坑”

-   融资坑： 别管叫 Token、积分还是治理凭证，只要涉及公众筹资，就是非法集资。
    
-   模式坑： \* 链游： 如果有“充值—抽奖—提现”闭环，容易被定性为“开设赌场”。
    
-   推广： 超过三级的“拉人头”返佣，极大概率触犯“传销罪”。
    
-   洗钱坑： 帮人把虚拟币换成人民币（OTC），最怕收到“黑钱”。轻则银行卡被封，重则涉嫌“帮信罪”（帮助信息网络犯罪活动）。
    

3\. 全球监管风向标

-   FATF（金融警察）： 推行“旅行规则”，要求大额转账（>$1000）必须实名，去中心化不代表完全匿名。
    
-   稳定币： 全球监管重点是“储备金”。如果 USDT/USDC 没钱兑付，会引发行业地震。
    
-   地区特色： 美国（SEC）看代币是否算“证券”；香港/新加坡（牌照制）只要拿了证就能合规玩。
    

4\. Web3 打工人的自我保护

-   合同： 很多 Web3 公司在境外，国内没实体。这意味着：没社保、没公积金、合同可能无效。
    
-   工资： 用 USDT 发工资在法律上不算“发放工资”。如果项目倒了，代币归零，薪水也就没了。
    
-   出金风险： 卖 U 换人民币时，务必走靠谱渠道，保留所有交易凭证，防止卡被冻结。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->














## 1月13日学习内容

## DeFi

### Uniswap

恒定乘积公式x\*y=k 用户向流动性池存入交易对，k常数交易对数量乘积生成，并且会动态变化。

LP如何赚钱：LP在流动性池中提供流动性，提供的资金会被用来进行交易，对于每笔交易收取一定手续费，手续费会更根据LP提供的资金量进行对应分配

### Compound

去中心化的借贷平台允许用户存入或者借出资产，LP存入资金不止可以获取手续费还可以获得项目方给与的的代币奖励，这就是流动性挖矿

借贷模式和超额抵押： 用户从借贷协议借出一定资产时会抵押超过借出资产价值的资产，当抵押资产的价值低于借出资产会触发强制清算，俗称爆仓

### MakerDAO:

DAI: 用户抵押资产后会获得稳定币DAI

稳定费率：稳定费事用户在还款中需要支付的利息，当dai价格脱锚下跌，费率会提高，导致借贷dai的减少，已经借贷的会偿还债务避免支付高额利息，

Dai的市场供应量因此减少，dai价格回归。当dai价格脱锚上涨，费率会降低，鼓励大家借贷，提高dai的市场供应，从而引导dai价格回归。

### 软技能

OKR写法与最佳实践

目标设定原则：每个季度设定三到五个，预计完成率60%-70%. 聚焦效果而非产出，质量比数量更重要。

关键结果设计：将完成目标的过程分解成多个子任务，每个步骤标志着每个人物完成的百分比，采用 SMART标准

评分与复盘：对任务过程中的每个子任务进行从低到高的评分，分析低分子任务的原因并反思高分的调整性是否不足。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->
















# 1.12学习规划

-   阅读并理解web3实习手册入门导读的部分
    
-   观看[**Day 1: A Developer’s Guide to Building on Ethereum**](https://www.youtube.com/watch?v=zuJ-elbo88E&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=1) - Intro并记笔记
    
-   阅读工具安装指南并按照指南学习使用相应工具
    
-   完成部分技术&运营通用任务
    

# 1.12学习内容

### **区块链的特性**

-   不可篡改：每个区块包含了上一个区块的哈希信息，如果想要篡改区块数据，需要修改当前区块后的所有区块
    
-   公开透明：所有人都可以通过scan工具查看某个钱包的交易信息以及钱包余额
    
-   快速交易：相较于传统银行转账，尤其是跨国转账，动辄需要两三天；而在链上点对点转账最低可以将时间压缩到几秒内。
    

### 区块链的运行过程

用户发起交易->交易广播给各个节点->节点验证交易有效性->经过POW交易被矿工打包放入区块-> 新区块添加到链上然后广播->向矿工发放代币奖励

### 公链，联盟链和私有链的优缺

|   | 优点 | 缺点 |
| 公有链 | 足够开发，透明，去中心化 | 决策效率低，维护成本高 |
| 联邦链 | 效率高，隐私性强 | 灵活性略差 |
| 私有链 | 效率极高，隐私极强 | 透明性差 |

### Web2 Web3和  Web3.0的区别

Web2是以及巨头为中心而构建的网络，数据被企业所拥有。Web3.0则是通过标准格式组织信息使得机器可以容易理解网络 Web3通过区块链实现用户真正拥有自己的资产，而且数据上链后无法修改不会消失。

### 以太坊相关不熟悉的概念整理

-   Layer 2:在链下批量处理交易让哦我定期将交易包上传到主网，主网再验证交易有效性
    
-   EIP-4844: 将L2中的常规交易替换成blob交易，降低储存成本
    
-   Zk-Rollup: 只需要验证一批交易的正确性证明来对交易进行验证，降低验证成本
    
-   Optimistic Rollup: 假设交易合法，仅在争议时验证，降低了gas费，但牺牲了部分交易效率
    
-   侧链(Sidechains):独立运行的链，通过桥接与主网交互，主链和侧链的资产转移通过锁定和铸造实现。
    

侧链vs Rollup

-   Rollup依赖于主链，rollup宕机，资产会受到主链的保护
    
-   侧链独立于主链运行，如果侧链宕机或者被攻击，资产存在丢失的风险
    

### 以太坊的三个关键机制

-   账户系统：1. 外部账户：通过公私钥对实现签名控制账户和进行转账 2. 合约账户：通过EOA触发，代码自动执行出货逻辑
    
-   Gas模型：总费用=Gas limit(自己评估需要使用单位）\*Gas price(根据网络拥堵程度动态调整）+tip（直接支付矿工），剩余gas费会退还
    
-   以太坊虚拟机(EVM): 运行合约代码的虚拟计算机
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
