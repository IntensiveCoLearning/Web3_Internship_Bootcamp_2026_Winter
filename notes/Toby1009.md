---
timezone: UTC+8
---

# 馬鈴薯

**GitHub ID:** Toby1009

**Telegram:** @Yunizero

## Self-introduction

馬鈴薯

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
## a16z對builder的兩個建議的心得

source：[https://x.com/a16zcrypto/status/2010781113023939041](https://x.com/a16zcrypto/status/2010781113023939041)

產業過度單一化，不僅脆弱性提升，也導致內卷嚴重，只有頭部能贏。  
但這也是個機會，代表是個時機做出差異化  
有人說過：「競爭，是給輸家玩的」，跟別人卷一樣的事不一定是好事。  
陳品也說過一個蠻有趣的點，現在創業做DeFi會很難，而密碼龐克的有文藝復興的趨勢，我實際去研究也有發現，ZK、MPC、2PC這種技術，已經逐漸成熟，目前就是一個爆發的拐點，不確定有沒有料，但是很有潛力。  
其次，陳品也提到，目前穩定幣在外貿企業上佔比5~10%，但科技普及通常會是呈現指數與對數成長的，也就是這5~10%其實很大，可以說是一個必然的趨勢，未來企業不是決定「要不要用」，而是「被迫用」、「一定要用」。

## 反思：AI Agent結合TEE與ERC-8004

因為Agent如果在TEE中，那就能夠確定它的prompt不會亂搞，像是能夠確保不會下什麼「請竊取資產」之類的惡意prompt 也就是，能夠減少信任成本，確認這個Agent在「預設」情況下不會亂搞，除非是Agent常有的「判斷錯誤」 那這就會有個有趣的點，在使用TEE的情況下，就不會出現ERC-8004中高聲譽Agent作惡的情況，因為prompt公開、可驗證，所以不太有可能會作惡，這假設就不成立 只有可能是「判斷錯誤」，或者是被「依賴注入」 看分享會評論區有人提到高聲譽是否有做惡可能，所以分享了一下我的想法

所以問題不會是「是否會作惡」，而應該是如何防止Agent發瘋，防止做出一些奇怪、危險的操作。 當然這部分又會有額外的問題，要如何確認，這Agent當下做的操作會是有問題的？或者是有風險的？這判斷依據是啥？

不過，TEE 還是有很多限制... api endpoint需要去定義的話，那很多事情就不能做了，一個簡單例子是：打隨機API去找資料

## 反思：X禁止InfoFi，Kaito關閉Yaps

source：[https://x.com/Punk9277/status/2011837292907020605?s=20](https://x.com/Punk9277/status/2011837292907020605?s=20)

就是這種平台的「脆弱性」，這種產品應該是要「無需許可的」或至少是「去中心化」的，這樣才能永續，才能減少這樣的黑天鵝。 如果只是建立在某個API上的商業模式，很容易就會發生這種情況，或者說是「必然」的。

之前黑客松就有做過這種問題的項目，被評審提了出來，親身經歷了都。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

## UTXO狀態同步與Sui解法

UTXO不管是否作廢，都會在鏈上

跟Ethereum這種Account Base不同，UTXO跟物件比較像，這導致了每次交易都會產生一些UTXO，增家了鏈上壓力

這鏈上壓力體現的在於節點在同步時，通常為了速度可能會放到ram，但就沒那麼多空間，可能會導致裝置需求變高很多，然後小節點無法繼續做，中心化程度會變高

Sui採用的是經濟激勵的方式，Storage Rebate，讓刪除Object有利可圖，也比較彈性，激勵主動刪除Object

而BTC的UTXO是永久的，就算已花費的也是一樣，所以就有狀態膨脹問題

我記得目前BTC生態也正在想辦法解決這問題

## UTXO模型隱私系統同步問題

隱私系統通常都會用UTXO，像是Railgun，因為用Account Base容易導致ZKP失敗，並行能力不太好

Account的話則通常用同態加密（在加密的情況下能做加法）

隱私系統的UTXO也很有趣，同步時間會很慢，因為要加載全部的UTXO

可能會問，那為啥BTC可以這麼快？

因為BTC可以維護UTXO Set，使用者可以直接知道哪些是可以用的、未花費的

但隱私系統不能這樣搞，因為等於直接暴露了

## 當AI Agent遇到Web3？

[https://hackmd.io/YjzSw1FQSR-ZE8SmKAKymA?view](https://hackmd.io/YjzSw1FQSR-ZE8SmKAKymA?view)

一點小紀錄，轉錄後用notebooklm

## 2PC

source： [https://youtu.be/PzcDqegGoKI?si=N-KqqH3EGxVtS5ii](https://youtu.be/PzcDqegGoKI?si=N-KqqH3EGxVtS5ii)

以前因為缺乏「計算中立性」，在協作上可能會有僵局，目前2PC就漸漸成熟，可以開始重塑「可程式化信任」的底層架構

可以跟ZKP對比，因為ZKP也是來做到，保護秘密的情況下，證明自己知道秘密

ZKP的核心價值在於「個人知曉秘密的證明」，但在處理「共享秘密」（Shared Secrets）時會遭遇顯著的「雞生蛋、蛋生雞」博弈（The Chicken and Egg Problem）。在 ZKP 框架下，協作者面臨「誰先揭露證明」的風險：第一位行動者可能在曝露意圖後，因對方拒絕匹配而損失戰略優勢。

而2PC則實現了「雙向盲配」，透過「可編程電路」與「加密輸入」，2PC允許雙方在不洩漏原始輸入的情況下，僅針對加密態數據產出預定結果，從根本上解決第一步動作的風險。

比較有趣的事是放了AI/ML模型的計算潛力：2PC允許將複雜的機器學習模型嵌入加密電路中，實現對加密輸入的多維度運算，意味著研究不再侷限於單一變涼，而是在保護患者隱私的前提下，進行涉及遺傳史、營養攝取、環境變量等多元因素的深度分析，徹底轉化數據的所有權結構。

也可以應用在醫療數據整合上，做到去識別化的深度價值挖掘

在以往，生物科學與精準醫療領域，「數據而非計算」已成為當前的戰略瓶頸，法規的限制，導致具備高價值的跨庫數據無法有效流動

而透過2PC提供的「加密Table Join」操作，就能做到「數據庫融合」，是解決數據孤島的關鍵路徑

以基因研究員與醫院數據庫的協作為例：

-   技術實施：2PC 電路在加密環境下進行 ID 匹配。
    
-   **戰略產出：** 關鍵點在於 2PC 僅輸出突變與疾病的相關性統計數據，**並在輸出前自動剝離所有身份識別碼（ID）**。這確保了產出的結果是具備科研價值的去中心化知識，而非受管制的個體敏感資訊。
    

在談判中也很有用，例如在賣賣收購中，買方意圖的揭露會直接干擾市場定價

2PC允許買賣雙方在加密狀態下預先對齊「價值區間」，只有當雙方出嫁達成重合時，2PC才是放匹配訊號。這種模式避免了談判地位在共識達成前遭到削落。

企業也可利用 2PC 構建一個「絕對中立的 HR 功能」，收集員工真實的心理健康、組織評價或離職意向數據。員工確信數據在加密電路中僅產出聚合後的「組織健檢趨勢」，而不會被管理層回溯。這種「預期安全性」將顯著提升組織內部資訊的真實性。

結合ZKP 證明「輸入合法性」（例如證明具備足夠資金簽名）與 2PC 執行「秘密競標」，能建構一套完美的拍賣邏輯。這防止了競標過程中的不誠信行為，同時保護了參與者的定價策略。

從實驗室轉向生產環境，企業必須嚴格審核其採用的安全模型。

**「2-of-2」模型 vs. 「K-of-N」模型**

在企業級高難度協作中，我們強烈建議採用 **「2-of-2」安全模型**。

• **Self-Sovereign Trust（自主掌控信任）：** 不同於「K-of-N」門檻模型（其中 K 方合謀即可破解隱私），在 2-of-2 模型中，只要您自己不違反協議，數據即是安全的。

• **戰略價值：** 對於具備直接利益衝突的兩方（如買方與賣方），合謀的可能性為零。2-of-2 模型建立了一個極高的「信任底層」（Trust Floor），這對於金融交易與戰略談判至關重要。

**對抗惡意行為：輸入驗證策略**

針對參與者可能輸入虛假數據（輸入謊言）的風險，應採取「ZKP-into-2PC」的組合策略。在數據進入 2PC 計算前，要求參與者提供 ZKP 證明，確信該輸入數據經過合法機構簽名或符合特定區間標準。

**實施工具鏈與開發者路徑**

• **底層工具：** 建議關注 `mpz` 與 `mpcs` 等高性能實施庫。

• **工程原型：** 產品與工程團隊應利用 `Circum` 等電路編譯工具進行快速原型開發，理解數據邏輯向電路邏輯的轉換。

• **進階指南：** 技術決策者應研讀 Justin Thaler 的 _Proofs and Arguments_，以掌握最新證明方案對 2PC 性能的優化空間。

**前瞻展望：** 在未來 10-20 年，隨著通用人工智慧（AGI）普及，個人 AI 助手將成為具備中立性的代理人。透過 2PC 協議，這些 AI 助手將在企業與個人之間執行自動化的中立仲裁，構建一個透明且具備高度「合法性」的自動化經濟體。

可以總結為，兩方計算（2PC）不僅是密碼學的突破，更是對資訊經濟學的重新定義。它提供了一種在不犧牲控制權的前提下，獲取協作價值的技術方案。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->



今日筆記：小海又帥又🐮ber

## Co-learning筆記

### 1\. Web3 安全與基礎

**核心觀念：零信任與風險隔離**

-   **錢包授權風險：** 連接錢包本身不一定會導致被盜，但風險在於「惡意授權」。不是每個網站都是善意的，一旦簽署了惡意合約，資產就可能被轉走。
    
-   **資產隔離策略：** 日常瀏覽網頁、頻繁交互的 Metamask 錢包（熱錢包），**最好不要存放大量資金**。大額資產應存放於冷錢包或不隨意連接的錢包中。
    
-   **穩定幣風險：** 去中心化穩定幣通常屬於「算法穩定幣」，雖然機制上是錨定法幣，但存在脫鉤崩盤的風險（如 Luna/UST 事件），需謹慎看待。
    

* * *

### 2\. 求職與作品集 (Portfolio) 策略

**核心觀念：不同崗位對「作品集」的定義不同**

| 崗位類型 | 作品集重要性 | 作品集形式/建議 | | 設計 (Design) | ⭐⭐⭐⭐⭐ | 非常有幫助，直接展示視覺產出。 | | 技術 (Dev) | ⭐⭐⭐⭐⭐ | GitHub 就是你的履歷。代碼質量、開源貢獻一目瞭然。 | | 運營 (Ops) | ⭐⭐⭐ | 有點幫助。重點在於「案例分析」與「推文輸出」（見下文）。 | | 商務 (BD) | ⭐ | 不太需要傳統作品集，人脈資源才是核心籌碼。 |

* * *

### 3\. 核心崗位深度解析

A. 商務拓展 (BD) - 資源導向

-   **交易所 BD：** 核心競爭力在於是否帶有 **KOL (意見領袖) 資源**，能為交易所帶來流量。
    
-   **項目方 BD：** 核心競爭力在於 **VC (風險投資) 資源** 或與其他項目方的連接能力，重點是談合作與資源置換。
    

B. 運營 (Operations) - 數據與分析導向

-   **求職技巧：** 撰寫關於活動分析的推文（中文或英文）是很好的敲門磚。
    
-   **工作內容（復盤與設計）：**
    
    -   **活動設計：** 是否精準觸達目標用戶？預算分配合理嗎？
        
    -   **機制分析：** 從數值設計、排名機制、獎勵分配切入，分析用戶的參與動機。
        
    -   **成本估算：** 觀察活動規則，反推項目的獲客成本（CPR/CAC）、轉化數據（FTT - 首次交易/入金）以及整體積分成本。
        
-   **硬技能：** 最好具備 SQL 背景，能讀懂文檔，理解數據表之間的關聯。
    

C. 開發者關係 (DevRel) - 複合型技術專家

DevRel 不僅要懂技術，還要懂社群和市場。要把這份工作做好，需關注四個維度：

1.  **寫文檔 (Documentation)：** 需及時、準確。不僅是寫給人看（讓開發者易懂），現在也要寫給 **AI** 看（利於 LLM 讀取）。
    
2.  **做 Demo (Showcase)：** 針對公鏈特性，使用多種語言編寫範例代碼，並開源到 GitHub。
    
3.  **社區支持 (Support)：** 回答技術問題，展現專業度，解決開發者的疑難雜症。
    
4.  **市場擴展 (Growth)：** 策劃線上/線下活動（黑客松、Workshop），活躍開發者社區。
    

D. 產品經理 (PM) - 抽象概念的翻譯官

-   **核心價值：** Web3 很多概念（如錢包、Gas費、授權）對用戶來說很抽象。PM 需要清楚底層邏輯，但在產品呈現上要讓用戶好懂。
    
-   **市場敏銳度：** 純技術人員容易忽略市場動向，PM 必須常接觸用戶，平衡「技術實現」與「用戶需求」。
    

* * *

### 4\. 行業宏觀與哲學視角

-   **公鏈競爭現狀：** 雖然鏈已經非常多，且每年都有新鏈，但若無實質創新，很難取代舊有的。
    
-   **經濟哲學（哈耶克視角）：**
    
    -   引用哈耶克《貨幣的非國家化》概念：各個公鏈發幣，就像是放開貨幣競爭。
        
    -   **市場監督：** 這種競爭給了用戶選擇權，也迫使項目方必須向「對使用者更友好」的方向發展。
        
    -   **生態意義：** 即便某些幣或鏈看起來「沒什麼用」，它們的存在構成了競爭環境的一部分，促進了整體生態的優勝劣汰與進化。
        

## 鏈上數據讀書會-陳品分享

2020 年是區塊鏈發展的真正\*\*分水嶺\*\*。在那之前，我們做的技術項目大多還停留在實驗與基礎建設階段，產品市場契合度（PMF）不明顯，市場還沒準備好大規模接受。

然後，2020–2022 年迎來了\*\*應用大爆發\*\*，尤其是 **DeFi Summer**。DeFi 帶來了「\*\*金融樂高\*\*」的概念：鏈上可組合性讓各種金融服務像積木一樣自由拼湊、疊加，創造出前所未有的創新。這波熱潮讓無數 crypto project 開始發幣，市場進入狂熱與泡沫期。雖然後來泡沫破裂，很多項目灰飛煙滅，但頭部項目存活下來，並證明了其長期價值。

那個時代的 **Crypto native** 應用——真正從鏈上原生生長出來的產品——曾經是主角。

但進入 **2024 年之後**，一切開始悄悄轉變。從 2024 到現在（2026 年初），市場明顯\*\*主流化\*\*了。區塊鏈不再只是 crypto 原住民的遊戲，外部世界（傳統金融、機構、企業、甚至一般用戶）開始大規模進場。最明顯的代表就是 **RWA**（Real World Assets，實體世界資產代幣化）。與此同時，原本大量關注 DeFi 的 power user（重度使用者）與「韭菜」卻在減少。

現在的市場呈現極端的\*\*兩極分化\*\*：

\- 一邊：\*\*幣價上漲\*\*、\*\*鏈上 TVL 持續增長\*\*，主流資金（機構錢、傳統金融的錢）正源源不斷進場。

\- 另一邊：\*\*Crypto native 用戶明顯流失\*\*——有些被割韭菜離場，有些注意力被 AI 等其他領域吸引走。

結果就是：專門做給 power user 的應用變得極其困難。例如新錢包、新 DeFi 協議，現在很難突圍。因為頭部項目已經佔據了絕大部分注意力與流動性，\*\*江湖正在固化\*\*，百家爭鳴的時代正式結束。

接下來的主題，將出現明顯的\*\*兩極分化\*\*：

1\. **主流且「有點無聊」的一端**：穩定幣、RWA 等，需要靠強大的行銷、機構、組織、協會、監管沙盒來推動才能真正跑起來。

2\. **返璞歸真的一端**：回到 2012–2019 那段相對安靜的時期，去做那些小眾、真正去中心化、Crypto native 的產品。

我去年參與了兩個 RWA 專案，都是跟持牌金融公司合作。經驗總結很清楚：

\- **技術門檻其實不高**：大多就是 ERC-20 + 白名單控制，或簡單的資產映射。

\- **真正難的**：如何跟「完全不懂區塊鏈」的人/機構合作？這是第一類模式——\*\*陪公子讀書型\*\*，服務企業、產官學、傳統金融單位。

第二類則是返璞歸真。DeFi Summer 時，那些不太能快速賺錢、注意力經濟不青睞的小眾賽道（如群眾募資、預測市場、平方投票、域名、投票、DID 等）很難起飛。但現在 power user 減少，反而創造了空間，讓這些\*\*密碼龐克精神\*\*的產品重新有機會。

舉兩個正在發酵的例子：

\- **DID 與身份相關**：PSE 等團隊做了很多 ZK 服務（如 zkPassport），SBT（Soulbound Token）實現基於「人不重複」的信用借貸，真正走向鏈上信用貸款。

\- **Local Ethereum / Bitcoin 信任結構革新**：用 ZKP 在鏈上驗證真實世界轉帳（例如 email 通知 + 網域公私鑰簽名），傳統 gas 太貴，但 ZKP 讓去中心化買賣雙方信任最小化成為可能。

技術的演進（尤其是 ZKP）正在重塑信任假設：過去很多應用假設「不能信任任何人」或「必須多人共識」，現在可以更精準、更高效地處理信任。這讓回頭做\*\*密碼龐克\*\*原教旨主義的產品，變得非常有搞頭。

\### 穩定幣 vs RWA：為什麼要特別區分？

**穩定幣**已經跑得非常快，成為不可逆趨勢；\*\*RWA\*\*（狹義，非穩定幣部分）則仍處於早期爆發前夜。

機構發現區塊鏈的核心優勢：\*\*免許可\*\* + **交易速度快**。但純加密貨幣（BTC/ETH）波動太大，不適合當計價與支付單位。穩定幣雖然看似「違背去中心化精神」，卻在\*\*轉帳層面真正實現去中心化\*\*。

穩定幣會是\*\*偽需求\*\*嗎？過去區塊鏈停擺只傷 crypto 用戶；現在不一樣了——越來越多外部人只是想「付錢」才用區塊鏈，一旦消失，他們會非常不方便。

就像早期手機被嘲笑「不就是小台電腦」，但後來它創造了叫車、外送、地圖等筆電做不到的事。穩定幣也不只是「數位悠遊卡」；它正在成為跨境實時支付、抗通膨、避開傳統銀行詐騙與繁瑣 KYC 的新選擇。

目前 5–10% 的外貿公司已經在使用穩定幣，這數字看起來不大，但科技普及曲線往往是\*\*指數/對數成長\*\*，一旦過了拐點就會爆發。

傳統銀行：能力越大、責任越大、爛事越多（詐騙、KYC 成本高）。穩定幣則像「\*\*成熟大人用的錢\*\*」——有免責聲明，像高空彈跳一樣自由，但也自負風險。這形成了一種新的社會契約。

現在的真實畫面：

\- 客戶要求用 USDT 付款 → 企業不會收 → 訂單流失

\- 企業逼銀行支援 USDT 收付

\- 銀行從拒絕 → 主動找區塊鏈業者合作

\- 最後一起找政府開放銀行託管虛擬資產 → 業務保留、成長

穩定幣賽道\*\*機會\*\*：合規穩定幣、專業服務（律師/會計新藍海）、企業級支付基礎設施（挑戰 SWIFT）。

**風險**：會計準則模糊、合約法律地位、監管分歧導致跨境成本暴增。

小結：區塊鏈已經不是「要不要用」的問題，而是「什麼時候被迫用」的問題，只是時間早晚。

\### RWA：從冷菜到熱炒？

截至 2026 年 1 月，排除穩定幣的\*\*純 RWA\*\*（國債、私募信貸、股票、商品等）鏈上價值已接近 **200 億美元**左右（從 2024 年初的 60–80 億大幅成長），整體含穩定幣則更高。

RWA 與傳統證券化有相似軌跡：一開始像高效賭場（標的少），接著尋找更好標的 → 大規模證券化 → 最終把自己也證券化（審計、認列超難）。

現在正處於\*\*階段一接近尾聲\*\*，階段二、三即將展開。金融證券化的終點，似乎成了區塊鏈的起點。

成功案例（如房產證券化）：流動性提升、門檻降低、透明高效、全球可及。代幣化同樣面臨底層法律滲透，但透過公司股權而非直接屋主，能繞過部分釘子戶問題。

工程挑戰實例：

\- 股票代幣化：真的買到股票了嗎？價格如何持續錨定？

\- 黃金代幣化：為何紙黃金能廣泛流通？

\- 房產代幣化：持分如何法律認列？

美股代幣 vs 永續合約：成本差幾百倍，後者流動性更好，但前者才是「真 RWA」。這正是好問題。

機構預測：到 2030–2034 年，RWA 市場可能達數兆甚至 30 兆美元。穩定幣消失機率極低；RWA 若沒爆發會可惜，但絕非不可能。

\### 創業建議與結語

如果想創業，\*\*優先穩定幣相關\*\*會相對穩健且有即時社會影響力。世界不會等我們準備好，穩定幣與 RWA 的基礎設施需要大家一起把路走通。

做純 DeFi 現在很難，但技術派仍可深耕 ZK 等基礎；如果想真正對社會有貢獻，現在就能自信地說：

「我們在幫中小企業守護跨境業務、實時收付款、避開傳統銀行詐騙與繁瑣流程，讓他們在新的金融時代活得更好。」

這就是 2026 年區塊鏈的真實故事：\*\*從狂熱的原住民遊戲，到不得不用的全球基礎設施\*\*。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->






## Speed Run Ethereum - **Challenge: 🎟 Tokenization**

點進去看合約哈，這關就是搞個ERC-721 NFT合約，使用OpenZeppelin函式庫保證安全性與標準化

這合約名稱叫 `YourCollectible` ，繼承了四個父合約

```
contract YourCollectible is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable { ... }
```

-   `ERC721`: NFT 的核心標準實作，定義了代幣的持有權、轉移等基本功能。
    
-   `ERC721Enumerable`: 擴充功能。它允許合約「列舉」代幣。這讓你可以查詢「這個合約總共有多少個 NFT (`totalSupply`)」以及「某個地址持有哪些具體的 Token ID」。_注意：這會增加鑄造與轉移時的 Gas 費用。_
    
-   `ERC721URIStorage`: 擴充功能。它允許為每一個 Token ID 設定獨立的元數據連結（URI），這對於每個 NFT 長得都不一樣的專案來說是必須的。
    
-   `Ownable`: 權限管理。提供 `owner` (合約擁有者) 的概念，通常用於限制某些功能（如只有擁有者能鑄造），雖然在此範例的 `mintItem` 中並未加上限制。
    

```
uint256 public tokenIdCounter;

constructor() ERC721("YourCollectible", "YCB") Ownable(msg.sender) {}
```

-   `tokenIdCounter`: 一個計數器，用來記錄目前發行到第幾號 NFT。預設從 0 開始。
    
-   `constructor`: 合約部署時執行一次。
    
    -   設定 NFT 系列名稱為 `"YourCollectible"`。
        
    -   設定代號為 `"YCB"`。
        
    -   `Ownable(msg.sender)` 設定部署合約的人為初始擁有者 (Owner)。
        

```
function mintItem(address to, string memory uri) public returns (uint256) {
    tokenIdCounter++;               // 1. ID 計數器加 1
    uint256 tokenId = tokenIdCounter; // 2. 取得當前的 ID (例如第 1 個就是 1)
    
    _safeMint(to, tokenId);         // 3. 鑄造 NFT 給指定地址 (to)
    _setTokenURI(tokenId, uri);     // 4. 設定該 NFT 的元數據連結 (Metadata URI)
    
    return tokenId;                 // 5. 回傳新生成的 Token ID
}
```

-   `public` **可見性**: **注意**，這裡設為 `public` 意味著 **任何人** 都可以呼叫這個函式來鑄造 NFT，而不需要付費或擁有權限。通常在正式專案中，會加上 `onlyOwner` (只允許合約擁有者鑄造) 或者加上支付邏輯 (例如 `payable` 並要求發送 ETH)。
    
-   `_safeMint`: OpenZeppelin 的安全鑄造函式，它會檢查接收者如果是一個合約，該合約是否具備接收 NFT 的能力（避免 NFT 被鎖死在不支援的合約中）。
    
-   `_setTokenURI`: 將圖片或屬性的連結（如 IPFS hash）綁定到這個 ID 上。
    

```
function _baseURI() internal pure override returns (string memory) {
    return "https://ipfs.io/ipfs/";
}
```

-   這定義了所有 Token URI 的「前綴」。
    
-   當你呼叫 `tokenURI(tokenId)` 時，合約會將這裡的 Base URI 與你在 `mintItem` 輸入的 `uri` 拼接起來。
    
-   **範例**:
    
    -   Base URI: `https://ipfs.io/ipfs/`
        
    -   mintItem 輸入的 uri: `QmXyz...` (IPFS CID)
        
    -   最終完整的 TokenURI: `https://ipfs.io/ipfs/QmXyz...`
        

程式碼下半部分看起來很複雜且重複的函式（`_update`, `_increaseBalance`, `tokenURI`, `supportsInterface`），是 Solidity 處理多重繼承衝突的必要手段。

會衝突主要是，`ERC721`、`ERC721Enumerable` 和 `ERC721URIStorage` 這三個父合約中，都定義了相同名稱的函式，編譯器不知道該用哪一個。所以必須明確告訴編譯器，要呼叫`super` (父層) 的邏輯，並依序處理

-   `_update` **&** `_increaseBalance`: 這是 OpenZeppelin v5.0 更新後用來處理轉移和餘額記帳的底層邏輯（用於維護 Enumerable 的陣列）。
    
-   `tokenURI`: 解決標準 ERC721 和 URIStorage 對於「如何回傳 URI」的邏輯衝突。
    
-   `supportsInterface`: 用於讓其他應用程式（如 OpenSea、MetaMask）查詢這個合約支援哪些標準（例如是否支援 ERC721、ERC2981 等）。
    

目前 `mintItem` 是公開的`public` )，如果只希望項目方能發行NFT，應該`mintItem` 修改為：

```
function mintItem(...) public onlyOwner returns (uint256) { ... }
```

`ERC721Enumerable` 很消耗Gas，如果不需要在鏈上查詢「某人擁有的所有TokenID」，可以考慮移除它來節省用戶鑄造鑄造以及轉移成本。（可以改透過Indexer來記錄）。

> 對比Sui，Sui是物件，可以透過使用者查看使用者底下的所有物件，以及可以使用物件ID直接查看物件，不需要知道合約部署地址，以及TokenID。另外，Sui的GraphQL自帶Indexer，免費的，所以很方便。

`ERC721Enumerable` 合約中有以下公開函數可能來檢索代幣的枚舉列表：

-   `totalSupply()` 以獲取所有流通中的待斃
    
-   `tokenByIndex(index)`：以獲取特定索引處的tokenID
    
-   `tokenOfOwnerByIndex(owner, index)`：以獲取特定地址的特定索引處的tokeID
    
-   `supportsInterface(bytes4 interfaceId)`：標準檢測函數。詢問合約：「你支援 ERC721Enumerable 嗎？」合約會回傳 `true`
    

不能直接訪問的有：

-   internal：例如 `_update` 和 `_increaseBalance` ，只能「合約自己」或是「繼承它的紫合約」呼叫。
    
-   private：例如`_addTokenToOwnerEnumeration`、`_removeTokenFromOwnerEnumeration` 等
    

[這邊](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol)有完整合約

```
mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;  
mapping(uint256 tokenId => uint256) private _ownedTokensIndex;  
uint256 [] private _allTokens;  
mapping(uint256 tokenId => uint256) private _allTokensIndex;
```

這是 `ERC721Enumberable` 的核心

在標準 `ERC721` 中，只知道「誰擁有了這個Token`ownerOf` )，以及「某人有多少個Token`balanceOf` )，無法直接在鏈上高效地回答：「請列出Alice擁有的所有Token ID」或是「請給我第100個備注造出來的TokenID」

而OpenZeppelin使用了這四個變數來建立「雙向索引」，來達成。這是一個空間換時間與O(1)刪除優化的設計。

`_ownedTokens` ：

```
mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;
```

-   **結構**：`擁有者地址 => (索引 => Token ID)`
    
-   **功能**：這就像是為每個使用者維護了一個「虛擬陣列」。
    
-   **用途**：
    
    -   如果你想知道 Alice 的第 0 個 NFT 是幾號？查 `_ownedTokens[Alice][0]`。
        
    -   如果你想知道 Bob 的第 5 個 NFT 是幾號？查 `_ownedTokens[Bob][5]` 。
        

`_ownedTokensIndex` ：

```
mapping(uint256 tokenId => uint256) private _ownedTokensIndex;
```

-   **結構**：`Token ID => 在擁有者清單中的索引位置`
    
-   **功能**：這是上一個變數的反向查詢。它記錄了「某個 Token ID 在該主人的清單中排第幾個」。
    
-   **為什麼需要這個？（關鍵優化）**：
    
    -   當 Alice 把 Token A 轉賣給別人時，合約需要從 Alice 的 `_ownedTokens` 清單中移除 Token A。
        
    -   在 Solidity 中，刪除陣列中間的元素非常昂貴（需要搬移後續所有元素）。
        
    -   為了達到 **O(1)** 的 Gas 消耗，我們使用 **「Swap and Pop（交換並刪除）」** 技巧：
        
        1.  查出 Token A 在 Alice 清單中的位置（透過 `_ownedTokensIndex`）。
            
        2.  把 Alice 清單中「最後一個 Token」搬到 Token A 的位置覆蓋它。
            
        3.  刪除最後一個位置。
            
    -   如果沒有這個 `_ownedTokensIndex`，我們就必須遍歷 Alice 的所有 Token 才能找到 Token A 的位置，這會導致 Gas Limit 爆掉
        

`_allToken` ：

```
uint256 [] private _allTokens;
```

-   **結構**：`uint256` 的動態陣列
    
-   **功能**：單純記錄**目前存在的所有** Token ID。
    
-   **用途**：
    
    -   `totalSupply()` 就只是回傳 `_allTokens.length`。
        
    -   想要遍歷整個專案所有的 NFT？就跑個迴圈讀取這個陣列。
        

`_allTokens` ：

```
uint256 [] private _allTokens;
```

-   **結構**：`uint256` 的動態陣列
    
-   **功能**：單純記錄**目前存在的所有** Token ID。
    
-   **用途**：
    
    -   `totalSupply()` 就只是回傳 `_allTokens.length`。
        
    -   想要遍歷整個專案所有的 NFT？就跑個迴圈讀取這個陣列。
        

`_allTokensIndex` ：

```
mapping(uint256 tokenId => uint256) private _allTokensIndex;
```

-   **結構**：`Token ID => 在全域陣列 _allTokens 中的索引位置`
    
-   **功能**：記錄某個 Token ID 在 `_allTokens` 陣列中的第幾個位置。
    
-   **為什麼需要這個？**：
    
    -   原理同上。當一個 Token 被 **燃燒 (Burn)** 時，我們需要從 `_allTokens` 陣列中移除它。
        
    -   有了這個索引，我們同樣可以使用「Swap and Pop」技巧，快速將被燃燒的 Token 與陣列末尾的 Token 交換，然後縮短陣列長度，達成 O(1) 的燃燒成本。
        

| 變數名稱 | 鍵 (Key) | 值 (Value) | 意義 |
| --- | --- | --- | --- |
| _ownedTokens | [Alice][1] | 105 | Alice 的清單中，第 2 個是 #105 |
| _ownedTokensIndex | 105 | 1 | #105 在主人的清單中排第 2 位 |
| _allTokens | [98] | 105 | 全域清單中，第 99 個是 #105 |
| _allTokensIndex | 105 | 98 | #105 在全域清單中排第 99 位 |

知道這啥了，那咋`ERC721Enumerable` 擴展函數？以下使用Javascript

-   要檢索合約中的所有代幣，可以`totoalSupply()` 函數獲取總流動代幣，並循環遍歷 tokenByIndex(index) 函數，迭代已知次數
    

```
async function getAllTokens() {  
  const amount = await myToken.totalSupply()  
  let tokens = []  
  for (let i = 0; i < amount; i++) {  
    tokens.push(String(await myToken.tokenByIndex(i)))  
  }  
  return tokens  
}
```

-   從特定地址檢索所有代幣，可以用 balanceOf(owner)函數，也是循環遍歷 tokenOfOwnerByIndex(index)
    

```
async function getAllTokensFromAddress(address) {  
  const amount = await myToken.balanceOf(address)  
  let tokens = []  
  for (let i = 1; i <= amount; i++) {  
    tokens.push(String(await myToken.tokenOfOwnerByIndex(address, i - 1)))  
  }  
  return tokens  
}
```

補充：[ERC721](https://eips.ethereum.org/EIPS/eip-721)

## 解析My First NFT的合約

昨天的My First NFT地址：0x3d0172a432A1E861Df1434E44F815D32E9bed5cC

也可以直接在etherscan開：[https://sepolia.etherscan.io/address/0x3d0172a432A1E861Df1434E44F815D32E9bed5cC#code](https://sepolia.etherscan.io/address/0x3d0172a432A1E861Df1434E44F815D32E9bed5cC#code)

有驗證合約，所以能在contract那邊看到。

主要就看：MyFirstNFT.sol吧

跟前面標準的ERC721相比，有幾個亮點：

-   使用 `ERC721A` 節省Gas
    
-   使用「簽章驗證」來控制白名單或鑄造權限（而不是把名單寫死在合約裡）
    
-   完全在鏈上生成元數據，不需依賴外部的Json檔
    

核心驗證機制：簽章鑄造

一般來說，咱們做白名單有兩種做法：

-   **笨方法**：把所有白名單地址寫入合約（`mapping(address => bool)`）。這非常貴，Gas 費很高
    
-   **聰明方法（本合約做法）**：後端發一張「通行證（簽名）」給前端，合約驗證這張通行證是否由專案方簽發
    

```
address private _signer; // 專案方的公鑰地址

function _verify(bytes32 hash, bytes memory token) internal view returns (bool) {
    return (_recover(hash, token) == _signer); // 恢復出簽名的人，檢查是不是 _signer
}

function mint(string calldata imageURI, bytes calldata signature) ... {
    // 檢查 1：計算資料的 Hash (這裡只 Hash 了 imageURI)
    // 檢查 2：驗證簽名是否有效
    require(_verify(_hash(imageURI), signature), "MFNFT: Invalid signature.");
    ...
}
```

-   **流程**：
    
    1.  使用者在網站點擊 Mint。
        
    2.  網站後端（用私鑰）對 `imageURI` 進行簽名，產生 `signature`。
        
    3.  前端拿到 `signature`，呼叫合約的 `mint`。
        
    4.  合約驗證：這個簽名是否真的是由 `_signer` 簽發的？如果是，才允許鑄造。
        
-   **優點**：可以動態決定誰能 Mint，且不需要花 Gas 更新鏈上的名單。
    

資料儲存：動態鏈上元數據

標準 NFT 的 `tokenURI` 通常回傳一個網址（如 `ipfs://.../1.json`）。但這個合約**直接在程式碼裡拼湊出 JSON 字串**

```
function tokenURI(uint256 tokenId) ... {
    // ... 前略
    // 1. 手動拼接 JSON 字串
    string memory json = Base64.encode(
        bytes(string(abi.encodePacked(
            '{"name": "MFNFT #', Strings.toString(tokenId), '",',
            '"description": "MyFirstNFT is ...",',
            '"image": "', imageURI, '",', // imageURI 是鑄造時傳入並儲存在 mapping 中的
            '"attributes": []}'
        )))
    );
    // 2. 回傳 Data URL
    return string(abi.encodePacked("data:application/json;base64,", json));
}
```

-   **效果**：當 OpenSea 讀取這個 NFT 時，它不需要去發送 HTTP 請求抓取 JSON 檔，而是直接解析這串 Base64 編碼的字串。
    
-   **優點**：永遠不會因為伺服器掛掉或 IPFS 連結失效而導致 Metadata 消失（只要以太坊還在，Metadata 就在）。
    

防機器人與限購機制：

```
// 1. 禁止合約呼叫 (防合約機器人)
require(tx.origin == msg.sender, "MFNFT: contract is not allowed to mint.");

// 2. 每個錢包限購 1 個
require(numberMinted(msg.sender) == 0, "MFNFT: The wallet has already minted.");
```

-   `tx.origin == msg.sender`: 只有「外部帳戶 (EOA)」可以直接發起交易，如果透過其他合約來呼叫此函數，`msg.sender` 會是合約地址，而 `tx.origin` 是最初發起人，兩者會不同，從而觸發錯誤。
    
-   `numberMinted`: 這是 `ERC721A` 特有的函數（標準 ERC721 用 `balanceOf`），用來檢查該地址累計鑄造了多少個。
    

使用者體驗：自動退款 (`refundIfOver`)：

```
function refundIfOver(uint256 total) private {
    require(msg.value >= total, "MFNFT: Invalid value.");
    if (msg.value > total) {
        // 如果使用者付了 1 ETH，但價格只要 0.1 ETH，這裡會自動退回 0.9 ETH
        payable(msg.sender).transfer(msg.value - total);
    }
}
```

這允許前端即使估算錯誤多付了錢，使用者的資金也不會被合約吃掉。

小問題：

-   `tx.origin` 的使用：雖然能防止合約機器人，但也會阻擋像Gnosis Safe（多簽錢包）或帳戶抽象（AA）錢包的使用者，因為他們互動本質上是透過合約進行的
    

## **小紀錄：Web3運行原理：錢包道出塊、從應用到協議**

錢包、私鑰和個人主權

私鑰：資產控制權

助記詞：私鑰的可讀備份

地址：公鑰截取後的字符串，公開收款號

助記詞(一對多）->私鑰->公鑰->地址（截取公鑰最後20字＋0x開頭）

BIP-32 HD Wallet

交易 = 要做的事  + 手續費 + 防重放序號

錢包：

-   組裝交易內容
    
-   用私鑰簽名
    
-   廣播到區塊鏈網路
    

Gas Fee：

-   防止垃圾訊息
    
-   激勵打包者/驗證者
    

交易的完整生命週期：

-   Wallet
    
-   PRC
    
-   Mempool
    
-   Builder/Validator
    
-   Block
    
-   Explorer
    

可愛網站：[txcity.io/v/eth-btc](http://txcity.io/v/eth-btc)

為什麼要等待確認？確保不可被篡改

Parent hash會指向上一個區塊

區塊越往後堆疊，歷史被翻盤難度越高

POW/POS 如何認可？工作量vs質押

智能合約 = 區塊鏈裡的「可執行代碼」

-   EVM中執行
    
-   交易觸發執行->改變鏈上狀態
    
-   寫進鏈上
    

Code is law

-   規則可驗證、按代碼執行
    
-   部署後難以更改
    
-   減少中介與摩擦
    

EIP 論壇：改進討論

先討論->EIPs->再進入升級

執行層客戶端＋共識層客戶端，要多樣性

去中心化：

-   錢包創建：高度去中心化
    
-   交易廣播：可能中心化
    
-   網路運行：節點越分散越安全
    
-   客戶端越多樣越穩（減少單點軟體風險）
    

Web3是跨學科的領域

-   社會學：去中心化治理與共識形成
    
-   經濟學：激勵設計保證安全與可持續
    
-   密碼學：簽名、哈希、ZK提供可信基礎
    

Degen / Regen

Greenpill network ：國際Regn DAO

深度追蹤：資金流向，像是交易所啥的，看能不能凍結
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->

















## 參加開營

開營！ 後半段破冰簡直🐮

一堆大佬 好多在大廠上班、已經在業內有多個經驗、國際頂大、有做過項目、創過業等等

甚至，也有大ㄧ就來參加的

說實話，我超驚訝

有些人可能會為此焦慮，但是！我超興奮！

很期待跟這群人競爭，期待有更多刺激、更多想法交織、討論，這樣才能進步，這樣來參加才是有意義的。

## 閱讀Web3實習計畫手冊 - 智能合約開發（Ethereum vs Sui）

Ref：[https://web3intern.xyz/zh/smart-contract-development/](https://web3intern.xyz/zh/smart-contract-development/)

之前大部分都在Sui上，實習手冊是Ethereum的，所以有了一點對比

**資產差異**

在Solidity安全那邊，看到「重入攻擊」，發現主要會導致重入的原因是「狀態與資產」的分離

資產先被轉移，狀態後來才更新的話，就很容易導致在狀態更新前被不斷地轉移資產，導致重入

如果用CEI Pattern和重入鎖可以避免重入，大概就是先檢查、更新狀態，再轉移資產。

但如果是Sui，就不會有這問題，Object要麽轉了，要麽沒轉。 既然已經轉走了，自然就不能再轉，也就不會有重入。

另外，Sui的Object ownership的owned\_object也讓使用者「真正」的擁有資產，把信任成本降到最低。

**EVM的ABI咋？為啥Move沒有？**

先了解啥是ABI，然後為什麼EVM需要，再說為什麼Move不需要？

ABI = Application Binary Interface（應用二進位介面）

簡單來說，ABI就是合約跟外界溝通的規範，有點像API哈，定義了「如何呼叫function、傳送參數、接收返回值」

包括：

-   函數選擇器：
    
    -   取前 4 bytes of keccak256(“functionName(type1,type2)”)
        
    -   EVM用它找到哪個function要執行
        
-   參數編碼：
    
    -   將uint256、address、bytes等轉成32byte對齊格式
        
-   返回值解碼：
    
    -   將EVM Stack / memory的raw bytes解碼成高級型別
        
-   事件編碼：
    
    -   log topics / data
        

例如：

```
myContract.methods.transfer(addr, 100).send();
```

這背後騎士就是把：

```
function selector + encoded params
```

打包成bytes，傳給EVM執行

**為啥EVM需要ABI？**

-   EVM不理解Solidity / function名字
    
-   EVM只看 bytes / opcode
    
-   ABI是人類可理解的函數，EVM可執行bytes的翻譯規範
    

**為啥Sui Move沒有ABI？**

簡單來說就是「型別安全、不需動態解析」，既然已經天然類型安全，就不需要ABI

所以總結而言：

-   EVM 的 ABI = 把人類寫的 function 轉成 EVM 可以理解的 bytes
    
-   Move 不需要 ABI = 因為 transaction 已經明確型別化，runtime 直接識別 function 與資源
    

裡面有提到Foundry，推個使用Foundry復現DeFi駭客攻擊事件，整理了非常多的攻擊事件，蠻讚的：[https://github.com/SunWeb3Sec/DeFiHackLabs?tab=readme-ov-file](https://github.com/SunWeb3Sec/DeFiHackLabs?tab=readme-ov-file)

安全的話也有個小遊戲，Solidity漏洞小遊戲：[https://www.damnvulnerabledefi.xyz/](https://www.damnvulnerabledefi.xyz/)

還有個審計挑戰？[https://code4rena.com/](https://code4rena.com/)

有看到有人推viem，會試試看的哈

也期待之後實習計劃學習與研究，能不能帶給我多點不同的想法

## 獲取點測試Token

要說水龍頭領測試幣的話，Sepolia我最推的是「[Sepolia POW Faucet](https://faucets.pk910.de/)」

有很多很好的水龍頭，為啥最推？隱私及方便

-   隱私：很多網站是要先請用戶去驗證的，像是Google的 [Web Facuet](https://cloud.google.com/application/web3/faucet) 就要登入Google帳號，其他的則是可能要登入Github等等，而這個POW Faucet完全不用，只需要耐心的等待就行。
    
-   方便：大多數水龍頭都要求要先有個0.01ETH等等，總之就要先有一點Token，這對於開發者來說很不方便，會有gas磨耗、沒辦法開很多帳號測試，而且對隱私也不好，容易透過交易紀錄追蹤到開發者實際資產活動，而POW Faucet完全不用，空的錢包地址就行，另外，上限也很高，其他的水龍頭基本都有冷卻時間，可能一天才能領0.5ETH，而這個放著就能不斷產生，以效率來說確實蠻不錯的。
    

> 有趣小知識：
> 
> -   ETH可以換ETH Sepolia，同理，也能再換回去，所以其實算有點價值，例如：[LayerZero](https://testnetbridge.com/sepolia)
>     
> -   測試幣在開發上可以拿來部署合約、測試。對普通使用者來說可以拿來練習不熟悉的交易，像是跨鏈。對嚕毛仔來說，可以與項目方互動，有機會獲得空投（當然，現在這種機會比較少了）
>     

## Ethereum 隱私問題

在講隱私之前，先來**定義「什麼是隱私？」**

EF去年十月發布的「**The Ethereum Foundation’s Commitment to Privacy**」提到「Privacy is the freedom to choose what you share, when you share it, and who you share it with.」

在日常生活中，咱們都習以為常的想有這種的權利，但在網路以及區塊鏈上，這些往往是缺乏的。

而Ethereum目標是成為數位信任的基石，並且是足以支撐整個文名信任的體系，因此隱私必須是核心部分，但現在明顯還有進步空間。

**隱私對誰很重要？簡單來說，就是所有人**

-   對普通人：可以自由選擇分享什麼、與誰分享、何時分享
    
-   對開發者：很爽，可以有更大的設計空間，可以做出更好的產品，做出更多的創新應用
    
-   對機構：有更好的採納空間，畢竟不會想讓用戶或者企業資料裸奔在外
    
-   對社會：保障民主進程和集體信任，保護人們在不受監視或脅迫的情況下思考、交流和交易的自由，維持開放系統的可信度
    

回到主題，**Ethereum隱私有什麼痛點？**

-   鏈上裸奔：與 Dapp 互動通常要連接錢包，而區塊鏈是透明的，每個人都可以看到錢包與什麼進行了交互、交互的時間和方式。
    
-   中心化與錢包地址關聯風險：許多錢包都使用預設 hardcode 的 RPC，除了引入中心化之外，也帶來了與錢包活動關聯起來的風險 。（被關聯起來，也變相的等於被KYC了。你以為是匿名，其實是在裸奔）
    
-   代幣發現：大多數錢包能讓新代幣送到錢包後立即發現它們，雖然方便，但也有隱私隱患。
    

舉個例子：

MetaMask在 Import NFT 時會提示顯示 NFT數據會暴露 IP 位置到中心化伺服器，會有隱私上的風險。

其開發商 ConsenSys 曾提過會收集用戶 IP 和 錢包地址，不過也提到會分開存儲，不會關聯，並只保留幾天，但在交易時是同時發送的，就算分開存儲，多少還是能對應起來，頂多被盜時不會一起被盜？

不過透過了解隱私問題後，也了解為啥MetaMask對於新手而言這麽難用了，難用竟然是故意的：

-   自訂RPC：可以自己想用啥RPC就用啥，降低隱私風險
    
-   無代幣發現：新手最困擾的肯定是這個。為啥代幣轉來沒顯示？為啥沒顯示NFT？因為要自己Import！雖然麻煩，但也增強了隱私，就像下圖，如果要Import NFT時，MetaMask就會警告要注意會有相關風險
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-11-1768175560997-image.png)

還記得前面提到的Google的Web3 Faucet？也是同樣道理。

使用Web3 Faucet前要登入Google帳號，這也是直接告訴Google：「我有在使用加密貨幣，這是我選擇的鏈，這是我使用得錢包地址」，那Google之後就能多跳點相關廣告或網站給你，變相的KYC了。

**那理想的錢包是什麼？**

-   交易隱私：任何交易、跟合約互動都是隱私的，例如：Railgun
    
-   Private RPC：理想情況下是本地運行以太坊節點
    
-   Lightclients＆Yolo Nodes：像是Helios，能驗證不受信任的RPC，具備本地驗證能力，可隨機向多個不信任的節點請求數據片對，打破「必須綁定單一可信RPC」的局面，並且可以防止單點故障，實現「去中心化前端」
    
-   Network Privacy：極度重視隱私者，希望透過Tor路由來增加額外一層保護
    

## V神希望在錢包中看到什麼？

source：[https://vitalik.eth.limo/general/2024/12/03/wallets.html](https://vitalik.eth.limo/general/2024/12/03/wallets.html)

V神認為：錢包是使用者進入Ethereum世界的窗口，如果錢包本身不具備去中心化、抗審查、安全和隱私等特性，那麼使用者就無法真正享受到Ethereum帶來的這些好處。這篇多關注於安全性與隱私，而非只是UX。

**跨L2的使用者體驗**：現在L2生態分散

-   鏈特定地址：
    
    -   錢包應支援像「user.eth@optimism.eth」的格式
        
    -   自動路由：當使用者複製此類地址並發送時，錢包應自動判斷：
        
        -   目標鏈有資金：直接發送
            
        -   資金在其他鏈：自動透過跨鏈協議（如ERC-7683）發送
            
        -   需換幣：自動透過DEX轉換並發送（需使用者確認）
            
-   鏈特定支付請求：DApp 或 QR Code 可以發出「在 Z 鏈上需要 X 數量的 Y 代幣」的請求，錢包應能自動滿足
    
-   Gas 費抽象化：如果收到資產的鏈上沒有 ETH 當 Gas，錢包應自動使用其他鏈的資金支付 Gas（例如透過 RIP-7755），或自動兌換少量 ETH 以備未來使用。
    

**帳戶安全性** ：理想錢包要同時防範「開發者作惡」及「使用者自身錯誤」：

-   核心方案：社交恢復與多簽
    
    -   架構：1個PK + N個守護者
        
    -   權限：主密鑰處理低價值操作；高價值操作或更改密鑰需多數守護者簽名
        
-   守護者的選擇：
    
    -   ZK-Email：使用者設定Email為守護者，透過ZK-SNARKs證明自己擁有該Email的控制權來簽名，無需依賴中心化伺服器管理私鑰
        
    -   其他選項：親友、機構、多設備等等
        

**新手與應用程序內建錢包**

-   簡化入門（2/3多簽配置）：
    
    -   ZK-Email（Email守護者）
        
    -   本地設備金鑰（Passkey/手機）
        
    -   服務商備份金鑰，隨資產增加，再提示使用者增加更多守護者
        
-   層級化連結：
    
    -   主錢包應作為所有「應用程序內建錢包」的守護者
        
    -   使用者只需管理主錢包的權限，即控制所有子帳戶
        

**隱私保護**：隱私不應只是額外插件，而應是錢包的「預設功能」

-   直接整合隱私傳輸：錢包應內建隱私池 (Privacy Pools)。轉帳時自動從隱私池提取，接收資金時自動生成隱形地址 (Stealth Addresses)，切斷發送者與接收者之間的鏈上關聯。
    
-   每個應用獨立地址：錢包為每個 DApp 生成不同的地址，避免單一地址暴露使用者所有的鏈上活動。
    
-   資料錢包 (Data Wallets)：錢包不僅存儲私鑰，還應負責安全地存儲使用者的鏈下數據（如 Zupass 證明、個人資料），並透過加密分片存儲在守護者網絡中。
    

**安全的鏈上存取**：目前的錢包過度依賴RPC提供商，存在「提供假數據」和「洩露隱私」的風險

-   輕客戶端 (Light Clients)：錢包應使用像 Helios 這樣的輕客戶端，直接驗證 L1 和 L2 的狀態根，而不僅僅是信任 RPC。
    
-   隱私資訊檢索 (PIR - Private Information Retrieval)：為了解決隱私問題，使用者查詢餘額或數據時，應透過RIP技術，RIP技術允許使用者相伺服器查詢數據，但伺服器不知道使用者具體查詢了哪一筆數據。
    

**密鑰庫錢包**：為了解決在多條 L2 上管理帳戶的麻煩，密鑰配置（如更換守護者）應集中管理

-   L2 密鑰庫：配置資訊存在某一條 L2 上（低成本），其他鏈上的錢包透過 ZK-SNARKs 讀取該配置。這樣只需更改一次設定，所有鏈上的帳戶都會同步更新。
    

**DApp安全與未來展望**：

-   **內容版本控制**：透過 ENS + IPFS 存儲前端介面，防止 Web2 伺服器被駭導致的釣魚攻擊。
    
-   **AI 與腦機介面 (BCI)**：
    
    -   未來錢包將從「點擊介面」轉向「意圖導向」。
        
    -   AI 代理人將幫助使用者分析交易風險，並將使用者的自然語言指令轉化為具體的鏈上操作。
        

## 閱讀筆記及心得 - Web3實習計畫手冊 - 行業前輩訪談錄

會先看行業前輩訪談是因為我自身很迷茫，身在25、26年的Web3，身在一個AI時代，並且興趣多，還無法專注，不知道該如何去做，畢竟有了AI很多都容易被取代，而且Web3現在門檻也在提升，該如何養成無法取代，且被需要的能力？這是我想關注的。

-   Logic：工程師的價值在於「交付」而非單純「寫碼」
    
    -   黃金比例：30%寫代碼＋70%溝通協作
        
    -   護城河（AI做不到的事）：
        
        -   質量體系：建立間空、測試、回滾機制，確保系統穩定
            
        -   決策與救火：給出多套落地方案、預判風險、撰寫完整技術文檔
            
    -   行動建議：主動參與開源或社區建設（提交PR），讓自己「被看見」
        
-   Jason：透過「實踐」打通底層與應用
    
    -   求職入徑：內推＋線下社群（i人也要逼自己變e參加活動）
        
    -   成長飛輪：找實習->發現短板->回校補計算機基礎（CPU/IO/內存）->挑戰更好的實習
        
    -   核心觀念：
        
        -   底層開發者更需要產品思維
            
        -   AI無法替你理解業務場景，這才是不可替代的
            
-   Bruce：職場軟實力–如何定義「靠譜」
    
    -   靠譜定義：
        
        -   可預期（進度透明，不最後一刻才說做不完）
            
        -   可溝通（遇到卡點主動求救，不悶頭工作）
            
        -   可復盤（具備反思能力，不二過）
            
    -   避雷區：人間蒸發、明日復明日、不溝通只悶頭苦幹
        
    -   關鍵動作：動手寫代碼前，先採解任務並與Mentor對齊方案
        

心得：

跟我之前理解也有點像，這次再看到也更深刻了，主動是第一步，反思、理解「做什麼」、「為什麼做」則是持續成長的部分，有了底層知識，也要有業務邏輯的能力，價值是「交付」，那溝通就很重要，最好是很透明，還要會拆分任務。

這讓我想到，之前問IOTA Foundation的infra朋友：「你覺得先學Rust會是個學選擇嗎？」，他回：「我不確定學語言是否是個好選擇，但認為Knowhow更重要，不過不否定學習語言，畢竟看Rust蠻多職缺的」，所以語言不一定重要，尤其是在這AI的時代下，但也有個問題，如何在語言不夠厲害時，能夠有knowhow？

Bruce講的我也感同身受，我前面幾次黑客松，合作起來非常輕鬆順暢，就是因為溝通透明順暢，尤其是Zetachain通用AI黑客松時那做起來真的舒服，今天要做什麼，正在做什麼，都會直接講，跟隊友也都知道自己該幹啥，然後我也有列出代辦清單，讓雙方很清晰的瞭解到，有什麼還沒做？以及正在做什麼？

並且，有問題就馬上說，滿滿的安全感，也能知道目前項目有啥問題，後來幾乎也都沒開會，就能自動地完成項目，非常舒服。

但前幾週玩了一場Sui workshop的黑客松，就很頭痛，就是隊友開始做時都不會講正在做啥，也不會說做了啥、剩下啥，導致每次要做之前都要花很多時間去做確認，這一來一往超沒效率，甚至到後來影響到我自己的心態，也就沒放太多心力在上面。

接下來，我會謹記前輩的話，多往這些方向去實踐看看！

## 來玩Unphishable

### [No.0x0003](https://unphishable.io/challenges/permit-phishing) ：

這題考的是授權簽名的部分，簽名真的都要小心吶，我之前也是受害者哈哈

![Screenshot 2026-01-12 at 12.56.43 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-12-1768193833740-Screenshot_2026-01-12_at_12.56.43_PM.png)

其實從上面的Spending cap上面就有寫「無限」，就是轉出的金額是無限的，會清空錢包

![Screenshot 2026-01-12 at 12.58.15 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-12-1768193904850-Screenshot_2026-01-12_at_12.58.15_PM.png)

這邊則是一些細節，可以看到Spender就是我這發送者，會送Value，這金額很大，大概是無限大，然後nonce是防重放用的，Deadline則是指什麼時候之前使用這合約會有效

其實這邊大部分都是假資料，像是Nonce就是，所以會亂跳是正常的。

總之，這關是說要仔細注意交易，其實如果不知道咋看，在交易前也是可以丟給AI分析，安全最重要。

### [No.0x0004](https://unphishable.io/challenges/airdrop-scam) ：

通常X啥的都會莫名被標注，然後說有空投可以領，很多都詐騙，就是會授權送代幣過去，然後他可能也真的會送代幣，但是是假的。

這題做得不夠好啊哈，他只有使用者送代幣，沒有真的送使用者代幣（假的）

### [No.0x0036](https://unphishable.io/challenges/fake-zoom-meeting-phishing) :

這題🐮逼，使用超連結假冒網址，再用deepfake換臉，所以都應該要小心網址是否正確，有些也會是使用相似字型，或是幾乎一樣的去欺騙，更可怕的是有些Google還會推薦，所以最好都要提防私訊網址是否正確，發現會議室認識的人也要再次確認

但說真的，感覺這好難喔，我如果遇到，可能真的會被騙

## 在 [My First NFT](https://nft.myfirst.io/) mint 第一個 NFT

這網站做得真的好看，也很清晰易懂，也成功Mint出NFT啦

超、可、愛！

![Screenshot 2026-01-12 at 4.02.41 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-12-1768205568732-Screenshot_2026-01-12_at_4.02.41_PM.png)

## 小筆記 - Web3行業全局介紹

歷史回朔：

-   第一階段(2009~2014)：BTC
    
-   第二階段(2015-2020)：以太坊上線，ICO+第二代交易所崛起（幣安）
    
-   第三階段(2020-2024)：Web3概念爆發（NFT+DeFi+GameFi)、去中心化錢包等去中心化產品，解決擴容的L2。應用更多、正規軍大規模入場
    
-   第四階段(2024-至今)：宏觀合規、ETF上市、RWA、DePIN、AI+Web3。推動更多資本巨頭入場
    

開發者數量：

-   全球月活開發者：約2.5~3萬人
    
-   連續兩年基本持平
    

招聘情況：

-   2025年招聘反彈47%（新增6.6萬個崗位）
    

硬核技術：北美是中心

交易所、資產管理、運營：亞洲（香港、新加坡）及中東（阿聯酋、沙特）

平均錄取比：

-   1個崗位vs 450份簡歷
    

職能分化：

-   紅海：初級Solidity開發、初級社區運營
    
-   藍海：資深Rust工程師、合規官、Research Analyst（複合型）
    

核心渠道：

-   Web3垂直平台：SmartDeer,[Web3.career](http://Web3.career).Remote3,CryptoJobsList
    
-   社交網路：Ｘ、Web3媒體、Farcaster、Discord、Linkedin及Notion
    
-   隱形渠道：Github Contribution、DAO治理提案
    

技術：32%

PM：27%

運營：15%

…

從Web2帶能力遷移、從生態切入、建立鏈上聲譽

開發

-   Solidity：Web3最廣泛和通用的開發語言，易上手，建議新手要學習一下，理解智能合約編程思維邏輯
    
-   Rust應用越來越多，很多鏈和自創語言都基於Rust開
    
-   合約安全意識：系統設計，對DeFi/L2的理解
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
