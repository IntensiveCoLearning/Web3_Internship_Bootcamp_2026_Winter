---
timezone: UTC+8
---

# 馬鈴薯

**GitHub ID:** Toby1009

**Telegram:** @Yunizero

## Self-introduction

馬鈴薯

## Notes

<!-- Content_START -->
# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
## Speed Run Ethereum - **Challenge: 🎟 Tokenization**

點進去看合約哈，這關就是搞個ERC-721 NFT合約，使用OpenZeppelin函式庫保證安全性與標準化

這合約名稱叫 `YourCollectible` ，繼承了四個父合約

```
contract YourCollectible is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable { ... }
```

-   `ERC721`: NFT 的核心標準實作，定義了代幣的持有權、轉移等基本功能。
    
-   `ERC721Enumerable`: 擴充功能。它允許合約「列舉」代幣。這讓你可以查詢「這個合約總共有多少個 NFT (`totalSupply`)」以及「某個地址持有哪些具體的 Token ID」。_注意：這會增加鑄造與轉移時的 Gas 費用。_
    
-   `ERC721URIStorage`: 擴充功能。它允許為每一個 Token ID 設定獨立的元數據連結（URI），這對於每個 NFT 長得都不一樣的專案來說是必須的。
    
-   `Ownable`: 權限管理。提供 `owner` (合約擁有者) 的概念，通常用於限制某些功能（如只有擁有者能鑄造），雖然在此範例的 `mintItem` 中並未加上限制。
    

```
uint256 public tokenIdCounter;

constructor() ERC721("YourCollectible", "YCB") Ownable(msg.sender) {}
```

-   `tokenIdCounter`: 一個計數器，用來記錄目前發行到第幾號 NFT。預設從 0 開始。
    
-   `constructor`: 合約部署時執行一次。
    
    -   設定 NFT 系列名稱為 `"YourCollectible"`。
        
    -   設定代號為 `"YCB"`。
        
    -   `Ownable(msg.sender)` 設定部署合約的人為初始擁有者 (Owner)。
        

```
function mintItem(address to, string memory uri) public returns (uint256) {
    tokenIdCounter++;               // 1. ID 計數器加 1
    uint256 tokenId = tokenIdCounter; // 2. 取得當前的 ID (例如第 1 個就是 1)
    
    _safeMint(to, tokenId);         // 3. 鑄造 NFT 給指定地址 (to)
    _setTokenURI(tokenId, uri);     // 4. 設定該 NFT 的元數據連結 (Metadata URI)
    
    return tokenId;                 // 5. 回傳新生成的 Token ID
}
```

-   `public` **可見性**: **注意**，這裡設為 `public` 意味著 **任何人** 都可以呼叫這個函式來鑄造 NFT，而不需要付費或擁有權限。通常在正式專案中，會加上 `onlyOwner` (只允許合約擁有者鑄造) 或者加上支付邏輯 (例如 `payable` 並要求發送 ETH)。
    
-   `_safeMint`: OpenZeppelin 的安全鑄造函式，它會檢查接收者如果是一個合約，該合約是否具備接收 NFT 的能力（避免 NFT 被鎖死在不支援的合約中）。
    
-   `_setTokenURI`: 將圖片或屬性的連結（如 IPFS hash）綁定到這個 ID 上。
    

```
function _baseURI() internal pure override returns (string memory) {
    return "https://ipfs.io/ipfs/";
}
```

-   這定義了所有 Token URI 的「前綴」。
    
-   當你呼叫 `tokenURI(tokenId)` 時，合約會將這裡的 Base URI 與你在 `mintItem` 輸入的 `uri` 拼接起來。
    
-   **範例**:
    
    -   Base URI: `https://ipfs.io/ipfs/`
        
    -   mintItem 輸入的 uri: `QmXyz...` (IPFS CID)
        
    -   最終完整的 TokenURI: `https://ipfs.io/ipfs/QmXyz...`
        

程式碼下半部分看起來很複雜且重複的函式（`_update`, `_increaseBalance`, `tokenURI`, `supportsInterface`），是 Solidity 處理多重繼承衝突的必要手段。

會衝突主要是，`ERC721`、`ERC721Enumerable` 和 `ERC721URIStorage` 這三個父合約中，都定義了相同名稱的函式，編譯器不知道該用哪一個。所以必須明確告訴編譯器，要呼叫`super` (父層) 的邏輯，並依序處理

-   `_update` **&** `_increaseBalance`: 這是 OpenZeppelin v5.0 更新後用來處理轉移和餘額記帳的底層邏輯（用於維護 Enumerable 的陣列）。
    
-   `tokenURI`: 解決標準 ERC721 和 URIStorage 對於「如何回傳 URI」的邏輯衝突。
    
-   `supportsInterface`: 用於讓其他應用程式（如 OpenSea、MetaMask）查詢這個合約支援哪些標準（例如是否支援 ERC721、ERC2981 等）。
    

目前 `mintItem` 是公開的`public` )，如果只希望項目方能發行NFT，應該`mintItem` 修改為：

```
function mintItem(...) public onlyOwner returns (uint256) { ... }
```

`ERC721Enumerable` 很消耗Gas，如果不需要在鏈上查詢「某人擁有的所有TokenID」，可以考慮移除它來節省用戶鑄造鑄造以及轉移成本。（可以改透過Indexer來記錄）。

`ERC721Enumerable` 合約中有以下公開函數可能來檢索代幣的枚舉列表：

-   `totalSupply()` 以獲取所有流通中的待斃
    
-   `tokenByIndex(index)`：以獲取特定索引處的tokenID
    
-   `tokenOfOwnerByIndex(owner, index)`：以獲取特定地址的特定索引處的tokeID
    
-   `supportsInterface(bytes4 interfaceId)`：標準檢測函數。詢問合約：「你支援 ERC721Enumerable 嗎？」合約會回傳 `true`
    

不能直接訪問的有：

-   internal：例如 `_update` 和 `_increaseBalance` ，只能「合約自己」或是「繼承它的紫合約」呼叫。
    
-   private：例如`_addTokenToOwnerEnumeration`、`_removeTokenFromOwnerEnumeration` 等
    

[這邊](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol)有完整合約

```
mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;  
mapping(uint256 tokenId => uint256) private _ownedTokensIndex;  
uint256 [] private _allTokens;  
mapping(uint256 tokenId => uint256) private _allTokensIndex;
```

這是 `ERC721Enumberable` 的核心

在標準 `ERC721` 中，只知道「誰擁有了這個Token`ownerOf` )，以及「某人有多少個Token`balanceOf` )，無法直接在鏈上高效地回答：「請列出Alice擁有的所有Token ID」或是「請給我第100個備注造出來的TokenID」

而OpenZeppelin使用了這四個變數來建立「雙向索引」，來達成。這是一個空間換時間與O(1)刪除優化的設計。

`_ownedTokens` ：

```
mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;
```

-   **結構**：`擁有者地址 => (索引 => Token ID)`
    
-   **功能**：這就像是為每個使用者維護了一個「虛擬陣列」。
    
-   **用途**：
    
    -   如果你想知道 Alice 的第 0 個 NFT 是幾號？查 `_ownedTokens[Alice][0]`。
        
    -   如果你想知道 Bob 的第 5 個 NFT 是幾號？查 `_ownedTokens[Bob][5]` 。
        

`_ownedTokensIndex` ：

```
mapping(uint256 tokenId => uint256) private _ownedTokensIndex;
```

-   **結構**：`Token ID => 在擁有者清單中的索引位置`
    
-   **功能**：這是上一個變數的反向查詢。它記錄了「某個 Token ID 在該主人的清單中排第幾個」。
    
-   **為什麼需要這個？（關鍵優化）**：
    
    -   當 Alice 把 Token A 轉賣給別人時，合約需要從 Alice 的 `_ownedTokens` 清單中移除 Token A。
        
    -   在 Solidity 中，刪除陣列中間的元素非常昂貴（需要搬移後續所有元素）。
        
    -   為了達到 **O(1)** 的 Gas 消耗，我們使用 **「Swap and Pop（交換並刪除）」** 技巧：
        
        1.  查出 Token A 在 Alice 清單中的位置（透過 `_ownedTokensIndex`）。
            
        2.  把 Alice 清單中「最後一個 Token」搬到 Token A 的位置覆蓋它。
            
        3.  刪除最後一個位置。
            
    -   如果沒有這個 `_ownedTokensIndex`，我們就必須遍歷 Alice 的所有 Token 才能找到 Token A 的位置，這會導致 Gas Limit 爆掉
        

`_allToken` ：

```
uint256 [] private _allTokens;
```

-   **結構**：`uint256` 的動態陣列
    
-   **功能**：單純記錄**目前存在的所有** Token ID。
    
-   **用途**：
    
    -   `totalSupply()` 就只是回傳 `_allTokens.length`。
        
    -   想要遍歷整個專案所有的 NFT？就跑個迴圈讀取這個陣列。
        

`_allTokens` ：

```
uint256 [] private _allTokens;
```

-   **結構**：`uint256` 的動態陣列
    
-   **功能**：單純記錄**目前存在的所有** Token ID。
    
-   **用途**：
    
    -   `totalSupply()` 就只是回傳 `_allTokens.length`。
        
    -   想要遍歷整個專案所有的 NFT？就跑個迴圈讀取這個陣列。
        

`_allTokensIndex` ：

```
mapping(uint256 tokenId => uint256) private _allTokensIndex;
```

-   **結構**：`Token ID => 在全域陣列 _allTokens 中的索引位置`
    
-   **功能**：記錄某個 Token ID 在 `_allTokens` 陣列中的第幾個位置。
    
-   **為什麼需要這個？**：
    
    -   原理同上。當一個 Token 被 **燃燒 (Burn)** 時，我們需要從 `_allTokens` 陣列中移除它。
        
    -   有了這個索引，我們同樣可以使用「Swap and Pop」技巧，快速將被燃燒的 Token 與陣列末尾的 Token 交換，然後縮短陣列長度，達成 O(1) 的燃燒成本。
        

| 變數名稱 | 鍵 (Key) | 值 (Value) | 意義 |
| --- | --- | --- | --- |
| _ownedTokens | [Alice][1] | 105 | Alice 的清單中，第 2 個是 #105 |
| _ownedTokensIndex | 105 | 1 | #105 在主人的清單中排第 2 位 |
| _allTokens | [98] | 105 | 全域清單中，第 99 個是 #105 |
| _allTokensIndex | 105 | 98 | #105 在全域清單中排第 99 位 |

知道這啥了，那咋`ERC721Enumerable` 擴展函數？以下使用Javascript

-   要檢索合約中的所有代幣，可以`totoalSupply()` 函數獲取總流動代幣，並循環遍歷 tokenByIndex(index) 函數，迭代已知次數
    

```
async function getAllTokens() {  
  const amount = await myToken.totalSupply()  
  let tokens = []  
  for (let i = 0; i < amount; i++) {  
    tokens.push(String(await myToken.tokenByIndex(i)))  
  }  
  return tokens  
}
```

-   從特定地址檢索所有代幣，可以用 balanceOf(owner)函數，也是循環遍歷 tokenOfOwnerByIndex(index)
    

```
async function getAllTokensFromAddress(address) {  
  const amount = await myToken.balanceOf(address)  
  let tokens = []  
  for (let i = 1; i <= amount; i++) {  
    tokens.push(String(await myToken.tokenOfOwnerByIndex(address, i - 1)))  
  }  
  return tokens  
}
```

## **小紀錄：Web3運行原理：錢包道出塊、從應用到協議**

錢包、私鑰和個人主權

私鑰：資產控制權

助記詞：私鑰的可讀備份

地址：公鑰截取後的字符串，公開收款號

助記詞(一對多）->私鑰->公鑰->地址（截取公鑰最後20字＋0x開頭）

BIP-32 HD Wallet

交易 = 要做的事  + 手續費 + 防重放序號

錢包：

-   組裝交易內容
    
-   用私鑰簽名
    
-   廣播到區塊鏈網路
    

Gas Fee：

-   防止垃圾訊息
    
-   激勵打包者/驗證者
    

交易的完整生命週期：

-   Wallet
    
-   PRC
    
-   Mempool
    
-   Builder/Validator
    
-   Block
    
-   Explorer
    

可愛網站：[txcity.io/v/eth-btc](http://txcity.io/v/eth-btc)

為什麼要等待確認？確保不可被篡改

Parent hash會指向上一個區塊

區塊越往後堆疊，歷史被翻盤難度越高

POW/POS 如何認可？工作量vs質押

智能合約 = 區塊鏈裡的「可執行代碼」

-   EVM中執行
    
-   交易觸發執行->改變鏈上狀態
    
-   寫進鏈上
    

Code is law

-   規則可驗證、按代碼執行
    
-   部署後難以更改
    
-   減少中介與摩擦
    

EIP 論壇：改進討論

先討論->EIPs->再進入升級

執行層客戶端＋共識層客戶端，要多樣性

去中心化：

-   錢包創建：高度去中心化
    
-   交易廣播：可能中心化
    
-   網路運行：節點越分散越安全
    
-   客戶端越多樣越穩（減少單點軟體風險）
    

Web3是跨學科的領域

-   社會學：去中心化治理與共識形成
    
-   經濟學：激勵設計保證安全與可持續
    
-   密碼學：簽名、哈希、ZK提供可信基礎
    

Degen / Regen

Greenpill network ：國際Regn DAO

深度追蹤：資金流向，像是交易所啥的，看能不能凍結
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->









## 參加開營

開營！ 後半段破冰簡直🐮

一堆大佬 好多在大廠上班、已經在業內有多個經驗、國際頂大、有做過項目、創過業等等

甚至，也有大ㄧ就來參加的

說實話，我超驚訝

有些人可能會為此焦慮，但是！我超興奮！

很期待跟這群人競爭，期待有更多刺激、更多想法交織、討論，這樣才能進步，這樣來參加才是有意義的。

## 閱讀Web3實習計畫手冊 - 智能合約開發（Ethereum vs Sui）

Ref：[https://web3intern.xyz/zh/smart-contract-development/](https://web3intern.xyz/zh/smart-contract-development/)

之前大部分都在Sui上，實習手冊是Ethereum的，所以有了一點對比

**資產差異**

在Solidity安全那邊，看到「重入攻擊」，發現主要會導致重入的原因是「狀態與資產」的分離

資產先被轉移，狀態後來才更新的話，就很容易導致在狀態更新前被不斷地轉移資產，導致重入

如果用CEI Pattern和重入鎖可以避免重入，大概就是先檢查、更新狀態，再轉移資產。

但如果是Sui，就不會有這問題，Object要麽轉了，要麽沒轉。 既然已經轉走了，自然就不能再轉，也就不會有重入。

另外，Sui的Object ownership的owned\_object也讓使用者「真正」的擁有資產，把信任成本降到最低。

**EVM的ABI咋？為啥Move沒有？**

先了解啥是ABI，然後為什麼EVM需要，再說為什麼Move不需要？

ABI = Application Binary Interface（應用二進位介面）

簡單來說，ABI就是合約跟外界溝通的規範，有點像API哈，定義了「如何呼叫function、傳送參數、接收返回值」

包括：

-   函數選擇器：
    
    -   取前 4 bytes of keccak256(“functionName(type1,type2)”)
        
    -   EVM用它找到哪個function要執行
        
-   參數編碼：
    
    -   將uint256、address、bytes等轉成32byte對齊格式
        
-   返回值解碼：
    
    -   將EVM Stack / memory的raw bytes解碼成高級型別
        
-   事件編碼：
    
    -   log topics / data
        

例如：

```
myContract.methods.transfer(addr, 100).send();
```

這背後騎士就是把：

```
function selector + encoded params
```

打包成bytes，傳給EVM執行

**為啥EVM需要ABI？**

-   EVM不理解Solidity / function名字
    
-   EVM只看 bytes / opcode
    
-   ABI是人類可理解的函數，EVM可執行bytes的翻譯規範
    

**為啥Sui Move沒有ABI？**

簡單來說就是「型別安全、不需動態解析」，既然已經天然類型安全，就不需要ABI

所以總結而言：

-   EVM 的 ABI = 把人類寫的 function 轉成 EVM 可以理解的 bytes
    
-   Move 不需要 ABI = 因為 transaction 已經明確型別化，runtime 直接識別 function 與資源
    

裡面有提到Foundry，推個使用Foundry復現DeFi駭客攻擊事件，整理了非常多的攻擊事件，蠻讚的：[https://github.com/SunWeb3Sec/DeFiHackLabs?tab=readme-ov-file](https://github.com/SunWeb3Sec/DeFiHackLabs?tab=readme-ov-file)

安全的話也有個小遊戲，Solidity漏洞小遊戲：[https://www.damnvulnerabledefi.xyz/](https://www.damnvulnerabledefi.xyz/)

還有個審計挑戰？[https://code4rena.com/](https://code4rena.com/)

有看到有人推viem，會試試看的哈

也期待之後實習計劃學習與研究，能不能帶給我多點不同的想法

## 獲取點測試Token

要說水龍頭領測試幣的話，Sepolia我最推的是「[Sepolia POW Faucet](https://faucets.pk910.de/)」

有很多很好的水龍頭，為啥最推？隱私及方便

-   隱私：很多網站是要先請用戶去驗證的，像是Google的 [Web Facuet](https://cloud.google.com/application/web3/faucet) 就要登入Google帳號，其他的則是可能要登入Github等等，而這個POW Faucet完全不用，只需要耐心的等待就行。
    
-   方便：大多數水龍頭都要求要先有個0.01ETH等等，總之就要先有一點Token，這對於開發者來說很不方便，會有gas磨耗、沒辦法開很多帳號測試，而且對隱私也不好，容易透過交易紀錄追蹤到開發者實際資產活動，而POW Faucet完全不用，空的錢包地址就行，另外，上限也很高，其他的水龍頭基本都有冷卻時間，可能一天才能領0.5ETH，而這個放著就能不斷產生，以效率來說確實蠻不錯的。
    

> 有趣小知識：
> 
> -   ETH可以換ETH Sepolia，同理，也能再換回去，所以其實算有點價值，例如：[LayerZero](https://testnetbridge.com/sepolia)
>     
> -   測試幣在開發上可以拿來部署合約、測試。對普通使用者來說可以拿來練習不熟悉的交易，像是跨鏈。對嚕毛仔來說，可以與項目方互動，有機會獲得空投（當然，現在這種機會比較少了）
>     

## Ethereum 隱私問題

在講隱私之前，先來**定義「什麼是隱私？」**

EF去年十月發布的「**The Ethereum Foundation’s Commitment to Privacy**」提到「Privacy is the freedom to choose what you share, when you share it, and who you share it with.」

在日常生活中，咱們都習以為常的想有這種的權利，但在網路以及區塊鏈上，這些往往是缺乏的。

而Ethereum目標是成為數位信任的基石，並且是足以支撐整個文名信任的體系，因此隱私必須是核心部分，但現在明顯還有進步空間。

**隱私對誰很重要？簡單來說，就是所有人**

-   對普通人：可以自由選擇分享什麼、與誰分享、何時分享
    
-   對開發者：很爽，可以有更大的設計空間，可以做出更好的產品，做出更多的創新應用
    
-   對機構：有更好的採納空間，畢竟不會想讓用戶或者企業資料裸奔在外
    
-   對社會：保障民主進程和集體信任，保護人們在不受監視或脅迫的情況下思考、交流和交易的自由，維持開放系統的可信度
    

回到主題，**Ethereum隱私有什麼痛點？**

-   鏈上裸奔：與 Dapp 互動通常要連接錢包，而區塊鏈是透明的，每個人都可以看到錢包與什麼進行了交互、交互的時間和方式。
    
-   中心化與錢包地址關聯風險：許多錢包都使用預設 hardcode 的 RPC，除了引入中心化之外，也帶來了與錢包活動關聯起來的風險 。（被關聯起來，也變相的等於被KYC了。你以為是匿名，其實是在裸奔）
    
-   代幣發現：大多數錢包能讓新代幣送到錢包後立即發現它們，雖然方便，但也有隱私隱患。
    

舉個例子：

MetaMask在 Import NFT 時會提示顯示 NFT數據會暴露 IP 位置到中心化伺服器，會有隱私上的風險。

其開發商 ConsenSys 曾提過會收集用戶 IP 和 錢包地址，不過也提到會分開存儲，不會關聯，並只保留幾天，但在交易時是同時發送的，就算分開存儲，多少還是能對應起來，頂多被盜時不會一起被盜？

不過透過了解隱私問題後，也了解為啥MetaMask對於新手而言這麽難用了，難用竟然是故意的：

-   自訂RPC：可以自己想用啥RPC就用啥，降低隱私風險
    
-   無代幣發現：新手最困擾的肯定是這個。為啥代幣轉來沒顯示？為啥沒顯示NFT？因為要自己Import！雖然麻煩，但也增強了隱私，就像下圖，如果要Import NFT時，MetaMask就會警告要注意會有相關風險
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-11-1768175560997-image.png)

還記得前面提到的Google的Web3 Faucet？也是同樣道理。

使用Web3 Faucet前要登入Google帳號，這也是直接告訴Google：「我有在使用加密貨幣，這是我選擇的鏈，這是我使用得錢包地址」，那Google之後就能多跳點相關廣告或網站給你，變相的KYC了。

**那理想的錢包是什麼？**

-   交易隱私：任何交易、跟合約互動都是隱私的，例如：Railgun
    
-   Private RPC：理想情況下是本地運行以太坊節點
    
-   Lightclients＆Yolo Nodes：像是Helios，能驗證不受信任的RPC，具備本地驗證能力，可隨機向多個不信任的節點請求數據片對，打破「必須綁定單一可信RPC」的局面，並且可以防止單點故障，實現「去中心化前端」
    
-   Network Privacy：極度重視隱私者，希望透過Tor路由來增加額外一層保護
    

## V神希望在錢包中看到什麼？

source：[https://vitalik.eth.limo/general/2024/12/03/wallets.html](https://vitalik.eth.limo/general/2024/12/03/wallets.html)

V神認為：錢包是使用者進入Ethereum世界的窗口，如果錢包本身不具備去中心化、抗審查、安全和隱私等特性，那麼使用者就無法真正享受到Ethereum帶來的這些好處。這篇多關注於安全性與隱私，而非只是UX。

**跨L2的使用者體驗**：現在L2生態分散

-   鏈特定地址：
    
    -   錢包應支援像「user.eth@optimism.eth」的格式
        
    -   自動路由：當使用者複製此類地址並發送時，錢包應自動判斷：
        
        -   目標鏈有資金：直接發送
            
        -   資金在其他鏈：自動透過跨鏈協議（如ERC-7683）發送
            
        -   需換幣：自動透過DEX轉換並發送（需使用者確認）
            
-   鏈特定支付請求：DApp 或 QR Code 可以發出「在 Z 鏈上需要 X 數量的 Y 代幣」的請求，錢包應能自動滿足
    
-   Gas 費抽象化：如果收到資產的鏈上沒有 ETH 當 Gas，錢包應自動使用其他鏈的資金支付 Gas（例如透過 RIP-7755），或自動兌換少量 ETH 以備未來使用。
    

**帳戶安全性** ：理想錢包要同時防範「開發者作惡」及「使用者自身錯誤」：

-   核心方案：社交恢復與多簽
    
    -   架構：1個PK + N個守護者
        
    -   權限：主密鑰處理低價值操作；高價值操作或更改密鑰需多數守護者簽名
        
-   守護者的選擇：
    
    -   ZK-Email：使用者設定Email為守護者，透過ZK-SNARKs證明自己擁有該Email的控制權來簽名，無需依賴中心化伺服器管理私鑰
        
    -   其他選項：親友、機構、多設備等等
        

**新手與應用程序內建錢包**

-   簡化入門（2/3多簽配置）：
    
    -   ZK-Email（Email守護者）
        
    -   本地設備金鑰（Passkey/手機）
        
    -   服務商備份金鑰，隨資產增加，再提示使用者增加更多守護者
        
-   層級化連結：
    
    -   主錢包應作為所有「應用程序內建錢包」的守護者
        
    -   使用者只需管理主錢包的權限，即控制所有子帳戶
        

**隱私保護**：隱私不應只是額外插件，而應是錢包的「預設功能」

-   直接整合隱私傳輸：錢包應內建隱私池 (Privacy Pools)。轉帳時自動從隱私池提取，接收資金時自動生成隱形地址 (Stealth Addresses)，切斷發送者與接收者之間的鏈上關聯。
    
-   每個應用獨立地址：錢包為每個 DApp 生成不同的地址，避免單一地址暴露使用者所有的鏈上活動。
    
-   資料錢包 (Data Wallets)：錢包不僅存儲私鑰，還應負責安全地存儲使用者的鏈下數據（如 Zupass 證明、個人資料），並透過加密分片存儲在守護者網絡中。
    

**安全的鏈上存取**：目前的錢包過度依賴RPC提供商，存在「提供假數據」和「洩露隱私」的風險

-   輕客戶端 (Light Clients)：錢包應使用像 Helios 這樣的輕客戶端，直接驗證 L1 和 L2 的狀態根，而不僅僅是信任 RPC。
    
-   隱私資訊檢索 (PIR - Private Information Retrieval)：為了解決隱私問題，使用者查詢餘額或數據時，應透過RIP技術，RIP技術允許使用者相伺服器查詢數據，但伺服器不知道使用者具體查詢了哪一筆數據。
    

**密鑰庫錢包**：為了解決在多條 L2 上管理帳戶的麻煩，密鑰配置（如更換守護者）應集中管理

-   L2 密鑰庫：配置資訊存在某一條 L2 上（低成本），其他鏈上的錢包透過 ZK-SNARKs 讀取該配置。這樣只需更改一次設定，所有鏈上的帳戶都會同步更新。
    

**DApp安全與未來展望**：

-   **內容版本控制**：透過 ENS + IPFS 存儲前端介面，防止 Web2 伺服器被駭導致的釣魚攻擊。
    
-   **AI 與腦機介面 (BCI)**：
    
    -   未來錢包將從「點擊介面」轉向「意圖導向」。
        
    -   AI 代理人將幫助使用者分析交易風險，並將使用者的自然語言指令轉化為具體的鏈上操作。
        

## 閱讀筆記及心得 - Web3實習計畫手冊 - 行業前輩訪談錄

會先看行業前輩訪談是因為我自身很迷茫，身在25、26年的Web3，身在一個AI時代，並且興趣多，還無法專注，不知道該如何去做，畢竟有了AI很多都容易被取代，而且Web3現在門檻也在提升，該如何養成無法取代，且被需要的能力？這是我想關注的。

-   Logic：工程師的價值在於「交付」而非單純「寫碼」
    
    -   黃金比例：30%寫代碼＋70%溝通協作
        
    -   護城河（AI做不到的事）：
        
        -   質量體系：建立間空、測試、回滾機制，確保系統穩定
            
        -   決策與救火：給出多套落地方案、預判風險、撰寫完整技術文檔
            
    -   行動建議：主動參與開源或社區建設（提交PR），讓自己「被看見」
        
-   Jason：透過「實踐」打通底層與應用
    
    -   求職入徑：內推＋線下社群（i人也要逼自己變e參加活動）
        
    -   成長飛輪：找實習->發現短板->回校補計算機基礎（CPU/IO/內存）->挑戰更好的實習
        
    -   核心觀念：
        
        -   底層開發者更需要產品思維
            
        -   AI無法替你理解業務場景，這才是不可替代的
            
-   Bruce：職場軟實力–如何定義「靠譜」
    
    -   靠譜定義：
        
        -   可預期（進度透明，不最後一刻才說做不完）
            
        -   可溝通（遇到卡點主動求救，不悶頭工作）
            
        -   可復盤（具備反思能力，不二過）
            
    -   避雷區：人間蒸發、明日復明日、不溝通只悶頭苦幹
        
    -   關鍵動作：動手寫代碼前，先採解任務並與Mentor對齊方案
        

心得：

跟我之前理解也有點像，這次再看到也更深刻了，主動是第一步，反思、理解「做什麼」、「為什麼做」則是持續成長的部分，有了底層知識，也要有業務邏輯的能力，價值是「交付」，那溝通就很重要，最好是很透明，還要會拆分任務。

這讓我想到，之前問IOTA Foundation的infra朋友：「你覺得先學Rust會是個學選擇嗎？」，他回：「我不確定學語言是否是個好選擇，但認為Knowhow更重要，不過不否定學習語言，畢竟看Rust蠻多職缺的」，所以語言不一定重要，尤其是在這AI的時代下，但也有個問題，如何在語言不夠厲害時，能夠有knowhow？

Bruce講的我也感同身受，我前面幾次黑客松，合作起來非常輕鬆順暢，就是因為溝通透明順暢，尤其是Zetachain通用AI黑客松時那做起來真的舒服，今天要做什麼，正在做什麼，都會直接講，跟隊友也都知道自己該幹啥，然後我也有列出代辦清單，讓雙方很清晰的瞭解到，有什麼還沒做？以及正在做什麼？

並且，有問題就馬上說，滿滿的安全感，也能知道目前項目有啥問題，後來幾乎也都沒開會，就能自動地完成項目，非常舒服。

但前幾週玩了一場Sui workshop的黑客松，就很頭痛，就是隊友開始做時都不會講正在做啥，也不會說做了啥、剩下啥，導致每次要做之前都要花很多時間去做確認，這一來一往超沒效率，甚至到後來影響到我自己的心態，也就沒放太多心力在上面。

接下來，我會謹記前輩的話，多往這些方向去實踐看看！

## 來玩Unphishable

### [No.0x0003](https://unphishable.io/challenges/permit-phishing) ：

這題考的是授權簽名的部分，簽名真的都要小心吶，我之前也是受害者哈哈

![Screenshot 2026-01-12 at 12.56.43 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-12-1768193833740-Screenshot_2026-01-12_at_12.56.43_PM.png)

其實從上面的Spending cap上面就有寫「無限」，就是轉出的金額是無限的，會清空錢包

![Screenshot 2026-01-12 at 12.58.15 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-12-1768193904850-Screenshot_2026-01-12_at_12.58.15_PM.png)

這邊則是一些細節，可以看到Spender就是我這發送者，會送Value，這金額很大，大概是無限大，然後nonce是防重放用的，Deadline則是指什麼時候之前使用這合約會有效

其實這邊大部分都是假資料，像是Nonce就是，所以會亂跳是正常的。

總之，這關是說要仔細注意交易，其實如果不知道咋看，在交易前也是可以丟給AI分析，安全最重要。

### [No.0x0004](https://unphishable.io/challenges/airdrop-scam) ：

通常X啥的都會莫名被標注，然後說有空投可以領，很多都詐騙，就是會授權送代幣過去，然後他可能也真的會送代幣，但是是假的。

這題做得不夠好啊哈，他只有使用者送代幣，沒有真的送使用者代幣（假的）

### [No.0x0036](https://unphishable.io/challenges/fake-zoom-meeting-phishing) :

這題🐮逼，使用超連結假冒網址，再用deepfake換臉，所以都應該要小心網址是否正確，有些也會是使用相似字型，或是幾乎一樣的去欺騙，更可怕的是有些Google還會推薦，所以最好都要提防私訊網址是否正確，發現會議室認識的人也要再次確認

但說真的，感覺這好難喔，我如果遇到，可能真的會被騙

## 在 [My First NFT](https://nft.myfirst.io/) mint 第一個 NFT

這網站做得真的好看，也很清晰易懂，也成功Mint出NFT啦

超、可、愛！

![Screenshot 2026-01-12 at 4.02.41 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Toby1009/images/2026-01-12-1768205568732-Screenshot_2026-01-12_at_4.02.41_PM.png)

## 小筆記 - Web3行業全局介紹

歷史回朔：

-   第一階段(2009~2014)：BTC
    
-   第二階段(2015-2020)：以太坊上線，ICO+第二代交易所崛起（幣安）
    
-   第三階段(2020-2024)：Web3概念爆發（NFT+DeFi+GameFi)、去中心化錢包等去中心化產品，解決擴容的L2。應用更多、正規軍大規模入場
    
-   第四階段(2024-至今)：宏觀合規、ETF上市、RWA、DePIN、AI+Web3。推動更多資本巨頭入場
    

開發者數量：

-   全球月活開發者：約2.5~3萬人
    
-   連續兩年基本持平
    

招聘情況：

-   2025年招聘反彈47%（新增6.6萬個崗位）
    

硬核技術：北美是中心

交易所、資產管理、運營：亞洲（香港、新加坡）及中東（阿聯酋、沙特）

平均錄取比：

-   1個崗位vs 450份簡歷
    

職能分化：

-   紅海：初級Solidity開發、初級社區運營
    
-   藍海：資深Rust工程師、合規官、Research Analyst（複合型）
    

核心渠道：

-   Web3垂直平台：SmartDeer,[Web3.career](http://Web3.career).Remote3,CryptoJobsList
    
-   社交網路：Ｘ、Web3媒體、Farcaster、Discord、Linkedin及Notion
    
-   隱形渠道：Github Contribution、DAO治理提案
    

技術：32%

PM：27%

運營：15%

…

從Web2帶能力遷移、從生態切入、建立鏈上聲譽

開發

-   Solidity：Web3最廣泛和通用的開發語言，易上手，建議新手要學習一下，理解智能合約編程思維邏輯
    
-   Rust應用越來越多，很多鏈和自創語言都基於Rust開
    
-   合約安全意識：系統設計，對DeFi/L2的理解
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
