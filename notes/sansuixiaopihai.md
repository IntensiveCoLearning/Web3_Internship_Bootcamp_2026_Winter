---
timezone: UTC+8
---

# sansuixiaopihai

**GitHub ID:** sansuixiaopihai

**Telegram:** @sansuixiaopihai_2024

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
\## 学习总结day13

今天主要的学习计划是看solidity的基础语法和复习前面的学习，并完善昨天的demo，今天主要记录其中的难点，和使用到的困难点；

payable 关键词用来接受以太的gas费用 只有在合约定义了payable关键字的函数才能接收msg.value（即能够接收Ether）

dapp开发框架Rainbow + wagmi

**Gas优化**

Storage（存储/区块链状态）：

比喻： 这是一个巨大的、带锁的保险柜，放在很远的地下室。

特点： 数据永久保存，永远不会丢。

代价： 非常非常贵！ 每次去读（SLOAD）或写（SSTORE），都要跑腿、开锁、记录。所以每次修改都需要 读-改-写 需要消耗大量的gas

代码对应： 全局变量，比如 balances。

Stack/Memory（栈/内存）：

比喻： 这是你手边的一张草稿纸。

特点： 数据只在当前计算时存在，函数运行完就扔了。

代价： 非常便宜！ 随手就能写。

代码对应： 函数里的局部变量，比如 uint256 current。

1、尽量避免在storage中存储变量，而是使用memory（减少存储操作）

2、使用位压缩：将多个变量压缩到一个 uint256 中以节省存储空间（合理调整变量顺序以使类型较小的变量相邻，可以实现最高效的压缩）

如：

uint128 a; // 占一个格子（虽然只用了一半，但剩下的空着）

uint256 b; // 占一个格子

uint128 c; // 占一个格子

不如这样优化

uint128 a;

uint128 c;

uint256 b;

3、使用 constant 和 immutable代替全局storage变量，相当于直接把数字写在了代码里（字节码）。读它们不需要去storage，超级便宜

4、函数可见性选择 - external 比 public 更节省 gas，适用于仅被外部调用的函数

5、 循环中的 ++i vs i++

i++ (后自增)：会多产生一个临时变量。

++i (前自增)：更直接。

6、使用 unchecked （不做无用的安全检查）Solidity 0.8 之后，每做一次加法（a + b），系统都会自动检查“有没有溢出”（比如数字太大超过了上限）。这个检查是要花 Gas 的。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->

## **学习总结day12**

今天主要的学习计划是看solidity的基础语法和复习前面的学习，并完善昨天的demo，今天主要记录其中的难点，和使用到的困难点；

昨天的demo有几个bug点

1.没有增加时间判断导致每次点击checkIn方法能获得多个积分，多次打卡，增加每一天打卡一次判断

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract PointSystem {
    // 增加权限
    address public owner;
    // 定义映射接收每个地址的积分
    mapping (address => uint) public points;
    // 增加每一个签到时候的时间
    mapping (address => uint256) public lastCheckInTime;
​
    // 构造函数
    constructor() {
        // 确认你是所有权
        owner = msg.sender;
    }
    // 定义一个权限
    modifier onlyOwner() {
        require(msg.sender == owner, "Not Owner"); 
        _;
    }
    // 每日签到功能，每日签到加10积分
    function checkIn() public {
        // 判断当前当前签到是否满足一天，如果满足一天就签到，没有就提示不满足时间
        require(block.timestamp - lastCheckInTime[msg.sender] >= 1 days, unicode"还没到时间，明天再来！");
        // 打卡之后把打卡的时间存储上，用于判断下次是否能打卡
        lastCheckInTime[msg.sender] = block.timestamp;
        points[msg.sender] += 10;
    }
​
    // 积分转账功能
    function transferAccount(address _to, uint256 sum) public {
        require(_to != msg.sender, unicode"不能转账给自己");
        // 判断是否有这么多积分
        require(sum > 0, unicode"转账金额必须大于0");
        require(points[msg.sender] >= sum, unicode"没有这么多积分");
        // 第二部扣除当前的积分
        points[msg.sender] -= sum;
        // 增加转账人的积分
        points[_to] += sum;
    }
    // 查询当前用户有多少积分
    function getUserPoints(address _add) public view returns(uint256) {
        return points[_add];
    }
​
    // 销毁积分
    function burn(uint256 _num) public {
        require(points[msg.sender] >= _num, unicode"积分不足");
        points[msg.sender] -= _num;
    }
    // 给某个地址打入积分（只有管理员才能打入）
    function sendPoint(address _add, uint256 po) public onlyOwner{
        require(po > 0, unicode"积分不能为0");
        points[_add] += po;
    }
}
```

**常见的solidity全局变量：**

`block`: 包含当前区块的元数据。

-   `block.timestamp`: 当前区块的时间戳（uint）当前的**绝对时间戳**。注意在solidity中**时间戳的单位永远是 _秒_**
    
-   `block.number`: 当前区块的编号（uint）。
    
-   `block.difficulty`: 当前区块的难度（uint）。
    
-   `block.gaslimit`: 当前区块的 Gas 上限（uint）。
    
-   `block.coinbase`: 当前区块矿工的地址（address payable）
    

`msg`: 包含当前交易的元数据。

-   `msg.sender`: 消息的发送者（address）。
    
-   `msg.value`: 发送的 Ether 数量（uint）。
    
-   `msg.data`: 包含函数选择器和参数的完整调用数（bytes）。
    
-   `msg.sig`: 调用数据的函数选择器（bytes4）。
    

`tx`: 包含当前交易的元数据。

-   `tx.origin`: 交易发起者（合约）的地址（address）。
    
-   `tx.gasprice`: 交易的 Gas 价格（uint）。
    

`address(this)` **/** `address(0)`:

-   `address(this)`: 当前合约的地址。
    
-   `address(0)`: 地址为零的地址。
    

mapping (address => uint) public points;

但在实际开发中，可以直接用 public 变量自带的查询功能，省几行代码

```
mapping (address => uint) public points;
// 这个函数都可以省略掉因为这个变量points可以直接使用
function getUserPoints(address _add) public view returns(uint256) {
    return points[_add];
}
```

**错误：**

```
//之前一直理解错误了require，一直以为是当前面的判断成立，才会走后面的错误提示，实际是反着来的
// 必须满足这个条件，否则就报错
require(myDeposit.amount >0, unicode"当前账户没有存钱");
```

**solidity中的时间单位：**

注意在solidity中**时间戳的单位永远是 _秒_**

你可以直接在代码里写：

-   `1 minutes` 自动等于 `60`
    
-   `1 hours` 自动等于 `3600`
    
-   `1 days` 自动等于 `86400`
    
-   `1 weeks` 自动等于 `604800`
    

**举个例子：**

如果你想让用户锁仓 **1天**，你的代码可以不用让人手动输入秒数，而是直接写

```
// 强制锁仓 1 天
bank[msg.sender] = Deposit({
    amount: _amount,
    unlockTime: block.timestamp + 1 days // Solidity 自动帮你把 1 days 换算成 86400
});
```

今日demo

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract PointSystem {
    struct Deposit {
        uint256 amount;      // 存了多少
        uint256 unlockTime;  // 什么时候能取（时间戳）
    }
    // 增加权限
    address public owner;
    // 定义映射接收每个地址的积分
    mapping (address => uint) public points;
    // 增加每一个签到时候的时间
    mapping (address => uint256) public lastCheckInTime;
    // 增加一个积分存款的功能
    mapping  (address => Deposit) public bank;
    // 构造函数
    constructor() {
        // 确认你是所有权
        owner = msg.sender;
    }
    // 定义一个权限
    modifier onlyOwner() {
        require(msg.sender == owner, "Not Owner"); 
        _;
    }
    // 每日签到功能，每日签到加10积分
    function checkIn() public {
        // 判断当前当前签到是否满足一天，如果满足一天就签到，没有就提示不满足时间
        require(block.timestamp - lastCheckInTime[msg.sender] >= 1 days, unicode"还没到时间，明天再来！");
        // 打卡之后把打卡的时间存储上，用于判断下次是否能打卡
        lastCheckInTime[msg.sender] = block.timestamp;
        points[msg.sender] += 10;
    }
​
    // 积分转账功能
    function transferAccount(address _to, uint256 sum) public {
        require(_to != msg.sender, unicode"不能转账给自己");
        // 判断是否有这么多积分
        require(sum > 0, unicode"转账金额必须大于0");
        require(points[msg.sender] >= sum, unicode"没有这么多积分");
        // 第二部扣除当前的积分
        points[msg.sender] -= sum;
        // 增加转账人的积分
        points[_to] += sum;
    }
    // 查询当前用户有多少积分
    function getUserPoints(address _add) public view returns(uint256) {
        return points[_add];
    }
​
    // 销毁积分
    function burn(uint256 _num) public {
        require(points[msg.sender] >= _num, unicode"积分不足");
        points[msg.sender] -= _num;
    }
    // 给某个地址打入积分（只有管理员才能打入）
    function sendPoint(address _add, uint256 po) public onlyOwner{
        require(po > 0, unicode"积分不能为0");
        points[_add] += po;
    }
    // 存积分和锁定时间
    function depositPoints(uint256 _amount, uint256 time) public {
        // 1. 检查他在 points 里有没有这么多钱？
        require(points[msg.sender] >= _amount, unicode"您账户现在好像没有那么多钱可用");
        // 2. 检查他是不是已经在 bank 里存过钱了？(为了简化难度，假设每人只能存一笔，如果有存款就报错)
        require(bank[msg.sender].amount == 0, unicode"您已经存过钱了，请先取出再存");
        // require(Deposit[msg.sender].unlockTime - time ==0, unicode"您已经存过钱了，请先取出再存");
        // 3. 扣除 points 里的余额
        points[msg.sender] -= _amount;
        // 4. 写入 bank
        bank[msg.sender] = Deposit({
            amount: _amount,
            unlockTime: block.timestamp + time
        });
    }
    // 取积分
    function withdrawal() public {
        Deposit memory myDeposit = bank[msg.sender];
        // 当前账号是否有存钱
        require(myDeposit.amount >0, unicode"当前账户没有存钱");
        // 当前账户的积分是否已经到期了
        require(block.timestamp >= myDeposit.unlockTime, unicode"当前账户没有到期了");
        // 计算利息
        // uint256 interest = myDeposit.amount*2;
        // 5. 把本金+利息 加回到 points 余额里
        points[msg.sender] += myDeposit.amount*2;
        // 删除 bank 里的存款记录
        delete bank[msg.sender];
    }
}
```
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->


\## 学习总结day11

今天主要的学习计划是看solidity的基础语法和复习前面的学习，并动手写demo，今天主要记录其中的难点

**msg全局变量对象有哪些常用的参数：**

\*`msg.sender`\*\* (地址类型 `address`)，调用当前函数的外部账户或者合约地址 **常用**

\*`msg.value`\*\* (大整数类型 `uint256`)，当前调用发送的以太币（Wei）数量`require(msg.value >= amount, "Insufficient funds");` 检查是否发送了足够金额 **常用**

\*`msg.data`\*\* (字节数组类型 `bytes`)，包含函数选择器和传递给函数的全部参数的原始字节数据，`bytes memory data = msg.data;` 获取完整调用数据

\*`msg.sig`\*\* (字节数组类型 `bytes4`）， 函数选择器`keccak256("functionName(arg1Type,arg2Type)")` 的前4个字节）`bytes4 sig = msg.sig;` 获取函数签名

\*`msg.gas`\*\* (大整数类型 `uint256`)，当前函数执行剩余的Gas数量（从 Solidity 0.5.0 版本起被 `gasleft()` 函数取代，但仍可访问）

**gas常见优化：**

减少存储操作：读取存储第一次需 2100 gas（后续 100 gas），而内存读取仅 3 gas。推荐多次访问同一存储数据时，将其缓存到内存以减少 SLOAD 次数，每次写入\*\*storage\*\*的成本高达 20,000 gas；优先使用 **memory**

\`\`\`

// ❌ 非优化写法

mapping(address => uint256) public balances;

function deposit() public payable {

balances\[msg.sender\] += msg.value;

}

// ✅ 优化写法（一次读，一次写）

function deposit() public payable {

uint256 current = balances\[msg.sender\];

balances\[msg.sender\] = current + msg.value;

}

\`\`\`

**使用位压缩（Bit Packing）**

\- 将多个变量压缩到一个 `uint256` 中以节省存储空间。

\`\`\`solidity

struct Packed {

uint128 a;

uint128 b;

}

\`\`\`

**循环优化**

\- 减少不必要的运算，如 `array.length` 缓存到变量中。

\`\`\`solidity

// ❌ 非优化

for (uint256 i = 0; i < arr.length; i++) {

...

}

// ✅ 优化

uint256 len = arr.length;

for (uint i = 0; i < len; ++i) {

...

}

\`\`\`

**函数可见性选择** `external` 比 `public` 更节省 gas，适用于仅被外部调用的函数。

**权限管理模版：**

如果没有 `Ownable`，你的合约就像是一个\*\*放在广场上的自动提款机\*\*，虽然有提款功能，但如果谁都能按那个按钮，钱早就被取光了。 有了 `Ownable`，这个按钮上就加了个盖子，只有拿着钥匙`owner`）的人才能按。

最简单的权限管理控制

\`\`\`solidity

contract MySafeContract {

address public owner; // 1. 存老板名字的变量

// 2. 构造函数：开业当天，确定老板是你

constructor() {

owner = msg.sender;

}

// 3. 定义一个“保安”（Modifier）

modifier onlyOwner() {

// 检查：调用者必须是老板，否则报错 "Not Owner"

require(msg.sender == owner, "Not Owner");

\_; // 这是一句咒语，意思是：“检查通过了，去执行函数原本的代码吧”

}

// 4. 给函数加上保安

// 注意看这里多加了一个词：onlyOwner

function withdraw() public onlyOwner {

payable(msg.sender).transfer(address(this).balance);

}

}

\`\`\`

**工业标准：OpenZeppelin 的 Ownable**

通常会引入第三方库OpenZeppelin

\`\`\`solidity

// 引入标准库

import "@openzeppelin/contracts/access/Ownable.sol";

// 继承 Ownable 的能力

contract MyNFT is Ownable {

// 因为继承了 Ownable，你自动拥有了 owner 变量和 onlyOwner 修饰符

function mint() public onlyOwner {

// 只有老板能铸造 NFT

}

}

\`\`\`

// 今日练习功能

\`\`\`solidity

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract PointSystem {

// 增加权限

address public owner;

// 定义映射接收每个地址的积分

mapping (address => uint) public points;

// 构造函数

constructor() {

// 确认你是所有权

owner = msg.sender;

}

// 定义一个权限

modifier onlyOwner() {

require(msg.sender == owner, "Not Owner");

\_;

}

// 每日签到功能，每日签到加10积分

function checkIn() public {

points\[msg.sender\] += 10;

}

// 积分转账功能

function transferAccount(address \_to, uint256 sum) public {

require(\_to != msg.sender, unicode"不能转账给自己");

// 判断是否有这么多积分

require(sum > 0, unicode"转账金额必须大于0");

require(points\[msg.sender\] >= sum, unicode"没有这么多积分");

// 第二部扣除当前的积分

points\[msg.sender\] -= sum;

// 增加转账人的积分

points\[\_to\] += sum;

}

// 查询当前用户有多少积分

function getUserPoints(address \_add) public view returns(uint256) {

return points\[\_add\];

}

// 销毁积分

function burn(uint256 \_num) public {

require(points\[msg.sender\] >= \_num, unicode"积分不足");

points\[msg.sender\] -= \_num;

}

// 给某个地址打入积分（只有管理员才能打入）

function sendPoint(address \_add, uint256 po) public onlyOwner{

require(po > 0, unicode"积分不能为0");

points\[\_add\] += po;

}

}

\`\`\`

明日练习，看看能不能实现代币生成、转账功能
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->



## **学习总结day10**

今天主要的学习计划是看solidity的基础语法和联系，今天的这些学习总结主要是记录一些比较难懂的学习点

**_web3开发工具流程：_**

![Web3 开发工具流程](https://web3intern.xyz/assets/web3_development-tools-flow_01-2XDurtQc.jpg)

前端检测并连web3提供者 -> 请求用户与授权访问钱包账户 -> 使用ABI和合约地址创建合约实例->通过合约实例调用智能合约函数->钱包对交易进行数字前面->将签名交易发送到区块链网络->获取交易结果并更新前端页面

**复合数据类型（Composite Types）：**

1、固定长度数组：写法如`uint[5]` (包含5个整数的数组)，

2、动态长度数组：写法如`uint[]` (不写数字),里面包含的方法有`push(x)`: 在末尾追加一个元素。`pop()`: 删掉末尾的一个元素。`length`: 看看现在清单有多长。其语法和js相似不做过多的记录

**结构体 (Structs)：** 结构体就是**自定义的一张表格**，把你需要的不同类型的数据打包在一起，有点像js中的对象一样，先定义，然后来使用

```
// 1. 定义一张“玩家表格”的样子
struct Player {
    string name;   // 名字
    uint level;    // 等级
    address wallet;// 钱包地址
}
​
// 2. 使用这张表格(实例化)
Player public myPlayer; // 创建一个叫 myPlayer 的变量
​
function createPlayer() public {
    // 填写表格
    myPlayer = Player("SuperMan", 99, msg.sender);
    
    // 或者只修改其中一项
    myPlayer.level = 100;
}
```

**映射 (Mappings) ：**核心逻辑`Key` (钥匙)---> `Value` (柜子里的东西)，注意映射的东西是不能遍历的

```
// 写法：mapping(钥匙类型 => 内容类型) 变量名;
mapping(address => uint) public balances;
​
function update() public {
    // 这里的逻辑是：
    // 拿着“我的地址”(key) 去找对应的 “余额”(value)
    // 把余额设为 100 这里的msg.sender是solidity的全局变量
    balances[msg.sender] = 100;
}
​
function check() public view returns (uint) {
    // 拿着地址去查余额
    return balances[msg.sender];
}
```

**引用类型的数据位置 (Data Location):**

当你使用数组、结构体或映射时，Solidity 总是会逼问你：**“这数据存哪儿？”**

**1.**`storage` **(仓库)**

-   **也就是**：区块链硬盘。
    
-   **特点**：**永久存储**。即使函数运行完了，数据还在那里。
    
-   **花费**：巨贵！就像你在市中心买地皮存东西。
    
-   **默认**：合约里的全局变量（状态变量）默认就是 storage。
    

**2\.** `memory` **(白板)**

-   **也就是**：内存。
    
-   **特点**：**临时存储**。函数开始运行时创建，函数结束时销毁。
    
-   **花费**：便宜。
    
-   **场景**：函数里的临时计算、临时变量。
    

**3\.** `calldata` **(只读便签)**

-   **也就是**：一种特殊的内存。
    
-   **特点**：**只读，不能改**。
    
-   **场景**：专门用于函数的**参数输入**（为了省钱）。
    

**构造函数（constructor）：**

可以理解为出厂设置，**核心作用只跑一次的初始化**它的生命周期很特别：**只执行一次**，当合约被部署的时到链的时候就会执行，**永不再见**，一旦合约完成部署之后，这个函数就消失了，**用于初始化**专门用来设置合约初始化

```
// 留言事件，便于检索器和区块链浏览器追踪
    event NewMessage(address indexed sender, string message);
constructor() {
    // 1. 定义一个临时字符串
    string memory initMsg = "Hello ETH Pandas";
    
    // 2. 写入数据
    // 注意：在这里，msg.sender 是“部署者”（也就是你）
    messages[msg.sender].push(initMsg);
    
    // 3. 告诉世界发生了一件事
    emit NewMessage(msg.sender, initMsg);
}
```

**Event（事件）：**

事件用于在链上记录重要状态变化，并可由外部监听器（如检索器或前端应用）捕捉，就想一个大喇叭一样

```
// 定义大喇叭 indexed值加了索引，方便前端网页进行过滤和搜索
event NewMessage(address indexed sender, string message);
​
// 使用大喇叭，
function leaveMessage(string memory _msg) public {
    // 1. 内部记账 (写进硬盘)将接收到的消息放到Storage (状态存储) 里
    messages[msg.sender].push(_msg); 
    
    // 2. 对外广播 (写进日志)
    emit NewMessage(msg.sender, _msg); 
}
```

**常用的变量msg.sender：**

这是 Solidity 里最重要的一个**全局变量**（Magic Variable）。你不用定义它，它永远都在那里 **谁在这个时刻调用了这个函数，谁就是** `msg.sender`

**你 (地址A)** 点击了按钮调用 `deposit()` -->此时代码里的 `msg.sender` 就是 **地址A**。

**你朋友 (地址B)** 点击了按钮调用 `deposit()` -->此时代码里的 `msg.sender` 就自动变成了 **地址B**。

今天完成了web3实习手册中的合约开发发送消息的Dapp功能，感觉到区块链比web2有趣的多，明天开始动手写一些简单的代码和功能
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->




## **学习总结day09**

今天主要的学习计划还是看智能合约开发的相关基础知识和扩展，

**_基本结构：_**

1.  `//` 是 Solidity 中的单行注释符号，例如：`// SPDX-License-Identifier: MIT` 用于指定源代码的许可证类型。
    
2.  `pragma` 关键字用于声明 Solidity 源代码所需的编译器版本，确保合约在兼容的编译器环境中正确编译。
    
3.  `contract` 关键字用于定义一个智能合约，其语法格式为：`contract 合约名 { ... }`。
    
4.  一个智能合约的基本结构通常由以下三部分组成：状态变量、构造函数和普通函数。
    

**_状态变量（State Variables）：_**

状态变量是指在合约中定义的、**其值永久存储在区块链上的变量**。它们用于记录合约的持久化数据，构成了合约的整体状态，主要实现和使用还是依靠修饰符public（任何地方都可以调用）、external（只能从合约外部调用）、internal（当前合约和子合约可调用）、private（只有当前合约可调用）来定义和使用如：

`uint256 public totalSupply //public可以通过前端代码访问`

**_函数（Functions）：_**

函数是 Solidity 智能合约中执行具体逻辑操作的核心组成部分。通过函数，可以实现对状态变量的读取、修改，或执行特定业务逻辑

```
function <函数名>(<参数列表>)
    <可见性> ：如 public、private、internal、external；
    <状态可变性> 如 view、pure、payable；
    <修饰符列表>
    <虚拟/重写关键字> virtual/override：用于支持继承与函数重写；
    returns (<返回值列表>)
{
    // 函数体
}
```

支持多参数与多返回值，以及命名返回值:

```
// 多个返回值
function getPersonInfo() public pure returns(string memory name, uint256 age) {
    name = "Alice";
    age = 25;
}
​
// 命名返回值
function calculate(uint256 a, uint256 b) public pure returns(uint256 sum, uint256 product) {
    sum = a + b;
    product = a * b;
    // 自动返回命名变量
}
```

**继承与函数重写（Inheritance and Override）:**

Solidity 支持单继承与多继承，子合约可重写父合约中的函数：

```
// 基础合约
contract Animal {
    string public name;
​
    constructor(string memory _name) {
        name = _name;
    }
​
    function speak() public virtual returns(string memory) {
        return "Some sound";
    }
}
​
// 继承合约
contract Dog is Animal {
    constructor(string memory _name) Animal(_name) {}
​
    // 重写父类函数
    function speak() public pure override returns(string memory) {
        return "Woof!";
    }
}
```

**事件机制（Events）:**

事件用于在链上记录重要状态变化，并可由外部监听器（如检索器或前端应用）捕捉：

```
contract EventExample {
    // 定义事件
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);
​
    mapping(address => uint256) public balances;
​
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
​
        balances[msg.sender] -= amount;
        balances[to] += amount;
​
        // 触发事件
        // 可以在区块链浏览器查找到当前事件记录
        emit Transfer(msg.sender, to, amount);
    }
}
```

**_以太坊技术基础：_**

### **1\. 帐户模型**

| 对比维度 | 外部拥有账户 EOA | 合约账户 Contract Account |
| --- | --- | --- |
| 地址来源 | keccak256(pubKey)[12:] (公钥 → 地址) | 创建时由 CREATE/CREATE2 计算 |
| 控制方式 | 私钥签名（用户、钱包） | 合约代码（EVM 字节码） |
| 状态字段 | nonce、balance | nonce、balance、codeHash、storageRoot |
| 能否发起交易 | ✅  必须用私钥签名 | ❌  只能由 EOA 触发或合约内部调用 |
| Gas 费用支付 | 由账户本身 ETH 余额承担 | 由调用者支付 |
| 典型场景 | 钱包地址、热冷账户 | ERC-20/721 Token、DeFi 协议、DAO |

### **2\. Gas 机制**

| 术语 | 含义 | 备注 |
| --- | --- | --- |
| Gas | 执行 1 条 EVM 指令的抽象工作量单位 | 汇编级别价格表见 evm.codes |
| Gas Limit (Tx) | 发送者愿为本笔交易消耗的 Gas 上限 | 防止死循环耗尽余额 |
| Gas Used | 实际执行指令花费的 Gas 总和 | 多退少不补 |
| Base Fee | 随区块动态调整的基础费用（EIP-1559） | 全网销毁，抑制拍卖狂飙 |
| Priority Fee / Tip | 发送者给出以激励打包者的附加费 | 给矿工 / 验证者 |
| Max Fee Per Gas | maxFee = baseFee + priorityFee 上限 | 钱包通常自动估算 |

### **3\. 交易生命周期**

-   签名构造
    
    -   钱包收集字段：`nonce, to, value, data, gasLimit, maxFeePerGas, priorityFeePerGas, chainId`
        
    -   使用私钥生成 `v, r, s` 签名 → **序列化 RLP**
        
-   广播到 P2P 网络
    
    -   交易进入本地 & 邻居节点的 **mempool**
        
    -   节点根据 `maxFeePerGas`、`gasLimit`、`nonce` 做基本筛查
        
-   打包 / 提议区块
    
    -   验证者（PoS）或矿工（PoW 时代）挑选利润最高、合法顺序的交易
        
    -   执行 EVM → 产生 **交易收据**（`status, gasUsed, logsBloom, logs[]`）
        
-   区块传播与共识
    
    -   区块头包含新 **stateRoot**、**receiptsRoot**
        
    -   超 2⁄3 质押者签名后在共识层定案（PoS Finality ≈ 2 Epoch ≈ 64 slot ≈ ~12 min）
        
-   确认数 & Finality
    
    -   客户端/前端常以 `n ≥ 12` 作"概率足够低"确认
        
    -   完全终结在 PoS 下由 **Finality Gadget**（Casper FFG）给出
        

开始有点看不懂了，周六日还是得要开始好好学习了\[晕\]
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->





## **学习总结day08**

### **理解 ERC-7962：**

ERC-7962 是一个旨在从底层改变代币所有权逻辑的标准，其核心目标是**隐私保护**和**交互灵活性**，在传统的 ERC-20 或 ERC-721 中，代币的所有者是一个公开的以太坊地址（例如 0x123...）。而在 ERC-7962 中，代币的所有者是一个 **keyHash**（公钥的哈希值）

**两大标准：**

**ERC-KeyHash721 (NFT)：**

-   运作方式类似于现有 NFT，但所有者字段存的是 Hash。
    
-   **隐私性：** 用户可以为每一个 NFT 生成一个新的密钥对。这样，即使一个人拥有 100 个 NFT，链上也看不出它们属于同一个人（因为每个 NFT 对应不同的 Hash，且互无关联）。
    

**ERC-KeyHash20 (代币)：**

-   **重大改变：UTXO 模型**。它不使用传统的“余额减法”，而是采用了类似比特币的 UTXO（未花费交易输出）模式。
    
-   **强制轮换：** 当你转账时，必须将余额全部“花费”，一部分转给接收方，剩下的“找零”必须转给一个新的、未使用的 keyHash。
    
-   **原因：** 一旦你在交易中暴露了公钥，该公钥的隐私性就丧失了。因此协议强制你在这个 Key 暴露后立即弃用它，将资产转移到新的安全哈希上。
    

**核心优势：**

1.  **原生隐私保护（Native Privacy）：**
    
    -   类似于“隐身地址”（Stealth Addresses）。在代币被花费之前，链上观察者无法将资产与具体的钱包地址关联起来。
        
    -   非常适合需要隐藏财富或交易路径的场景（如匿名收藏品、企业隐私支付）。\[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fethereum-magicians.org%2Ft%2Ferc-7962-key-hash-based-tokens%2F24422)\]
        
2.  **Gas 代付与账户抽象：**
    
    -   由于验证是基于签名的，持有代币的人不需要有 ETH 来支付 Gas。
        
    -   **任何人**都可以帮忙提交交易，只要签名是正确的。这意味着项目方可以轻松补贴用户的 Gas 费，或者用户可以用代币本身支付手续费。
        
3.  **安全性设计：**
    
    -   **一次性密钥：** 协议设计上假定密钥是一次性的。一旦交易发生，公钥在链上数据（Calldata）中公开，该密钥就被视为不再私密，必须转移资产。
        
    -   **无 Approve/Allowance：** 因为密钥是一次性的，传统的“授权给第三方扣款”的逻辑不再适用，被直接移除。
        

今天看一些Solidity 基础语法和remix使用，Solidity 的语法和之前的Javascript的语法有点相像

**_Solidity类型和值：_**

bool ：布尔值 true和false uint ：无符号整型，有uint256、uint8、uint16（往上加8就行） int ：整型，-2 **256 to 2** 255 - 1 .min : 最小值 .max : 最大值（这些内置函数跟python一样） address : solidity独特的变量类型，内容就是个20字节数字，默认就是0x0，像个表情符号

payable address：比普通地址多了 transfer 和 send 两个成员方法，用于接收转账

bytes32 ：比地址类型长，是32位数字

contract : 合约，后面接函数名，把它理解成一个python的类 function ：函数 external ： 访问权限关键词，作用跟public一样，控制谁可以调用这个函数，但它只允许外部账户（比如我自己的钱包地址或者其他合约），当前合约内部的其他函数不能够调用 pure ：纯函数类型，不能够读、也不能够写状态变量，只能局部变量，概念还不是很懂，就说是不能对链上进行任何的读写操作

**_函数修饰符：_**

| public | 内部 + 外部 | 任何地方都可以调用 | 对外提供的公共接口 |
| --- | --- | --- | --- |
| external | 仅外部 | 只能从合约外部调用 | 外部用户接口，gas 效率更高 |
| internal | 内部 + 继承 | 当前合约和子合约可调用 | 内部逻辑函数，需要被继承 |
| private | 仅内部 | 只有当前合约可调用 | 私有实现细节 |

**_状态修饰符：_**

| 修饰符 | 状态读取 | 状态修改 | Gas 消耗 | 描述 |
| --- | --- | --- | --- | --- |
| pure | ❌ | ❌ | 低 | 不读取也不修改状态的函数 |
| view | ✅ | ❌ | 低 | 只读取状态，不修改状态 |
| payable | ✅ | ✅ | 正常 | 可以接收以太币的函数 |
| 无修饰符 | ✅ | ✅ | 正常 | 可以读取和修改状态 |
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






## 学习总结day07

今天看一些其他的扩展阅读，这些笔记是扩展阅读的记录，今天总结主要是为了下周的一些预习和准备

**_什么是Dapp？_**

Dapp全称去**中心化应用**，是与**传统集中式应用不同的全新应用模式**，通常运行在区块链或分布式网络上。与传统应用相比，Dapp 的核心特点在于去中心化，意味着应用的逻辑和数据不由单一实体控制，而是由多个参与者共同维护。因此，开发 Dapp 需要理解和掌握去中心化技术栈、智能合约编程以及前端与区块链的交互方式。

**_Dapp主要构成_**_：_

**前端（User Interface）**：

​ DApp 前端不会直接连接区块链网络，而是通过 钱包注入的 Provider 或第三方 RPC 节点 与区块链交互，和web2区别不同

-   通过 RPC 节点对 智能合约发起只读调用（如 eth\_call），获取合约状态、事件日志等链上数据
    
    对需要修改状态的操作，由前端构造对 智能合约的交易调用，交由钱包完成签名后，再通过 RPC 节点广播到区块链网络并最终上链执行
    
-   前端还需要集成区块链钱包（如 MetaMask）来进行身份验证和签署交易，确保用户的隐私和安全
    

**_智能合约（Smart Contracts）_**_：_

-   能合约是 Dapp 的核心，它定义了应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。
    
-   在以太坊平台上，智能合约通常使用 **Solidity** 编程语言编写，并通过 **Ethereum Virtual Machine (EVM)** 执行
    

**_数据检索器（Indexer）：_**

-   Dapp 在前端进行数据展示时需要检索器内的数据。一个简单的示例是某 NFT 项目需要展示用户持有的所有 NFT，但是 NFT 合约并不会提供通过输入地址参数返回该地址下的所有 NFT 的函数，此时我们可以运行数据检索器将 `Transfer` 事件读取后写入传统数据库内，前端可以在传统数据库内检索用户持有的 NFT 数据
    

**区块链和去中心化存储（Blockchain & Decentralized Storage）**：

-   通过使用去中心化存储，Dapp 确保所有数据在多个节点上备份，保证数据的持久性和去中心化特性
    

**开发流程**：需求分析 -> 合约编写与测试 ->检索器开发 -> 前端开发 ->部署与上线

**_开发环境搭建_**

-   **必备工具**：Node.js、Git、包管理器（npm/yarn）。
    
-   **主流框架**：
    
    -   **Hardhat**：基于 JavaScript/TypeScript，生态成熟，推荐新手。
        
    -   **Foundry**：基于 Rust，速度极快，集成了测试、部署等功能，适合进阶。
        
-   **辅助工具**：Remix IDE（在线编辑器，适合快速测试）、MetaMask（钱包）、OpenZeppelin（安全合约库）
    

**_智能合约编程 (Solidity)_**

-   **基础语法**：涵盖数据类型（uint, address, mapping等）、函数可见性（public, external等）、修饰符（modifier）和事件（event）。
    
-   **安全实践**：
    
    -   **重入攻击防护**：使用“检查-生效-交互”（CEI）模式或重入锁（ReentrancyGuard）。
        
    -   **访问控制**：使用 onlyOwner 或角色权限控制（AccessControl）保护关键函数。
        
    -   **整数溢出**：Solidity 0.8.0+ 版本已内置溢出检查。
        

**_RPC是什么（Remote Procedure Call，远程过程调用）_**_：_ RPC 是一种通信协议，允许应用程序通过网络调用远程服务器上的函数或方法。在区块链开发中，RPC 节点是运行区块链客户端软件的服务器，它们维护完整的区块链数据副本，并提供 API 接口供开发者查询链上数据、发送交易等操作

-   读取链上数据：查询账户余额、交易历史、读取智能合约的状态变量、获取区块信息、Gas 价格等
    
-   发送交易：向智能合约写入数据、调用智能合约函数、发送以太币等
    
-   事件监听：监听智能合约事件（Events）、实时获取链上状态变化、支持 WebSocket 长连接推送
    
-   网络管理：切换不同的区块链网络（主网、测试网）、获取网络信息和链 ID、管理节点连接状态 以太坊使用 JSON-RPC 2.0 协议作为标准的 RPC 通信格式。所有请求和响应都是 JSON 格式，通过 HTTP 或 WebSocket 传输。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->







## **学习总结day06**

今天看一些其他的扩展阅读，这些笔记是扩展阅读的记录

**_什么是区块链不可能三角：_**

区块链不可能三角指的是在设计区块链系统时，去中心化、安全性和可扩展性这三个主要目标之间的冲突

-   **去中心化：**这意味着确保区块链系统中的所有节点拥有平等的权力，不存在任何集中式机构控制网络。去中心化是区块链的基本特征，是系统安全和抵御攻击的基础。
    
-   **安全性：**安全性是指确保区块链系统内交易的真实性、完整性、不可篡改性和抵御攻击的能力。它是区块链系统可靠性和可信度的关键保障。
    
-   **可扩展性：**可扩展性或性能是指区块链系统支持大量交易、节点和用户的能力。它是满足实际应用需求的必要条件。
    

这三个目标往往需要权衡取舍，如sol链在性能上tps大大的超过以太坊，但节点和代币过于中心化

**_解决方法第二层技术：_**

引入第二层网络。来分担第一层网络（第一层）的负载，从而实现可扩展性。由于水平扩展面临诸多挑战，构建用于垂直扩展的第二层网络便成为一种可行的解决方案。

状态通道利用多重签名技术，允许双方将一定金额的资金锁定在**智能合约中**，从而创建一个内部通道。在这个通道内，他们可以快速、低成本地进行大量小额交易。经过特定时间后，他们可以通过单个交易证明提取资金。状态通道是比特币闪电网络和以太坊雷电网络的技术基础。

**_解决方法侧链（side chain）技术：_**

为了克服状态通道在**处理复杂交易方面**的局限性，侧链解决方案应运而生。

**侧链可以被视为相对独立的区块链**，通常采用类似于主链（如以太坊）的架构，从而简化主链项目向侧链的迁移。

通过在主链的智能合约中锁定特定数量的资产，可以在侧链上铸造等量的资产，从而实现“原子交换”。通过将资产存入侧链，可以在侧链上执行各种交易，并在必要时将其转移回主链。

**侧链的安全性取决于其自身共识节点的完整性**，常见的侧链Polygon 、Ronin

**_乐观汇总（Optimistic Rollup，也称为“乐观捆绑”）_**

基于大多数参与者值得信赖的假设运行。它使用一部分验证节点来收集、排序和验证交易。此外，它还为挑战者分配角色，挑战者负责验证验证者提交数据的准确性。

OP-Rollup 会定期向以太坊主网上传两种类型的数据：

-   状态根：状态根可快速验证 Layer 2 账本的内容完整性。
    
-   压缩交易数据：它封装了各种交易详情，包括用户签名。
    

**_什么是零知识证明（ZK-Rollup）？_**

零知识证明是一种在不泄露任何额外信息的情况下，向另一方证明某个陈述为真的方法。例如，假设有一条环形走廊，走廊中间有一扇需要密码才能打开的门。为了向B证明A知道这扇门的密码，A只需从入口进入走廊，再从另一侧出来，就能向B证明A知道密码，而无需透露实际的密码。

**零知识证明特征：**

1.  完备性：如果一个命题为真，任何证明者都可以说服验证者相信其真值，即“真命题是可验证的”。
    
2.  可靠性：如果一个命题是假的，任何不诚实的证明者都无法欺骗验证者，即“错误的陈述将被检测出来”。
    
3.  零知识：证明一个命题为真并不会揭示除其真值之外的任何额外信息。
    
4.  简洁性：证明篇幅短小，可以迅速验证。
    
5.  零知识：它们隐藏了计算的输入信息。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->








\## 学习总结day05

**AI与Web3的融合：**

\*\*\*传统的LLM（大语言模型）存在致命的限制：\*\*\*

\- **无状态**：每次对话都是从零开始，不记得历史信息，上下文窗口有限。

\- **无工具**：只能生成文本，不能执行代码、调用API或访问外部系统。

\- **无身份**：不能代表任何个人或组织行动，无法签署协议或管理资产。

\*\*\*一个完整的AI智能体（Agentic AI）由核心构成组件\*\*\*

\- **大脑 (LLM)**：作为推理引擎，负责理解意图、制定计划和生成行动指令。

\- **记忆 (RAG)**：通过向量数据库实现私有记忆，让AI能够记住历史信息，不再“聊完就忘”。

\- **手脚 (工具)**：通过Function Calling或API接口执行具体操作，如发邮件、查数据库等，将思考转化为行动。

\*\*\*区块链技术如何解决当前AI智能体面临的身份欺诈、行为审计和隐私安全这三大信任问题？\*\*\*

区块链通过其核心特性解决了AI的信任问题。它的去中心化、不可篡改和可编程性，为AI智能体提供了一个在无信任环境中验证身份和记录行为的解决方案，从而有效应对身份欺诈、行为不可审计和部署不可管控的挑战

\*\*\*传统支付系统为什么不适用于AI：\*\*\*

\- **身份认证障碍**：注册流程中的验证码、KYC（身份验证）和人脸识别等机制，其设计初衷就是为了防止机器人。

\- **支付颗粒度不匹配**：传统支付（如信用卡）有最低交易成本和手续费，无法高效处理AI交互中常见的大量、低于1美元的微支付。

\- **结算速度慢**：T+1到T+3的结算周期无法满足AI毫秒级的交互需求。

\- **订阅模式错配**：传统的月度/年度订阅模式与AI智能体高动态、时而峰值时而空闲的工作模式不匹配。

\*\*\*HTTP 402协议在AI与Web3融合下的基本工作流程是怎样的：\*\*\*

HTTP 402协议旨在将支付能力嵌入HTTP协议本身，为AI智能体之间提供原生的支付方式。其工作流程是：客户端发起请求，服务器返回402状态码，并在响应头中包含支付地址、金额和代币类型；AI钱包自动签署交易并支付，然后将支付证明连同请求再次发送给服务器以获取服务。

\*\*\*ERC-8004标准被称作“AI的链上护照”，它为什么选择使用NFT（ERC-721）作为AI身份的基础：\*\*\*

ERC-8004选择使用NFT作为AI身份的基础，主要利用了NFT的几个关键特性：

◦ **唯一性**：每个NFT的ID全局唯一，确保每个AI智能体拥有独一无二的身份。

◦ **可验证性**：任何人都可以查询链上数据，验证该身份的存在及其所有者。

◦ **可转让性**：AI智能体的所有权可以像资产一样被转移。

◦ **可编程性**：可以在智能合约中实现更复杂的权限管理和逻辑。\*\*ERC-8004的声誉系统通过以下机制防止刷分：\*\*

◦ **付费评价**：只有与该AI智能体在链上有过真实交易（即支付过费用）的地址才能提交评价。

◦ **Gas成本**：每次评价都需要支付Gas费，增加了大规模刷分的成本。

◦ **权重挂钩**：评价的权重可能与历史交易金额挂钩，防止小额交易刷出高权重好评。

◦ **不可篡改**：评分一旦上链就永久存在，无法删除差评。

**当数以亿计的AI智能体开始以毫秒为单位进行海量交易时**，传统的金融系统将不堪重负。只有区块链这种专为机器间高频、无需信任的交互而设计的网络，才能承载这个即将到来的庞大经济体。

\------

\#### **EVM与Gas机制：**

\*\*\*EVM虚拟机：\*\*\*

EVM的本质：全球共享的“状态机与中央处理器”，来源将EVM定义为运行在每个以太坊节点上的虚拟计算机，它是智能合约得以运行的基石

\- **统一的执行环境**：EVM为全球节点提供了标准化的规则，确保无论在何时何地，同样的输入和合约代码都会产生\*\*绝对一致的输出（确定性）\*\*，这是全网达成共识的前提。

\- **沙盒隔离与安全性**：EVM是一个受限的沙盒环境，合约代码无法访问节点的本地文件系统或网络，这种隔离性保障了主机的安全性。

\- **核心组件**：EVM包含用于计算的\*\*栈（Stack）\*\*、用于临时存储的\*\*内存（Memory）\*\*存储（Storage）\*\*。其中，\*\*写入存储是最昂贵的操作。

\*\*\*逐条执行（OpCode）的逻辑必要性\*\*\*：

\- 智能合约在EVM中是以\*\*操作码（OpCode）\*\*的形式逐条执行的，这不仅是技术实现，更是安全策略。

\- **共识的基础**：通过将复杂的业务逻辑拆解为极小的原子指令（如ADD、SSTORE），确保了不同编程语言实现的客户端（如Geth、Nethermind）在执行结果上能高度对齐。

\- **精确计费**：每一条操作码都有预定义的Gas成本。例如，简单的加法很便宜，而改变链上状态的存储指令则非常昂贵

\##### _Gas机制：安全防线与资源度量衡_

Gas不仅是手续费，更是以太坊的\*\*安全防线和资源配额系统\*\*

\- **防范拒绝服务（DoS）攻击**：通过为计算和存储定价，使恶意的无限循环或资源滥用攻击在经济上变得极其昂贵。

\- **Gas Limit的约束**：每笔交易必须设置Gas Limit，一旦执行中Gas耗尽，交易将\*\*触发异常并回滚（Revert）\*\*。此时，\*\*已消耗的费用不予退还\*\*，以惩罚对网络资源的无效占用。

\- **经济激励**：Gas为验证者提供了处理交易和维护网络安全的报酬。

\*\*\*费率市场的结构性变革：EIP-1559\*\*\*

**伦敦升级**（London Upgrade）对Gas市场的重塑，将其视为以太坊经济模型的重要转折点

\- **基础费（Base Fee）与销毁机制**：由协议根据区块拥堵程度自动计算并\*\*直接销毁（Burn）\*\*，这赋予了ETH潜在的\*\*通缩特性\*\*。

\- **优先费（Priority Fee/Tip）**：用户自愿支付给验证者的小费，用于激励优先打包。

\- **可预测性**：新机制使Gas价格更易预估，显著改善了用户发送交易时的费率博弈体验

针对Solidity开发者，来源提出了多项降低Gas成本的设计原则，核心是\*\*读多写少\*\*，\*\*减少存储写入（SSTORE）、利用新型指令、变量优化\*\*
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->









## **学习总结day04**

**_web3安全及合规_**

**_Web3 技术安全趋势与防范：_**

**精准猎杀 (Targeted Killing)：**

-   目标：交易所、TVL协议、大户、项目方、普通投资者
    
-   手段特征：深度社交工程、精准钓鱼、供应链攻击， 针对性强，由国家级黑客组织（如Lazarus）等专业团队执行，追求单次高额收益
    

**广撒网 (Mass Spraying)：**

-   目标：Web3小白、普通投资者
    
-   手段特征：钓鱼工具包、Rug Pull、资金盘。 黑色产业链化、自动化攻击，成本低、范围广，利用人性弱点进行欺诈
    

**新兴技术引入的风险：**

-   **AI时代的攻防风险：**
    
-   **Deepfake：** AI深度伪造技术被用于视频通话等场景进行身份欺诈（如UXLINK事件）。
    
-   **AI辅助攻击：** AI被用于辅助发现代码漏洞、自动化生成钓鱼邮件等。
    
-   **软件供应链攻击：** 攻击者可能通过污染AI模型或训练数据，植入恶意后门。
    
-   • **新技术引入的漏洞：**
    
-   **EIP-7702：** 新的以太坊改进提案可能因其赋予EOA账户合约能力而引入新的安全漏洞，如恶意的自动转账逻辑。
    
-   **地址投毒/粉尘攻击：** 通过向用户钱包发送零额代币，制造一个与用户常用交易地址高度相似的“投毒地址”，诱导用户在下次转账时复制错误地址。
    

**安全建议与原则：**

1.  **不点 (Don't Click):** 不轻易点击来源不明的链接。
    

2.  **不签 (Don't Sign):** 拒绝签署无法完全理解内容的链上交易或授权。
    

3.  **核对 (Verify):** 转账前，务必仔细、多渠道核对收款地址和合约地址的真实性。
    

4.  **不转 (Don't Transfer):** 确认转账目的与内容完全相符后再执行操作。
    

**法律合规框架与刑事风险：**

1.  **法律滞后性与中心化监管的冲突：**Web3作为一个新兴且激进的行业，其**业务生态与相对滞后的法律体系**之间存在天然的紧张关系。在中国大陆，监管机构并非遵循“**法无规定不处罚**”的原则，而是倾向于利用现有的、更中心化的法律规定来界定和限制新兴商业行为的边界
    

2.  **三大核心负面清单：\***\*ICO与非法公开融资、虚拟货币交易所运营、虚拟货币挖矿
    

3.  **“中国特色合规”的深层含义：**合规包含两个层面，**形式合规 (文书合规)、深度合规 (关系合规)**
    

**个人从业风险：**

1.  出入金：从“冻卡”到“路径攻击”
    

-   个人出入金是Web3从业者面临的最普遍风险，且风险形态在不断演化：
    
-   **传统风险：** 通过OTC等渠道出金时，极易收到涉及电信诈骗、网络赌博等上游犯罪的**赃款**，导致个人银行账户被司法冻结。目前，多数地方公安机关处理方式趋于文明，会通过电话联系，要求提供证明材料以协商解冻。
    
-   **新型风险 - “路径攻击”：** 随着行业合规意识提升，洗钱成本增加，出现了一种新型攻击手段。攻击者主动向目标人物（如体制内竞争对手）的银行账户打入一笔赃款，利用公安机关的封控系统，使其账户被多地公安冻结乃至立案，从而达到攻击目的。
    
-   **合规出金路径：** 前往香港持牌交易所进行合规出金是目前相对安全的选择，但需注意，此举可能会触发大陆税务机关的关注，并被要求主动申报个人所得税。
    

2.  U商与U卡生态的陷阱
    

-   **U商 (USDT承兑商):** 邓律师明确指出，在目前的大陆环境下，**U商业务已“做不了了”**。由于无法有效进行KYC/KYT和反洗钱，U商极易成为犯罪集团的洗钱通道，面临极高的刑事风险。
    
-   **U卡 (加密货币卡):** 对于希望过上“数字游民”生活的用户，U卡提供了一定的便利。但其风险在于发卡方本身是否合规。不合规的U卡发行方可能存在以下问题：
    
-   **身份伪造：** 将用户注册为某公司的“员工”，以公司账户为用户开卡，一旦被查实，账户将被冻结。
    
-   **资金池风险：** 发卡方使用多签钱包归集所有用户的资金，用户的消费实际上是从该资金池中划拨。一旦合伙人内讧、跑路，或其在交易所的账户因其他违规行为被冻结，所有用户的资金都将面临无法使用甚至全部丢失的风险。
    

• **入职前的背景调查要点：**

**牌照真实性：** 深入核实项目方宣称的牌照。例如，美国的MSB牌照仅为注册性质，合规深度有限。

**大陆业务剥离程度：** 亲自测试是否无需VPN即可访问其网站/App，是否能用大陆手机号/邮箱注册。若可以，则其“不向大陆展业”的声明很可能只是表面说辞。

**岗位风险评估：** 从事**合约、期权**等衍生品相关板块的岗位，被卷入刑事案件的风险显著更高。

• **劳动合同与薪资发放的合规博弈：**

**合同主体：** 与海外主体签订合同，发生劳动争议时在国内维权极其困难。与境内主体签约，则个人与该境内实体的法律风险直接绑定。

**薪资形式：** 接受U等虚拟货币作为薪资存在风险。已有判例显示，由于虚拟货币不具法偿性，员工在离职后提起劳动仲裁，法院不支持虚拟货币支付的合法性，判决公司需另行支付法币工资。

* * *

### **以太坊网络结构与节点类型**

**_客户端组成：_**

-   **执行客户端 (Execution Client, EL)**：被形象地比喻为**“干活的书记员”**,。它主要负责链上的业务逻辑，包括监听网络交易、在**以太坊虚拟机 (EVM)** 中执行智能合约、维护账户余额和合约存储等状态数据库，并向开发者提供 **JSON-RPC 接口**,。常见的实现包括 **Geth、Nethermind、Besu、Erigon 和 Reth**（多语言实现协议，可以避免因单一客户端出现bug而导致全网瘫痪的单点故障风险，从而强化以太坊的去中心化保障）。
    
-   **共识客户端 (Consensus Client, CL)**：被比喻为**“做出裁决的法官”**,。它负责运行**权益证明 (PoS)** 共识逻辑，管理验证者集合，并根据 **Beacon Chain（信标链）** 的规则决定哪个区块被接受为正式账本。代表软件有 **Lighthouse、Prysm、Teku、Nimbus 和 Lodestar**。
    
-   **Engine API（两者通讯桥梁）**：这两个独立的客户端进程通过一个标准化的内部接口进行通信，共识客户端通过它向执行客户端发送指令（如请求打包区块或验证执行负载），确保账本执行与共识达成高度一致
    
-   **验证者客户端 (Validator Client)（可选）：**对于希望参与出块并赚取质押收益的用户，来源提到需在共识客户端的基础上增加一个**验证者客户端**，相当于是一个陪审团代表，专门负责管理验证者密钥、提议新区块以及在每个时隙（slot）进行投票
    

**_节点类型：_**

1.  全节点 (Full Node)：去中心化的基石与“主权”入口来源将全节点定义为网络的“行政中枢”和安全保障。
    

-   **核心职能**：全节点保存所有区块的区块头和区块体，验证所有新交易和区块的合法性，并独立判断“链的正统性”。它会保留最近约128个区块的完整状态，而对更老的状态进行“修剪（Pruning）”以节省空间。自建全节点意味着**不求人、更安全、更隐私**，遵循“**不要信任，要验证（Don't trust, verify）**”的区块链哲学
    

2.  归档节点 (Archive Node)：历史的“时间机器”
    

-   **技术特性**：它在全节点的基础上禁用了修剪功能，保留了自创世块以来**每一个高度的完整状态快照**（包括余额、合约存储、状态树等）。
    

3.  轻节点 (Light Node)：资源受限者的“移动书柜”，轻节点旨在降低参与门槛，主要面向手机、浏览器插件或物联网设备。
    

4.  验证节点 (Validator Node)：共识的“陪审团”，来源指出，如果你想参与出块并赚取质押奖励，就需要在 共识客户端上挂载“验证者客户端”。
    

**_通信协议：_**

**P2P网络（去中心化的“群聊”）：**

P2P 网络意味着节点之间直接连接并交换数据，**没有中心化服务器**。在这种网络里，每个节点既是“读者”又是“广播者”：它既可以接收别人的交易和区块，也可以将自己看到的新消息转发出去。这种像“没有主持人的群聊”一样的模式，确保了只要还有节点在线，网络就很难被关闭或控制。

**Gossip协议（传八卦）：**

Gossip 是节点之间传播关键信息的主力通道，即使某些节点宕机、掉线或作恶不转发、消息仍然可以通过其他邻居路径扩散出去

Gossip 协议相当于以太坊的“去中心化广播系统”： 它让每个节点只需 和少数邻居聊天，就能在几秒内把新交易、新区块及 PoS 投票散播到整个 网络，从**而在没有中心服务器的前提下，实现高可用、高容错、可扩展的 全网信息同步**。

**节点发现（UDP + Kademlia）：**

节点启动时，通过 **UDP** 上的 Discovery 协议（discv4/discv5）寻找邻居。它采用 **Kademlia 风格的分布式哈希表（DHT）**，利用逻辑距离算法填满“通讯录”，实现高效的节点定位
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->










## **学习总结day03**

**_web3运行的原理_**

私钥：相当是一个专属密码，终极签名印章，谁有就控制了资产，私钥不可重置

助记词：从私钥分叉出的一个账户，私钥的唯一地址，助记词和私钥是一对多的关系

助记词是钱包，私钥是钱包里面的夹层

地址：公钥特殊截取后的公开地址，eth（是截取公钥后20位，加上0x）

**_昨天听布老师的分享会提出的疑问_**

**_为什么以太坊的交易打进区块中之后，还没有显示完成，还需要等十几分钟，是每条链完成交易的时间都不一样，那影响因素是什么_**

这个所经历的等待，实际上是交易变得不可逆转，区块链是一个分布式网络，存在一个巨大的风险——**分叉（Fork）和重组（Reorg）**

**什么是重组风险：**

-   想象一下，世界上有两个验证者几乎同时挖出了第 #100 号区块。
    
-   你的交易在验证者 A 的区块里，但没在验证者 B 的区块里。
    
-   此时全网会短暂出现两个版本的账本。网络需要时间来决定哪一条链是“主链”。
    
-   如果最终网络选择了 B 的链，A 的链就被抛弃（叔块），你的交易就好像从来没发生过一样（或者回到内存池等待重新打包）。
    

**以太坊的“安全时间”：**

以太坊升级后，引入了**“最终性”（Finality）**的概念

-   以太坊将 32 个区块（Slots）归为一个**Epoch（时段）**，大约 6.4 分钟。
    
-   当一个 Epoch 结束并被全网验证投票通过后，它被称为“Justified”（已证明）。
    
-   当第二个 Epoch 紧接着也通过后，前一个 Epoch 里的交易才变成“Finalized”（最终确定）。
    
-   **计算：** 2 个 Epoch大约需要 **12.8 分钟**（64个区块，一个块的时间大概是12s）。
    
-   **结论：** 这就是为什么交易所通常要求你等待 12-15 分钟。只有达到“Finalized”状态，交易被回滚的成本才高到天文数字（需要烧毁全网 1/3 的质押 ETH），才算绝对安全。
    

**_每条链的时间都不一样吗？_**

不太一样，这完全取决于该公链的设计哲学和共识机制。我们可以把它们分为三类：

**比特币（最慢，最稳）：**

-   **机制：** PoW（工作量证明）。
    
-   **出块时间：** 10 分钟一个块。
    
-   **确认时间：** 通常需要 6 个确认（6个块）。
    
-   **总耗时：** 约 **60 分钟**。
    
-   _原因：比特币追求极致的安全和去中心化，牺牲了速度。_
    

**以太坊（中等）：**

-   **机制：** PoS（权益证明）。
    
-   **出块时间：** 12 秒一个块。
    
-   **确认时间：** 达到“最终性”需要 2 个 Epoch。
    
-   **总耗时：** 约 **13 分钟**。
    

**Solana / Aptos / Sui 等高性能链（极快）：**

-   **机制：** 改进的 PoS + BFT（拜占庭容错）变体。
    
-   **出块时间：** 400 毫秒（0.4秒）。
    
-   **确认时间：** 这里的确认通常是“亚秒级”或几秒。
    
-   **总耗时：** 通常 **几秒钟** 显示完成。
    
-   _原因：它们使用了独特的共识机制（如 Solana 的 PoH），允许节点在不完全同步全网的情况下预先执行，从而实现极快的“最终性”。_
    

**ps：**比如以太坊 Layer 2（如 Arbitrum/Optimism），虽然在 L2 上几秒就确认了，但交易所充值有时还是很慢，因为交易所在等 L2 把数据传回以太坊主网（L1）并确认，这可能需要十几分钟甚至更久

### **Web3 领域的核心法律合规要求与网络安全风险**

**核心法律风险梳理：**

代币发行与交易行为的法律风险、赌博、传销、洗钱等刑事风险、场外交易中的洗钱与非法经营风险、民商事争议

**国内监管环境概览：**

-   禁止一切形式的首次代币发行（ICO）、首次交易所发行（IEO）及首次 DEX 发行（IDO）
    
-   禁止虚拟货币交易所的运营及提供撮合、定价等中介服务
    
-   明确虚拟货币不具备法偿性，不得作为支付工具在市场上流通使用
    
-   禁止境外虚拟货币交易平台向中国境内居民提供服务
    
-   严厉打击以虚拟货币为载体的非法集资、传销、洗钱、赌博等犯罪活动
    
-   将虚拟货币“挖矿”活动定性为淘汰类产业，并予以全面禁止
    

**_全球监管背景和趋势_**

-   **欧盟 (EU)：**对稳定币发行商提出严格的资本和流动性要求。禁止算法稳定币，要求加密服务提供商持牌经营。
    
-   **美国 (USA)：**SEC (证券交易委员会):将大部分代币视为证券进行监管。CFTC (商品期货交易委员会): 将比特币和以太坊视为商品，监管其衍生品。- OCC (货币监理署): 允许银行提供加密货币托管服务。
    
-   **香港 (Hong Kong)：**2023年6月生效，要求加密货币交易所持牌经营。 对零售投资者开放交易，但要求严格的 KYC/AML 措施
    
-   **国际组织：**制定全球 AML/CFT (反洗钱/反恐怖融资) 标准，要求虚拟资产服务提供商 (VASP) 在转账时收集和传输交易双方信息
    

**_国内从业者法律风险防范：_**

-   **雇佣关系风险：** 大多数项目主体注册在境外（如新加坡、BVI），无法与境内员工签订有效的劳动合同和缴纳社保公积金。这不仅影响员工在购房、落户、子女教育等方面的权益，一旦发生劳动纠纷，也难以获得法律保障。
    
-   **薪酬结构风险：** 以“人民币 + Token”或“全 USDT”支付薪酬的模式，其虚拟货币部分不符合《劳动法》规定。项目代币价值的剧烈波动也给员工收入带来巨大不确定性。
    
-   **虚拟货币出金风险：** 将虚拟货币兑换为法币（“出金”）的过程充满风险。通过 C2C 或 OTC 交易极易收到涉诈、涉赌的“黑钱”，导致银行账户被冻结，甚至被追究“帮信罪”等刑事责任。
    
-   **项目合法性审查：** 入职前，必须对项目的白皮书、代币模型、收益结构以及是否面向中国大陆用户进行审查，避免在不知情的情况下参与非法金融活动而被牵连
    

### **常见的网络安全和**

**_针对小白的常见攻击：_**

-   **钓鱼攻击 (Phishing):** 最常见的攻击手段。攻击者通过伪造官方邮件、网站或在社群中冒充官方人员，发布虚假面试通知、空投活动，诱导受害者点击恶意链接、连接钱包或泄露私钥/助记词。
    
-   **恶意软件与木马 (Malware & Trojans):** 攻击者将木马伪装成“专用面试软件”、“破解工具”或浏览器插件。这些软件一旦安装，可实现剪贴板劫持（自动替换钱包地址）、窃取浏览器 Cookie 和密码、远程控制电脑等功能。
    
-   **社交工程 (Social Engineering):** 通过冒充 HR、导师、同学等可信身份获取受害者信任，然后诱导其转账、泄露信息或点击恶意链接。
    
-   **供应链攻击 (Supply Chain Attacks):** 攻击者在广泛使用的开源库或浏览器插件中植入后门代码，导致所有下游用户受到影响，危害范围广且难以防范。
    
-   **传统账号安全风险：** 弱密码、多平台密码复用、未开启双因素认证（2FA）、邮箱或 SIM 卡被劫持等传统安全问题，同样是导致资产损失的重要原因。
    

**_防范策略：_**

-   **拒绝未知软件：** 坚持使用 Zoom、腾讯会议等公开会议工具，拒绝安装任何“公司专用”或来源不明的面试软件。
    
-   **多方核实：** 对面试邀请的邮箱、域名、联系人进行多渠道核实。
    
-   **钱包与交易安全**
    
-   **私钥离线保存：** 助记词和私钥必须手写并离线保存在安全地点，千万不要截图、上传云盘或通过网络发送。
    
-   **地址反复核对：** 转账前务必仔细核对收款地址的前 6 位和后 4 位，以防剪贴板被劫持。
    
-   **定期审查授权：** 使用 [Revoke.cash](http://Revoke.cash) 等工具定期检查并取消不必要的钱包授权。
    
-   **钱包隔离：** 使用专门的测试钱包参与空投等高风险活动，主钱包资产进行冷存储。
    
-   **软件与插件管理**
    
-   **来源可靠：** 所有软件和浏览器插件仅从官网或官方应用商店下载。
    
-   **审慎安装：** 安装前检查软件的口碑、开发者信息和下载量，避免安装恶意插件。
    
-   **权限最小化：** 开启系统防火墙，并对摄像头、麦克风等敏感权限按需授权。
    
-   **社交媒体警惕性**
    
-   **不轻信私聊：** 对社群中自称“官方人员”或“管理员”的私聊和链接保持高度警惕。
    
-   **验证请求：** 遇到好友“紧急转账”、“帮忙测试”等请求，务必通过电话或其他可靠渠道确认其身份。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->











## **学习总结day02**

今天的学习主要是021学习以太坊第一章，同时也是按照自身工作经验来安排后续的到岗位意向

岗位意向：

昨天晚上听了老师的web3行业全局介绍和岗位概览，然后对比一下自身的情况，发现DApp开发还是比较适合我，我的web2本职工作是前端开发，我在web3中的意向岗位是是DApp开发，一个是我有几年的前端开发工作经验，还有一个是岗位相似度比较高、可以快速上手。

反省一下自身，感觉现在用ai coding用的太多导致自己对问题的思考能力已经下降了很多，现在尽量还是少用，或者用的时候先思考，在动手去做，最大幅度的提升自己的思考能力。技术方面觉得也是有所欠缺：web3中常用的前端技术栈有react、next.js、typescript，还有一些经常使用的web3库如：ether.js、web3.js，这些东西都是在web2不常用的，空闲时间还需要多学习和使用

希望达到的成就：最高的还是希望能在web3找到一份不错的工作，虽然这难度是有点高、但还是要按着这个目标去努力

**_Ether（ETH）的定义与系统职能_**

以太币（Ether，ETH）是以太坊区块链上的原生数字资产，且有真实且浮动的市场价格，**ETH三大核心作用：**

-   **网络燃料（Gas）**：支付交易和计算费用，gas费用的计算由很多因素影响，如：**网络拥堵（供需决定价格）、交互复杂程度（如果只是简单的转账费用就会低、如果是mintNFT等操作消耗的会更高）、全球用户的活跃时间差**
    

-   **参与网络共识与安全（Staking）：**从The Merge（2022年9月15日）以来以太坊的工作模式从pow工作量证明转变成pos权益证明，用户可**将质押（Staking）资产——>获得奖励（Rewards）**,提供经济安全（Security / “保证金”）还有Slashing处罚机制
    
-   **验证者会被奖励或被 Slashing：**Slashing 是 PoS 系统里最严厉的惩罚，用来针对那些危害网络安全的行为， 而不是单纯“偶尔掉线”包括：**对同一个 slot 双重提议区块、对同一高度同时给两个不同区块投票、提交 “环绕投票“试图篡改链的最终性**
    
-   **价值储存和交换媒介：**DeFi 生态的抵押品与流动性基石、NFT 与数字经济的基石货币
    
-   **NFT 与同质化 / 非同质化代币：**NFT （Non-Fungible Token）是在区块链上具有唯一标识的加密代币，每一枚 NFT 都代表某个特定、不可互换的资产，有点像数字世界里的“所有权凭证”或“收藏证书”
    

**_以太坊为何被誉“全球可编程区块链”_**

-   区块链：不只是记账，它去中心化（没老板）、不可篡改（写了改不了）、公开透明（谁都能查），不会因为一次断点事故导致不可运行、也不会因为某个公司垄断
    
-   可编程：**智能合约**也是以太坊的灵魂，能让部署在区块链上的代码
    
-   全球性：虽然它是由全球成千上万台节点组成的，但在用户眼里，它就是唯一的一台大电脑，不论在全球哪些地方只要有网络连接上的都是同一个以太坊，看到的数据也是相同的
    

**_以太坊 dApps 的概念与应用_**

dApp去中心化应用程 是构建在去中心化网络上的应用，它把两块东 西拼在一起链上的智能合约（后端逻辑） • 链下的前端页面 / 客户端（用户界面）,在以太坊上，**智能合约就像一组开放、透明、永远在线的 API**：任何人都可 以调用，**你的 dApp 甚至可以直接复用别人已经部署的合约逻辑**

dApp特性：1、去中心化 2、确定性 3、图灵完备 4、隔离性

**为什么要用 dApp？**

-   只要以太坊网络还在，dApp 就永远在线，不会出现“机房停电”这回事，公司倒闭这回事
    
-   没人能阻止你发交易，也没有公司能封杀你
    
-   不用担心公司随时跑路，银行倒闭
    
-   黑客或者内鬼没办法后台修改数据
    

**_dApp实际应用_**

Defi（金融）、NFT（资产）、DAO（治理）、基础建设

**_dApp缺点：_**

-   维护困难，代码一旦部署上链，默认不能更改，除非升级
    
-   性能差：以太坊主网太过拥挤，处理速度太慢，一般都跟不上现在新的L1链如（sol、sui等）
    
-   门槛太高：普通人很难搞懂助记词、Gas 费、私钥这些概念，一但助记词丢失谁也找不回来了
    

**_生态系统创新：DeFi、NFT 与 DAO_**

可以把以太坊生态想成三块：**金融操作系统（DeFi） + 数字资产与身份 层（NFT） + 组织与治理层（DAO）**

**去中心化金融（DeFi）：重塑全球金融“操作系统”**

**用代码代替银行，重新设计钱的玩法**：主要分为：自动做市商 (AMM) & DEX (如 Uniswap)、借贷 (如 Aave)、稳定币 (如 DAI)、扩容技术 (Layer 2)、Layer2主要解决的问题是以太坊主路太堵了

**NFT（资产层）—— 唯一身份证**

**不只是卖图片，而是给万物确权**：你可以把NFT的使用权租给别人，但所有权还是在你手里

**DAO（组织层）—— 代码即法律**

**核心的逻辑是把公司章程写进代码，让所有人投票决定未来**

**协议 DAO(如 Uniswap DAO)**：谁持有代币谁就是股东，大家可以投票来决定项目的任何提案和功能

**公共物品 DAO (如 Gitcoin)**：专门给开源项目捐款的组织

**创意 DAO (如 Nouns)**：每天卖一个头像，钱自动进金库。大家一起投票决定这笔巨款怎么花

**以太坊如新时代的火种，以代码点亮人类协作的未来。它让价值在网络中自 由流动，让信任在无形中生根发芽。在以太坊的世界里，规则由代码书写，创新 由无数双手织就**
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->












## **学习总结day01**

今天的学习主要是web3实习手册入门导读，虽然在入营前就已经看完了这篇手册，但再次阅读还是能在上面学到不少东西，这次阅读增加笔记，方便后期学习

### **区块链基础概念**

**_什么是区块链_**

区块链是一种去中心化的分布式账本技术

就好像是全村人公用的一个超级账本，当每一个人在支出，或者收入的时候，每个人都要在自己的账本上记上一笔交易记录

**_什么是区块？_**

就是账本里的**“一页纸”**。这页写满了交易记录，就写不下了，需要翻到下一页

**_什么是链？_**

这些纸是按顺序**“钉死”**在一起的。每一页都这就包含了上一页的特征（暗号），如果你想撕掉第一页或者涂改它，第二页、第三页就会对不上号，一眼就被发现，这就是区块链的特性，不可篡改

**_大家凭什么费时费力帮你记账呢_**

因为记账会有奖励，如（Token，比如比特币、以太坊），系统规定：谁抢先帮大家把这一页账记好，且不出错，系统就**自动奖励**他一些币，这些币因为数量有限，又能在网络里流通，所以就有了价值

## **以太坊概览**

**_什么是以太坊_**

如果说比特币是**“数字黄金”**（只能存钱、转账的计算器），那么以太坊就是**“世界计算机”**（一台大家共用的、永不停机的超级智能手机）

**_什么是智能合约 (Smart Contract)、以太币 (ETH)、Gas（汽油费）、去中心化应用 (DApp)_**

-   智能合约：就像自动售货机，你投钱，它出货。规则写在代码里，自动执行，不需要谁信任谁，也没人能赖账
    
-   以太币 (ETH)、Gas（汽油费）：就想你去自动贩卖机里面买饮料投入的硬币
    
-   去中心化应用 (DApp)：既然以太坊是智能手机，DApp 就是上面的微信、支付宝或游戏，和正常手机上的app的区别是这些app不受中心化的管理
    

**_以太坊和比特币有啥不一样？_**

-   **比特币：** 功能单一，就是为了记账和储值，以此保证极致的安全。就像**诺基亚砖头机**，虽然只能打电话发短信，但可扩展性差，现在的处境有点像行业信仰。
    
-   **以太坊：** 功能强大，允许程序员在上面写各种代码（发币、借贷、做游戏）。就像**智能手机**，虽然系统复杂点，但能装各种好玩的应用。
    

**_以太坊生态概览：L1、L2、Sidechains 等_**

-   L1：以太坊主网核心区块链，负责最终安全性与共识
    
-   L2：以太坊二层网络，通过将交易批量处理后提交至 L1，降低 Gas 费
    
-   Sidechains ：独立运行的链，通过桥接与主网交互
    

**_应用场景_**

**_DeFi（去中心化金融）：_**

没人管理的自动银行，只有写好代码的智能合约在执行

-   **交易（Uniswap）：** 像无人超市。你想把 A 币换成 B 币，直接和池子里的钱换，不用找人撮合。
    
-   **借贷（Compound）：** 你抵押比特币，借出美元（稳定币），就像把房子抵押给当铺，但这里没人审你征信，系统自动算。
    
-   **印钱（MakerDAO/Sky）：** 你抵押资产，生成美元代币（DAI/USDS），相当于自己做央行
    

**_NFT（非同质化代币）——“数字世界的房产证”_**

-   **CryptoPunks：** 像数字古董，虽然是像素头像，但因为是鼻祖所以超贵。
    
-   **OpenSea：** 就是“NFT 界的淘宝”，大家都在这买卖数字藏品。
    

**_DAO（去中心化自治组织）——“没有老板大家想怎么来就怎么来的互联网公司”_**

一群陌生人因为同一个目标凑钱、凑人，通过投票来决定怎么干，没有老板，全看大家投票

**南塘 DAO：** 能把 Web3 用在中国乡村建设上，发个“南塘豆”来鼓励大家做社区贡献，这个是我从来没有想到过的，web3还能这样玩

**_Web3 工作方式_**

有点像发了一本数字数字游民实操手册

讲了一些使用软件的安装、操作：Twitter、Telegram、Discord、MetaMask、Linkedln、Notion、Zoom、Calendly、Figma、GitHub等软件及操作

一些通用的行业黑话：

| DYOR | Do Your Own Research，投资前请自行研究，项目方常用于免责 |
| --- | --- |
| FOMO | Fear of Missing Out，害怕错过，指因贪婪而追高的情绪 |
| FUD | Fear, Uncertainty, Doubt，恐慌、不确定、怀疑，指唱衰情绪或舆论攻击 |
| WAGMI | We're All Gonna Make It，大家都会发财，社区常用打气口号 |
| NGMI | Not Gonna Make It，讽刺某人/项目做法不行 |
| REKT | 被"爆锤"，损失惨重，如投资失败、合约被黑等 |
| Airdrop | 空投，免费发放代币以激励用户参与项目 |
| Whale | 加密大户、巨鲸，能影响市场价格的人 |
| Degen | "投机狗"，不问项目质量只冲高风险高回报机会的人 |
| Shill | 宣传、推销（常含贬义），如"shill 项目"指恶意安利 |
| Exit Scam | 项目方跑路，携款失联 |

技术类

| L1 / L2 | Layer 1（主链，如以太坊）和 Layer 2（扩容方案，如 Arbitrum、zkSync） |
| --- | --- |
| EVM | Ethereum Virtual Machine，以太坊虚拟机，运行智能合约的核心 |
| Smart Contract | 智能合约，自动执行合约逻辑的链上程序 |
| Bridge | 跨链桥，用于在多条链之间转移资产 |
| Oracle | 预言机，用于向链上提供链下数据 |
| Fork | 分叉，指复制已有代码的项目，或区块链协议分裂 |
| Mint | 铸造，生成新的 NFT 或代币 |
| Burn | 销毁代币，减少总量，用于通缩机制 |
| Rugpull | 抽地毯，项目方卷款跑路（尤其在 DeFi 项目） |

投资类

| Pump | 拉盘，代币价格快速上涨 |
| --- | --- |
| Dump | 砸盘，代币价格快速下跌 |
| HODL | 原为"Hold"打错，后来变成文化，意为坚定持币不卖 |
| Bagholder | "接盘侠"，高位买入亏损后长期持币的人 |
| Alpha | 内部消息/潜在机会，表示未公开但价值潜力大的信息 |
| Tokenomics | 代币经济学，研究代币发行、分配、用途等机制 |

社区文化

| gm / gn | good morning / good night，Web3 社区日常打招呼方式 |
| --- | --- |
| Anon | 匿名者，社区中不透露真实身份的成员 |
| KOL | Key Opinion Leader，意见领袖，影响力人物 |
| CT | Crypto Twitter，加密行业活跃的信息与讨论来源 |
| DAO | 去中心化自治组织，社区驱动型的组织管理形式 |
| NFT PFP | NFT 头像项目，如 CryptoPunks、BAYC，PFP = Profile Picture |

开发类

| Hardhat / Foundry | 常用的智能合约开发框架 |
| --- | --- |
| RPC | Remote Procedure Call，链上节点访问接口 |
| Gas | 交易费用，以太坊中以 Gwei 计费 |
| Etherscan | 区块浏览器，用于查看合约、交易、地址信息 |
| Viem / Ethers.js / Wagmi | Web3 前端交互库 |
| ABI | Application Binary Interface，合约调用所需的接口信息 |
| Mainnet / Testnet | 主网 / 测试网，分别对应正式和测试环境 |
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
