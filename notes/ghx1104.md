---
timezone: UTC+8
---

# ghx1104

**GitHub ID:** ghx1104

**Telegram:** 

## Self-introduction

我是Link，目前base青岛，目前一名研三学生，专业是生物学，偏向于基因组学和生物信息学，熟练使用Linux shell命令、python、R等等。从24年接触web3，玩过一级市场和二级市场，是一名业余开发者，技术栈是node，熟悉solidity，参与过monad的上的一些链上交互开发项目。

## Notes

<!-- Content_START -->
# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->
今天，**LangChain 与 LangGraph（学习笔记）**：LangChain 是一个用于将 LLM 与外部工具、数据源和函数调用连接起来的应用框架，核心优势在于把“单次 prompt”扩展为**可复用的链式调用（prompt + tool + memory）**；而 LangGraph 则进一步将这种链式结构升级为**显式状态机/图结构**，支持分支、循环、多 Agent 协作和失败回退。相比普通 prompt 一次性生成、不可控、难复现的特点，LangChain 适合构建**多步骤但线性的任务流程**（如 RAG、工具调用、自动化助手），LangGraph 则更适合**有状态、有决策、有重试和风控要求的复杂场景**（如交易/MEV Bot、链上 Ops Agent、长任务规划、多人协作 Agent）。总体而言，普通 prompt 解决“回答问题”，LangChain 解决“完成任务”，而 LangGraph 解决“在复杂、不确定环境中持续做正确决策”。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->

2026-01-18今天参加了晚上八点的会议：**Key Hash Based Tokens: 从 ERC-721 到 ERC-7962。**ERC-721 将 NFT 建模为 **任意 tokenId 与所有者的映射**，tokenId 本身通常没有密码学语义；而 **ERC-7962** 则把 tokenId 设计为某个 **Key / 声明的哈希值**，使 NFT 本身成为一个 **加密承诺（commitment）**。在这种模型下，零知识证明（ZK）可以自然地用来证明“我知道对应的 secret 或满足某个条件”，而无需暴露具体信息，从而直接以 ERC-7962 的 tokenId 作为链上锚点。相比之下，ERC-721 与 ZK 的结合往往需要额外的绑定层；而 ERC-7962 从设计之初就与 ZK 对齐，使 NFT 从“可转移的资产编号”演进为“可被零知识使用的身份、权限或凭证原语”
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->


**2026-01-17学习MEV 的常见类型**：从机制上看，MEV 可以按“如何利用排序与执行优势”来理解，主要包括几类典型形式：① **DEX 套利（Arbitrage）**，利用不同交易池或市场之间的价格差进行无风险套利；② **清算抢跑（Liquidation MEV）**，在借贷协议中优先执行清算以获取奖励；③ **三明治攻击（Sandwich Attack）**，在用户大额交易前后插入交易以操纵价格并获利；④ **抢跑 / 插队（Frontrunning / Backrunning）**，基于 mempool 可见性提前或紧随执行特定交易；⑤ **时间与排序 MEV（Time-bandit / Reordering MEV）**，通过重排区块内交易甚至重组历史区块来获取额外收益；⑥ **NFT / 初始发行 MEV**，在 NFT mint、IDO、空投等场景中通过优先打包获取稀缺资产。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->




可以压缩成 **3 个逻辑清晰、偏学习笔记的段落**，保留 MEV → PBS → 认知变化 这条主线，如下（可直接用）：

* * *

最近对MEV非常感兴趣，想要做一个关于MEV的项目，对其进行学习：

通过学习 MEV，我逐渐意识到它并不是某种“异常行为”，而是源自区块链中交易可见性与排序权的**结构性价值**。只要交易顺序会影响执行结果，而又有人能够影响排序，MEV 就不可避免地存在。无论是 DEX 套利、清算抢跑还是三明治攻击，本质上都是对信息与执行位置优势的利用，而非合约漏洞。这让我意识到，MEV 不是某个参与者的问题，而是系统设计本身的结果。

进一步学习了 searcher、builder、proposer 的角色分工后，我开始理解 PBS（Proposer-Builder Separation）的核心动机：将“构建区块”和“提出区块”的权力拆分，降低验证者直接参与 MEV 竞争的门槛，并通过竞争机制将 MEV 从私下博弈转为可协调的市场。以 Ethereum 为例，builder 构建并出价区块，proposer 在看不到具体交易内容的情况下选择出价最高的区块，从而减少复制 MEV 的动机。PBS 并不是为了消灭 MEV，而是重新定义 **谁能抽取 MEV、以及如何分配**。

从 MEV 和 PBS 的视角重新审视区块链，我逐渐意识到去中心化并不等于结果公平，技术中立也不意味着价值中立。排序权、接口设计和执行层位置，都会直接影响价值的流向。MEV 更像是区块链真实权力结构的显性化，而 PBS 则是一种制度与工程层面的回应。这让我对 Web3 的理解，从“协议功能”转向了“激励、权力与治理结构”的整体思考。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->





今天2026-01-15的co-learning：wachi老师说的一个比喻我觉得很有道理，就是刚入行web3有很多噪音，这就跟开车一样，一开始开车面对很多噪音，但是开多了就会能够实时捕捉有用的信息；晚间的课程：从聊天机器人到自主经济体系智能体 AI 与Web3 的融合。比较硬核，我认为ai agent在链上具有身份是未来的趋势，有很大的未来开发潜力。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->






今天2026-01-14的co-learning：最大的收获是wachi老师的分享，“好奇心+积极主动”或可以使人收获颇多！
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->







昨天2026-01-12忘记打卡，在此一并记录：2026-01-11开营仪式；2026-01-12下午参与了以太坊周会，晚上参与了web3行业全局介绍&岗位概览，这个收获还是颇多的，比如web3全球月活开发者为2.5-3万人，2025招聘反弹47%（新增6.6万个岗位）；且没想到目前web3也挺卷的，平均录取比为1个岗位 vs 450份简历（450:1）,目前我掌握了solidity，但是rust似乎是未来的趋势。web3的岗位垂直平台有：SmartDeer [Web3.career](http://Web3.career) Romote3 CryptoJobsList，值得关注一下

今天2026-01-13，在co-learning环节，关于DAO的讨论令人印象深刻，目前DAO的治理存在着寡头和普通参与者投票权矛盾的问题，如果寡头投票权大，那么似乎与去中心化不符，谁钱多谁控制一切；如果寡头、巨鲸和普通参与者同样的投票权，然而投票后的决策似乎可能会先使巨鲸的利益受到损失，且可能巨鲸的利益损失最大，这也不符合直觉，或许这是一个POS机制的底层问题？或许可以加入开发者的历史参与证明来增加权重？或者适当增加寡头权重但是不至于使其控制全局的程度？2026-01-13晚学习web3运行原理：1.数字签名：使用私钥签名一段消息，任何人都可以用对应的地址验签，任何人都无法伪造你的签名（除非拿到私钥）【[https://gemini.google.com/share/54a1d1ee8263](https://gemini.google.com/share/54a1d1ee8263)】；2.从一笔交易到出块（完整生命周期）：wallet（签名）-> RPC/Node（传播）-> Mempool（排队）-> Builder/Validator（挑选）-> Block（落盘）-> Explorer（可查）【[https://txcity.io/v/eth-btc](https://txcity.io/v/eth-btc)】3.抢跑是什么？当你的私钥泄露，hacker会把你的钱转走，你可以用更高的gas，使你的这笔交易更快的发出（比黑客更快），就可以使黑客的交易失效。
<!-- DAILY_CHECKIN_2026-01-13_END -->
<!-- Content_END -->
