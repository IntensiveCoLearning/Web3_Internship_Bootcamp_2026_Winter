---
timezone: UTC+8
---

# Jiaxin Chen

**GitHub ID:** PlutoKirito

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->
# ERC-7962：从公开所有权到隐私身份凭证

## 1\. 背景：ERC-721 的隐私困境

-   **核心特征**：完全公开透明。通过 `ownerOf(tokenId)` 可直接查询资产关联的以太坊地址。
    
-   **隐私图谱风险**：攻击者能轻易通过地址关联用户的 NFT、ERC-20 资产及交易历史，描绘精准的“用户画像”。
    
-   **行业痛点**：对于**会员身份**、**医疗凭证**等隐私敏感型资产，ERC-721 的公开性会导致严重的商业隐私泄露。
    

* * *

## 2\. 商业案例：星巴克与机场贵宾厅的“三角困境”

在跨机构验证场景中，三方需求往往互相冲突：

-   **发行方（星巴克）**：需提供权益，但受合规限制不能直接共享会员地址名单。
    
-   **验证方（机场）**：需确认身份，但不想（也不应）存储他人的完整会员数据库。
    
-   **持有者（用户）**：想享受服务，但不希望暴漏名下关联巨额资产的个人地址。
    

* * *

## 3\. ERC-7962 的核心技术解决方案

ERC-7962 借鉴了隐私计算与比特币 UTXO 的思想，引入了两大底层创新：

### 3.1 核心设计一：密钥哈希 (Key Hash) 替代地址

-   **逻辑**：所有权不再绑定 `address`，而是绑定 `Key Hash`（公钥的单向哈希值）。
    
-   **隐私屏障**：由于哈希的**不可逆性**，外界观察者只能看到一串无意义字符，无法反推真实公钥或关联到具体的钱包地址。
    

### 3.2 核心设计二：所有权与交易发起的“解耦”

-   **签名上链**：资产所有者仅需在链下生成一个**数字签名**（表达转移或验证意图）。
    
-   **中继转发 (Relayer)**：签名可由任何第三方（如项目方）提交上链并代付 Gas。
    
-   **验证机制**：智能合约只验证“签名是否匹配 Key Hash”，不再关心 `msg.sender`（交易发起者）是谁。
    

* * *

## 4\. 深度对比：ERC-721 vs. ERC-7962

| 特性维度 | ERC-721 (公开资产) | ERC-7962 (隐私资产) |
| 所有权标识 | 公开的 Address (易被追踪) | 隐藏的 Key Hash (难以关联) |
| 交易发起 | 所有者必须亲自发起并支付 Gas | 所有者签名，由 Relayer 提交并代付 |
| 关联性机制 | 强关联，形成全网公开隐私图谱 | UTXO 式密钥更新，交易后更换 Key Hash，切断追踪路径 |
| 用户门槛 | 高（需持有原生代币、管理 Gas） | 低（Gas 费赞助，Web2 级无感体验） |

* * *

## 5\. Web3 大规模应用的桥梁：UX 的飞跃

ERC-7962 不仅保护隐私，更彻底革新了用户体验，让 Web3 真正走向主流：

1.  **无感 Gas (Gas Sponsorship)**：用户无需在交易所买 ETH 也能转账，项目方可代付费用。
    
2.  **简化交互**：用户只需点击“签名”，无需理解私钥、助记词等底层概念，交互逻辑与 Web2 App 别无二致。
    
3.  **高度灵活性**：天然支持**批量交易**与**账户抽象 (AA)**，极大提升了企业级应用的运营效率。
    

* * *

## 6\. 总结

**ERC-7962** 是连接 Web2 用户与 Web3 世界的关键桥梁。它通过解决“隐私泄露”和“交互繁琐”这两大痛点，将区块链从“极客的公开账本”进化为“大众的隐私数字生活工具”。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->

# Solidity 智能合约

## 一、 语言定义

-   **Solidity**：一种面向合约、静态类型的编程语言，专门用于在 **EVM（以太坊虚拟机）** 上实现智能合约。
    
-   **运行环境**：代码编译为字节码（Bytecode）后部署于链上，由全球节点在 EVM 中并行执行。
    

* * *

## 二、 基础数据类型

### 1\. 数值与地址 (Value Types)

-   **uint256 / int256**：最常用的整数类型（256 位）。`uint` 默认为 `uint256`。
    
-   **address**：20 字节的以太坊地址。`address payable` 额外支持转账方法。
    
-   **bool**：布尔值（`true` / `false`）。
    

### 2\. 复杂类型 (Reference Types)

| 类型 | 描述 | 特点 |
| mapping | mapping(K => V) | 哈希表实现，查询复杂度 $O(1)$，不可遍历。 |
| struct | struct Name { ... } | 用户自定义的复合数据结构。 |
| array | T[] 或 T[k] | 动态或定长数组，支持 push（仅动态）和 length。 |
| enum | enum Status { ... } | 增强代码可读性的枚举类型。 |

* * *

## 三、 函数修饰符 (Modifiers)

### 1\. 可见性 (Visibility)

-   **public**：内部/外部均可访问。
    
-   **private**：仅限当前合约内部。
    
-   **internal**：当前合约及子合约（继承）可见。
    
-   **external**：仅限外部访问（通常处理大数组参数时更省 Gas）。
    

### 2\. 状态修饰符 (State Mutability)

-   **view**：**只读**。读取链上状态但不修改。
    
-   **pure**：**纯计算**。既不读取也不修改链上状态（如数学运算）。
    
-   **payable**：**可支付**。必须标注此项，函数才能接收 ETH。
    
-   **默认**：既读取又修改状态，消耗 Gas 正常。
    

* * *

## 四、 开发范式与安全原则

1.  **状态机模式**：通过 `enum` 管理合约状态（如：`Pending`, `Active`, `Closed`）。
    
2.  **事件驱动 (Events)**：使用 `event` 记录日志，是前端（Web3.js/Ethers.js）监听合约变化的唯一途径。
    
3.  **检查-效果-交互 (CEI)**：
    
    -   先**检查**条件（`require`）。
        
    -   再更新内部**状态**（如减少余额）。
        
    -   最后执行外部**交互**（如转账），以防重入攻击。
        

* * *

## 五、 合约标准结构示例

Solidity

```
// 1. 许可声明与版本号
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 2. 合约定义
contract MyContract {
    // 3. 状态变量 (永久存储在链上)
    uint256 public myNumber;
    address public owner;

    // 事件定义
    event NumberChanged(uint256 newValue);

    // 4. 构造函数 (仅部署时执行一次)
    constructor(uint256 _initialNumber) {
        myNumber = _initialNumber;
        owner = msg.sender;
    }

    // 5. 普通函数
    function setNumber(uint256 _newNumber) public {
        // 权限检查
        require(msg.sender == owner, "Only owner can change number");
        
        myNumber = _newNumber;
        emit NumberChanged(_newNumber); // 触发事件
    }

    // 只读函数示例
    function getDoubleNumber() public view returns (uint256) {
        return myNumber * 2;
    }
}
```
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->


# ERC721 存储逻辑与 Gas 权衡 (Enumerable 深度解析)

## 一、 核心矛盾：Mapping 的“单向盲区”

在标准的 ERC721 合约中，核心数据结构是：

mapping(uint256 => address) private \_owners;

-   **单向索引**：只能实现 **TokenID $\\rightarrow$ Owner** 的查找。
    
-   **链上限制**：Mapping 在 EVM 中不存储键的列表，也不记录长度。这意味着**无法在链上直接获取“某个地址持有的所有 NFT 列表”**。
    
-   **计算代价**：若要在链上强制实现“持有人 $\\rightarrow$ ID 列表”的查询，必须遍历全量 TokenID，Gas 消耗将呈线性增长（$O(n)$），极易触碰区块 Gas 上限导致交易失败。
    

* * *

## 二、 解决方案：ERC721Enumerable 扩展

为了解决查询痛点，OpenZeppelin 提供了 **ERC721Enumerable** 扩展包。

-   **原理**：在 Mapping 基础上，额外维护了多个**动态数组 (Array)** 和**索引映射**。
    
-   **新增接口**：
    
    -   `totalSupply()`：返回当前总发行量。
        
    -   `tokenOfOwnerByIndex(address owner, uint256 index)`：通过索引遍历用户持有的 NFT。
        
    -   `tokenByIndex(uint256 index)`：通过索引遍历全量 NFT。
        

* * *

## 三、 核心权衡：写入成本 vs 读取便利 (The Trade-off)

区块链开发遵循\*\*“能量守恒”\*\*：**查询越方便，写入（状态修改）越昂贵。**

| 维度 | 标准 ERC721 | ERC721 + Enumerable |
| Mint / Transfer Gas | 低（仅需修改 1-2 个 Mapping） | 极高（需同步更新多个数组及索引） |
| 链上查询便利性 | 差（无法直接获取用户列表） | 优（可直接调用接口遍历） |
| 逻辑复杂度 | 简单 | 复杂，增加了状态同步出错的风险 |
| 适用场景 | 高频转账、批量 Mint、Gas 敏感型项目 | 对链上遍历有强需求的特定逻辑（少见） |

* * *

## 四、 现代开发最佳实践：链下索引 (Off-chain Indexing)

随着以太坊生态的成熟，**“为了查询方便而牺牲 Gas”** 已被视为反模式。

1.  **瘦合约 (Slim Contracts)**：去掉 Enumerable 扩展，保持 `mint` 和 `transfer` 的极低成本。
    
2.  **链下索引器**：
    
    -   **The Graph (Subgraphs)**：通过监听合约事件（Transfer），在链下数据库中自动构建“持有人 $\\rightarrow$ TokenID”的对应关系。
        
    -   **中心化 API**：使用 Alchemy、Moralis 或 NFTScan 等提供的 API 直接获取用户资产列表。
        
3.  **结果**：用户在前端（如 OpenSea、钱包）依然能看到完整的 NFT 列表，但无需在每次转账时多交 30%-50% 的 Gas 费。
    

* * *

## 五、 总结：开发者心法

-   **Gas 是稀缺资源**：永远不要在链上做非必要的“列表维护”。
    
-   **异步思维**：链上负责**核心逻辑与确权**，链下负责**数据聚合与展示**。
    
-   **优化方向**：如果项目预期会有大量交易（如百 E 级蓝筹、游戏道具），请果断抛弃 Enumerable，转而使用索引器。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->



# Solidity 编程基础：智能合约开发核心

## 一、 语言定义

-   **定位**：面向合约的高级强类型语言，运行于 **EVM (以太坊虚拟机)**。
    
-   **特性**：语法借鉴 C++ (继承)、Python (修饰符) 和 JavaScript (函数式)，核心在于处理**资产**与**状态**。
    

* * *

## 二、 数据类型 (Data Types)

### 1\. 值类型 (Value Types) —— 传值调用

-   **uint / int**：整数类型。`uint256` 最常用（匹配 EVM 256位字长），`uint` 默认指 `uint256`。
    
-   **bool**：布尔值（`true` / `false`）。
    
-   **address**：20 字节以太坊地址。
    
    -   `address`：基本地址。
        
    -   `address payable`：拥有 `transfer()` 和 `send()` 方法，可接收 ETH。
        

### 2\. 引用类型 (Reference Types) —— 传址调用

-   **Structs**：自定义数据结构，用于封装复杂业务逻辑。
    
-   **Arrays**：包括定长数组和动态数组。
    
-   **Mappings**：`mapping(key => value)`。
    
    -   **特性**：哈希表实现，查询复杂度 $O(1)$，极其高效。
        
    -   **限制**：**不可遍历**，仅存于存储 (Storage) 中。
        

* * *

## 三、 数据位置 (Data Locations) —— Gas 优化的核心

在 Solidity 中，数据存在哪直接决定了交易成本：

| 位置 | 存储性质 | Gas 成本 | 说明 |
| Storage | 永久存储 (链上) | 极高 | 类比硬盘，修改状态变量时使用。 |
| Memory | 临时存储 (内存) | 较低 | 类比 RAM，函数执行完即销毁。 |
| Calldata | 临时存储 (只读) | 最低 | 外部函数参数专用，不可修改，最省 Gas。 |

* * *

## 四、 函数详解 (Functions)

### 1\. 可见性修饰符 (Visibility)

-   **public**：内外皆可访问。
    
-   **external**：仅外部访问。读取大数组参数时比 `public` 更省 Gas。
    
-   **internal**：仅当前合约及子合约可见。
    
-   **private**：仅当前合约可见。
    

### 2\. 状态修饰符 (Mutability)

-   **view**：只读不写（不修改状态变量）。
    
-   **pure**：不读不写（如纯数学运算）。
    
-   **payable**：必须加此关键字，函数才能接收 ETH。
    

* * *

## 五、 错误处理与安全 (Error Handling)

Solidity 遵循**原子性**：一旦触发回滚，所有状态更改都会撤销。

-   **require(bool, string)**：**最常用**。用于校验输入或执行前提，失败则回滚并退还剩余 Gas。
    
-   **revert()**：处理复杂的逻辑跳转，手动触发回滚。
    
-   **assert(bool)**：用于检查内部变量的一致性，失败通常意味着合约有重大 Bug（会耗尽所有 Gas）。
    
-   **Custom Errors (0.8.4+)**：`error InsufficientBalance();`。比 `require` 的字符串描述更省 Gas，推荐使用。
    

* * *

## 六、 现代 Solidity 必备概念

-   **Constructor**：仅在部署时运行一次的初始化函数。
    
-   **Events**：合约与前端/后端交互的桥梁，数据存储在廉价的“日志”中（不可被合约读取）。
    
-   **Modifiers**：函数修改器，常用于鉴权（如 `onlyOwner`）。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->




## 一、 全球主流加密监管框架对比

### 1\. 欧盟：MiCA (最全、最具示范性)

-   **核心内容**：统一欧盟境内的 **CASP (加密资产服务提供商)** 许可制，允许“一证通行”跨境运营。
    
-   **稳定币监管**：严格的储备金与赎回机制（资产参考代币/电子货币代币）。
    
-   **诉求**：构建单一市场，消除碎片化，防范系统性金融风险。
    

### 2\. 美国：GENIUS & STABLE Act (聚焦稳定币)

-   **核心内容**：将稳定币纳入联邦监管，强制 **1:1 全额储备**（美元或美债）。
    
-   **监管格局**：明确 SEC 与 CFTC 的分工，补齐国会立法空白。
    
-   **诉求**：保护美元金融主权，填补监管碎片化带来的不确定性。
    

### 3\. 新加坡与香港：亚洲金融枢纽

-   **新加坡 (PSA)**：以《支付服务法》为基础，MAS 主导，强调 **FATF 接轨 (Travel Rule)** 与创新平衡。
    
-   **香港 (VASP/稳定币条例)**：强制本地实体设立、资本要求与储备隔离，志在打造全球数字金融中心。
    

### 核心地区对比表

| 地区 | 代表法规 | 监管核心 | 推动主因 |
| 欧盟 | MiCA | CASP 统一许可、披露义务 | 市场一体化、风险隔离 |
| 美国 | GENIUS Act | 稳定币联邦化、全额储备 | 维护金融主权与稳定性 |
| 新加坡 | PSA | 数字支付令牌许可、AML/CFT | 创新与安全双驱动 |
| 香港 | 虚拟资产条例 | 交易所/稳定币双许可、储备隔离 | 争夺数字金融枢纽地位 |

* * *

## 二、 加密资产税务合规：从匿名到透明

### 1\. 国际框架：OECD CARF

-   **本质**：加密资产版 CRS。要求 CASP 自动收集并交换用户身份、交易与转移信息。
    
-   **目标**：消除利用加密资产进行的跨国逃税，实现“同债同标”。
    

### 2\. 各国实践

-   **欧盟 (DAC8)**：与 MiCA 并行，强制成员国间自动交换加密资产交易数据。
    
-   **美国 (IRS)**：将资产定义为 **“财产 (Property)”**而非货币，买卖/挖矿/利息均触发税务。
    
-   **港新中心**：不对资本利得征税，但对“经营性收入”征收利得税/所得税。
    

* * *

## 三、 数字资产与数据要素：新型生产关系

### 1\. 欧盟：制度先行

-   **GDPR**：确立数据所有权与保护。
    
-   **Data Act**：明确数据使用权，激活工业与 IoT 数据要素流通。
    
-   **DLT Pilot Regime**：支持链上资产证券化（RWA）合规实验。
    

### 2\. 中国：要素驱动

-   **定位**：将数据列为与土地、资本并列的 **“第五大生产要素”**。
    
-   **现状**：推进数据确权、定价，通过北数所、深数所建立市场化交易体系。
    

### 3\. 美国：市场驱动

-   无统一数据法，依靠行业法（如医疗、金融）与州法（如 CCPA）进行碎片化监管。
    

* * *

## 四、 交叉合规总结：三重合流趋势

> **金融合规**（洗钱/融资）+ **税务合规**（申报/逃税）+ **数据合规**（确权/隐私）

1.  **实名化**：链上地址正演变为“准实名金融账户”，匿名性被合规压力大幅稀释。
    
2.  **资产化**：加密资产正从技术实验全面进入主流财务报告与征税体系。
    
3.  **标准化**：各国监管逻辑正从“沙盒实验”转向“全面许可”与“风险管理”。
    

一句话总结：

合规不再是“补丁”，而是 Web3 项目进入主流金融体系的准入证。税务解决“国家受益”，要素条例解决“分配效率”，二者共同推动 Web3 进入法治时代。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->





## 不点！不签！不装！不转！

## 一、 Web3 安全：攻防新态势

2025 年安全事故依然频发，整体损失维持在 **数十亿美元** 级别，攻击呈现“两极分化”趋势。

### 1\. 两大主流攻击路径

-   **精准猎杀（针对机构/大户）**：由国家级黑客或高级黑客组织主导。长期潜伏供应链，通过前端劫持（如 **Bybit** 案例）或合约深度漏洞（如 **Sonne Finance**）实施致命一击。
    
-   **广撒网（针对散户）**：利用 AI 批量生成钓鱼网站、虚假项目，靠规模化获利。
    

### 2\. 2025 核心新风险

-   **AI 深度威胁**：Deepfake 视频会议诈骗常态化；AI 被用于快速挖掘合约零日漏洞（0-day）。
    
-   **隐蔽钓鱼**：利用“地址合约化”等新协议特性掩盖恶意签名；**地址投毒**专骗依赖交易记录复制地址的用户。
    
-   **供应链后门**：在 AI 辅助编程时代，恶意插件和第三方代码依赖库成为新的隐蔽入口。
    

### 3\. 用户防御四字诀

> 不乱点（链接）、不盲签（权限）、不乱装（插件/软件）、不急转（核实地址）。
> 
> 核心逻辑：冷热钱包分离，私钥物理隔绝。

* * *

## 二、 Web3 合规：从形式到本质

Web3 合规不是新学科，其核心依然是 **金融合规**。

### 1\. 两个维度的合规

| 维度 | 核心内容 | 局限性 |
| 形式合规 (表面) | 合同、白皮书避开“保本/融资/收益承诺”，对齐 FATF/MiCA 框架。 | 仅能规避初级监管，无法在出事时作为“免死金牌”。 |
| 实质合规 (核心) | 业务逻辑不踩红线：不搞 ICO、不服中、远离赌博/洗钱、具备真实技术服务支撑。 | 决定了项目能否长久运行，是防范刑事风险的关键。 |

* * *

## 三、 从业者现实生存指南

### 1\. 项目成色判断

-   **合规红线**：看官网是否直连、是否允许大陆身份认证（KYC）。
    
-   **业务烈度**：合约、期权、高杠杆业务的法律风险远高于现货或基础设施。
    
-   **牌照祛魅**：有牌照不代表绝对安全，需看牌照的**业务许可范围**。
    

### 2\. 个人劳动保障

-   **主体风险**：纯境外主体合同在境内维权难度极大。
    
-   **薪资风险**：境内仲裁基本不认可“数字货币”作为工资，建议争取部分法币结算。
    
-   **岗位避险**：技术、行政岗位的法律风险通常低于直接接触资金与获客的业务岗。
    

### 3\. 出金与司法调查

-   **渠道选择**：首选香港合规持牌渠道；小额可使用合规 U 卡；严禁使用 OTC 导致账户被封。
    
-   **危机处理**：
    
    1.  **证据保全**：保留完整的合法收入证明。
        
    2.  **专业介入**：情况复杂时**先找律师**，不要盲目自行解释。
        
    3.  **协同解冻**：在配合退赔时，务必争取同步解除银行账户冻结。
        

* * *

## 四、 新人保命三原则

1.  **底线意识**：绝不触碰明显踩线的业务（如非法集资、洗钱）。
    
2.  **不作恶**：产品逻辑的清白比合规文本的精美更重要。
    
3.  **专家咨询**：在做出涉及大额资金或业务转向的决策前，**先行咨询律师**。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->






## 一、核心概念辨析

-   **区块 (Block)**：实际存储交易数据和状态的“账本页”。
    
-   **节点 (Node)**：运行客户端软件并接入以太坊网络的物理计算机/服务器。
    
-   **客户端 (Client)**：实现以太坊协议的具体**软件实现**。节点通过运行客户端来下载、验证并保存区块。
    

## 二、 节点架构：执行与共识 (Post-Merge)

在 PoS 时代，一个“完整节点”必须同时运行两种客户端，两者通过 **Engine API** 通信。

-   **执行客户端 (EL, Execution Layer)**：
    
    -   **职责**：处理交易执行、维护以太坊状态（EVM）、管理智能合约。
        
    -   **关注点**：区块里的交易做了什么？状态转换是否正确？
        
-   **共识客户端 (CL, Consensus Layer)**：
    
    -   **职责**：运行 PoS 共识算法，负责区块的广播、验证及最终确定性（Finality）。
        
    -   **关注点**：哪个区块是全网公认的“真链”？
        

> **隔离意义**：将复杂的交易逻辑与共识逻辑解耦，增强安全性，某一方崩溃不会导致另一方数据损坏。

## 三、 节点类型

| 类型 | 存储数据 | 验证功能 | 适用场景 |
| 全节点 (Full Node) | 存储最近状态，按需裁剪历史数据 | 完全验证所有区块与交易 | 大多数日常应用、质押 |
| 归档节点 (Archive Node) | 存储自创世块以来的所有历史状态 | 完全验证 | 区块浏览器、链上数据分析 |
| 轻节点 (Light Node) | 仅存储区块头 (Headers) | 仅验证特定交易的有效性 | 移动端、资源受限设备 |

## 四、 网络通信与区块同步

### 1\. 节点互联三部曲

1.  **发现阶段 (UDP + Kademlia)**：利用 `ping/pong` 寻找邻居节点，维护自己的“通讯录”。
    
2.  **连接阶段 (TCP + RLPx)**：建立加密的 TCP 连接，确保数据传输的可靠与私密。
    
3.  **传播阶段 (Gossip)**：新交易和区块像“八卦”一样在全网扩散；历史数据则通过点对点请求拉取。
    

### 2\. 链式结构与分叉处理

-   **结构**：区块通过引用“父区块哈希”形成单向链。
    
-   **分叉 (Fork)**：当多名验证者同时产块时产生。以太坊使用 **LMD GHOST** 算法（基于权重/投票）选择主链。
    
-   **最终确定性 (Finality)**：在 PoS 下，当区块获得 2/3 验证者确认（通常需 2 个 Epoch，约 12.8 分钟），该区块即不可篡改。
    

## 五、 同步本质：因果链重组

节点同步是把 **“区块存在（共识）”** 和 **“区块执行（结果）”** 两条线锁在一起的过程：

1.  **共识对齐**：先跟随共识层确定全网公认的最新检查点（Checkpoint）。
    
2.  **执行追赶**：从已确定的安全位置开始，由执行层逐块计算状态，直到追齐进度。
    

## 六、 钱包与 RPC 交互误区

1.  **交互路径**：钱包 **不直接** 参与 P2P 网络，而是通过 **RPC 接口**（如 Infura, Alchemy）与节点通信。
    
2.  **交易流程**：
    
    -   钱包负责：组装交易 -> **私钥签名** -> 发送到 RPC 节点。
        
    -   RPC 节点负责：将签名交易广播到以太坊 P2P 网络。
        
3.  **交易状态**：
    
    -   **Unfinalized**：区块刚被挖出，虽在链上但尚未达到最终确定性，存在极小概率回滚。
        
    -   **Finalized**：已通过 PoS 共识确认，不可篡改。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->







## 1.观看分享会 - 以太坊中文周会 260112

## 2.创建钱包，并尝试测试币转账

领水可能由于ip问题不太顺利，查资料在[Sepolia PoW Faucet](https://sepolia-faucet.pk910.de/#/)这个网站上相当于去挖矿，挖出来一些测试币进行使用。

## 3.在 My First NFT mint 第一个 NFT
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
