---
timezone: UTC+8
---

# Jiaxin Chen

**GitHub ID:** PlutoKirito

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->
# Web3 实战：从所有权理解到 Sepolia 部署

## 一、 理解 ERC-721：链上所有权核心

在区块链世界，所有权由代码定义，具有**清晰、透明、不可篡改**的特性。

| 功能 | 解释 | 核心函数/实现 |
| 所有权归属 | 返回特定 Token ID 的唯一所有者地址。 | ownerOf(tokenId) |
| 余额查询 | 查询特定地址拥有的 NFT 总数。 | balanceOf(address) |
| 转移权限 | 仅所有者或授权地址有权转移资产。 | transferFrom |
| 授权机制 | 授权第三方（如交易平台）操作你的 NFT。 | approve / setApprovalForAll |

* * *

## 二、 部署至 Sepolia 测试网

将合约从本地环境推向公共测试网是迈向生产环境的第一步。

### 1\. 环境配置

-   **修改网络**：打开 `packages/hardhat/hardhat.config.ts`。
    
-   **设置默认网络**：将 `defaultNetwork` 的值更改为 `"sepolia"`。
    

### 2\. 账号准备

-   **生成钱包**：运行 `yarn generate`。这会创建一个本地部署者钱包。
    
-   **安全提醒**：系统提示设置密码时请务必牢记，这用于加密你的私钥。
    
-   **检查余额**：运行 `yarn account` 查看部署地址及 ETH 余额。
    

### 3\. 获取测试币 (Faucet)

部署合约需要消耗 Gas 费。复制你的部署者地址，访问以下“水龙头”领取测试 ETH：

-   [Alchemy Sepolia Faucet](https://sepoliafaucet.com/)
    
-   [Infura Sepolia Faucet](https://www.infura.io/faucet/sepolia)
    

### 4\. 正式部署

确保钱包到账后，执行以下命令将合约发布至 Sepolia：

Bash

```
yarn deploy --network sepolia
```

* * *

## 三、 前端应用上线 (Vercel)

合约上线后，需要部署用户界面（DApp），让全球用户通过浏览器访问。

### 1\. 前端网络适配

-   打开 `packages/nextjs/scaffold.config.ts`。
    
-   将 `targetNetwork` 设置为 `chains.sepolia`。
    

### 2\. 钱包连接

-   应用上线后，需连接真实钱包（如 **MetaMask**）切换至 Sepolia 网络进行交互测试。
    

### 3\. 一键部署

使用 Vercel 托管服务，在终端运行：

Bash

```
yarn vercel
```

根据提示操作完成后，你将获得一个公开的访问 URL。

* * *

## 四、 源码验证：在 Etherscan 上建立信任

部署完成后，通过以下命令验证合约逻辑：

Bash

```
yarn verify --network sepolia
```

### 为什么要验证合约？

-   **透明度**：将 Solidity 源码与区块链上的机器码（字节码）关联，任何人皆可查看逻辑。
    
-   **安全性**：证明合约功能与宣称一致，防止“黑箱操作”。
    
-   **信任背书**：经过验证的合约在 Etherscan 上会显示 **绿色对勾**，这是项目正规化的标志。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->

# Ethernaut ：从逻辑推演到实战破解

## 一、 Ethernaut 的通用解题思维（以 Level 1 Fallback 为例）

面对陌生的合约关卡，建议按以下四个维度进行逆向拆解：

### 1\. 寻找终点：我的目标是什么？

通常 CTF 的终极目的只有两个：

-   **夺取最高权限**：成为 `owner`。
    
-   **清空合约资金**：让 `address(this).balance` 归零。
    

> **本关案例**：发现 `withdraw()` 函数带有 `onlyOwner` 修饰符，且功能是提走所有余额。因此目标锁定为：**“将变量** `owner` **修改为我的地址”。**

### 2\. 寻找修改点：谁能改变状态变量？

在代码中搜索所有 `owner =` 的赋值语句，并评估其可行性：

-   **构造函数**：部署时运行，**Pass**（已过期）。
    
-   `contribute()` **函数**：需要捐款额超过原 Owner（1000 ETH），**Pass**（成本太高）。
    
-   `receive()` **回退函数**：只要触发，就能直接赋值 `owner = msg.sender`。**目标锁定！**
    

### 3\. 破解门槛：触发逻辑是什么？

查看 `receive()` 的 `require` 条件： `require(msg.value > 0 && contributions[msg.sender] > 0);`

-   **条件 A**：`msg.value > 0` —— 必须带点钱转账（1 wei 即可）。
    
-   **条件 B**：`contributions[msg.sender] > 0` —— 我必须在合约里有过捐款记录。
    

### 4\. 制定攻略：执行动作顺序

1.  **动作 1**：调用 `contribute({value: toWei("0.0001")})`，满足“捐款记录 > 0”。
    
2.  **动作 2**：直接向合约地址发送一笔纯转账（1 wei），触发 `receive()`。
    
3.  **结果**：你成为新 Owner，最后执行 `withdraw()` 收割资金。
    

* * *

## 二、 核心漏洞：链上伪随机性

许多关卡涉及到“博弈”或“猜数字”，常见的错误逻辑是利用区块链状态作为随机种子：

Solidity

```
uint256 blockValue = uint256(blockhash(block.number - 1));
uint256 coinFlip = blockValue / factor;
```

### 为什么不可行？

-   **透明性**：区块链上一切皆公开。攻击者合约可以实时读取 `block.number - 1` 的哈希。
    
-   **同步性**：如果在同一个区块中，攻击合约先计算出“必胜”结果，再将结果传入目标合约，胜率是 **100%**。
    

**防御方案**：在 Web3 中获取真随机数，必须使用 **Chainlink VRF** 等预言机方案。

* * *

## 三、 JS 交互必坑指南：`receive` 与 `fallback`

在 Ethernaut 控制台中，`receive()` 或 `fallback()` 函数无法像普通函数那样通过名字调用。

### 1\. 为什么 `contract.receive()` 会报错？

`receive()` 是一个没有名字的“默认备选方案”。它在 ABI 接口中不存在函数名映射，因此 JS 找不到这个方法。

### 2\. 正确触发方式：发送原始交易

要触发没有名字的函数，必须使用 `sendTransaction`，不指定 `data`（即不指定函数签名）时，以太坊会自动寻找 `receive()`。

JavaScript

```
// 在控制台执行以下代码触发 receive()
await contract.sendTransaction({
  value: toWei("0.0001") // 金额必须 > 0
});
```

* * *

## 四、 总结：

> **先看目标函数，后找赋值入口。** **拆解门槛条件，顺序步步为营。** **链上无随机，计算皆透明。** **JS 发交易，无名用 sendTx。**
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->


# Solidity 核心笔记：事件与继承机制

## 一、 事件 (Events)

`event` 是 EVM 日志的抽象，是合约与前端（如 ethers.js）交互的桥梁。

-   **响应性**：前端通过 RPC 接口订阅事件，实时感知链上状态变化。
    
-   **经济性**：事件存储在交易收据的日志中（不可被合约读取），成本远低于状态变量：
    
    -   **事件日志**：约 2,000 Gas。
        
    -   **状态变量**：约 20,000 Gas（新变量存储）。
        

* * *

## 二、 基础继承规则

Solidity 支持单继承和多重继承。

### 1\. 关键字：`virtual` 与 `override`

| 关键字 | 作用 | 适用位置 |
| virtual | 声明该函数/修饰器可以被子合约重写 | 父合约 |
| override | 声明该函数/修饰器正在重写父合约逻辑 | 子合约 |

### 2\. 声明顺序（辈分原则）

在声明继承关系时，必须遵循**由简到繁、从高到低**（从最基础到最派生）的顺序：

-   ✅ **正确**：`contract Erzi is Yeye, Baba { }`
    
-   ❌ **错误**：`contract Erzi is Baba, Yeye { }`（编译报错）
    

* * *

## 三、 多重继承下的函数冲突

当多个父合约拥有同名函数时，子合约必须显式重写并指定所有父合约：

Solidity

```
function hip() public pure override(Yeye, Baba) returns(string memory) {
    return "Erzi";
}
```

> **注意**：修饰器（Modifier）同样支持 `virtual` 和 `override` 继承。

* * *

## 四、 菱形继承与 C3 线性化

**菱形继承**指多个父合约拥有共同祖先。Solidity 通过 **C3 线性化算法** 将复杂的树状结构拉平为单一线性路径，避免重复调用。

### 1\. 线性化路径解析

假设 `God` 是祖先，`Adam` 和 `Eve` 分别继承 `God`，`Human` 继承 `Adam, Eve`：

-   **声明**：`contract Human is Adam, Eve`
    
-   **拉平后的调用链**（从右往左）：`Human` → `Eve` → `Adam` → `God`
    

### 2\. `super` 关键字的威力

在多重继承中使用 `super`，函数调用会沿着上述**线性路径向上寻找下一个合约**，而不是直接跳向祖先。

**调用** `Human.foo()` **的执行顺序演示：**

1.  执行 `Human.foo`
    
2.  `super.foo` 找到声明中最右侧的父合约 `Eve`，执行 `Eve.foo`
    
3.  `Eve.foo` 中的 `super.foo` 找到路径下一站 `Adam`，执行 `Adam.foo`
    
4.  `Adam.foo` 中的 `super.foo` 找到最终祖先 `God`，执行 `God.foo`
    

### 3\. 核心优势

-   **无重复执行**：即使多个父合约都继承自 `God`，`God` 的代码也只会被执行一次。
    
-   **顺序可预测**：通过声明顺序（从左到右）即可推断出执行路径（从右往左）。
    

* * *

## 五、 总结

-   **事件**用于省钱和通知前端。
    
-   **继承**必须先写“爷爷”再写“爸爸”。
    
-   **super** 按照 C3 线性化顺序跳转，它是处理菱形继承、避免代码重复执行的神器。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->



# Solidity：函数与数据存储位置

## 一、 函数定义语法

Solidity 函数的标准声明结构如下：

Solidity

```
function <name>(<params>) {visibility} [mutability] [virtual|override] [<modifiers>] [returns (<types>)] {
    <body>
}
```

### 1\. 可见性说明符 (Visibility)

| 修饰符 | 合约内部调用 | 继承合约调用 | 外部合约/钱包调用 | 说明 |
| public | ✅ | ✅ | ✅ | 默认生成的 Getter 函数也是 public |
| private | ✅ | ❌ | ❌ | 权限最严，子合约不可见 |
| internal | ✅ | ✅ | ❌ | 状态变量的默认可见性 |
| external | ⚠️ | ❌ | ✅ | 内部需通过 this.f() 调用，通常更省 Gas |

### 2\. 状态修饰符 (State Mutability)

决定函数对链上数据的读写权限，直接影响 **Gas 消耗**：

-   **pure**：既不读取也不修改链上状态（如：纯数学计算）。
    
-   **view**：只读不写。可以读取状态变量，但不能修改。
    
-   **payable**：允许函数在调用时接收 ETH。
    
-   **(无修饰符)**：默认类型，可读可写，消耗 Gas。
    

> **Gas 贴士**：前端直接调用 `pure/view` 函数不消耗 Gas；但在合约内部被非 `pure/view` 函数调用时，仍会产生 Gas。

* * *

## 二、 深度解析：Pure vs. View

### 1\. 什么是“修改链上状态”？

只要执行以下操作，就必须支付 Gas，且不能标记为 `view/pure`：

1.  修改状态变量；2. 释放事件 (emit)；3. 创建合约；4. 使用 `selfdestruct`；5. 发送 ETH；6. 调用任何非 `view/pure` 的函数。
    

### 2\. 状态变量 (Storage) 与 函数参数 (Memory)

| 对比项 | 状态变量 (State Var) | 函数参数 (Params) |
| 存储位置 | 区块链上 (Storage) | 内存/栈 (Memory/Stack) |
| 生命周期 | 永久存在 | 仅函数执行期间 |
| Pure 访问 | ❌ 不允许读取 | ✅ 允许读取 |

**💡 密室类比**：

-   **Pure 函数** = 密室里的计算器。
    
-   **状态变量** = 墙外的公告牌（密室看不见，所以不能用）。
    
-   **函数参数** = 你带进密室的小纸条（自己带的，随时可以用）。
    

* * *

## 三、 继承修饰符 (Inheritance)

-   **virtual**：父合约中的函数必须标有 `virtual` 才能被子合约重写。
    
-   **override**：子合约重写父合约函数时，必须使用 `override` 关键字。
    

* * *

## 四、 三大内存结构 (Data Locations)

在处理引用类型（数组、结构体、映射）时，必须明确指定位置。

| 关键字 | 含义 | C 语言类比 | 修改原数据？ |
| storage | 引用。指向链上永久存储的指针。 | int* p = &x | ✅ 会 |
| memory | 复制。在内存中创建临时副本。 | memcpy() | ❌ 不会 |
| calldata | 只读副本。外部参数专用，不可修改。 | const int* | ❌ 不允许改 |

### 代码示例：指针 vs 副本

Solidity

```
uint[] x = [1, 2, 3]; 

function update() public {
    // 情况 A：storage (引用)
    uint[] storage xPtr = x; 
    xPtr[0] = 100; // x 变为 [100, 2, 3]

    // 情况 B：memory (复制)
    uint[] memory xCopy = x; 
    xCopy[1] = 200; // x 依然是 [100, 2, 3]，副本变了但原件没变
}
```

* * *

## 五、 总结与最佳实践

1.  **优先使用** `external`：如果函数只被外部调用，`external` 比 `public` 更节省 Gas。
    
2.  **显式声明**：状态变量默认是 `internal`，但最好手动写出以增强代码可读性。
    
3.  **慎用** `storage`：在函数内部修改 `storage` 变量非常昂贵，如无必要，先在 `memory` 处理后再写回。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->




# ERC-7962：从公开所有权到隐私身份凭证

## 1\. 背景：ERC-721 的隐私困境

-   **核心特征**：完全公开透明。通过 `ownerOf(tokenId)` 可直接查询资产关联的以太坊地址。
    
-   **隐私图谱风险**：攻击者能轻易通过地址关联用户的 NFT、ERC-20 资产及交易历史，描绘精准的“用户画像”。
    
-   **行业痛点**：对于**会员身份**、**医疗凭证**等隐私敏感型资产，ERC-721 的公开性会导致严重的商业隐私泄露。
    

* * *

## 2\. 商业案例：星巴克与机场贵宾厅的“三角困境”

在跨机构验证场景中，三方需求往往互相冲突：

-   **发行方（星巴克）**：需提供权益，但受合规限制不能直接共享会员地址名单。
    
-   **验证方（机场）**：需确认身份，但不想（也不应）存储他人的完整会员数据库。
    
-   **持有者（用户）**：想享受服务，但不希望暴漏名下关联巨额资产的个人地址。
    

* * *

## 3\. ERC-7962 的核心技术解决方案

ERC-7962 借鉴了隐私计算与比特币 UTXO 的思想，引入了两大底层创新：

### 3.1 核心设计一：密钥哈希 (Key Hash) 替代地址

-   **逻辑**：所有权不再绑定 `address`，而是绑定 `Key Hash`（公钥的单向哈希值）。
    
-   **隐私屏障**：由于哈希的**不可逆性**，外界观察者只能看到一串无意义字符，无法反推真实公钥或关联到具体的钱包地址。
    

### 3.2 核心设计二：所有权与交易发起的“解耦”

-   **签名上链**：资产所有者仅需在链下生成一个**数字签名**（表达转移或验证意图）。
    
-   **中继转发 (Relayer)**：签名可由任何第三方（如项目方）提交上链并代付 Gas。
    
-   **验证机制**：智能合约只验证“签名是否匹配 Key Hash”，不再关心 `msg.sender`（交易发起者）是谁。
    

* * *

## 4\. 深度对比：ERC-721 vs. ERC-7962

| 特性维度 | ERC-721 (公开资产) | ERC-7962 (隐私资产) |
| 所有权标识 | 公开的 Address (易被追踪) | 隐藏的 Key Hash (难以关联) |
| 交易发起 | 所有者必须亲自发起并支付 Gas | 所有者签名，由 Relayer 提交并代付 |
| 关联性机制 | 强关联，形成全网公开隐私图谱 | UTXO 式密钥更新，交易后更换 Key Hash，切断追踪路径 |
| 用户门槛 | 高（需持有原生代币、管理 Gas） | 低（Gas 费赞助，Web2 级无感体验） |

* * *

## 5\. Web3 大规模应用的桥梁：UX 的飞跃

ERC-7962 不仅保护隐私，更彻底革新了用户体验，让 Web3 真正走向主流：

1.  **无感 Gas (Gas Sponsorship)**：用户无需在交易所买 ETH 也能转账，项目方可代付费用。
    
2.  **简化交互**：用户只需点击“签名”，无需理解私钥、助记词等底层概念，交互逻辑与 Web2 App 别无二致。
    
3.  **高度灵活性**：天然支持**批量交易**与**账户抽象 (AA)**，极大提升了企业级应用的运营效率。
    

* * *

## 6\. 总结

**ERC-7962** 是连接 Web2 用户与 Web3 世界的关键桥梁。它通过解决“隐私泄露”和“交互繁琐”这两大痛点，将区块链从“极客的公开账本”进化为“大众的隐私数字生活工具”。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->





# Solidity 智能合约

## 一、 语言定义

-   **Solidity**：一种面向合约、静态类型的编程语言，专门用于在 **EVM（以太坊虚拟机）** 上实现智能合约。
    
-   **运行环境**：代码编译为字节码（Bytecode）后部署于链上，由全球节点在 EVM 中并行执行。
    

* * *

## 二、 基础数据类型

### 1\. 数值与地址 (Value Types)

-   **uint256 / int256**：最常用的整数类型（256 位）。`uint` 默认为 `uint256`。
    
-   **address**：20 字节的以太坊地址。`address payable` 额外支持转账方法。
    
-   **bool**：布尔值（`true` / `false`）。
    

### 2\. 复杂类型 (Reference Types)

| 类型 | 描述 | 特点 |
| mapping | mapping(K => V) | 哈希表实现，查询复杂度 $O(1)$，不可遍历。 |
| struct | struct Name { ... } | 用户自定义的复合数据结构。 |
| array | T[] 或 T[k] | 动态或定长数组，支持 push（仅动态）和 length。 |
| enum | enum Status { ... } | 增强代码可读性的枚举类型。 |

* * *

## 三、 函数修饰符 (Modifiers)

### 1\. 可见性 (Visibility)

-   **public**：内部/外部均可访问。
    
-   **private**：仅限当前合约内部。
    
-   **internal**：当前合约及子合约（继承）可见。
    
-   **external**：仅限外部访问（通常处理大数组参数时更省 Gas）。
    

### 2\. 状态修饰符 (State Mutability)

-   **view**：**只读**。读取链上状态但不修改。
    
-   **pure**：**纯计算**。既不读取也不修改链上状态（如数学运算）。
    
-   **payable**：**可支付**。必须标注此项，函数才能接收 ETH。
    
-   **默认**：既读取又修改状态，消耗 Gas 正常。
    

* * *

## 四、 开发范式与安全原则

1.  **状态机模式**：通过 `enum` 管理合约状态（如：`Pending`, `Active`, `Closed`）。
    
2.  **事件驱动 (Events)**：使用 `event` 记录日志，是前端（Web3.js/Ethers.js）监听合约变化的唯一途径。
    
3.  **检查-效果-交互 (CEI)**：
    
    -   先**检查**条件（`require`）。
        
    -   再更新内部**状态**（如减少余额）。
        
    -   最后执行外部**交互**（如转账），以防重入攻击。
        

* * *

## 五、 合约标准结构示例

Solidity

```
// 1. 许可声明与版本号
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 2. 合约定义
contract MyContract {
    // 3. 状态变量 (永久存储在链上)
    uint256 public myNumber;
    address public owner;

    // 事件定义
    event NumberChanged(uint256 newValue);

    // 4. 构造函数 (仅部署时执行一次)
    constructor(uint256 _initialNumber) {
        myNumber = _initialNumber;
        owner = msg.sender;
    }

    // 5. 普通函数
    function setNumber(uint256 _newNumber) public {
        // 权限检查
        require(msg.sender == owner, "Only owner can change number");
        
        myNumber = _newNumber;
        emit NumberChanged(_newNumber); // 触发事件
    }

    // 只读函数示例
    function getDoubleNumber() public view returns (uint256) {
        return myNumber * 2;
    }
}
```
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->






# ERC721 存储逻辑与 Gas 权衡 (Enumerable 深度解析)

## 一、 核心矛盾：Mapping 的“单向盲区”

在标准的 ERC721 合约中，核心数据结构是：

mapping(uint256 => address) private \_owners;

-   **单向索引**：只能实现 **TokenID $\\rightarrow$ Owner** 的查找。
    
-   **链上限制**：Mapping 在 EVM 中不存储键的列表，也不记录长度。这意味着**无法在链上直接获取“某个地址持有的所有 NFT 列表”**。
    
-   **计算代价**：若要在链上强制实现“持有人 $\\rightarrow$ ID 列表”的查询，必须遍历全量 TokenID，Gas 消耗将呈线性增长（$O(n)$），极易触碰区块 Gas 上限导致交易失败。
    

* * *

## 二、 解决方案：ERC721Enumerable 扩展

为了解决查询痛点，OpenZeppelin 提供了 **ERC721Enumerable** 扩展包。

-   **原理**：在 Mapping 基础上，额外维护了多个**动态数组 (Array)** 和**索引映射**。
    
-   **新增接口**：
    
    -   `totalSupply()`：返回当前总发行量。
        
    -   `tokenOfOwnerByIndex(address owner, uint256 index)`：通过索引遍历用户持有的 NFT。
        
    -   `tokenByIndex(uint256 index)`：通过索引遍历全量 NFT。
        

* * *

## 三、 核心权衡：写入成本 vs 读取便利 (The Trade-off)

区块链开发遵循\*\*“能量守恒”\*\*：**查询越方便，写入（状态修改）越昂贵。**

| 维度 | 标准 ERC721 | ERC721 + Enumerable |
| Mint / Transfer Gas | 低（仅需修改 1-2 个 Mapping） | 极高（需同步更新多个数组及索引） |
| 链上查询便利性 | 差（无法直接获取用户列表） | 优（可直接调用接口遍历） |
| 逻辑复杂度 | 简单 | 复杂，增加了状态同步出错的风险 |
| 适用场景 | 高频转账、批量 Mint、Gas 敏感型项目 | 对链上遍历有强需求的特定逻辑（少见） |

* * *

## 四、 现代开发最佳实践：链下索引 (Off-chain Indexing)

随着以太坊生态的成熟，**“为了查询方便而牺牲 Gas”** 已被视为反模式。

1.  **瘦合约 (Slim Contracts)**：去掉 Enumerable 扩展，保持 `mint` 和 `transfer` 的极低成本。
    
2.  **链下索引器**：
    
    -   **The Graph (Subgraphs)**：通过监听合约事件（Transfer），在链下数据库中自动构建“持有人 $\\rightarrow$ TokenID”的对应关系。
        
    -   **中心化 API**：使用 Alchemy、Moralis 或 NFTScan 等提供的 API 直接获取用户资产列表。
        
3.  **结果**：用户在前端（如 OpenSea、钱包）依然能看到完整的 NFT 列表，但无需在每次转账时多交 30%-50% 的 Gas 费。
    

* * *

## 五、 总结：开发者心法

-   **Gas 是稀缺资源**：永远不要在链上做非必要的“列表维护”。
    
-   **异步思维**：链上负责**核心逻辑与确权**，链下负责**数据聚合与展示**。
    
-   **优化方向**：如果项目预期会有大量交易（如百 E 级蓝筹、游戏道具），请果断抛弃 Enumerable，转而使用索引器。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->







# Solidity 编程基础：智能合约开发核心

## 一、 语言定义

-   **定位**：面向合约的高级强类型语言，运行于 **EVM (以太坊虚拟机)**。
    
-   **特性**：语法借鉴 C++ (继承)、Python (修饰符) 和 JavaScript (函数式)，核心在于处理**资产**与**状态**。
    

* * *

## 二、 数据类型 (Data Types)

### 1\. 值类型 (Value Types) —— 传值调用

-   **uint / int**：整数类型。`uint256` 最常用（匹配 EVM 256位字长），`uint` 默认指 `uint256`。
    
-   **bool**：布尔值（`true` / `false`）。
    
-   **address**：20 字节以太坊地址。
    
    -   `address`：基本地址。
        
    -   `address payable`：拥有 `transfer()` 和 `send()` 方法，可接收 ETH。
        

### 2\. 引用类型 (Reference Types) —— 传址调用

-   **Structs**：自定义数据结构，用于封装复杂业务逻辑。
    
-   **Arrays**：包括定长数组和动态数组。
    
-   **Mappings**：`mapping(key => value)`。
    
    -   **特性**：哈希表实现，查询复杂度 $O(1)$，极其高效。
        
    -   **限制**：**不可遍历**，仅存于存储 (Storage) 中。
        

* * *

## 三、 数据位置 (Data Locations) —— Gas 优化的核心

在 Solidity 中，数据存在哪直接决定了交易成本：

| 位置 | 存储性质 | Gas 成本 | 说明 |
| Storage | 永久存储 (链上) | 极高 | 类比硬盘，修改状态变量时使用。 |
| Memory | 临时存储 (内存) | 较低 | 类比 RAM，函数执行完即销毁。 |
| Calldata | 临时存储 (只读) | 最低 | 外部函数参数专用，不可修改，最省 Gas。 |

* * *

## 四、 函数详解 (Functions)

### 1\. 可见性修饰符 (Visibility)

-   **public**：内外皆可访问。
    
-   **external**：仅外部访问。读取大数组参数时比 `public` 更省 Gas。
    
-   **internal**：仅当前合约及子合约可见。
    
-   **private**：仅当前合约可见。
    

### 2\. 状态修饰符 (Mutability)

-   **view**：只读不写（不修改状态变量）。
    
-   **pure**：不读不写（如纯数学运算）。
    
-   **payable**：必须加此关键字，函数才能接收 ETH。
    

* * *

## 五、 错误处理与安全 (Error Handling)

Solidity 遵循**原子性**：一旦触发回滚，所有状态更改都会撤销。

-   **require(bool, string)**：**最常用**。用于校验输入或执行前提，失败则回滚并退还剩余 Gas。
    
-   **revert()**：处理复杂的逻辑跳转，手动触发回滚。
    
-   **assert(bool)**：用于检查内部变量的一致性，失败通常意味着合约有重大 Bug（会耗尽所有 Gas）。
    
-   **Custom Errors (0.8.4+)**：`error InsufficientBalance();`。比 `require` 的字符串描述更省 Gas，推荐使用。
    

* * *

## 六、 现代 Solidity 必备概念

-   **Constructor**：仅在部署时运行一次的初始化函数。
    
-   **Events**：合约与前端/后端交互的桥梁，数据存储在廉价的“日志”中（不可被合约读取）。
    
-   **Modifiers**：函数修改器，常用于鉴权（如 `onlyOwner`）。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->








## 一、 全球主流加密监管框架对比

### 1\. 欧盟：MiCA (最全、最具示范性)

-   **核心内容**：统一欧盟境内的 **CASP (加密资产服务提供商)** 许可制，允许“一证通行”跨境运营。
    
-   **稳定币监管**：严格的储备金与赎回机制（资产参考代币/电子货币代币）。
    
-   **诉求**：构建单一市场，消除碎片化，防范系统性金融风险。
    

### 2\. 美国：GENIUS & STABLE Act (聚焦稳定币)

-   **核心内容**：将稳定币纳入联邦监管，强制 **1:1 全额储备**（美元或美债）。
    
-   **监管格局**：明确 SEC 与 CFTC 的分工，补齐国会立法空白。
    
-   **诉求**：保护美元金融主权，填补监管碎片化带来的不确定性。
    

### 3\. 新加坡与香港：亚洲金融枢纽

-   **新加坡 (PSA)**：以《支付服务法》为基础，MAS 主导，强调 **FATF 接轨 (Travel Rule)** 与创新平衡。
    
-   **香港 (VASP/稳定币条例)**：强制本地实体设立、资本要求与储备隔离，志在打造全球数字金融中心。
    

### 核心地区对比表

| 地区 | 代表法规 | 监管核心 | 推动主因 |
| 欧盟 | MiCA | CASP 统一许可、披露义务 | 市场一体化、风险隔离 |
| 美国 | GENIUS Act | 稳定币联邦化、全额储备 | 维护金融主权与稳定性 |
| 新加坡 | PSA | 数字支付令牌许可、AML/CFT | 创新与安全双驱动 |
| 香港 | 虚拟资产条例 | 交易所/稳定币双许可、储备隔离 | 争夺数字金融枢纽地位 |

* * *

## 二、 加密资产税务合规：从匿名到透明

### 1\. 国际框架：OECD CARF

-   **本质**：加密资产版 CRS。要求 CASP 自动收集并交换用户身份、交易与转移信息。
    
-   **目标**：消除利用加密资产进行的跨国逃税，实现“同债同标”。
    

### 2\. 各国实践

-   **欧盟 (DAC8)**：与 MiCA 并行，强制成员国间自动交换加密资产交易数据。
    
-   **美国 (IRS)**：将资产定义为 **“财产 (Property)”**而非货币，买卖/挖矿/利息均触发税务。
    
-   **港新中心**：不对资本利得征税，但对“经营性收入”征收利得税/所得税。
    

* * *

## 三、 数字资产与数据要素：新型生产关系

### 1\. 欧盟：制度先行

-   **GDPR**：确立数据所有权与保护。
    
-   **Data Act**：明确数据使用权，激活工业与 IoT 数据要素流通。
    
-   **DLT Pilot Regime**：支持链上资产证券化（RWA）合规实验。
    

### 2\. 中国：要素驱动

-   **定位**：将数据列为与土地、资本并列的 **“第五大生产要素”**。
    
-   **现状**：推进数据确权、定价，通过北数所、深数所建立市场化交易体系。
    

### 3\. 美国：市场驱动

-   无统一数据法，依靠行业法（如医疗、金融）与州法（如 CCPA）进行碎片化监管。
    

* * *

## 四、 交叉合规总结：三重合流趋势

> **金融合规**（洗钱/融资）+ **税务合规**（申报/逃税）+ **数据合规**（确权/隐私）

1.  **实名化**：链上地址正演变为“准实名金融账户”，匿名性被合规压力大幅稀释。
    
2.  **资产化**：加密资产正从技术实验全面进入主流财务报告与征税体系。
    
3.  **标准化**：各国监管逻辑正从“沙盒实验”转向“全面许可”与“风险管理”。
    

一句话总结：

合规不再是“补丁”，而是 Web3 项目进入主流金融体系的准入证。税务解决“国家受益”，要素条例解决“分配效率”，二者共同推动 Web3 进入法治时代。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->









## 不点！不签！不装！不转！

## 一、 Web3 安全：攻防新态势

2025 年安全事故依然频发，整体损失维持在 **数十亿美元** 级别，攻击呈现“两极分化”趋势。

### 1\. 两大主流攻击路径

-   **精准猎杀（针对机构/大户）**：由国家级黑客或高级黑客组织主导。长期潜伏供应链，通过前端劫持（如 **Bybit** 案例）或合约深度漏洞（如 **Sonne Finance**）实施致命一击。
    
-   **广撒网（针对散户）**：利用 AI 批量生成钓鱼网站、虚假项目，靠规模化获利。
    

### 2\. 2025 核心新风险

-   **AI 深度威胁**：Deepfake 视频会议诈骗常态化；AI 被用于快速挖掘合约零日漏洞（0-day）。
    
-   **隐蔽钓鱼**：利用“地址合约化”等新协议特性掩盖恶意签名；**地址投毒**专骗依赖交易记录复制地址的用户。
    
-   **供应链后门**：在 AI 辅助编程时代，恶意插件和第三方代码依赖库成为新的隐蔽入口。
    

### 3\. 用户防御四字诀

> 不乱点（链接）、不盲签（权限）、不乱装（插件/软件）、不急转（核实地址）。
> 
> 核心逻辑：冷热钱包分离，私钥物理隔绝。

* * *

## 二、 Web3 合规：从形式到本质

Web3 合规不是新学科，其核心依然是 **金融合规**。

### 1\. 两个维度的合规

| 维度 | 核心内容 | 局限性 |
| 形式合规 (表面) | 合同、白皮书避开“保本/融资/收益承诺”，对齐 FATF/MiCA 框架。 | 仅能规避初级监管，无法在出事时作为“免死金牌”。 |
| 实质合规 (核心) | 业务逻辑不踩红线：不搞 ICO、不服中、远离赌博/洗钱、具备真实技术服务支撑。 | 决定了项目能否长久运行，是防范刑事风险的关键。 |

* * *

## 三、 从业者现实生存指南

### 1\. 项目成色判断

-   **合规红线**：看官网是否直连、是否允许大陆身份认证（KYC）。
    
-   **业务烈度**：合约、期权、高杠杆业务的法律风险远高于现货或基础设施。
    
-   **牌照祛魅**：有牌照不代表绝对安全，需看牌照的**业务许可范围**。
    

### 2\. 个人劳动保障

-   **主体风险**：纯境外主体合同在境内维权难度极大。
    
-   **薪资风险**：境内仲裁基本不认可“数字货币”作为工资，建议争取部分法币结算。
    
-   **岗位避险**：技术、行政岗位的法律风险通常低于直接接触资金与获客的业务岗。
    

### 3\. 出金与司法调查

-   **渠道选择**：首选香港合规持牌渠道；小额可使用合规 U 卡；严禁使用 OTC 导致账户被封。
    
-   **危机处理**：
    
    1.  **证据保全**：保留完整的合法收入证明。
        
    2.  **专业介入**：情况复杂时**先找律师**，不要盲目自行解释。
        
    3.  **协同解冻**：在配合退赔时，务必争取同步解除银行账户冻结。
        

* * *

## 四、 新人保命三原则

1.  **底线意识**：绝不触碰明显踩线的业务（如非法集资、洗钱）。
    
2.  **不作恶**：产品逻辑的清白比合规文本的精美更重要。
    
3.  **专家咨询**：在做出涉及大额资金或业务转向的决策前，**先行咨询律师**。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->










## 一、核心概念辨析

-   **区块 (Block)**：实际存储交易数据和状态的“账本页”。
    
-   **节点 (Node)**：运行客户端软件并接入以太坊网络的物理计算机/服务器。
    
-   **客户端 (Client)**：实现以太坊协议的具体**软件实现**。节点通过运行客户端来下载、验证并保存区块。
    

## 二、 节点架构：执行与共识 (Post-Merge)

在 PoS 时代，一个“完整节点”必须同时运行两种客户端，两者通过 **Engine API** 通信。

-   **执行客户端 (EL, Execution Layer)**：
    
    -   **职责**：处理交易执行、维护以太坊状态（EVM）、管理智能合约。
        
    -   **关注点**：区块里的交易做了什么？状态转换是否正确？
        
-   **共识客户端 (CL, Consensus Layer)**：
    
    -   **职责**：运行 PoS 共识算法，负责区块的广播、验证及最终确定性（Finality）。
        
    -   **关注点**：哪个区块是全网公认的“真链”？
        

> **隔离意义**：将复杂的交易逻辑与共识逻辑解耦，增强安全性，某一方崩溃不会导致另一方数据损坏。

## 三、 节点类型

| 类型 | 存储数据 | 验证功能 | 适用场景 |
| 全节点 (Full Node) | 存储最近状态，按需裁剪历史数据 | 完全验证所有区块与交易 | 大多数日常应用、质押 |
| 归档节点 (Archive Node) | 存储自创世块以来的所有历史状态 | 完全验证 | 区块浏览器、链上数据分析 |
| 轻节点 (Light Node) | 仅存储区块头 (Headers) | 仅验证特定交易的有效性 | 移动端、资源受限设备 |

## 四、 网络通信与区块同步

### 1\. 节点互联三部曲

1.  **发现阶段 (UDP + Kademlia)**：利用 `ping/pong` 寻找邻居节点，维护自己的“通讯录”。
    
2.  **连接阶段 (TCP + RLPx)**：建立加密的 TCP 连接，确保数据传输的可靠与私密。
    
3.  **传播阶段 (Gossip)**：新交易和区块像“八卦”一样在全网扩散；历史数据则通过点对点请求拉取。
    

### 2\. 链式结构与分叉处理

-   **结构**：区块通过引用“父区块哈希”形成单向链。
    
-   **分叉 (Fork)**：当多名验证者同时产块时产生。以太坊使用 **LMD GHOST** 算法（基于权重/投票）选择主链。
    
-   **最终确定性 (Finality)**：在 PoS 下，当区块获得 2/3 验证者确认（通常需 2 个 Epoch，约 12.8 分钟），该区块即不可篡改。
    

## 五、 同步本质：因果链重组

节点同步是把 **“区块存在（共识）”** 和 **“区块执行（结果）”** 两条线锁在一起的过程：

1.  **共识对齐**：先跟随共识层确定全网公认的最新检查点（Checkpoint）。
    
2.  **执行追赶**：从已确定的安全位置开始，由执行层逐块计算状态，直到追齐进度。
    

## 六、 钱包与 RPC 交互误区

1.  **交互路径**：钱包 **不直接** 参与 P2P 网络，而是通过 **RPC 接口**（如 Infura, Alchemy）与节点通信。
    
2.  **交易流程**：
    
    -   钱包负责：组装交易 -> **私钥签名** -> 发送到 RPC 节点。
        
    -   RPC 节点负责：将签名交易广播到以太坊 P2P 网络。
        
3.  **交易状态**：
    
    -   **Unfinalized**：区块刚被挖出，虽在链上但尚未达到最终确定性，存在极小概率回滚。
        
    -   **Finalized**：已通过 PoS 共识确认，不可篡改。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->











## 1.观看分享会 - 以太坊中文周会 260112

## 2.创建钱包，并尝试测试币转账

领水可能由于ip问题不太顺利，查资料在[Sepolia PoW Faucet](https://sepolia-faucet.pk910.de/#/)这个网站上相当于去挖矿，挖出来一些测试币进行使用。

## 3.在 My First NFT mint 第一个 NFT
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
