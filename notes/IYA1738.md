---
timezone: UTC+8
---

# IYA1738

**GitHub ID:** IYA1738

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
今天把整个 staking 模块从头跑了一遍，结果意外发现几个容易被忽略的小坑，记录一下免得以后再踩。

第一个问题是 accRewardPerShare 的语义一定要保持干净。它代表的是“单位质押量对应的累积奖励”，不是“这段时间产出了多少 token”。我最初的版本里把 rewardDelta 直接加进 acc，然后后面又除一次 totalStaked，相当于把两种概念混在一起。逻辑看起来没崩，但会计意义直接对不上，尤其在新用户进场和老用户持仓变化时，会出现不该被吃掉的奖励被吃掉、或者 rewardDebt 对不齐的情况。

第二个坑出现在 rewardDebt 的同步时机上。如果用户在 unstake 后 rewardDebt 不立即对齐，那下一次 settle 会用“旧的 rewardDebt × 新的 stakeAmount”进行计算。表现出来就是 pending 多算一段，纯粹因为变量不是同一时刻更新的。这个问题比较隐蔽，光看公式看不出来，一跑流程就明显出错。

第三个是时间边界。一开始没认真处理 endTime，导致 period 结束后奖励仍然在往外释放；没处理 totalStaked==0，又会出现没人质押但奖励曲线继续往前走的情况。单独看都能解释通，但组合在一起会让整个模型变得很奇怪。最后是 view 层，如果不在读取时模拟一次 update，前端看到的 pending 会一直落后真实状态半拍，看起来像奖励没在增长。

整体下来，staking 的难点倒不是公式，而是每个变量的语义必须严格对齐，更新顺序必须完全一致，否则只要有一处时间点不统一，整个奖励分配就会偏一段。今天算是把这些地方全都重新校了一遍，之后应该不会再踩了。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

今天随手看了个合约的 _safeMint 扩展逻辑，结果又发现一个特别诡异的点：_beforeTokenTransfer 里做余额检查真的能把自己玩死。因为 ERC721 转账流程是 before → storage 更新 → after，有些人喜欢在 before 里做“限制当前余额”“限制当前 owner 状态”这种业务判断，结果一旦某些合约用 safeTransferFrom 搭配回调、或 batch mint、或 operator 代操作，before 看到的是“没更新前的状态”，以为这里能拦住异常状态，实际上组合起来会直接 bypass 判断。更阴间的是，如果在 before 里连 allowance／授权检查都自定义覆盖掉，那 operator 转移会出现“检查通过但实际 owner 还没更新”的奇怪过渡态，导致多次转移路径里出现 ghost owner，一眼看上去相当奇怪。总之，ERC721 的 before/after 钩子千万不能拿来当 “真实状态校验”，它处理的是“即将发生的动作”，不是“当前已发生的状态”，写过头了真的会把自己绕晕。
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->


今天看了一下 ERC20 + Permit 的代币，结果发现这个东西也挺容易踩坑的，顺手记录一下今天遇到的几个点，免得以后再坑自己。

1.  Permit 的 nonce 管理非常容易写错。
    
    标准要求每次成功签名执行都必须自增 nonce，但实现上很容易在两个地方写成先读再存或者忘记自增，导致重放攻击风险。另外注意一点，nonces\[owner\]++ 必须在所有校验通过后执行，否则出现验证失败但 nonce 升了的诡异状态。
    
2.  Deadline 的逻辑不要写反。
    
    Permit 里的 require(block.timestamp <= deadline) 和 >= 很多人肉眼一飘就写错。
    
    一旦方向写反，permit 会直接永不过期或永远过期，这类 bug 提交到测试网根本不容易被人立刻发现，因为多数人不会测极限 timestamp。
    
3.  DOMAIN\_SEPARATOR 不能偷懒硬编码。
    
    在链上环境可能遇到 fork、chainId 变化（比如 L2 上特别明显），如果合约选择 lazy load 的 domain separator，就要把 chainId 缓存逻辑写正确。尤其是 EIP712 要求的计算方式，一旦 chainId 换了但合约没更新，会导致所有签名全部 invalid。
    
4.  owner == spender 的 permit 要特别处理。
    
    标准允许同一个地址给自己授权，逻辑上没问题，但实际实现时如果 allowance 写法不小心绕过了检查，可能导致 allowance 无限叠加。大多数实现不会出问题，但自写的时候确实容易忘记 owner==spender 的特殊性。
    

Permit 完成后 allowance 更新要注意两种情况。

需要区分：

1.  类似 USDC/DAI 的“覆盖式” allowance：permit 会直接将 allowance 设置为指定值。
    
2.  ERC20 的“追加式” allowance：写错很容易变成无限增加模式。
    
    一旦业务逻辑错了，后续 transferFrom 就会出现完全意料之外的结果
    

整体总结一下：Permit 看起来是个很基础的扩展，但里面细节多、变量多、分支多，且大部分 bug 都很隐蔽，写的时候一定要逐行确认规范，不然非常容易在一些以为不会出错的地方翻车一次。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->



今天写了个治理代币，还挺容易写错的其实，记录一下今天的踩坑点。  
1.转移票权时，要兼顾到代币转移，销毁、铸造、委托，写的时候要注意每个地方都要更新票权，忘一个地方整个治理代币就崩了，但偏偏很容易忘记，要多加注意。  
2.delegatee的初始化选择，这个方面需要根据设计选择来定，而不是只能一个固定方案，通常分为两种方案.  
1): 不初始化， mapping(address => address) delegatees中每个key都先对应address(0), 用户第一次做交互前需要先调一次delegate才能进行操作，compound的治理采取的就是这种模式。  
2): 交互时检查初始化，如果没有初始化就先把delegatee设置为自己，在这个场景下，用户不需要先调delegate，可以给到更好的用户体验感，但是缺点就是每次交互时都要进行检查，gas消耗比较大，如果是高频率大批量投票的话，这个方案就不太好。并且这个方案是没法把delegatee设置为address(0)来作为放弃票权的，只能走burn来销毁票权，如果采取方法二的情况下设置delegatee为address(0)，也会导致整个账本乱掉。  
3\. 这里的二分是可以优化的，和算法竞赛直接打个二分模板不一样，由于checkpoint的fromBlock在治理代币的机制规则下必然是单调递增,所以应该先检查最后一个checkpoint是否直接大于投票的区块，是的话就直接return 0，说明最早有票的时候都晚于要求的区块，反过来也是一样。  
4.做票权账本更新的时候要注意，什么地方用delegatee，什么地方用balanceOf(holder), 变量多的时候很容易用错，所以要每次用这俩变量的时候都要记得，多数票权会变化的地方都是delegatee，只有setDelegate的时候才需要balanceOf来拿总票权的数量，balanceOf主要还是走ERC20相关的业务时才需要考虑。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->




今天看到做meta-transaction的gas relayer的forwarder合约中的这段代码

```solidity
if (gasLeft < request.gas / 63) {
            assembly {
                invalid()
            }
        }
```

本来以为63是什么Magic value，问了下GPT知道，原来这是EIP150,也就是63/64法则。  
假设当前有一条调用链EOA => 合约A => 合约B,开始时EOA为这笔支付给了1000Gas  
那么根据EIP150，每次调用时转发给后面合约的Gas不会是当前剩下的所有Gas，而是floor(leftGas \* 63 / 64), 也就是有1/64是会被EVM拿走，拿走之后也并不会分配，而是直接销毁掉。这样的效果就是，函数不能过于大量递归来侵占资源，在一些调用后很快就会被抽光Gas导致OOG。  

而为什么类似于forwarder之类的合约会使用这样的判断呢，目的就是看看此时剩余的Gas是否充足，有没有被target用掉太多Gas导致forwarder自己后续的逻辑无法执行，如果剩余的Gas已经非常少了, 那么就用assembly和invalid()来提前终止掉，并把交易回滚。选择用这俩的原因也是因为gas消耗低，防止连终止都发不出来
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->





ERC4626记账问题:  
今天审计的Vault合约就太熟了，因为有做Vault的经验，非常快就能发现到以下合约代码中的问题

```solidity
if (convertToShares(totalSupply) != balanceBefore)
            revert InvalidBalance(); // enforce ERC4626 requirement
```

如果希望保持这样的不变量关系，必须内部维护余额账本，因为通常的ERC4626实现取asset都是使用如下代码

```
function totalAsset() public view returns(uint256){
  return IERC20(asset).balanceOf(address(this));
}
```

攻击者直接转任意数量代币到vault中(不通过deposit()), 此时会导致supply没增加，但是asset增加，最终导致这个校验永远revert。而此功能为闪电贷调用，这意味着这项业务功能会被轻易的攻击导致瘫痪。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->






今天看Certik给Venus的审计报告里学到一些之前在可升级合约中没有注意过的东西。  
首先我们知道最常见的namespace写法是在ERC1967中给的实现合约SLOT,也就是这样

```
bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
```

与此同时oz方案有时候会这样写:

```
keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) 
```

相当于多做了一次keccak256来把hash值变换得更自然hash的样子  
而ERC7201，需要写成这样子

```
keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))
```

去做& ~bytes32(uint256(0xff))的结果是将hash的最低位的8个bits置0，核心目的是为了扩展性，在实用中假设起始slot经过上述变换后成为了0x123...ab, 接下来如果写新的slot的话，将会使用到0x123...ab+1。而ERC7201要求将所有namespace的最低8位都置为0，也就是至少需要从0x123.....00写到0x123......ff才能跳到"下一页"，来避免跳到别的namespace的slot去。这个可扩展的slot长度显然为0xff, 99%合约不会用超过20个slot，因此显然是够用的。而前248位由于是来自于多重keccak256，也就是这种情况下前面的hash完全相同的概率近似于1/2^248, 因此可以忽略不计。实际上在生产场景下，这个防碰撞的效果是微乎其微的，但是我们无法从数学角度形式化证明hash结果绝对不会碰撞，因此ERC7201的Slot扩展方法就是为了进一步防止这种超低概率事件的发生。  
  
TStore/Tload, 在看Venus审计报告的过程中，看到他们的ReentrancyGuardTrensient合约，这是一个Gas成本更低的ReentrancyGuard，核心是引入了EIP1153中提出的TStore和Tload。mstore和mload的数据只在当前call frame中可见，每次call和delegatecall都会有新的call frame，但是等回调的时候已经是新call frame了，所以mstore和mload做不了reentrancyGuard，因此传统方法都是使用sstore和sload，但问题是这两个opcode的成本很高。而tstore和tload在于它们是同交易的读写指令，生命周期为一个tx，并且opcode的gas花费显著低于sstore和sload，但是又能做到防reentrancy的所有需求，因为ReentrancyGuard的业务范围也是单tx的。本质上ReentrancyGuardTrensient就是用ERC1802这种namespace模式给定这个写标记的slot，然后用tstore和tload来在这个slot中进行读写来做重入锁，然后tx结束后自动回收slot中的数据。但是当前solidity并没有给出高级调用，因此还需要使用assembly inline或者自己把YUL代码包装成一个函数，solidity 0.9.0开始也许就支持了吧。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->







今天学会了用**solidity-code-metrics**这个智能合约分析工具，solidity-code-metrics 本质上是一个用来评估 Solidity 项目工程健康度的分析工具。它通过统计代码规模、结构与复杂度，帮助审计快速判断一个项目的审计工作量、潜在风险点和优先关注区域。  
还看了前openzeppelin首席审计员tincho的审计过程教学，吸取了例如审计前最好去开发团队网站或介绍文档中看看产品功能等审计习惯，因为这样可以更好的直观了解系统功能，而不是每次都靠自己看合约去判断功能是什么。  
差不多就是这样，今天学习的都是工具操作类和工作SOP类的东西，和EVM理论知识不太相关，比较难写笔记，但是也是学到不少东西的一天
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->








今天周末所以没做审计，稍微歇一歇，来了解了一下几个比较冷门的ERC/EIP。  
ERC4907,主要的设计目的是完成可租赁的NFT，在ERC721中，只有Owner的概念，如果想租赁NFT的话得在到期前让租赁者transfer回来，但是ERC4907加入了两个字段，一个是address user另一个是uint64 expires,在expires到期时自动将user置为address(0), 而从始至终的owner都是原owner，这样可以很方便的做到所有权可控。  
ERC3525, 主要功能是可以做许多金融衍生品的操作，主要分为slot, tokenId, amount.在一开始学习这个概念的时候感觉，这不就是和ERC1155差不多嘛，但是仔细研究后发现是不一样的，ERC1155主要是做同一个物品但是允许有多个数量，就像GameFi中可能要去表示100瓶药水，10把剑这种同一物品不同的数量。而ERC3525的slot限定了品类，例如期权，债券。而tokenID可以是持有者的所有权证明，而amount就对应了数量。例如solv protocol是可以做金融衍生品打包交易的，那么可以考虑某团队将vesting reward通过solv protocol打包成债券形式。此时的slot是例如该protocol的核心团队三个月的vesting reward，tokenId是团队各成员的权益证明，而amount就是他们持有的份额，并且这个amount是可分割可转让的。  
ERC721A，这个是在做Mint Fitst NFT任务后，后面看了一下Web3实习计划官方出品的这个NFT合约，和ERC721的本质区别就在于不再继续维护一个mapping去映射NFT和owner的关系，而是采用在一段连续编号的ID中，在第一个ID留下owner的地址， 找owner的时候就输入当前NFT的ID，然后不断递减直到找到有owner的那一个NFT，把那个NFT的owner作为当前的owner。所以也引出一个问题，在transfer之后需要记得给transfer的那个ID加上新owner的地址，也就是类似于给这一段打上一个断点，否则会找错owner。这个模式的好处就在于适合批量铸造，因为ERC721每次铸造都要写一遍tokenId和owner的映射，这就导致价格比较昂贵，而当前模式下无论mint多少，都只需要写一次tokenId和owner的映射关系。但是对于这个任务的场景来说，由于限制了每个人都只能进行一次Mint，所以使用ERC721A是意义不大的，可以直接用ERC721就好了。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->









今天开始开始接触了形式化验证，希望接下来的bootcamp时间里可以学会基本的形式化验证吧。  
周末学得不算多，主要以了解基础为主。  
首先是区别于常规的单元测试和fuzzing测试，形式化验证是采用数学验证的方式保证所有路径在数学性质上必然不会失效。用在一些容易量化的场景下非常好用，例如验证复杂Staking系统中用户可领永远不超过设定的奖励阈值，或者Lending协议中永远不会出现费率倒挂(例如借款利率必然高于提供LP的利率，否则用户直接借出钱来存钱套利)。  
形式化验证主要分为建模，写spec语言定义规则，求解。个人感觉最重要的就是建模了，因为在复杂Defi协议中，如何正确建模数学模型其实是非常困难的。  
目前求解器选择的是certora prover，接下来会继续分享certora的spec语法学习。  
小tips：建模形式化验证时，可以把需要验证的合约拆成harness，即包含需要测试的性质所需的最小合约，这样可以大幅减少复杂度，代码量，并加快prover收敛速度。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->










今天发现相同的行为由不同端承担风险就会从协议的正常行为变成攻击行为。  
例如说交易聚合器多跳，在uniswap之类的协议的swapRouter类的合约中，实际上是没有必要对每一跳进行校验的，因为协议默认这是用户的正常行为，假设说用户拿自己的钱去烂池子里换token，或者说故意拉歪流动性池价格(用户将要自行承担存入另外一个资产来拉歪价格或自己走闪电贷拉歪价格，此时风险在用户端)，然后再拿离谱的价格去剩余跳中换其他的价值币，这样的行为是router所允许的，因为router只在乎执行输入的path和最后检测一下amountMinOut。流动性池和AMM池之类的价格拉歪不是Router的责任，因此在审计中通常也没必要把这样的问题标Risk  
但如果说交易聚合的函数并不是一个只负责执行的交易聚合器，而是协议的一部分并且使用了协议自己的资产先去换资产，并且用户还可以自行构造交易路径等参数。那么此时最好加上白名单token，path中只允许白名单token(根据设计取舍)，但sanity check和oracle check是必须要的，通常通过多源TWAP来check。如果没有检查，此时可以考虑给critical或high risk  
实际上这两个函数在实现上几乎是一模一样的，但承担风险的角色不一样的时候，审计的角度和开发应该做的防护是不一样的。这是我觉得今天总结的最核心的原则。  
除去技术相关的问题以外，今天还有感触就是其实需要对大产品去魅，今天看了下pancakeSwap的审计报告，关于syrup token做得确实有够差，高度怀疑是当年抄代码但是没抄明白，抄下来没有理解设计机制后用错了，从而导致syrup失去治理功能了(主要问题出在\_moveDelegateeVotes的参数错误上)。算是印证了DYOR的原则。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->











今天有点发烧，没怎么做很多事情，只有一些比较简单的东西来记录一下。  
今天审了份ERC20相关的合约。发觉到其实许多的ERC20代币都有高中心化风险，因为ERC20在没有丢弃权限时，很多时Mint权限是在某个地址上的。结合昨天Web3安全分享会中老师分享的Safe被劫持的事件，以下是一些小的见解。  
在许多项目中，项目方不丢弃权限但是会采用多签钱包去控制权限。在昨天的分享会之前，实际上我也认为多签+时间锁已经足够安全了，但是昨天的会议中得知，多签也会有问题，这就意味着这个路径有一定风险，应该归为Low-Risk(如果单钱包权限是High-RIsk的话)。  
那么在目前最安全的做法应该要是DAO+时间锁+挑战期(如果不考虑操作时效的话), 因为即使是多签，仍然有多签的所有人员都被定向劫持了钱包。但攻击者无法劫持这么多DAO成员的钱包去做投票，最终的执行者钱包需要先校验DAO提案是否通过，如果DAO提案通过的话，再由多签钱包负责执行。那么在这样的流程中，相对DAO而言比较中心化的多签钱包只能做执行，而不能随心所欲的操作，这个时候就能有效减少作恶风险了。  
目前来说是这么思考的，等不发烧了再来仔细思考一下会发生的其他side-effect和应该如何防范。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->












今天在做一些自己的事情，由于我的工作是智能合约审计，因此记录一下今天审计带来的一些开发时的思考。  
  
审计目标是一份借贷协议的controller, 也是这个协议的entry point.其中的分桶抵押机制，也就是稳定抵押品只能借出高波动难清算的抵押品，反之亦然。项目方的目的是为了防止高波动资产能作为抵押高波动抵押品的情况。  
  
现假设稳定抵押品为A，高波动抵押品为B，A的有效担保抵押价值为cA，稳定抵押品和高波动抵押品的风险因子分别为rA，rB。  
此协议的问题在于，正确做法下取出A时，要么减少cA，要么提高rB，但是开发者提高了rA。  
攻击者可以存入大量A来提高rB，从而借出大量的B，然后抽走抵押的A，此时的rB不变，再重复存入A，进一步推高rB，等到rB允许借出池中所有B时，此时攻击者存入池中的A的抵押价值远小于此时攻击者借走的B，这个时候直接不还借走的B，赔偿抵押的A，攻击者就偷走了资产把坏账留给了B池。由于操作都在同块进行，而抵押率不足的清算需要等价格在下一块更新后才能清算，因此攻击者用少量A借出大量B的行为也不会被清算，等清算的时候攻击已经完成了。  
  
总结的开发者应该注意的点有几个：  
1.注意拼写，尤其是命名近似且相同数据类型相同场景下使用的数据容易写错导致严重漏洞，但是编译器并不会报错，在不涉及当前路径的操作中，也难以发现漏洞。  
2.用户可组合操作资金的功能可以考虑跨块执行，避免同块执行，避免预言机离散更新的间隔导致整个协议的攻击面扩大。可以考虑加入cooldownBlock或cooldownTimeStamp(抵押借贷等场景推荐cooldownBlock)来禁止同块执行或大于预言机时间更新窗口(但加入这一防护后无法使用闪电贷)。这一举措可以减少整个协议的闪电贷攻击风险与清算不及时的风险。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->













今天的co-learning有在听到讨论DAO治理怎么样公平。其实很难去有一个完全公平的体制。  
但是之前有想过一个DAO架构，1token1票，但是权重根据token越多增长得越少，相当于给巨鲸加入了一个边际递减。  
与此同时，给每个地址去量化当前地址的声誉与贡献，也加入投票的权重中，避免巨鲸可以把大量token分散到多个地址来绕过token数量带来权重影响的边际递减。  
再在这个时候在有一定质押量的地址中随机抽取12个（也可以更多），作为公民裁决团。  
大致的架构就是DAO成员根据上述的权重计算规则先投一次票，再看公民裁决团投票之前的DAO成员投票是否合理。  
但这里又引入了新的问题，如何保证公民裁决团不会投票冷漠？如何保证公民裁决团不会串通好然后在本次投票形成新的寡头层？如果巨鲸通过钱让很多人创建很多钱包，然后被选上公民裁决团的几率比普通公民大怎么办？  
所以其实仍然是有很多的问题，但对于一个更好的体制，目前确实是没有一个准确的答案。  
但是XiaoHai老师讲到的一个例子让我觉得非常有道理，那就是ETH的硬分叉。  
仔细思考过后我认为，这一点确实是民主的保障。民主很多时候都是由大多数人的共识确立的，让多数人满意了。  
但是问题是，那其他人的想法该怎么办？遵从了多数人的想法后，是不是一种对意见不同的人的少数人的剥削？  
所以此时一个退出机制就很重要，这个退出机制是让不同意当前主流共识的人可以尽量低成本无惩罚的去离开当前的体制，建立自己的体制。也就是我们需要先承认有一些分歧是不可调和的，此时我们需要保障少数人的意见仍然可以生效，那就硬分叉咯。就像民主国家也不能靠投票来保证每个人都满意，但是文明国家都不会限制移民，如果你对体制不满，你可以直接不和这个体制玩了。  
所以我觉得以太坊硬分叉的理念确实是体现了一个非常重要的民主举措。但是到底什么是真正公正的制度，还是需要继续思考。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->














今天参与了Co- Learning会议，感觉受益匪浅呢。以前没有关注过以太坊的每个层，听完同学们提的问题后研究了一下。  
  
共识层并不知道什么是EVM，什么是智能合约，它只保证区块的有效性合法性。  
  
而执行层应该是可以概括为负责状态的转移，本质上EVM做的许多工作都是不断的sload与sstore的不断进行状态的转移。  
  
Rollup层是自己执行完交易后生成state root等可验证证明，发送到执行层去做验证，验证通过的话就被认为是一次合法的状态转移，并将修改后的状态写入下一个区块中等待验证者打包后给共识层校验区块有效后写入链上。但是Rollup的方案是不同的，ZkRollup是给zk proof，然后执行层验证。optimism是L1先假设这个证明是对的，在一段时间内如果有人有疑问的话可以来挑战，挑战成功的话就不会被验证通过了。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
