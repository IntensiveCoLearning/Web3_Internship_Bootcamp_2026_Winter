---
timezone: UTC+8
---

# changlu812

**GitHub ID:** changlu812

**Telegram:** @14758354023

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->
1.  体验My First zk vote
    
2.  查看【投研基础框架建立】
    
3.  学习ERC-7962
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->

1.  听黑客松分享会
    
2.  学习spoonOS
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->


1.  通过ethernaut两关
    
2.  听say hi社区分享会
    
3.  完成本周总结
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->



1.  完成一个Gas优化案例
    
2.  完成一个漏洞修复案例并编写笔记
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->




1.  观看Web3公共物品资金分配第一课回放
    
2.  学习Solidity by example 0.8.26 basic部分
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->





## **Solidity 基础语法详解**

### **文件结构**

1.1版本声明

// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; // 指定编译器版本

1.2导入其他合约

import "./OtherContract.sol"; import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

### **合约定义**

contract ContractName { // 状态变量 // 构造函数 // 函数 // 事件 // 修饰器 // 结构体 // 枚举 }

### **数据类型**

布尔类型

bool public isActive = true; bool public isCompleted = false;

整数类型

int8 public smallInt = -128; // 8位有符号整数 uint8 public smallUint = 255; // 8位无符号整数 int256 public bigInt; // 256位有符号整数 uint256 public bigUint; // 256位无符号整数

地址类型

address public owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4; address payable public payableAddress; // 可支付地址

定长字节数组

bytes1 public a = 0x61; // 1字节 bytes32 public hash; // 32字节

枚举

enum Status { Pending, Approved, Rejected } Status public status = Status.Pending;

固定大小数组

uint\[5\] public fixedArray = \[1, 2, 3, 4, 5\];

动态数组

uint\[\] public dynamicArray; address\[\] public addresses;

映射

mapping(address => uint) public balances; mapping(uint => string) public data;

结构体

struct Person { string name; uint age; address wallet; }

字节数组

bytes public dynamicBytes = "Hello"; string public greeting = "Hello, World!";

### **变量和常量**

状态变量

// 存储位置 uint256 public storageVariable; // 存储在链上

// 内存变量（在函数内声明） function example() public pure { uint256 memoryVariable = 100; // 仅存在于函数执行期间 }

常量

uint256 public constant MAX\_SUPPLY = 1000000; address public constant ADMIN = 0x...;

不可变变量

address public immutable owner; uint256 public immutable creationTime;

constructor() { owner = msg.sender; creationTime = block.timestamp; }

### **函数**

函数声明

// 函数结构 function functionName(parameterType parameterName) visibility stateMutability modifiers returns (returnType) { // 函数体 }

函数可见性

function publicFunction() public { // 任何人都可以调用 }

function privateFunction() private { // 仅当前合约内可调用 }

function internalFunction() internal { // 当前合约和继承合约可调用 }

function externalFunction() external { // 只能从外部调用 }

状态可变性

function viewFunction() public view returns (uint) { // 读取但不修改状态 return someVariable; }

function pureFunction(uint a, uint b) public pure returns (uint) { // 不读取也不修改状态 return a + b; }

function payableFunction() public payable { // 可以接收以太币 // 修改状态 }

### **特殊变量**

全局变量

// 区块信息 block.number; // 当前区块号 block.timestamp; // 当前区块时间戳 block.difficulty; // 当前区块难度 block.coinbase; // 当前区块矿工地址

// 交易信息 msg.sender; // 函数调用者地址 msg.value; // 发送的以太币数量 [msg.data](http://msg.data); // 完整的调用数据 msg.sig; // 函数选择器

// 合约信息 address(this).balance; // 合约余额 this; // 当前合约地址

### **控制结构**

条件语句

// if-else if (condition) { // 代码块 } else if (anotherCondition) { // 代码块 } else { // 代码块 }

// 三元运算符 uint result = condition ? a : b;

循环

// for 循环 for (uint i = 0; i < 10; i++) { // 代码块 }

// while 循环 uint i = 0; while (i < 10) { // 代码块 i++; }

// do-while 循环 uint j = 0; do { // 代码块 j++; } while (j < 10);

### **错误处理**

require：require(condition, "Error message");// 条件不满足时回滚，返回剩余 gas

revert：if (!condition) { revert("Error message"); }

assert：assert(condition); // 用于检查内部错误，消耗所有 gas

### **事件**

// 声明事件 event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value);

// 触发事件 function transfer(address to, uint256 amount) public { // ... 转账逻辑 emit Transfer(msg.sender, to, amount); }

### **修饰器**

// 定义修饰器 modifier onlyOwner() { require(msg.sender == owner, "Not owner"); \_; // 继续执行函数 }

modifier costs(uint price) { require(msg.value >= price, "Insufficient funds"); \_; }

// 使用修饰器 function changeOwner(address newOwner) public onlyOwner { owner = newOwner; }

function buyItem(uint itemId) public payable costs(1 ether) { // 购买逻辑 }

### **继承**

// 父合约 contract Ownable { address public owner;

constructor() { owner = msg.sender; }

modifier onlyOwner() { require(msg.sender == owner, "Not owner"); \_; } }

// 子合约 contract MyContract is Ownable { // 继承 Ownable 的所有功能 function adminFunction() public onlyOwner { // 只有所有者可以调用 } }

### **接口**

// 定义接口 interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function transfer(address to, uint256 amount) external returns (bool);

event Transfer(address indexed from, address indexed to, uint256 value);

}

// 实现接口 contract MyToken is IERC20 { // 必须实现所有接口函数 function transfer(address to, uint256 amount) external override returns (bool) { // 实现逻辑 return true; } }
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->






## **Uniswap工作原理解析**

### **Uniswap v2：CPMM恒积做市商**

**与AMM、CFMM的关系：层层递进**

去中心化交易所 →做市商机制 (Market Making) → 自动化做市商 (AMM) → 一种实现方式 ↓ 恒定函数做市商 (CFMM) → AMM的一种主流数学框架 ↓ 恒定乘积做市商 (CPMM) → CFMM 中最著名、最常用的一个函数（Uniswap V1/V2）

**恒定乘积公式**

x \* y = k

**相关概念**

-   liquidity--流动性
    
-   iso-price line--等价格曲线
    
-   price impact--价格影响
    
-   slippage--滑点
    
-   impermanent loss--无常损失
    
-   flash loan--闪电借贷
    
-   TWAP oracle--时间加权平均价格预言机
    
-   LP--流动性提供者，向池子提供资金的人
    
-   交易者--与池子进行兑换的人
    

**价格影响vs.滑点**

价格影响Price Impact：交易本身会“推着池子价格走”，导致成交价格变差，这种因为价格曲线而产生的偏离可预期，取决于池子深度

滑点Slippage：期望的价格/数量和最终实际成交价格/数量之间的偏差，不可预期（但可设置），取决于交易顺序或MEV

**什么是无常损失Impermanent Loss**

**无常损失** 是指，当你作为流动性提供者，将两种资产存入 AMM 池（如 Uniswap 的 ETH/USDC 池）后，与单纯地将这两种资产拿在手里“囤着”相比，因为池内资产价格发生变化而**产生的价值差额**。

本质就是做市商的反向操作特性，当ETH涨价时，池子自动卖出ETH，买入USDC，而作为LP，被动执行了“涨卖跌买”的相反策略。

**特点：**

-   与价格波动幅度正相关：两种资产价格偏离越大无常损失越严重
    
-   永远非正：最好的情况是价格不变，其他任何价格变动都会导致无常损失
    
-   对于一个标准的50/50 CPMM池，无常损失的百分比可以用以下公式近似估算（p为价格变化比率）：
    
-   无常损失率 = \[2 \* sqrt(p) / (1+p)\] - 1
    

**如何弥补无常损失？**

LP会通过赚取交易手续费来对冲和覆盖无常损失

**对冲条件：**若赚取的手续费>无常损失，则LP总体盈利

**影响因素：**稳定币对（如USDC/USDT）价格波动小，无常损失极小，主要赚取手续费；波动性大的币对（如ETH/新山寨币），无常损失风险很高。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->







### **前端与合约交互流程**

**交互流程**

1.  **初始化连接**：前端检测并连接 Web3 提供者
    
2.  **用户授权**：请求用户授权访问钱包账户
    
3.  **合约实例化**：使用 ABI 和合约地址创建合约实例
    
4.  **函数调用**：通过合约实例调用智能合约函数
    
5.  **交易签名**：钱包对交易进行数字签名
    
6.  **广播交易**：将签名交易发送到区块链网络
    
7.  **状态更新**：获取交易结果并更新前端界面
    

**关键技术栈**

-   **合约语言：** 掌握 Solidity 等相关合约开发语言
    
-   **Web3.js/Ethers.js：** JavaScript 库，提供区块链交互 API (当前 Web3.js/Ethers.js 库比较老旧，本技术只用来学习理解整体流程，可以使用 Viem、Wagmi 进行新项目开发)
    
-   **钱包连接器**：如 RainbowKit、ConnectKit、WalletConnect、Web3Modal 等
    
-   **状态管理**：React Context 等管理连接状态
    
-   **错误处理**：网络异常、用户拒绝、Gas 不足等场景处理
    

上述技术栈中，合约语言与一些前端 JS 区块交互的 API 最为基础，其他方面往往由其他厂商提供，如 RPC 节点、钱包等。

> **连接钱包**
> 
> 前端通过调用浏览器中的以太坊钱包插件（如 MetaMask）提供的 API，实现用户地址的连接与授权操作。
> 
> **合约ABI的定义**
> 
> -   ABI（**Application Binary Interface**，应用二进制接口）是智能合约对外提供的接口描述规范。
>     
> -   在前端，ABI 以 JSON 格式定义，描述合约中的函数、参数、返回类型等。
>     
> -   ABI 是实现前端与合约交互的基础，前端可通过 ABI 调用对应函数、读取状态变量。
>     
> 
> **合约实例化**
> 
> 完成 ABI 导入与钱包连接后，通过 Web3.js 创建合约实例，绑定合约地址与 ABI，从而可直接调用合约中的函数接口。
> 
> **合约方法调用**
> 
> 写入操作（需要 Gas）
> 
> -   `.send()` 方法用于执行状态改变的交易
>     
> -   需要指定 `from` 参数（发送者地址）
>     
> -   返回交易对象，包含 `transactionHash` 等信息
>     
> -   用户需要在钱包中确认交易并支付 gas 费用
>     
> 
> 只读或模拟操作（免费）
> 
> -   `.call()` 方法用于执行只读查询或者模拟操作以判断某笔交易是否会成功
>     
> -   不需要 gas 费用，不会改变区块链状态
>     
> -   可以直接获取返回值
>
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->








## **智能合约开发**

### **Dapp架构**

> **前端**
> 
> 基础技术栈与传统web一样，html+ css +JavaScript+ vue /react等
> 
> 与传统web应用不同的是，DApp前端不直接连接区块链网络，而是通过钱包注入的Provider或第三方RPC节点与区块链交互
> 
> **智能合约Smart Contracts**
> 
> 是DApp的核心，定义了应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性
> 
> **数据检索器Indexer**
> 
> 智能合约通常以 `Event` 形式释放日志事件，比如释放代表 NFT 转移的 `Transfer` 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中
> 
> **区块链和去中心化存储（Blockchain & Decentralized Storage）**
> 
> 区块链用于存储智能合约的状态数据及交易记录。去中心化存储如 **IPFS** （InterPlanetary File System）或 **Arweave**，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。
> 
> 使用去中心化存储，DApp可确保所有数据在多个节点上备份，保证数据的持久性和去中心化特性

### **DApp开发流程**

**需求分析与规划**

-   **确定功能需求**：需要定义用户可以进行的操作，比如转账、查询余额、创建投票等。
    
-   **选择区块链平台**：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。
    
-   **设计用户体验（UX）**：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。
    

**智能合约开发**

-   **编写智能合约**：使用 **Solidity** 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。
    
-   **编写测试用例**：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。
    
-   **审计和优化**：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。
    

**检索器开发**

-   **确定功能需要的数据内容**: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据
    
-   **编写检索器程序**: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码
    
-   **部署和运维**: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维
    

**前端开发**

-   **选择前端框架**：可以使用现代前端框架（如 **React**、**Vue**）来构建 UI。前端将通过 JavaScript 与智能合约进行交互。
    
-   **连接钱包**：通过集成 **MetaMask** 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。
    
-   **显示区块链数据**：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。
    
-   **处理交易签名与确认**：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链。
    

**与区块链交互**

前端和智能合约通过 **Viem**（推荐）、**Ethers.js** 或 **Wagmi** 等现代化库进行交互。这些库提供更好的 TypeScript 支持和性能优化：

-   **读取数据**：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。
    
-   **发送交易**：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。
    

**部署与上线**

-   **部署智能合约**：推荐使用 **Hardhat** 或 **Foundry**（现代化开发工具）将智能合约部署到测试网（如 **Sepolia**、**Holesky**）或主网。
    
-   **前端部署**：将前端应用部署到去中心化平台（如 **IPFS**）或传统的 Web 服务（如Vercel）。
    
-   **发布和维护**：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。
    

### **以太坊开发**

**和DApp开发的关系**

-   **以太坊开发**是**以以太坊区块链为底层平台**的开发活动，包括智能合约编写、链上交互、节点部署等；
    
-   **DApp开发**是**构建去中心化应用的整体过程**，其底层可以是以太坊，也可以是其他公链（如Solana、BSC、Polygon等）或联盟链/私有链。
    

基础环境：Node.js、npm/yarn、 Git

本地开发链：

**Foundry（rust实现，极快）提供的开发工具：**

-   `forge`: 帮助构建、测试、调试、部署和验证智能合约
    
-   `anvil`: 本地开发节点，完全兼容以太坊 JSON-RPC 规范
    
-   `cast`: 命令行工具，用于与链上应用交互
    

**Hardhat（推荐，现代以太坊开发框架）**

**以太坊钱包和前端交互**

-   推荐使用 MetaMask 浏览器插件作为开发钱包。
    
-   前端推荐使用 Viem 和 Wagmi。
    

### **RPC在DApp开发中的职责**

> **读取链上数据**
> 
> -   查询账户余额、交易历史
>     
> -   读取智能合约的状态变量
>     
> -   获取区块信息、Gas 价格等
>     
> 
> **发送交易**
> 
> -   将用户签名的交易广播到区块链网络
>     
> -   查询交易状态和确认数
>     
> -   估算交易所需的 Gas 费用
>     
> 
> **事件监听**
> 
> -   监听智能合约事件（Events）
>     
> -   实时获取链上状态变化
>     
> -   支持 WebSocket 长连接推送
>     
> 
> **网络管理**
> 
> -   切换不同的区块链网络（主网、测试网）
>     
> -   获取网络信息和链 ID
>     
> -   管理节点连接状态
>     

### **JSON-RPC协议**

以太坊使用 **JSON-RPC 2.0** 协议作为标准的 RPC 通信格式。所有请求和响应都是 JSON 格式，通过 HTTP 或 WebSocket 传输。

### **RPC 使用最佳实践**

> **保护API**
> 
> -   使用环境变量存储 RPC URL 和 API Key
>     
> -   不要将敏感信息提交到 Git 仓库
>     
> -   使用 `.gitignore` 忽略 `.env` 文件
>     
> -   定期轮换 API Key，特别是发现泄露时
>     
> 
> **错误处理和重试**
> 
> -   RPC 调用可能因网络问题失败，需要实现重试机制
>     
> -   设置合理的超时时间
>     
> -   处理常见的错误码（如 `429` 速率限制、`503` 服务不可用）
>     
> 
> **速率限制管理**
> 
> -   了解服务商的速率限制（Rate Limit）
>     
> -   实现请求队列或节流（Throttling）
>     
> -   对于高频请求，考虑使用 WebSocket 连接
>     
> 
> **多节点备份**
> 
> -   不要依赖单一 RPC 节点
>     
> -   配置多个 RPC 端点作为备用
>     
> -   实现故障转移（Failover）机制
>     
> 
> **监控和日志**
> 
> -   记录 RPC 调用的成功率和延迟
>     
> -   监控 API 使用量，避免超出免费额度
>     
> -   设置告警，及时发现服务异常
>     
> 
> **本地节点开发**
> 
> -   开发测试时优先使用本地节点（如 Hardhat Node、Anvil）
>     
> -   本地节点响应快，不受速率限制
>     
> -   可以重置状态，方便测试
>     

### **安全实践**

> **重入攻击Reentrancy保护**
> 
> 该攻击方式通常发生在合约向外部地址发送以太币或调用外部合约函数时，攻击者利用回调机制在合约状态更新之前重复调用受影响的函数，从而多次提取资金或重复执行某些操作，造成资产损失或逻辑混乱。
> 
> 典型的重入攻击流程如下：
> 
> 1.  合约调用外部合约或地址（如 `call` 发送以太币）；
>     
> 2.  外部合约在其回调函数中重新调用原合约尚未更新状态的函数；
>     
> 3.  原合约在状态尚未变更的前提下再次执行逻辑；
>     
> 4.  攻击者反复进入该函数，实现多次提现等恶意操作。
>     
> 
> 防护措施：检查-生效-交互模式（CEI Pattern）、重入锁（Reentrancy Guard）
> 
> **访问控制**
> 
> 访问控制是保障智能合约安全性的核心机制之一。通过对关键函数设置访问权限，可以有效防止未经授权的用户执行敏感操作，从而避免资金被盗、状态被篡改等严重安全风险。
> 
> **整数溢出防护**（Integer Overflow Protection）
> 
> 自 Solidity 0.8.0 起，所有算术运算默认开启溢出/下溢检查，若发生异常会自动 `revert`。除此之外，也建议通过逻辑限制控制最大值，防止边界绕回。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->









### **节点同步的目标和意义**

节点要同步的内容主要包括两部分：

-   区块链数据（每个区块及其头信息）
    
-   状态数据（每个账户余额、合约存储、代码等）
    

三种同步模式：FullSync（全同步）、SnapSync（快照同步）、LightSync（轻节点同步）

### **什么是区块头&区块体**

-   区块头（Block Header）：包含区块的元数据，用于识别、验证与链接区块。
    
-   区块体（Block Body）：包含实际交易数据和其他可选信息，是区块中“做事情”的部分。
    

### **节点间交换的数据类型**

**交易信息**：节点负责存储、验证和转发交易信息。

**区块数据**：数据以区块的形式存储并链接在一起，形成一个链。

**加密哈希**：区块通过加密哈希值相互链接，这些哈希值是每个区块的唯一标 识符，并确保交易的顺序和时间。

**账户信息**：这包括账户余额、随机数、合约代码和合约存储等。

**公钥和私钥**：公钥密码学用于唯一识别区块链网络中的参与者。

**智能合约代码和执行数据**：以太坊节点处理智能合约和状态变化。

**网络状态**：EVM 会更新以太坊上所有账户和智能合约的状态，包括账户余 额、随机数、合约代码和合约存储。

**日志/事件**：智能合约在执行过程中可以发出日志或事件，外部系统可以利用 这些信息进行监控。

  
ps：今天学的有点少，主要在赶学校的项目了，下周继续加油
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->










## **021以太坊学习笔记**

**什么是RPC？**

RPC=Remote Produce Call，即远程过程调用。就是一个程序或客户端可以像调用本地函数一样向远端服务器节点发出请求，让对方执行某个过程（procedure/方法/函数）并返回结果，客户端自己不关心这个过程实际在哪个机器运行或在什么网络中

在区块链生态中，RPC通常指区块链节点提供的一种接口，供应用程序（钱包/dApp/区块链浏览器etc）远程调用，让应用可以：

-   查询区块、交易、账户余额、智能合约状态等数据
    
-   提交新的事务到网络
    
-   调用智能合约方法
    
-   检测交易确认状态等
    

RPC节点或RPC服务商就提供这些接口和endpoint。应用端只需要知道这个endpoint地址以及支持RPC的方法，就能和区块链交互，而且不需要每个应用都自己运行完整节点。

**开发者或机构运行全节点的必要性**

> **不泄露隐私：不用把地址&IP给第三方**
> 
> 大多数钱包/dApp默认连的是公共RPC，也就意味着每次查余额、读合约、发交易的请求都会先到RPC提供商那里，提供商一般会收集IP+钱包地址等元数据。而官方/社区文档对“自己跑节点”第一条好处就是不用把地址、调用、交易习惯暴露给别人的节点，你和以太坊所有交互只经过自己的机器
> 
> **不被卡脖子：抵御RPC层面的“软审查“**
> 
> 完全依赖公共RPC的风险：
> 
> -   服务商可基于IP、地区、请求特征做限流或封锁
>     
> -   某些交易或合约交互可能会因为内部政策被拒绝广播
>     
> -   服务商宕机或出现bug时，你的dApp会挂掉
>     
> 
> 而自己跑全节点就说明：
> 
> -   任何时候你都能自主广播交易，不用看某个云服务心情
>     
> -   即使有第三方服务“降级/风控”，你的业务仍能通过自有节点维持基本功能
>     
> 
> **“不要信任，要验证”：自己验证每一笔区块和交易**
> 
> Don't trust，verify
> 
> 当你自己运行全节点时：
> 
> -   所有区块和交易都会在本地被完整验证（共识+执行）
>     
> -   不必相信任何公共RPC提供的结果，可以自己算一遍
>     
> -   dApp、风控系统、清结算逻辑都可以直接基于自己验证的状态来做判断
>     
> 
> 这一点尤其是在：金融机构/交易所做入账确认、做清结算/风控确认数据未被修改、做合规审计需要有可追溯和复现“本地真相来源”场景中尤为重要
> 
> **帮以太坊撑腰：去中心化和客户端多样性**
> 
> 如果某个客户端占比太高，一旦它出现bug，可能直接拖垮整条链的安全性或终局性，鼓励把每个客户端占比压倒1/3以下
> 
> 当开发者/机构选择跑一个全节点并且有意识选择“不是头部垄断”的客户端实现时，就是在直接增强 以太坊的弹性和去中心化
> 
> **为 dApp 和内部系统提供稳定的“数据底座”**
> 
> 典型收益：
> 
> -   自定义RPC接口：根据业务需要配置限流、日志、鉴权、白名单等
>     
> -   更低延迟：节点就在本机房或内网，读写延迟和稳定性更好
>     
> -   可以在节点挂索引服务、内部风控/数据仓库流水、各部门使用的分析面板
>     
> 
> **高级玩法：归档节点支撑分析、审计和合规**
> 
> 归档节点时全节点的升级版，在全节点基础上多做一件事：保存从创世到现在的全部历史状态快照，可以在瞬间回答“在区块#N的时候，这个地址/合约状态是什么”
> 
> 适合：
> 
> -   做连上行为的合规审计与报表
>     
> -   做量化研究、策略回测、风控模型训练
>     
> -   为外部团队提供“历史视图丰富的链上数据服务”（区块浏览器、分析平台、RWA平台etc）
>     
> 
> 普通开发者只需要全节点就够日常开发； 需要大量历史查询 / 调试 / 审计的机构，就几乎总会考虑自己维护一套归 档节点。
> 
> **升级与分叉选择权：用脚“投票”的能力**
> 
> 在以太坊的社会共识链里，协议升级、偶发分叉都是通过“谁跑哪个客户端版本、谁跟随哪条链”来定胜负的
> 
> 如果完全依赖第三方，那透明升级到哪条链，只能被动跟随到哪，没有真正意义的“协议主权”
> 
> 而如果自己运行全节点，就可以决定什么时候升级、是否接受某个EIP，必要时可观察两条链情况，主动决定自己认为哪个是“正统”
> 
> **配置自由：客户端选型、参数调优、合规要求**
> 
> 只有自己的节点，才能做到按自己的业务来调，以自己的合规来配
> 
> 比如：
> 
> -   选用不同客户端（Geth、Erigon、Nethermind、Besu…）满足：性能需求、语言栈/运维团队熟悉度、企业特性
>     
> -   自己控制日志留存、监控指标、访问控制策略，满足合规或内部审计要求
>     
> -   为共识层/执行层做特殊配置
>     
> 
> **总结**
> 
> 开发者和机构运行全节点，是为了拿回三件东西：
> 
> -   ① 自己验证、自主管理的安全与隐私；
>     
> -   ② 抗审查、抗单点故障的基础设施韧性；
>     
> -   ③ 在以太坊协议和应用层上的话语权与自主权。 这既是为自己负责，也 是为整个以太坊网络“增肌”
>     

### **归档节点在数据查询中的优势**

-   即时查询任意历史状态（无需重放）
    
-   支持按区块高度查询的高级 RPC
    
-   历史分析、审计与治理的基础设施
    
-   代价：空间和同步时间非常“奢侈”
    

总结：全节点知道“现在发生了什么”，归档节点记得“从第一天起发生过的一 切”。 对所有需要频繁查历史状态的应用来说，归档节点就是一台链上的 时间机器——代价是，你得在机房里给它备一整个机柜的硬盘。

### **合并后执行与共识客户端的区别**

一个“完整以太坊节点”必须同时运行这两种客户端，并通过 Engine API 互相通信：执行客户端管“算账 + 状态”，共识客户端管“选块 + 投票”

**执行客户端（Execution Client）： EVM + 状态 + RPC**

执行客户端负责以太坊的执行层（Execution Layer），也就是你理解中的“业 务逻辑”和“链上状态机”：处理交易、执行EVM操作、维护状态和数据库、提供JSON-RPC API、执行层P2P网络、配合集成Engine API

常见执行客户端：Geth、Nethermind、Besu、Erigon、Reth 等

可以把执行客户端想成：“世界计算机”的 CPU + 内存 + 本地数据库 + RPC 网关

**共识客户端（Consensus Client）： PoS + Beacon + Finality**

共识客户端负责以太坊的共识层（Consensus Layer / Beacon Chain），专门 处理 PoS 逻辑与链头选择：运行 PoS 共识，提议 / 验证新区块 、追踪链头与最终性（finality） 、管理验证者集与奖励 / 惩罚 、共识层 P2P 网络 、 Beacon API / 共识 RPC

常见共识客户端：Prysm、Lighthouse、Teku、Nimbus、Lodestar 等

可以把共识客户端想成：一群“裁判 + 选举委员会”：负责安排谁出块、谁投票、票数到哪条链头 上，什么时候给“最终盖章”

### **它们之间如何配合？——Engine API 的“内线电话”**

后Merge框架精髓：

以太坊节点=执行客户端+共识客户端+它们之间的Engine API

-   共识客户端收到新区块 / 或被选中提议新区块
    
-   执行客户端执行交易，返回执行结果
    
-   共识客户端把执行结果“装进” Beacon 区块
    
-   其他节点的共识客户端接收区块 → 交给本地执行客户端复验
    

总之：

-   执行客户端负责“这块里的交易是否合法？最终状态是什么？”
    
-   共识客户端负责“我们全网要不要接受这块当下一步？哪条链是正统？ 谁作恶要被 slash？”
    

**开发者要记住的是**

**调用 eth\_\* / 部署合约 / 查状态？**

找的是 执行客户端（EVM + JSON-RPC）

**质押 32 ETH 做验证者 / 关心 attestation、finality、slashing？**

这是 共识客户端 + 验证者客户端 的工作。

**为啥要拆两块？**

为了模块化、易维护、多客户端实现、独立升级，以及更清晰的安 全边界：执行层可以专心把 EVM 和状态做到极致性能，共识层可以独立演进 PoS、PBS 等协议设计。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->











## **021以太坊学习笔记**

### **节点间的连接与通信方式**

**节点发现：先“加好友”再扩散（基于 UDP + Kademlia）**

当一个以太坊节点刚启动时，它一开始谁也不认识，只知道少数几个引导节 点（boot nodes）的地址。 这些引导节点是长期在线、对外公布地址的全节点，新节点第一次进网时会 先去找它们，就像刚进公司只认识 HR，先加 HR 微信，再通过 TA 认识别人。

> **Discovery 协议：Ping / Pong / FindNode / Neighbors**
> 
> 以太坊的节点发现协议跑在UDP上，专做①确认对方在线：给对方发ping，对方回pong
> 
> ②要通讯录：发送FindNode请求，对方回Neighbors或Nodes（里面是一批其他活跃节点联系方式）
> 
> 新节点拿到这些“邻居”后，会继续对这些地址发 Ping/Pong、FindNode， 反复迭代，逐步把自己的邻居表填满，直到达到预设上限——这一套就是 Kademlia 风格的 DHT（分布式哈希表）发现机制。
> 
> **Kademlia 的直观类比：快递分拨中心**
> 
> Kademlia 里，每个节点有一个 256 bit 的 ID，“距离”用 XOR 差异来度 量，而不是地理距离。
> 
> 它类比成全国快递分拨中心网络：
> 
> -   每个分拨中心有一个“编号”（节点 ID）； 每个中心都记着“在不同距离区间内，离我最近的几个中心”；
>     
> -   当要把快递寄往一个目标编号时，会一步步转发给“离目标更近”的中 心，越转越接近收件人；
>     
> -   最终快递就被精准送到目的地。
>     
> 
> 在以太坊里，查找节点 / 扩散通讯录也是这么做的：每一跳都把搜索范围 “逼近”目标 ID，大大减少广播范围，提高发现效率。
> 
> **总结**
> 
> 发现阶段 = 用 UDP + Kademlia 找到一堆靠谱的邻居，把自己的“好友 列表”填满。

**建立安全连接：TCP+ RLPx /devp2p**

发现了别人之后，还需要建立一条真正能稳定传输数据的管道，这就进入第二步： 从“打招呼”升级成“拉一个加密的私聊通道”

> **TCP:先搭建好稳定管道**
> 
> 节点之间一旦决定互相连接，就会通过 TCP 建立双向连接。UDP 用来发现节点，因为它轻量、无连接，速度快；真正传输交易和区块这种重要数据时， 还是需要 TCP 这种带确认、可重传的“可靠管道”
> 
> **RLPx：在一个 TCP 里多路复用多种协议**
> 
> 以太坊在 TCP 之上跑的是 devp2p 协议栈，其底层加密与多路复用由 RLPx 负责：
> 
> -   先通过握手交换密钥，建立加密会话（防窃听、防篡改）；
>     
> -   再在这条加密 TCP 通道上，复用多种子协议（capabilities），比如：
>     
> 
> -   eth/66 / eth/68：同步区块、传播交易（执行层）
>     
> -   les：为轻客户端提供服务
>     
> -   其他自定义子协议
>     
> 
> 即：RLPx = 在一条 TCP 线上开很多“分机”：同一根网线同时承载区块同步、 交易广播、状态请求等多种子协议流量。

**消息是怎么在全网传播的？——Gossip+请求/响应**

以太坊这里用的是两种模式： ① Gossip（广播式传播） ② 点对点请求-响应（拉取指定数据）

> **Gossip 协议：像办公室八卦一样扩散**
> 
> 所谓 Gossip 协议，就是模拟人类“传八卦”的传播方式：
> 
> -   某节点收到一笔新交易 / 一个新块；
>     
> -   它随机挑几个还没听说过这件事的邻居告诉一遍；
>     
> -   那些邻居再各自“转发给自己的朋友”；
>     
> -   经过若干轮之后，整个网络几乎所有节点都知道这条消息。
>     
> 
> 优点：
> 
> -   不需要中心服务器指挥：完全去中心化、自组织
>     
> -   传播路径随机，鲁棒性好，局部故障不会阻止全网同步
>     
> -   实际测量中，以太坊能在几秒钟级别完成一笔交易/区块的全网传播
>     
> 
> 在以太坊中：
> 
> -   执行层：通过 devp2p 上的 eth/\* 子协议，gossip 交易和区块；
>     
> -   共识层：共识客户端有自己的 P2P 网络和 gossip 协议，用来广播 Beacon block、attestation 等共识消息。
>     
> 
> **请求-响应：按需拉取历史区块、状态等**
> 
> Gossip 适合传播“最新消息”，但如果你掉线一段时间，需要补历史数据， 就不能靠八卦了。
> 
> 这时节点会通过 devp2p 的子协议，向具体的邻居 发起精确请求：
> 
> -   “给我从高度 N 开始的 128 个区块头”；
>     
> -   “给我这些区块的区块体 / receipts”；
>     
> -   “给我某个区块对应的状态部分”。
>     
> 
> **总结**
> 
> Gossip = 大家在茶水间互相聊最新八卦；
> 
> 请求-响应 = 你专门去档案室翻某一天的旧报纸。
> 
> 两者结合在一起，才能既保证新消息快速散播，又保证任何节点都能随时补 齐历史、追上最新状态。

### **全节点、轻节点、归档节点的区别**

-   全节点 = 当前状态 + 全部区块（但老状态会被“裁剪”）；
    
-   归档节点 = 全节点 + 从创世到现在的“所有历史状态”；
    
-   轻节点 = 只存区块头，需要时向全节点要具体数据。
    
    **全节点**
    
    > **全节点是什么？**
    > 
    > -   运行一对执行客户端 + 共识客户端，从创世块起验证整条链（或者从一个可信检查点开始，用 snap/fast sync 补齐后再完全自我验证）
    >     
    > -   保存所有区块的区块头和区块体（也就是交易、收据等历史记录不会 被删）
    >     
    > -   只保留最近若干个区块的完整状态（典型是最近 ~128 个区块的状态 数据），更老的状态会被“修剪（pruning）”掉，以节省磁盘。
    >     
    > 
    > **全节点能做什么？**
    > 
    > -   验证所有新来的交易和区块，独立判断“这条链是不是合法”；
    >     
    > -   直接为钱包、dApp、脚本提供 JSON-RPC 接口，是一个“完全自托 管的以太坊入口”
    >     
    > -   理论上可以重构任何历史状态——只是对非常久远的状态，可能需要 向归档节点请求一些旧数据，再自己重放计算。
    >     
    > 
    > 全节点最重要的特点是“自己验证，不求人”，但不会保存所有历史状态快照，这部分交给归档节点
    

**归档节点**

> **它是什么？**
> 
> 本质上就是：禁用修剪（pruning）的全节点。
> 
> 除了全节点拥有的所有数据以外，还保存从创世到现在的每一个区块 高度下的完整状态： 某个老区块高度上每个账户的余额、合约存储、状态树……都能 “一查即得”，不需要重算
> 
> **归档节点的代价**
> 
> -   体量非常大：从 TB 甚至多 TB 起步；
>     
> -   同步时间长、维护成本高，不适合普通用户在家里跑
>     
> 
> **谁需要归档节点？**
> 
> -   区块浏览器（Etherscan 类）、链上分析公司；
>     
> -   高级调试 / 回测工具
>     
> -   一些需要频繁查 任意历史状态快照 的服务。
>     
> 
> 归档节点 = “国家档案馆”： 保存了所有历史状态，对研究、分析、服务商非常有用，但对普通用户来 说完全是“性能过剩”

**轻节点/轻客户端（Light Node / Light Client）**

> **它是什么？**
> 
> -   只保存 区块头（block headers），不保存完整区块体和全量状态；
>     
> -   需要时，向全节点/归档节点请求具体数据（交易、账户状态、合约存储 等），并用区块头里的 state root / Merkle 根 对收到的数据进行验证。
>     
> 
> **优点**
> 
> -   极大降低存储与带宽需求，可以在：手机、浏览器插件、硬件设备等资源受限环境中运行；
>     
> -   依然保留“可验证性”：它不需要完全信任提供数据的全节点，可以用 Merkle 证明 + 状 态根独立校验。
>     
> 
> **限制**
> 
> -   不参与共识：不能做验证者（不签区块、不投票）；
>     
> -   对数据获取有一定依赖，需要有可访问的全节点 / 网关
>     
> 
> 轻节点 = “只看目录 + 零信任校验”： 不存全书，只存区块头和必要证明，但依然可以做到“不完全信任别人、 自己核对关键部分”
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->












## **021学习以太坊笔记**

### **什么是以太坊节点**

节点（node）：任何一台运行以太坊客户端软件并连接到其他节点的电脑， 就是一个以太坊节点

### **什么是客户端client**

是对以太坊协议的具体实现，会按协议规则验证数据、同 步区块和状态，帮助网络保持安全。

-   执行客户端（Execution Client，EL）
    
-   共识客户端（Consensus Client，CL）
    
-   验证者客户端（Validator）——作为共识客户端的“插件”（参与出块、赚质押收益）。
    

### **执行者客户端（Execution Client）---“干活的”**

执行客户端（也叫执行层客户端、EL 客户端、旧称 Eth1 客户端），主要负 责链上的“业务逻辑和状态”：

-   监听网络上广播来的交易与区块
    
-   在 EVM（以太坊虚拟机） 中执行交易和智能合约 维护当前链的状态数据库（账户余额、合约存储等）
    
-   提供 JSON-RPC 接口（eth\_\*）， 给 dApp / 钱包 / 脚本调用
    
-   通过自己的 P2P 网络转发交易和区块头 / 区块体
    

### **共识客户端（Consensus Client）——“法官”**

共识客户端（也叫信标链客户端、CL 客户端、旧称 Eth2 客户端），主要负 责权益证明 PoS 共识：

-   维护信标链（Beacon Chain）视 图 和 fork choice 规 则（ LMD-GHOST 等）
    
-   在每个 slot 里选择谁来提议区块，并对区块进行投票（attestation）
    
-   跟踪验证者集合、质押余额、惩罚（slashing）等共识状态
    
-   把来自执行客户端的结果当作“材料”，决定哪一个区块被接受到链上
    

### **验证者客户端（Validator）——“陪审团代表”**

在 PoS 模式下，如果你想质押 ETH、参与出块并获取奖励，就需要在共识 客户端基础上再运行一个 验证者客户端：

-   它负责：管理你的验证者密钥、在轮到你时提议新区块、在每个 slot 为看到的区块做 attestation（投票）
    
-   从实现角度看，很多共识客户端本身就自带 validator 子进程，也有项 目把它拆成单独进程。
    

### **那节点和客户端到底什么关系？**

-   客户端（client） 是软件实现（比如 Geth、Lighthouse、Teku…）
    
-   节点（node） 是“跑着这些客户端的软件实例的那台电脑”。
    

因此：

-   一台电脑上跑着 1 个执行客户端 + 1 个共识客户端 → 这是一个全节点
    
-   如果再挂上一个或多个验证者 → 这是一个验证节点；
    
-   轻节点则只保存部分信息，可通过同步委员会等机制验证区块头。
    

### **总结**

以太坊节点 = 一台电脑 + 两个必备客户端 + （可选）一个验证者客户端：

-   执行客户端负责“算交易、管状态、对外提供 RPC”
    
-   共识客户端负责“跑 PoS、选区块、投票达成共识”；
    
-   它们通过 Engine API 的“专线电话”互相协作，整个节点再通过 P2P。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->













\# 安全与合规

\## Web3合规性要求与常见法律风险

\### **1.核心法律风险梳理**

\>#### **1.代币发行与交易行为的法律风险**

\>

\>当前，中国法律明令禁止任何单位或个人通过 ICO、IEO、IDO 等方式进行融资活动。不论代币是否命名为“积分”“凭证”或“治理 Token”，只要具备融资功能或可流通性，即可能构成非法金融行为。

\>

\>技术人员若参与代币模型设计、空投逻辑配置、合约部署等环节，也会被视为“共同行为人”，无法以“只是写代码”为由免责。

\>

\>#### **2.赌博、传销、洗钱等刑事风险**

\>

\>Web3 项目的设计与经济激励模型直接影响风险等级。例如，部分链游存在“充值—抽奖—提现”的闭环结构，玩家投入法币或 USDT 购买盲盒、转盘机会，随机获得稀有 NFT 或 Token，后续可在平台提现或转售。这种“下注—随机收益—兑现”的机制容易被认定为开设赌场罪。

\>

\>NFT 项目、DAO 社群、挖矿平台中常见的“邀请返利”“算力挂靠”“多级推广”模式，一旦涉及团队计酬、多层级返佣，可能触犯组织、领导传销活动罪。

\>

\>#### **3.场外交易中的洗钱与非法经营风险**

\>

\>虚拟货币在场外交易环节常被用作规避监管的“地下换汇”工具。境内个人先用人民币购买 USDT、ETH 等虚拟币，再通过链上或境外平台兑换美元、欧元等外币，形成跨境资金流转链条。这个过程绕过了外汇监管，可能构成非法经营外汇业务。

\>

\>#### **4.民商事争议**

\>

\>按照我国现行政策和司法实践，虚拟币交易大概率被认为无效，需风险自担

\### 2.全球监管背景与趋势

\>#### **1.什么是FATF**

\>

\>FATF（Financial Action Task Force，金融行动特别工作组） 是一个政府间组织，成立于 1989 年，总部位于法国巴黎。它是全球反洗钱和反恐怖融资标准的制定者。

\>

\>#### **2.它的核心职能是什么？**

\>

\>- 制定国际标准：制定反洗钱（AML）和反恐怖融资（CFT）的国际标准

\>- 评估成员国：对成员国进行合规性评估，发布"灰名单"和"黑名单"

\>- 协调全球行动：协调各国监管机构打击金融犯罪

\>

\>#### **3.对Web3有什么影响？**

\>

\>Travel Rule（旅行规则）是 FATF 对加密货币行业最重要的监管要求：

\>

\>- 要求虚拟资产服务提供商（VASP）在转账时收集和传输发送方、接收方信息

\>- 适用于超过 1000 美元/欧元的转账

\>- 对 DeFi 协议和 DEX 提出了合规挑战

\>

\>#### **4.全球主要监管趋势**

\>

\>美国：SEC（证券交易委员会）、CFTC（商品期货交易委员会）、OCC(货币监管署)

\>

\>欧盟：MiCA加密资产市场法规

\>

\>香港：虚拟资产服务提供商VASP制度、稳定比监管

\### 3.Web3入职法律风险防范指南

\>#### **雇佣关系新形态**

\>

\>Web3 项目普遍采用境外注册方式并通过 Telegram、Zoom 等方式线上面试及协作。

\>

\>由于许多项目方在中国境内无注册公司，不具备用工主体资格，因此难以与员工签订有效的《劳动合同》，也无法依法缴纳五险一金。一旦发生薪资争议或因公受伤，员工将难以依照《劳动合同法》享受合法保障。

\>

\>为弥补上述漏洞，有些项目方会通过 EOR（名义雇主）模式，委托国内合规公司与员工签署合同。通过这种方式可以解决劳动关系里的部分问题，但在发生纠纷的情况下，劳动关系的认定仍然是需要关注的重点。

\>

\>#### **薪酬结构及风险提示**

\>

\>Web3 企业的薪酬结构常见“人民币 + Token”或“全 USDT”模式

\>

\>根据我国《劳动法》规定，工资应以法定货币（即人民币）支付，不得以实物或虚拟币等形式代替。这意味着，如果薪酬中 Token 或 USDT 部分被认定为工资支付，可能导致支付行为无效。

\>

\>相反，如果该部分未被明确纳入工资范围，则会拉低员工的平均工资基数，影响其社保缴纳、经济补偿计算等，间接损害劳动者合法权益。

\>

\>更需注意的是，用自发 Token 支付薪资的项目，其代币价值波动剧烈，甚至可能在项目失败后彻底归零，员工收入将大打折扣。

\>

\>#### **虚拟货币出金与合规风险**

\>

\>员工通常需要通过“出金”将其兑换为人民币以满足日常支出。目前主流方式为 C2C 交易，包括场内挂单、场外担保交易、OTC 交易群等。

\>

\>然而，出金过程中极易卷入刑事风险。若交易对手使用涉赌、涉诈资金购币，收款方极可能因接收非法资金而遭遇银行卡冻结，甚至被要求退赔全部涉案金额。与此同时，参与高价出 U 交易、协助他人洗钱、绕开监管等行为，还可能构成 “帮信罪” 或 “掩饰、隐瞒犯罪所得罪”。

\>

\>因此求职者可以根据自身的经济情况和消费习惯，若日常需要法币支出，可以和公司协商薪资发放的方式，保留一部分法币收入。在出金时，务必通过可信渠道进行出金，避免参与灰色交易，并定期留存相关资金合法来源记录，以便自证清白。

\>

\>#### **项目合法性需提前审查**

\>

\>入职前还应重点审查项目是否合法。即便员工非主导方，若整体项目涉嫌非法金融活动，也可能被牵连调查。建议主动要求查阅项目白皮书、Token 分发机制、收益模型、是否面向中国大陆用户、是否含有返利结构、投资承诺等。

\## 常见网络安全风险与防护措施

\### 常见网络安全风险与攻击方式

\>#### **钓鱼攻击**

\>

\>钓鱼攻击是最常见、最有效的网络攻击手段之一。攻击者通过伪造官方网站、社交账号、邮件、短信等，诱导受害者点击恶意链接、输入敏感信息（如助记词、私钥、账号密码），或下载恶意软件。

\>

\>- **伪造邮件/网站：** 攻击者会仿冒知名企业、学校、项目方的邮箱或网站，发送“面试通知”“奖学金发放”“账号异常”等紧急信息，诱导你点击钓鱼链接。

\>- **社交平台钓鱼：** 在微信群、QQ 群、Telegram、Discord 等社群中，冒充官方人员、HR、学长学姐，发布虚假招聘、空投、福利活动。

\>- **假冒客服/好友：** 通过盗号、伪造头像昵称等方式，冒充你信任的人，诱导你转账或泄露信息。

\>

\>#### **恶意软件/木马**

\>

\>- **伪装成面试/学习软件：** 攻击者将木马程序伪装成“面试专用软件”“学习资料”“破解工具”等，诱导学生下载安装。

\>- **剪贴板劫持：** 木马常驻后台，监控剪贴板内容，一旦检测到钱包地址，自动替换为攻击者地址。

\>- **浏览器扩展/插件后门：** 通过伪装成热门插件，窃取浏览器中的敏感数据。

\>- **远程控制：** 木马获取系统权限后，可远程操控电脑，窃取文件、录屏、键盘记录等。

\>

\>#### **社交工程攻击**

\>

\>- **冒充 HR/导师/同学：** 通过社交平台、邮件、电话等方式，冒充你信任的人，获取信任后诱导你操作。

\>- **群聊钓鱼：** 在微信群、QQ 群、Telegram、Discord 等群聊中，冒充管理员、官方人员，发布钓鱼链接或虚假活动。

\>- **“好友”求助：** 盗取你好友账号后，以“急需用钱”“帮忙测试”“转发链接”等理由诱导你转账或点击恶意链接。

\>

\>#### **供应链/第三方依赖攻击**

\>

\>攻击方式与手段

\>

\>- 恶意浏览器插件/扩展：攻击者在 Chrome 商店等平台上传带有后门的插件，诱导用户安装。

\>- 开源库后门：攻击者在常用开源库、依赖包中植入恶意代码，影响大量下游用户。

\>- 官方渠道被劫持：即使是“正规商店”下载的软件，也可能因被攻击而批量感染。

\>

\>#### **地址污染与扫描木马**

\>

\>- 剪贴板劫持：木马监控剪贴板，一旦检测到钱包地址，自动替换为攻击者地址。

\>- 输入框监听：恶意软件监听浏览器或输入法，实时获取输入内容。

\>

\>#### **传统隐私与账号安全风险**

\>

\>- 弱密码/密码复用：多个平台使用相同密码，一旦某个平台泄露，其他账号也被攻破。

\>- 邮箱/SIM 卡劫持：通过社工、运营商漏洞等手段，劫持你的邮箱或手机号，重置所有账号密码。

\>- 双因素认证缺失：未开启 2FA，账号易被盗
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->














## **DeFi：去中心化金融的创新实践**

### **DeFi是什么？**

DeFi，全称为 Decentralized Finance（去中心化金融），是基于区块链技术建立的金融体系，目标是提供不依赖传统银行或金融中介的服务，比如借贷、交易、支付等，让每个人都可以自由参与，无需审批、无需信任中介机构。

### **三个DeFi领域典型案例**

**1.Uniswap：去中心化交易所(DEX)**

Uniswap是去中心化交易所的代表，由Hayden Adams在2018年创立。核心创新是引入“自动做市商AMM”模式，通过“恒定乘积公式”实现代币定价。用户通过存入流动性池（如 ETH 和 DAI）成为流动性提供者(LP)，赚取交易手续费

> **恒定乘积公式 x \* y =k**
> 
> x，y代表两种货币，它们的乘积k是一个常数，当你在这个池子交易时，这个公式始终成立
> 
> Uniswap通过这个公式，自动决定每个交易的价格和兑换率，确保池子总价值保持平衡，价格随储备比例连续调整，大额单会产生滑点
> 
> **流动性池和流动性提供者LP**
> 
> 流动性池是 Uniswap 交易的核心。它是由很多用户共同提供的资金池，用于交易中的兑换。用户不需要通过中心化交易所来等待匹配订单，只需要加入流动性池，Uniswap会根据池子里的资金自动帮用户完成交易
> 
> **LP如何赚钱呢？**
> 
> -   当你把资金存入流动性池时，你成为了流动性提供者（LP）。每当别人进行交易时，你提供的资金就会被用来进行兑换。
>     
> -   LP 在每次交易中都会收取一定的 交易手续费。这些手续费会根据你在流动性池中提供的资金比例进行分配。
>     
> 
> **去中心化vs.中心化交易所的好处**
> 
> ![image-20260113182751853.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/changlu812/images/2026-01-13-1768304069763-image-20260113182751853.png)

**2.Compound：去中心化借贷协议**

Compound 是一个去中心化的借贷平台，允许用户借入或借出加密资产。由 Robert Leshner 于 2017 年创建。用户在平台上存入资产并获得相应的 **cToken**，这是一种代表用户在协议中存入资金的代币。用户可以通过这个代币赚取利息，同时也可以借入其他资产，但需要提供超额担保。

> **流动性挖矿与利息收入**
> 
> 用户将自己的资产（如 ETH、DAI）存入 Compound，便能获得 cToken（比如存入一个ETH，可以获得相应的cETH代币）
> 
> 利息是根据实时市场动态决定的，平台采用动态利率模型。当借贷需求增加时，利率会上升，反之则会下降。
> 
> **借贷模式与超额抵押**
> 
> 用户在借入资产时，必须提供超额的担保，比如想借出 2000 美元的 USDC，那么他需要抵押超过等值的资产（如 ETH）。如果市场波动导致抵押资产的价值低于借款要求（例如抵押的 ETH 被市场价格大幅波动），Compound 会触发强制清算，即强制卖出部分抵押资产来偿还贷款。

**3.MakerDAO（现名Sky）：稳定币系统**

MakerDAO 是一个去中心化的借贷协议，它允许用户通过超额抵押资产来生成 **DAI**，一种与美元挂钩的稳定币。DAI 的价值稳定在 1 美元左右，因此可以作为一个避险工具或支付手段。MakerDAO 通过智能合约管理抵押资产，并利用 **稳定费率** 来调整系统中 DAI 的供需关系。

> **超额抵押生成DAI**
> 
> 在 MakerDAO 中，用户可以将其资产（如 ETH、BAT 或其他加密货币）抵押到系统中，并通过智能合约生成与美元挂钩的 DAI 稳定币。生成 DAI 时，用户的资产需要超额抵押，例如用户必须将价值 2 美元的资产抵押，才能生成 1 美元的 DAI。
> 
> **稳定费率与清算机制**
> 
> -   为了确保 DAI 稳定，MakerDAO 使用 稳定费率来调节市场。稳定费是用户在还款时需要支付的利息。这一机制帮助 MakerDAO 控制 DAI 的供应量，避免其脱离 1 美元的目标价格。
>     
> -   如果抵押资产的价值下降，且用户的抵押率低于系统设定的安全阈值，系统会触发 清算，自动将抵押资产出售以偿还债务，防止系统破产。
>     

## **NFT：数字所有权的革命**

**1.NFT的本质：数字资产的唯一性和所有权**

每个 NFT 代表一个唯一的数字资产，并且在区块链上存有不可篡改的记录。通过 NFT，你不仅可以拥有数字文件的“副本”，而且可以拥有它的唯一性和所有权，这一点无法被复制或篡改。

**2.智能合约：自动化的所有权转移和交易**

智能合约是一种自执行的协议，意味着合约中的条款在满足特定条件时会自动执行，而无需第三方中介。这些合约不仅能确保交易的安全性和自动化，还能赋予 NFT 一些特别的功能：如，在 NFT 交易中，智能合约可以设定当你转售该 NFT 时，原作者会自动获得一定比例的转售收入（这被称为“版税”）。这个过程是自动化的，根本不需要依赖传统的艺术经纪人或拍卖行。

**3.OpenSea：NFT交易的中心**

OpenSea 是目前全球最大的 NFT 交易平台，基本上覆盖了所有主流 NFT 的交易，用户可以自主买卖。OpenSea的创新在于，它不仅仅是一个交易平台，它的基础设施使得 NFT 能够快速流通，所有权记录通过区块链系统得到确认和传递。你不再需要通过传统的金融系统，而是可以直接用加密货币（如以太坊）进行交易。

## **DAO：去中心化组织的崛起**

DAO（Decentralized Autonomous Organization，去中心化自治组织），不依赖传统的公司架构，而是通过智能合约和社区投票来做决策。它不需要一个管理层，所有事情都由持有代币的社区成员共同治理，公开透明，没有什么事情可以背着大家，尤其是利益分配相关的问题。

## **MEME：文化与投资热潮**

MEME 原意为“迷因”，即网络文化中的梗、表情包、搞笑段子等。在加密圈，MEME 通常指那些以网络文化为基础的代币，比如 DOGE（狗狗币）、PEPE（青蛙币）、SHIB（柴犬币）等。

MEME 币的特点通常是“有趣、搞怪、社区驱动”，它们往往缺乏明确的技术价值，但通过强大的社区共识和文化认同获得价值。2024-2025 年，MEME 币市场出现了新的特点：**公平发射**（Fair Launch）、**社区自治**和**实用性整合**成为新趋势。

MEME币具有极高投机性和波动性，价格可能短时暴涨暴跌

## **2025趋势**

> **1.Intent-Based交易**
> 
> 传统的 Web3 交易需要用户明确指定每一步操作（如选择 DEX、设置滑点等），而意图驱动的交易允许用户表达目标（如“用 100 USDC 买到最多的 ETH”），由系统内不同的求解器给出报价，系统最终自动寻找最优报价对应的路径执行。
> 
> 核心技术栈：
> 
> -   **Solver 网络**：专门的求解器竞争为用户找到最优解决方案
>     
> -   **Intent 标准化**：ERC-7683 等标准定义意图表达格式
>     
> -   **跨链聚合**：自动在多个链之间寻找最佳流动性
>     
> 
> **代表项目：**
> 
> -   **UniswapX**：基于荷兰拍卖的意图交易协议
>     
> -   **1inch Fusion**：零 Gas 费的意图驱动 DEX 聚合器
>     
> -   **CoW Protocol**：专注 MEV 保护的批量交易协议
>     
> 
> **2.账户抽象与智能钱包**
> 
> 账户抽象（Account Abstraction, AA）通过 ERC-4337 标准，让以太坊账户具备智能合约的灵活性，用户无需持有 ETH 即可进行交易，支持社交恢复、批量操作等高级功能。
> 
> 核心功能：
> 
> -   **Gas 代付**：第三方可为用户支付交易费用
>     
> -   **社交恢复**：通过朋友/家人恢复钱包，而非助记词
>     
> -   **批量交易**：一次签名执行多个操作
>     
> -   **自定义验证**：支持生物识别、多重签名等
>     
> 
> **代表项目：**
> 
> -   **Safe**：企业级多重签名智能钱包
>     
> -   **Argent**：移动端智能钱包先驱
>     
> -   **ZeroDev**：开发者友好的 AA 基础设施
>     
> 
> **3.模块化区块链**
> 
> 2025 年的区块链架构向模块化发展，将执行、共识、数据可用性、结算等功能分离，实现更好的可扩展性和可定制性。
> 
> **核心层级：**
> 
> -   **结算层**：最终性和争议解决（Ethereum L1）
>     
> -   **数据可用性层**：数据存储和检索（Celestia、EigenDA、Ethereum Blob）
>     
> -   **执行层**：交易处理和状态转换（Optimism、Arbitrum）
>     
> -   **共识层**：区块排序和最终确定（Ethereum PoS）
>     
> 
> **代表项目：**
> 
> -   **Celestia**：专用数据可用性层
>     
> -   **Polygon CDK**：可定制的 zkEVM 部署工具
>     
> -   **OP Stack**：模块化的 Optimistic Rollup 框架
>     
> 
> [**4.AI**](http://4.AI)**+Web3融合**
> 
> 人工智能与 Web3 的结合创造了新的应用范式，从去中心化 AI 训练到 AI 驱动的自动化交易。
> 
> **主要方向：**
> 
> -   **去中心化 AI 训练**：分布式计算资源共享
>     
> -   **AI 代理**：自主执行的智能合约机器人
>     
> -   **预测市场**：AI 增强的市场预测和决策
>     
> -   **内容生成**：AI 创作的 NFT 和数字资产
>     
> 
> **代表项目：**
> 
> -   [**Fetch.ai**](http://Fetch.ai)： AI 代理网络
>     
> -   **SingularityNET**：去中心化 AI 市场
>     
> -   **Render Network**：分布式 GPU 计算网络
>
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->















## **Web3每日学习记录**

### **区块链基础概念**

**什么是区块链？**

区块链是一种去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据。

特性：不可篡改、公开透明、匿名、快速交易

**如何真的保证记录不被篡改且可信呢？**

一个区块链网络使用非常多的节点（矿机）来记账，每个节点都记录完整的、相同的区块链信息

有了分布式网络，才多了个去中心化的特性，即没人能控制全部节点，这份区块链数据一直存在。

**什么是比特币(BTC)?**

区块链网络节点服务商可以得到奖励，不同服务商得到不同代币奖励，BTC就是其中一种，BTC的供应量有限，还可以自由转账，也就有了货币特性，成为加密货币。

**那么，BTC缺点是什么？**

匿名有利有弊。弊端在于难以追踪和控制，常被黑产利用；打包一个区块得要10min，会影响交易实时性；每个区块存储数据有限。

**关于区块链的核心组成**

去中心化的网络和区块链：区块链由一条链来记录全部信息，存在于对应的去中心化网络。去中心化网络将由无数节点提供服务来维持网络运行。节点通过计算验证交易获取代币奖励。

维持网络运行的代币激励：去中心化网络将由无数节点提供服务来维持网络运行的操作统称挖矿，支付代币作为Gas Fee就是矿工的“工资”。进行交易、转账、铸造NFT都要支付代币

**一条区块链如何运行？**

关键步骤：

1.  **用户发起交易**：用户通过钱包应用发起转账、智能合约调用等操作
    
2.  **交易广播**：交易信息被广播到整个网络中的各个节点
    
3.  **节点验证**：网络中的矿工节点验证交易的合法性（余额是否足够、签名是否正确等）
    
4.  **打包成块**：通过共识机制（如工作量证明），矿工将验证过的交易打包成新的区块
    
5.  **链接上链**：新区块被添加到区块链上，更新全网的账本状态
    
6.  **奖励发放**：成功打包区块的矿工获得代币奖励和交易手续费
    

**什么是公链、私链、联盟链？**

去中心化程度从高到低排序：公链>联盟链>私链

①公链（Public Blockchain）就像一个完全开放的公共公园，任何人都可维护节点，自由进出；数据所有人可见，决策去中心化；缺点是人太多决策效率低、维护成本高

②联盟链（Consortium Blockchain）就像多公司联合的董事会，要成为节点，必须要邀请或申请才行；董事会成员可能分为决策者和观察者，前者权限更高；数据管理半开放式，只有内部成员才看得到，联合决策；比起公链，效率高、隐私好，但不如私链灵活

③私链（Private Blockchain）就像私人俱乐部，只有会员才能进，俱乐部boss完全控制规则，经boss审批才可加入，且一旦加入，成员权限也由boss决定；数据管理完全私有，账本只有会员能看，决策boss说了算；效率极高、隐私极强但是缺乏透明性

**Web3.0 ≠ Web3**

-   Web3 是**区块链驱动**的革命
    
-   Web 3.0 是**语义网技术驱动**的数据组织升级
    

**Web3去中心化互联网**

核心特征：

-   数据主权归用户：有区块链存储身份和资产
    
-   无需信任中介：智能合约自动执行规则
    
-   核心组件：
    
    钱包->(签名)->Dapp->(调用)->智能合约->(读写)->区块链
    
-   典型：MetaMask、Uniswap、ENS
    

### **以太坊概览 2026.1.12**

**什么是以太坊？**

以太坊（Ethereum）是一个开源的去中心化区块链平台，加密货币为以太币Eth，提供去中心化的以太虚拟机EVM来处理对点合约。

以太坊核心创新在智能合约Smart Contacts。智能合约时存储在区块链上的可执行代码，可在满足预设条件时自动执行操作。

**比特币与以太坊对比**

![image-20260112165805754.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/changlu812/images/2026-01-12-1768211429670-image-20260112165805754.png)

**以太坊生态概览**

以太坊的生态系统由多层架构组成：L1（主网）、L2（二层扩展解决方案）、侧链（Sidechains）

Layer1(L1)：

-   **以太坊主网**：核心区块链，负责最终安全性与共识。
    
-   **EVM**：以太坊虚拟机，执行智能合约代码。
    
-   **账户系统**：外部账户（EOA）与合约账户（CA）共同构成网络基础。
    

Layer2(L2)

-   Rollup：通过将交易批量处理后提交至 L1，降低 Gas 费。
    
    -   **Optimistic Rollup**：假设交易合法，仅在争议时验证。
        
    -   **ZK Rollup**：通过零知识证明验证交易，无需链上争议。
        

侧链：独立运行的链，通过桥接与主网交互

**以太坊生态层次**：

NaN.  **应用层（Application Layer）**
      

用户直接交互的应用和界面：

-   **DeFi 应用**：Uniswap（去中心化交易所）、Aave（借贷协议）、Compound（借贷协议）
    
-   **NFT 平台**：OpenSea、Foundation、SuperRare
    
-   **钱包应用**：MetaMask、Coinbase Wallet、Rainbow
    
-   **DAO 工具**：Snapshot、Aragon、Colony
    

**2.协议层（Protocol Layer）**

以太坊的核心基础设施：

-   **共识层客户端**：Prysm、Lighthouse、Nimbus、Teku
    
-   **执行层客户端**：Geth、Nethermind、Erigon、Besu
    
-   **核心协议**：EVM、状态管理、Gas 机制
    

**3.扩展层（Scaling Layer）**

提升性能和降低成本的解决方案：

-   **Layer 2 Rollups**： Arbitrum、Optimism、Polygon zkEVM、zkSync Era
    
-   **侧链**：Polygon PoS、xDAI（Gnosis Chain）
    
-   **状态通道**：Lightning Network for Ethereum
    

**以太坊的核心机制：从账户到执行的完整链路**

三大关键机制：账户系统、Gas模型、以太坊虚拟机EVM

**账户系统** 包含由私钥控制的 **外部账户（EOA）** 和由智能合约代码控制的 **合约账户（CA）**

每个账户都包含四个关键字段：

-   **Nonce**：防止重复交易的计数器（EOA 记录发送次数，CA 记录创建合约次数）。
    
-   **余额**：账户持有的 ETH 数量（单位为 Wei）。
    
-   **CodeHash**： EOA 为空哈希，CA 存储合约字节码的哈希值。
    
-   **StorageRoot**：记录账户数据的 Merkle 树根哈希（如 NFT 归属关系）
    

**Gas模型：交易的燃料费**

Gas 费用 = **用多少 × 每单位多少钱=Gas Limit × Gas Price**

Gas 的存在有两个目的：

-   **激励矿工/验证者**：你给得越多（Gas Price 越高），他们越愿意优先处理你的交易。
    
-   **防止资源滥用**：如果有人想让合约死循环，Gas 会用光，交易失败，系统不会被拖垮。
    

现在Gas分成基础费用Base Fee和小费Tip（给矿工的额外费用）

**以太坊虚拟机EVM：代码的执行引擎**

核心特点：

-   **图灵完备**：就像真正的电脑一样，EVM 可以执行各种逻辑，比如 if 判断、循环等。
    
-   **全球同步**：每个矿工/节点都会自己执行一遍合约代码，保证结果一样。
    
-   **隔离安全**：EVM 把合约“关”在一个小房间里运行，不允许它乱访问用户的数据和网络，保护隐私和安全。
    

一般流程

1.  **用户通过 EOA 发起交易**（如调用合约与 **CA** 交互，或者转账与其他用户的 **EOA** 交互）。
    
2.  **交易附带 Gas 参数**，矿工 / 验证者选择打包。
    
3.  **EVM 执行合约代码**，修改存储（如更新 NFT 归属）。
    
4.  **Gas 费用按 Gas Limit × Gas Price 扣除**，保障资源合理使用
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
