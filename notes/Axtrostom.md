---
timezone: UTC+8
---

# Axtrostom

**GitHub ID:** Axtrostom

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
## Unphishable 钓鱼攻防挑战

第一章测试是安装小狐狸

连接钱包

连接测试网络

领取测试币

之前已经做过了，基本上没什么问题

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGM0NmUyMDg4Y2IwOTEyYjc2OWVlODRmOTYxMWViMWJfbGljdTFxcWIzQmEzNnBOaVVUcTJaTDVBTE1aMmpkTlBfVG9rZW46SEgyMmJvTHZQbzg1cG54eFo5OGNSeThqbktiXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA2M2I5NmZjNzg5YWU5YzU2N2Y3Y2IyYjY5N2ZjMTFfYU1QUWR0RzNsQXhGeE5yYVBuM0N4WjRwc3pOb2tBR3JfVG9rZW46SUZFZ2JHdms4b1R1UDZ4UXNJdmMxQjRtbk5iXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

然后第二个实验是防钓鱼测试

钱包这个东西不是丢了就丢了，怎么还能找回的） 也算是顺利通过

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk5OThkYjUyNTYwMWFmNGJiMmMyZDNjYTgzMGUxYTJfY2NIaElNMHpRZEtCcEI1TFZjd1prUW1paHA0bHh6ZktfVG9rZW46RTF1bWJJSXdmb2VaRlF4UFQ1VmNIM2pRbjRlXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

然后第三个实验是请求比我身份证号都长的支出上限

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY5ZDQzODE5MDJiYzliMTc5ZTgwY2ZjYmQzNDlhZTJfWkVVWmcxSFdQaXJJaHlJdnMzRUJJYWw2V1M4T3FqWjdfVG9rZW46UVdiUmJoSjVnb1ZaOTB4cVVFWWNzdTIxbk1iXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

取消后直接完成了

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU4NWVjZjY5ZjUxMDY2MTdjOTA1MGE5YjkxM2E5NGVfcHRTSTJ2UWE1NGhnUmt4VW5qc3RwNGhzeGRVNnJBRHZfVG9rZW46T1RjUGJ1czRwb3JEbXF4bnJkRWM2TjJSbjllXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

然后是第四个测试，怎么领取空投还要我自己花钱的

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg2NDQ1YzkyZTRkNDQ0ZWYyMzU5NDg0MjRjNzFjZDJfT3lmNVRidGgzaW1EaDhXT2lkVjh4RkttNUhqUmhEdmpfVG9rZW46V3hMN2JteG92b0RLZFl4WlJkV2NTc2dibk1oXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

也是通过了

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=MTlkNjFlM2IyNjgwMDRkMTQ1MzUyOTFkNTY1MDUzOGJfc0xlYnJLZXZpRXdCamFNcXRnY0ZTc0hFMkNlY0YwR3ZfVG9rZW46R01ETWJlYUs4b0tQbkh4aE9EUWNNRURSbmhmXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

感觉总之就是不要花钱）

第五个也通过了

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=YzAxNGE2ZWVmZWRiMDFkMjdmZjFhMzFhNDU3MTA1ZWVfUVNlUmJyZ241eFYybFN3dnpmZU9JZjZQMUxaTDdzRlpfVG9rZW46TTNvMmJFQmIxb2RJVXB4RVg4aWNsNHlabkJlXzE3Njg1NjYwNDA6MTc2ODU2OTY0MF9WNA)

[app.un1swap.org](http://app.un1swap.org)

[app.uniswap.org](http://app.uniswap.org)

查了一下交易信息的格式

```YAML
Transaction Hash:   0x5d2a... (唯一的交易ID)
Status:             Success (成功)
Block:              18234567
Timestamp:          1 min ago
Transaction Action: Swap 1,000 USDT for 0.5 ETH (明确的操作描述)
From:               0xYourWalletAddress (你的钱包地址)
Interacted With (To): 0xUniswapRouterAddress (Uniswap 官方路由合约，且通常有绿勾认证)

ERC-20 Tokens Transferred: 
From 0xYourWallet... To 0xUniswapPool... For 1,000 USDT (Tether USD)
From 0xUniswapPool... To 0xYourWallet... For 0.5 WETH (Wrapped Ether)

Value:              0 ETH (因为你转的是代币，不是 ETH 本身)
Transaction Fee:    0.002 ETH (Gas 费)
```

钓鱼信息中

```YAML
Transaction Hash:
0x1b23f927c47a6cb68fb7207a42c600a34726c583082301d2b7626d5447a5e363
Status:
Success 20 Block Confirmations
Block:
3504400
Timestamp:
5 mins ago (Mar-17-2025 02:34:36 AM UTC)
Transaction Action:
Call Function by 0x4276BF06...a1B7D03Ce on 0x4d264c6A...41F757Fe5
From:
0x4276BF06Aebd8A1F3D89a1fd5BF84bFa1B7D03Ce
Interacted With (To):
0x4d264c6Ab8933633cd8B052dE243Fa41F757Fe5
ERC-20 Tokens Transferred:
From 0x4276BF06...a1B7D03Ce To 0xE1a9d5C7...615506D4
For 8,888 ERC-20: app.un1swap.org (UNI)
Value:
0 ETH
Transaction Fee:
0.0000001689464305 ETH
Gas Price:
0.003237514 Gwei (0.000000000003237514 ETH)
```

ERC-20 Tokens Transferred:

From 0x4276BF06...a1B7D03Ce To 0xE1a9d5C7...615506D4

For 8,888 ERC-20: [app.un1swap.org](http://app.un1swap.org) (UNI)

这部分本应该是代币名称的，被改成钓鱼链接了

然后下一个测试也是要无上限的转账
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

### 一、 宏观背景与合规基本逻辑

1\. 合规 vs. 风控

-   **企业端**：主要强调“合规”（Compliance）。
    
-   **个人端**：本质是“风控”（Risk Control）。
    
-   **核心矛盾**：法律具有**滞后性**，而Web3行业具有激进性和创新性。在大陆语境下，由于政策收紧，合规空间狭窄。
    
-   **律师的作用**：将滞后的法律规定与新兴业务形态进行梳理和匹配，通过规范业务动作来规避法律红线。
    

2\. 地域差异（大陆 vs. 香港）

-   **法无禁止即自由**：在香港等地，如果没有明确法律禁止（如早期的找换店），业务可以开展；一旦立法（如稳定币条例），业务需收缩或持牌。
    
-   **大陆环境**：强调刑事合规，监管更为严厉，往往缺乏明确的“Web3法律”，而是套用现有的刑法罪名。
    

* * *

### 二、 具体业务场景的风险与案例

1\. 发币与ICO（非法集资风险）

-   **现状**：单纯发币（如Meme币）本身不一定构成犯罪，但**“公开融资”**是红线。
    
-   **负面清单**：大陆严厉打击利用发币进行公开融资的行为（ICO）。
    
-   **案例**：
    
    -   **畜牧业类比**：“认养一头牛”模式若涉及传销机制和公开融资，同样违规。
        
    -   **Mimi Coin案例**：某项目仿照Meme Coin玩法，社区喊单后撤回流动性，即便请了国内顶尖刑辩律师，最终仍被认定为**诈骗罪**。
        

2\. 交易所与永续合约（开设赌场风险）

-   **办案逻辑**：
    
    -   办案人员不懂技术，通常问：“听过94、924公告吗？”若听过仍从业，被视为有主观犯罪故意。
        
    -   **定性**：永续合约被视为“压大小”的赌博，交易所被定性为**开设赌场**，技术人员（即使主张技术中立）会被视为共犯（提供技术支持）。
        
-   **辩护难点**：虽然律师主张合约是金融活动（风险控制权在用户手中）而非赌博（买定离手），但在大陆语境下，常出现**“逐利性执法”**（通过打击交易所实现地方财政创收）。
    
-   **合规出路**：
    
    -   **形式合规**：完善法律文本。
        
    -   **深度合规**：这就涉及到“中国特色”的合规，即与地方建立良好关系。
        

3\. 挖矿业务（政策波动与转型）

-   **演变**：从全面禁止到部分地方政府默许回流。
    
-   **转型路径**：将挖矿包装为**AI算力超算中心**。与政府签协议，甚至获取政策福利。算力可合规外贸卖给海外，至于海外买家是用来挖矿还是跑AI，则属于服务范畴，风险隔离。
    

4\. 去中心化业务（Polymarket类）

-   **定性**：虽然美国可能将其视为金融衍生品，但在大陆法律体系下，如果华人开设此类预测市场，必被定性为**赌博**。
    
-   **建议**：彻底出海，不要在大陆硬刚司法认定。
    

* * *

### 三、 资金与账户风险（OTC、出入金、U商）

1\. 个人出入金（风险极高）

-   **数据**：出金涉案比例在律所咨询中占比约7%。
    
-   **现状**：
    
    -   **冻卡风险**：核心是收到赃款（电信诈骗、赌博资金）。
        
    -   **警方态度**：部分地区（内蒙、新疆）仍倾向跨省抓人；其他地区若能证明“善意取得”（不知是赃款、价格合理、留存证据），可协商解冻。
        
    -   **税务风险**：通过香港合规交易所出金回国，已被税务局盯上，要求**申报税务**。
        

2\. 新型风险：入金攻击（洗钱新手段）

-   **背景**：海外资金盘洗钱成本高、通道少。
    
-   **手法**：洗钱团伙找普通人（如正规职业者），要求普通人付5万现金，团伙向其指定账户打入10万赃款。
    
-   **后果**：账户因收赃款被冻结甚至立案。
    
-   **建议**：若账户莫名收到大额资金，需警惕并考虑主动报案留底；交易必须核实对手方身份（KYC）。
    

3\. U商（USDT交易商）

-   **结论**：在大陆**做不了**，要做只能去海外。
    
-   **终极形态**：加密支付（Crypto Payment）。
    
-   **B端风险**：即便做B端生意，也难免被“车队”（海外洗钱团伙/地下钱庄）盯上，混入黑钱导致账户连坐冻结。
    

4\. U卡（加密信用卡）风险

-   **挂靠公司风险**：发卡方将用户挂靠为公司员工，一旦公司被查，资金冻结。
    
-   **“私池”风险**：发卡方是个人组局，资金在其控制的多签钱包或个人地址中。若合伙人闹翻、被抓或跑路，用户资金归零。
    

* * *

### 四、 项目方与KOL的衍生风险

1\. 项目方经营风险

-   **“配增公司”/技术侦查**：大陆存在与公安合作的技术公司，专门分析链上数据、卧底项目群、固定证据，举报后从罚没款中**拿返点**。
    
-   **常见罪名**：
    
    -   **非法吸收公众存款/集资诈骗**：针对公开募资。
        
    -   **非法经营罪**：口袋罪，涉及法币与虚拟币兑换（对敲）。
        
    -   **组织、领导传销活动罪**：
        
        -   误区：认为只有两级、不直接分润就没事。
            
        -   现实：司法实践直接穿透，实质重于形式。
            

2\. KOL（关键意见领袖）风险

-   **案例**：
    
    -   某资讯平台因给海外交易所（被定性为赌博网站）打广告，员工被抓，定罪\*\*“非法利用信息网络罪”\*\*。
        
    -   个人KOL接交易所推广，拿返佣（Rebate），被定性为**开设赌场罪的共犯**。
        
-   **求职建议**：入职Web3公司若涉及合约、期权板块，风险较高。
    

* * *

### 五、 总结与建议

1.  **出海是核心**：在大陆做Web3合规极其困难，建议业务和人员主体出海。
    
2.  **不要抱侥幸心理**：形式上的合规（如层级设计、技术中立说辞）在大陆穿透式执法面前往往无效。
    
3.  **深度合规**：如果必须在大陆展业，除了法律文本合规，还需要建立“中国特色”的深度合规（如与地方政府、监管的良好沟通与合作）。
    
4.  **警惕新型犯罪**：如入金攻击、配增公司的钓鱼执法等。
    

**结束语**：合规不仅是针对Web3，任何行业在大陆进行非法募资或违规金融活动都会受到打击。在当前环境下，保护好自己（人身安全与资产安全）是第一要务。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->


## w1d3

-   **入门技术&深度技术任务**
    
    -   [**Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs**](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)
        
    -   021 以太坊 第四章
        
-   **Rust基础**
    
    -   10 [Generic Types, Traits, and Lifetimes](https://rust-book.cs.brown.edu/ch10-00-generics.html#generic-types-traits-and-lifetimes)
        
-   **杂项**
    
    -   改卷子
        
    -   整理企业项目方案
        

有点慢了，感觉走远了

总之加油干吧还能怎么办，实在不行明天开始争取能把上午的时间变成学习的

看着后面几天的任务好像不多，等到周五六日猛猛补进度吧

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=OTBlNGEwODFkNTY1N2Q3NDZhMTFiNTJhNzgyNDM4OTFfU2NtN1A5bkF6ZXR2YmY2eFN0VGUybmo3djFXRFhKWDhfVG9rZW46VFBrb2JFcWtsb0dMT3p4VHRpMGNHTG5FbmJhXzE3NjgzNjc4Mjk6MTc2ODM3MTQyOV9WNA)

* * *

-   [https://layer2.myfirst.io/#1.3-layer2](https://layer2.myfirst.io/#1.3-layer2)
    

不知道什么时候打开的网页，后面看一下

## Rust 基础[Generic Types, Traits, and Lifetimes](https://rust-book.cs.brown.edu/ch10-00-generics.html#generic-types-traits-and-lifetimes)

### Generic Types 泛型

在函数体中使用参数时，必须声明该参数。 参数签名中应包含参数名称，以便编译器知道该名称的含义。

定义泛型函数，我们将类型名称声明放在尖括号内。 在函数名和参数列表之间 `<>` ，如下所示：

```Rust
fn largest<T>(list: &[T]) -> &T {
```

我们把这个定义理解为：函数 `largest` 在某种类型上是泛型的 `T` 此函数有一个名为 `list` 的参数，它是一个类型为 `T` 的值的切片。 `largest` 函数将返回对相同类型 `T` 的值的引用。

**用泛型定义结构体**

```Rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

```Rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

用泛型定义枚举

```Rust
enum Option<T> {
    Some(T),
    None,
}
```

```Rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**定义相关方法**

```Rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {//函数名与字段名相同，是因为一般情况下字段名是私有的，需要通过方法来访问
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

为特定类型f32实现方法

```Rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

你不能同时实现同名的特定方法_和_通用方法。例如，如果你为所有类型 `T` 实现了一个通用的 `distance_from_origin` 方法，又为 `f32` 实现了一个特定的 `distance_from_origin ，那么编译器会拒绝你的程序：Rust 不知道在调用` `Point<f32>::distance_from_origin` \` 时应该使用哪个实现。

**如何在同一个方法中，混合使用“结构体定义的泛型”和“方法自带的泛型”**

```Rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

**Rust 的泛型没有任何运行时性能损耗**

下面这个代码无法通过编译

```Rust
fn print_slice<T>(v: &[T]) {
  for x in v {
    println!("{x}");
  }
}
fn main() {
  print_slice(&[1, 2, 3]);
}
```

Rust 的编译器非常严谨。虽然你说 `T` 可以是任何类型，但并非所有类型都能用 `{}` 格式来打印。

需要给 `T` 加一个约束，告诉编译器：“我只接受那些**实现了打印功能**的类型”。

```Rust
use std::fmt::Display; // 引入 Display 特征

// 关键点：<T: Display>
// 这句话的意思是：T 可以是任何类型，但前提是它必须能被打印
fn print_slice<T: Display>(v: &[T]) {
    for x in v {
        println!("{x}");
    }
}

fn main() {
    print_slice(&[1, 2, 3]);
}
```

### Trait

Trait 定义了一种“共同的行为”或“能力”

类似接口，需要给出一些需要实现的功能

例如，假设我们有多个结构体，分别保存各种类型和数量的文本：

-   一个 `NewsArticle` 结构体，用于保存特定位置的新闻报道；
    
-   一个 `SocialPost` 结构体，最多可以包含 280 个字符，以及指示它是新帖子、转发帖子还是对另一个帖子的回复的元数据。
    

我们希望创建一个名为 `aggregator` 的媒体聚合库 crate，它能够显示可能存储在 `NewsArticle` 或 `SocialPost` 实例中的数据摘要。为此，我们需要每种类型的摘要，并且将通过在实例上调用 `summarize` 方法来请求该摘要。清单 10-12 展示了一个公开的 `Summary` 特性的定义，该特性表达了这种行为。

```Rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

**在类型上实现特性**

```Rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

在一个类型上实现特性与实现常规方法类似。不同之处在于，在 `impl` 后面，我们放置要实现的特性名称，然后使用 `for` 关键字，接着指定要为其实现特性的类型名称。

需要 trait 或者 类型 在当前 crate 才可以为其实现 trait

**默认实现**

```Rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

后续可以选择保留，也可以直接覆盖

```Rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

也可以这样写，直接调用别的 trait

**将 Trait 作为参数**

```Rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

上面的代码意思是 item 需要是实现了 Summary trait 的类型

**Trait Bound 约束**

```Rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

跟刚才的代码功能上一样，不过刚才的代码使用了语法糖，更简单一些，这个是展开的写法

这种写法比较适用于更复杂的情况，例如，我们可以有两个实现 `Summary` 的参数。使用 `impl Trait` 语法看起来像这样：

```Rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

如果我们希望强制两个参数具有相同的类型，我们必须使用特征约束，如下所示：

```Rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

我们也可以指定多个特质约束。

```Rust
pub fn notify(item: &(impl Summary + Display)) {
```

```Rust
pub fn notify<T: Summary + Display>(item: &T) {
```

但是如果面对更复杂的情况，会导致函数签名过长，可以使用 where

```Rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {

fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
```

可以在返回位置使用 `impl Trait` 语法来返回一个实现某个特征的类型的值，如下所示：

```Rust
fn returns_summarizable() -> impl Summary {
```

只能在使用单个返回类型时使用 `impl Trait` 。例如，以下代码返回一个 `NewsArticle` 或一个 `SocialPost` ，并且将返回类型指定为 `impl Summary` ，这样将无法工作

```Rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {}
    } else {
        SocialPost {}
    }
}
```

即使你用了 `impl Trait` 隐藏了具体类型，但在编译时，**该函数的所有分支返回的具体类型必须完全一样。**

**使用 trait bound 条件性的实现方法**

```Rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {//给只有实现了 Display + PartialOrd trait 的 T 实现的功能
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

### 生命周期

-   一种泛型
    
-   生命周期确保引用在我们需要它们有效的时间内始终有效
    

生命周期的主要目的是防止悬垂引用

```Rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

简单来说就是指针指向的内存**原本是有效的**，但是后来被释放（free/drop）了，而指针还在

```Rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

编译器在检查 `longest` 函数时，是一个 **局部检查 (Local Analysis)**。它只盯着这个函数看，看不到外部是谁在调用它（看不到 `main` 函数里的花括号）。

如果函数返回 `x`，那么返回值的寿命 = `x` 的寿命。

如果函数返回 `y`，那么返回值的寿命 = `y` 的寿命。

现在问题来了：既然不知道返回谁，那编译器应该要求返回值的寿命必须多长才安全呢？它陷入了逻辑死循环。

既然编译器猜不到，我们就手动写下“生死契约”。

**契约内容 (**`'a`**)**：我们告诉编译器：“别管具体是 `x` 还是 `y`，反正**返回值的寿命**肯定不会比 **输入参数里寿命最短的那个** 更长。”

**生命周期注解语法**

  生命周期注解不会改变任何引用的存活时间

  生命周期注解的语法略有不同：生命周期参数的名称必须以撇号（ `'` ）开头，通常全部小写且非常简短，类似于泛型类型。大多数人使用 `'a` 作为第一个生命周期注解的名称。我们将生命周期参数注解放在引用的 `&` 之后，用空格将注解与引用的类型分开

  仅有一个生命周期标注本身并没有太多意义，因为这些标注的目的是告诉 Rust 多个引用的泛型生命周期参数之间是如何相互关联的

**函数签名中的生命周期注解**

```Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

感觉这部分没看太明天，但是基本上知道怎么用了

为什么没看明白？

没搞懂这个生命周期是干什么用的，似乎只能给编译器提供信息

好像该报错的地方还会报错

**结构体定义中的生命周期注解**

```Rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

我们在结构体名称后面的尖括号中声明泛型生命周期参数的名称，以便在结构体定义的主体中使用生命周期参数。这个注解意味着 `ImportantExcerpt` 的实例不能比它在其 `part` 字段中持有的引用存活得更久

**生命周期推断**

```Rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

在 Rust 的早期版本（1.0 之前），这段代码是无法编译的，因为每个引用都需要显式的生命周期

在编写了大量 Rust 代码后，Rust 团队发现 Rust 程序员在特定情况下会反复输入相同的生命周期注解。这些情况是可预测的，并遵循几种确定性的模式。开发人员将这些模式编程到编译器的代码中，以便借用检查器可以在这些情况下推断生命周期，而无需显式注解。

当结构体本身带有生命周期参数时，如何为它实现方法

```Rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

特殊生命周期 `'static`

表示受影响的引用可以持续整个程序的运行时间

* * *

卷子改不完了😭😭😭😭😭😭😭😭😭
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->




## w1d2

今天先保底把昨天没干完的事情干完吧

-   **入门技术&深度技术任务**
    
    -   021 学习以太坊第 3 章
        
    -   [**Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs**](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)
        
    -   [Uniswap V2 学习官方文档](https://docs.uniswap.org/contracts/v2/overview?utm_source=chatgpt.com)
        
-   **Rust基础**
    
    -   第八章 common collection
        
    -   第九章 error handling
        
-   **杂项**
    
    -   把小登试卷er图那题改完吧
        

先这样吧，至少今天要把这些事给干完

* * *

## **Rust基础**

### **String**

**str和 String的区别**

-   str 是字符串切片，是一串长度可变的字节序列，是要访问的一块数据本身
    
-   &str 胖指针，起始位置+长度
    
-   String 是 围绕 Vec<u8> 封装的结构体，封装了一些列
    

**构造**

```Rust
println!("Hello, world!");

let mut s = String::new();
let data = "initial contents";
let s = data.to_string();
// The method also works on a literal directly:
//实现了display trait的类型都可以使用to_string方法
let s = "initial contents".to_string();
let s = String::from("initial contents");
```

**连接字符串**

```Rust
let mut s = String::from("foo");
s.push_str("bar");//使用push_str方法追加字符串

let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);//使用push_str方法追加字符串，本质上s2没有被移动，对s2的数据进行了一次“字节拷贝”
println!("s2 is {s2}");//s2仍然有效

let mut s = String::from("lo");
s.push('l');//使用push方法追加单个字符

let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1被移动，无法再使用
//s2仍然有效，因为它是通过引用传递的

let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{s1}-{s2}-{s3}");
//使用format!宏来连接字符串，format!宏不会获取任何参数的所有权
```

**迭代字符串的方法**

字符串不支持索引访问，因为字符串是UTF-8编码的，某些字符可能占用多个字节

不支持下面的操作

```Rust
let s1 = String::from("hi");
let h = s1[0];
```

获取第N个字节

```Rust
let s1 = String::from("hello");
// 1. 先转成字节切片，再索引
let h_byte = s1.as_bytes()[0]; 
println!("{}", h_byte); // 输出 104 (这是 'h' 的 ASCII 码)
println!("{}", h_byte as char); // 强转回 char，输出 'h'
```

获取第N个Unicode字符

```Rust
let s1 = String::from("你好World");
// 1. 获取迭代器 -> 取第0个 -> 解包(因为可能越界返回None)
let c = s1.chars().nth(0).unwrap(); 
println!("{}", c); // 输出 "你"
```

直接迭代

```Rust
for c in "Зд".chars() {
    println!("{c}");
}
```

逐字节

```Rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

### Hash Map

> 用太久dict说哈希表想不起来是什么，其实就是字典

基础操作

```Rust
    use std::collections::HashMap;//导入HashMap类型

    let mut scores = HashMap::new();//创建一个空的HashMap

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);//向HashMap中插入键值对

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);//通过键获取值

    for (key, value) in &scores {//遍历HashMap中的键值对
        println!("{key}: {value}");
    }
```

在通过调用 `insert` 将变量移入哈希映射后，我们无法再使用这些变量，所有权转移到哈希表

解决方法可以直接使用clone或者引用，但是用引用的话需要考虑生命周期的问题

更新

直接 insert ，相同的键会被覆盖

使用 entry 可以只在没有键值的时候插入

```Rust
    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);
```

`Entry` 上的 `or_insert` 方法被定义为：如果该键存在，则返回对应 `Entry` 键的值的可变引用；如果不存在，则将参数作为此键的新值插入，并返回对新值的可变引用。

基于旧值更新

```Rust
    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }
```

hashmap的所有权最小粒度是hashmap，不是键值对

```Rust
fn reverse(v: &mut Vec<String>) {
    let n = v.len();
    for i in 0 .. n / 2 {
        let p1 = &mut v[i] as *mut String;
        let p2 = &mut v[n - i - 1] as *mut String;
        unsafe { std::ptr::swap_nonoverlapping(p1, p2, 1); }
    }
}
```

### 错误处理

Rust 认为错误不可避免，因此强制要求开发者在**编译阶段**就显式处理潜在的错误，以确保程序的健壮

Rust 将错误明确分为两类：

-   **可恢复错误**（Recoverable）：例如文件未找到，通常只需报告问题或重试。
    
-   **不可恢复错误**（Unrecoverable）：通常是 Bug（如数组越界），需要立即终止程序。
    

与大多数语言使用“异常”（Exceptions）不同，Rust 使用特定的工具来处理这两类错误：

-   用 `panic!` **宏** 处理不可恢复错误。
    
-   用 `Result<T, E>` **类型** 处理可恢复错误。
    

用 Result 的一个例子

```Rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };
}
```

还能进一步细分处理

```Rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            },
            _ => {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}
```

更进一步，不使用 match 的写法

```Rust
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
```

使用 unwrap 的例子

```Rust
let greeting_file = File::open("hello.txt").unwrap();
```

`unwrap()` 的本质就是：“如果不成功，就 panic”。

就相当于不处理失败的 result

**Expect**

```Rust
let greeting_file = File::open("hello.txt").expect("hello.txt should be included in this project");
```

expect相当于加了个错误信息的 unwrap ，失败时 panic 并且输出错误信息

Propagating Errors 错误传递

当一个函数的实现调用了一个可能失败的函数时，与其在函数内部处理错误，不如将错误返回给调用代码，由它来决定如何处理

```Rust
fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");
    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();
    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

下面是更简单的写法

```Rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

再缩

```Rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?;
    Ok(username)
}
```

再缩

```Rust
fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

我们只能在返回 Result、Option 或实现 FromResidual 的其他类型的函数中使用 ? 操作符。

`?` 是 Rust 中用于“错误传播” (Error Propagation) 的语法糖：如果这个操作成功了，就把里面的值给我；如果出错了，立马把错误扔给调用我的函数，我也不干了

`File::open("hello.txt")?.read_to_string(&mut username)?`

在 open 返回 err 的时候就不会执行 read\_to\_string 了

```Rust
fn read_username_from_file() -> Option<String> {
  let mut username_file = File::open("hello.txt")?;
  let mut username = String::new();
  username_file.read_to_string(&mut username)?;
  Some(username)
}
```

这个代码不能通过编译，因为 ？ 会直接返回一个 result 类型，但是函数的输出是 option

修改的话可以将 option 换为 result

To panic! or Not to panic!

-   在原型设计阶段，当你还没准备好处理错误时，\` `unwrap` 和 `expect` 方法非常有用
    
-   当您有一些逻辑确保 `Result` 值为 `Ok` 时，调用 `expect` 也是合适的，但这些逻辑编译器无法理解。
    

* * *

## 021学习以太坊 第三章

### 创建合约的两个操作码

  **CREATE**

  合约地址 = keccak256( RLP(\[s ender, nonce\]) ) 的后 20 字节

  **CREATE2**

  合约地址 = keccak256(0xff + deployer + salt + keccak256(init\_code)) 的后 20 字节

CREATE2 的最大价值是可预测地址，相同输入在任意 EVM 链上会生成相同地 址

### 一、EOA 的定义与控制方式

以太坊有两种账户

-   EOA：由公私钥对控制，可以发起交易，简单来说就是发起交易或者调用合约的人
    
    -   有私钥，不可存代码，只能签名，只能交易
        
-   合约账户：用于存储被调用的合约，可以通过访问合约账户的地址执行存储的合约
    
    -   没有私钥，有地址，有余额，可持有NFT
        

一个账户有以下字段：

| 字段 | EOA (你的钱包) | 合约账户 (如 Uniswap) |
| nonce | 交易次数 | 创建过的子合约数 |
| balance | 你的 ETH 余额 | 合约持有的 ETH 余额 |
| storageRoot | 空 | 指向合约的数据存储树 |
| codeHash | 空哈希 | 指向合约的代码逻辑 |

**助记词**

-   BIP-39 定义了助记词，便于记忆
    
-   由助记词可以生成**无数个**私钥。
    
-   一组助记词能生成无数个私钥，那具体生成哪一个呢？这就要靠**派生路径**来指定。
    

$$\\text{助记词} \\xrightarrow{\\text{加盐(可选)}} \\mathbf{\\text{种子 (Seed)}} \\xrightarrow{\\text{派生路径}} \\mathbf{\\text{特定的私钥}}$$

### 二、合约账户的概念与创建流程

**合约账户**

-   有地址，有余额
    
-   有 code（合约逻辑）和 storage（状态存储），可以读写状态、转账、 调用其他合约
    
-   不能主动发起交易
    

**创建合约账户流程**

1.  编写智能合约
    
2.  编译成 EVM 字节码
    
    1.  初始化部署在链上
        
    2.  被调用
        

**如何在 Solidity 合约代码中，去调用另一个合约或给别人转账**

**方法一：使用低级接口** `.call`

```Solidity
(bool success, bytes memory data) = _targetAddress.call{value: _amount, gas: _gas}(_payload);
```

  参数

    **目标地址 (**`_targetAddress`**)**:

-   你要转账给谁？或者你要调用哪个合约？
    
-   类型：`address` 或 `address payable`。
    

    **附带金额 (**`value`**)** _(可选)_:

-   你要转多少 ETH 过去？
    
-   参数写法：`{value: 1 ether}` 或 `{value: msg.value}`。
    
-   注意：单位是 Wei。如果不写，默认为 0。
    

    **Gas 限制 (**`gas`**)** _(可选)_:

-   你限制这步操作最多消耗多少 Gas？
    
-   参数写法：`{gas: 5000}`。
    
-   建议：通常**不建议**手动指定，除非有特殊安全需求。默认会把剩余所有 Gas 传过去。
    

    **调用数据 (**`_payload`**)**:

-   **如果是纯转账**：传空字符 `""`。
    
-   **如果要调用函数**：需要使用 `abi.encodeWithSignature(...)` 对函数名和参数进行编码。
    

```Solidity
function sendMoney(address payable _to) public payable {
    // 接口：call
    // 参数：value (金额), data (空)
    (bool success, ) = _to.call{value: msg.value}("");
    
    require(success, "Transfer failed."); // 必须检查返回值
}
```

**方法二：使用接口 Interface**

```Solidity
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
```

```Solidity
function callByInterface(address _tokenAddress, address _to, uint256 _amount) public {
    // 1. 实例化接口
    IERC20 token = IERC20(_tokenAddress);
    
    // 2. 直接调用 (编译器会自动处理参数编码和 call 接口)
    bool success = token.transfer(_to, _amount);
    
    require(success, "Token transfer failed");
}
```

算了，先不看 solidity 了，等之后系统的学一下吧

合约账户的能力与限制

**核心能力**

-   **管钱管数据**：既能持有 ETH/Token，又能存储复杂数据（Storage）。
    
-   **执行逻辑**：是 DEX、NFT、DAO 的载体，代码定义规则。
    
-   **链上交互**：在运行过程中，可以转账、调用别的合约，甚至生出新合约（CREATE/CREATE2）。
    

**核心限制**

-   **被动执行**：**无私钥**。它不能主动“动”起来，必须由外部（EOA）或其他合约“推一把”才能运行。
    
-   **代码固化**：部署后**代码不可改**（Code Immutable），只能修改内部数据（除非用代理模式）。
    
-   **部署昂贵**：因为占用了链上的永久存储空间，创建合约的 Gas 费很高。
    

### 三、以太坊地址“0x”开头的由来

以太坊地址本质是一串 20 字节（160 bit）的二进制数据，写成字符串时通 常用十六进制展示，于是按照编程界传统加了个前缀 0x

### 四、EOA 与合约账户的控制方式对比

| 维度 | EOA (外部账户) | CA (合约账户) |
| 控制核心 | 私钥 (Private Key) | 代码 (Code Logic) |
| 能否主动 | 能 (一切交易的起点) | 不能 (只能被动响应调用) |
| 创建成本 | 免费 (本地生成密钥对) | 昂贵 (需支付 Gas 存贮代码上链) |
| 权限管理 | 只有“拥有/未拥有”私钥两种状态 | 高度灵活 (多签、角色、白名单) |
| 主要风险 | 私钥丢失/泄露 | 代码漏洞 (Bug) / 逻辑错误 |
| 可变性 | 行为固定 (只能签名发交易) | 代码不可变 (但可经由代理升级) |
| 识别方式 | eth_getCode 返回空 | eth_getCode 返回字节码 |

由于 EOA 存在“单点故障”（私钥丢了就全完了），而合约账户可以编程，因此衍生出了两种增强安全性的机制：

**A. 多签钱包 (Multisig Wallet)**

-   **本质**：用智能合约模拟“多把钥匙开一把锁”。
    
-   **机制**：**M-of-N**。例如 3 人管理，至少 2 人签名同意才能转账。
    
-   **优势**：
    
    -   **防单点故障**：丢了一个私钥，钱还在。
        
    -   **适合团队**：DAO 国库、公司资产管理 (如 Gnosis Safe)。
        

**B. 时间锁 (Timelock)**

-   **本质**：给操作加一个“冷静期”或“公示期”。
    
-   **机制**：**提案 -> 等待延迟(Delay) -> 执行**。
    
    -   例如：管理员想修改合约参数，提交后必须等 48 小时才能生效。
        
-   **优势**：
    
    -   **防跑路/恶意篡改**：社区发现管理员作恶，可以在 48 小时内卖币退出。
        
    -   **增加透明度**：所有重大变更不仅公开，而且有预告。
        
-   **代价**：牺牲了紧急响应速度（修 Bug 也要等）。
    

### 六、合约账户的余额与状态存储

无论哪种账户，在状态树中都存储为：

$$Account = (nonce, balance, storageRoot, codeHash)$$

### 七、EOA 与合约账户的互相调用机制

### 九、ERC20 / ERC721 代币与合约账户的关系

转代币” 本质上是 “调用代币合约的一段代码 + 改一行存储

> 感觉这一章结构好像有点乱，很多重复的东西在来回讲

* * *

## Uniswap V2 学习官方文档

分为核心层和外围层

-   核心层 [https://github.com/Uniswap/v2-core](https://github.com/Uniswap/v2-core)
    
-   外围层 [https://github.com/Uniswap/v2-periphery](https://github.com/Uniswap/v2-periphery)
    

### Ecosystem Participants

**主要参与角色**

-   **流动性提供者 (LPs)**：提供资金（卖方/做市商）。
    
-   **交易者 (Traders)**：进行兑换（买方）。
    
-   **开发者 (Developers)**：构建工具和入口（基础设施）。
    

**核心机制**：

-   LPs 把代币存入池子 -> 交易者来兑换并支付 **0.30%** 的手续费 -> 这些手续费全部分给 LPs 作为奖励。
    
-   这个机制激励了更多人提供流动性，流动性越好，交易滑点越低，吸引更多交易者，产生更多手续费，从而吸引更多 LPs……
    

**A. 流动性提供者 (Liquidity Providers / LPs)**

1.  **被动型 LPs (Passive LPs)**：普通持币者，存池子里吃利息
    
2.  **专业型 LPs (Professional LPs)**：专业的做市商团队。他们使用复杂的策略和自定义工具来监控各个 DeFi 协议的收益率，并在不同项目间搬砖。
    
3.  **代币项目方 (Token Projects)**：新发币的项目方（比如发了一个新 Token "ABC"），为了让大家能买卖 "ABC"，项目方自己会充当 LP，创建一个 "ABC/ETH" 的交易对。这样一来，Uniswap 就成了这个代币的“交易所”。
    
4.  **DeFi 先驱 (DeFi Pioneers)**：探索高阶玩法的人。比如把 LP Token（你在 Uniswap 存钱后拿到的凭证）再拿去抵押借贷，实现“流动性挖矿”或“乐高组合”。
    

**B. 交易者 (Traders)**

1.  **投机者 (Speculators)**：普通的买卖交易者。比如看涨 ETH，就用 USDT 换 ETH。
    
2.  **套利机器人 (Arbitrage Bots)**：低买高卖的自动脚本，虽然它们是为了赚钱，但在客观上帮助 Uniswap 的价格**回归市场公允价格**，保持了市场的有效性。
    
3.  **DAPP 用户**：为了使用某个应用而买币。
    
4.  **智能合约 (Smart Contracts)**：比如“DEX 聚合器”（如 1inch），它是一个合约，它会自动计算发现 Uniswap 的价格最好，于是它的合约代码会自动调用 Uniswap 的合约进行交易。
    

**C. 开发者 (Developers)**

就是各种各样围绕 Uniswap 做开发的人

### Smart contracts

架构采用 核心 + 外围 的涉及

Core（核心层）**“极简主义 (Brutalist)”**。

-   代码极少，逻辑极简。容易审计，安全性越高。这是因为 Core 掌管着所有资金，绝对不能出错。
    
-   因为太简单，所以对人类很不友好（User-unfriendly），直接调用它会很麻烦且容易出错。
    
-   **包含组件**：
    
    -   **Singleton Factory (单例工厂)**：只有一个。它的任务只有两个：
        
        -   创建并索引所有的 Pair 合约（每个交易对一个）
            
            1.  每一个 Pair 合约就是一个独立的“资金池”
                
        -   控制是否开启协议收费。
            
    -   **Pairs (交易对)**：
        
        -   **做市商 (AMM)**：实际执行 `x * y = k` 逻辑的地方。
            
        -   **存钱罐**：记录池子里有多少币。
            
        -   **价格预言机**：提供历史价格数据。
            

Periphery（外围层）“用户友好”

-   它是 Core 的“管家”或“界面”。它没有特权（Permissionless），只是为了方便大家使用而写的一套工具合约。
    
-   Periphery 哪怕有 Bug，通常也不会导致 Core 里的资金直接被盗（因为资金在 Pair 里，不在 Router 里），最多是用户在使用 Router 过程中出问题。
    
-   **包含组件**：
    
    -   **Library (库)**：提供各种计算公式（比如算价格、算地址），主要是为了复用代码。
        
    -   **Router (路由)**：这是前端（Web UI）和钱包直接打交道的对象。
        
        -   **路径路由**：支持 `ETH -> A -> B -> C` 这种多跳交易。
            
        -   **ETH 支持**：把 ETH 处理成 WETH（后面会细讲）。
            
        -   **辅助功能**：比如支持用签名来移除流动性（Meta-transactions）。
            

三大关键设计决策 (Design Decisions)

Sending Tokens (代币发送机制)

-   **传统做法**：通常我们调用合约是 `approve` -> `transferFrom`。即：我授权给你，你把钱从我这拉走。
    
-   **Uniswap V2 的做法**：**“先转钱，再调用”**。
    
    -   **流程**：
        
        -   用户先把代币转账（Transfer）给 Pair 合约。
            
        -   用户调用 Pair 的 `swap` 或 `mint` 函数。
            
        -   Pair 检查：`当前余额 - 记录的余额 = 用户打进来的钱`。
            
    -   **为什么这么做？** 文档提到这部分原因在白皮书里，简单说是为了**解耦**和**安全性**，同时也支持了 **Flash Swap（闪电贷）**（这是唯一例外，可以先借钱再还）。
        

WETH (包装 ETH)

-   **V1 vs V2**：
    
    -   V1 的池子必须是 ETH ↔ ERC20。
        
    -   V2 的池子是 ERC20 ↔ ERC20。
        
-   **问题**：ETH 是原生货币，不符合 ERC-20 标准（它没有 `approve`, `transferFrom` 接口）。
    
-   **解决**：V2 Core 完全不支持 ETH。
    
    -   如果想创建 ETH 交易对，必须先把 ETH 包装成 **WETH (Wrapped ETH)**，它就是一个标准的 ERC-20 代币。
        
    -   这样 Core 的代码就不用写两套逻辑（一套处理 ETH，一套处理 ERC20），代码更干净。
        
    -   **用户感知**：用户在前端依然是用 ETH，是因为 **Router (Periphery)** 帮用户做了“ETH 转 WETH”的动作。
        

Minimum Liquidity (最小流动性销毁)

-   **机制**：当第一个人给一个新池子添加流动性时，会有 **1000 wei** (极微小的金额) 的 LP Token 被永久**销毁（Burn）**。
    
-   **目的**：**防数学攻击**。
    
    -   如果不销毁，攻击者可以通过操控初始流动性，构造出极其极端的价格或数量（比如把 totalSupply 弄得非常小），从而利用舍入误差（Rounding Errors）窃取后续用户的资金。
        
    
    > 在 Solidity（以太坊编程语言）中，**除法是向下取整的**。
    > 
    > -   `3 / 2 = 1.5` -> 在 Solidity 中结果是 **1**。
    >     
    > -   `1 / 2 = 0.5` -> 在 Solidity 中结果是 **0**。
    >     
    > 
    > 如果算出来的结果不到 1，就会变成 0。如果你存了钱，但系统计算你应该得到 `0.99` 个凭证，系统就会给你 **0** 个凭证。你的钱进去了，凭证没拿到，钱就归池子里其他人了。
    > 
    > 攻击者利用 `TotalSupply = 1`，通过捐赠操控分母，让后续用户的 `(存款 * 1) / 储备量` 计算结果小于 1，利用 Solidity 的舍入为 0 特性，让用户“存了钱却拿不到凭证”。
    > 
    > 强行把 `TotalSupply` 拉大 1000 倍。攻击者想操控比例，成本也随之扩大 1000 倍甚至更多，导致攻击在经济上不划算。
    
    -   销毁这 1000 wei 相当于提高了攻击门槛（成本），让这种数学攻击变得极其昂贵且不可行。
        
    -   对于正常用户，这 1000 wei 的价值几乎为零，可以忽略不计。
        

### Glossary

-   **utomated market maker(自动做市商)**：自动做市商是以太坊上的一个智能合约，它持有链上流动性储备。用户可以根据自动做市商公式设定的价格，与这些储备进行交易。
    
-   **Constant product formula(恒定乘积公式)**：Uniswap 使用的自动做市算法。参见 x\*y=k。
    
-   **ERC20(ERC20)**：ERC20 代币是以太坊上的同质化代币。Uniswap 支持所有标准的 ERC20 实现。
    
-   **Factory(工厂合约)**：一个智能合约，用于为任意 ERC20/ERC20 交易对部署一个唯一的智能合约。
    
-   **Pair(交易对合约)**：由 Uniswap V2 工厂合约部署的智能合约，用于实现两种 ERC20 代币之间的交易。
    
-   **Pool(资金池)**：交易对内的流动性是汇集了所有流动性提供者资金的集合。
    
-   **Liquidity provider / LP(流动性提供者 / LP)**：流动性提供者是指将等值的两种 ERC20 代币存入交易对流动性池中的人。流动性提供者承担价格风险，并获得费用作为补偿。
    
-   **Mid price(中间价)**：在特定时刻用户买入和卖出代币价格的中间值。在 Uniswap 中，这是两种 ERC20 代币储备量的比率。
    
-   **Price impact(价格影响)**：中间价与一笔交易实际成交价格之间的差额（通常由交易规模引起）。
    
-   **Slippage(滑点)**：交易对的价格在交易“提交时”与“实际执行时”之间的变动量（通常由市场波动或抢跑引起）。
    
-   **Core(核心合约)**：Uniswap 赖以生存的基础智能合约。升级核心合约的新版本需要进行流动性迁移。
    
-   **Periphery(外围合约)**：有用但非 Uniswap 存在所必需的外部智能合约。部署新的外围合约无需迁移流动性。
    
-   **Flash swap(闪电兑换)**：一种允许在支付代币费用之前就可以先使用所购买代币的交易模式。
    
-   **x _y = k(x_ y = k)**：恒定乘积公式。
    
-   **Invariant(不变量/恒定值)**：恒定乘积公式中的 "k" 值。
    

### Swaps

当提取（购买）任一代币时，必须存入（卖出）一定比例的另一种代币，以维持常数不变。

在最基础的层面上，Uniswap V2 中的所有兑换都发生在一个函数中，该函数被恰当地命名为 `swap`：

```Solidity
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data);
```

**Uniswap V2 模式 (Transfer + Swap)**

1.  **用户**：直接把 100 USDT **推（Push / Transfer）** 到 Pair 合约地址。
    
2.  **用户**：调用 Pair 合约的 `swap` 函数。
    
3.  **Pair**：看一眼自己兜里现在的钱，再查一下账本上原来的钱，算出差额：
    
4.  `当前余额 (Balance)` - `账本储备 (Reserve)` = `用户刚才打进来的钱 (Input)`。
    
5.  **Pair**：根据这个差额，算出该给你多少目标代币，然后发给你。
    

如果在非原子操作中，先转币给交易对再调用 swap 是不安全的，因为发送的代币容易被套利者截获

### Pools 资金池

-   **冷启动**：池子刚创建时是空的（余额为 0）。
    
-   **定价权**：**第一个**存入流动性的人（Initial LP），他存入的 Token A 和 Token B 的**比例**，直接决定了池子的**初始价格**。
    
-   **风险约束**：如果第一个人乱定价（比如存入比例偏离市场价），套利者（Arbitrageurs）会立刻进场搬砖，把便宜的币买走，导致第一个人亏损。
    
    -   _结论：市场博弈迫使 LP 必须按公允价格存币。_
        

**Pool tokens (资金池代币 / 流动性代币)**

  **LP Token = 存款收据**：当你存入流动性，你会收到 `Liquidity Tokens`。

-   **首次铸造公式**：数量 = sqrt(x \* y)。
    
-   **后续存入**：必须按当前池子的价格比例存入。
    

  **收益来源**：每笔交易收取的 **0.3% 手续费**，会按比例分给所有 LP。

-   注意：手续费不会直接打到你钱包，而是加到池子里，让你的 LP Token 变得更值钱。
    

  **退出机制**：把 LP Token 发回给合约（**Burn/销毁**），合约把对应的本金 + 赚到的手续费退给你。

### Flash Swaps

-   **什么是 Flash Swap？** 它允许你从 Uniswap 的池子里**预先提取**任意数量的代币（甚至把池子借空），拿去干任何你想干的事（比如去别的平台卖掉）。
    
-   **唯一的条件**： 这一切必须在同一个交易（同一区块）内完成。在交易结束的那一刹那，你必须：
    
    -   **方案 A**：用另一种代币支付刚才借走的代币（相当于买）。
        
    -   **方案 B**：把借走的代币原本奉还，并支付少量手续费（相当于借）。
        
-   **如果不还钱？** 整个交易会直接 **Revert（回滚）**，就像这一切从未发生过一样。
    

**场景 A：无本金套利 (Capital Free Arbitrage)**

-   **痛点**：以前发现差价（Uniswap 便宜，Oasis 贵），你得自己先有本金买下便宜的，再去卖。没钱就只能看着机会溜走。
    
-   **Flash Swap 解法**：
    
    -   **借**：从 Uniswap 借出 1 ETH（此时还没付钱）。
        
    -   **卖**：去 Oasis 把这 1 ETH 卖成 220 DAI。
        
    -   **还**：回到 Uniswap，按照当时的价格（比如 200 DAI）还债。
        
    -   **赚**：剩下的 20 DAI 就是你的利润，你实际上是**空手套白狼**（除了 Gas 费）。
        
-   **意义**：实现了**套利的民主化**，任何人只要有技术（代码），不需要有资本，就能抹平市场差价。
    

**场景 B：瞬时杠杆 (Instant Leverage)**

-   **痛点**：以前想在 MakerDAO 做 2 倍杠杆，需要“抵押 -> 借贷 -> 买币 -> 再抵押 -> 再借贷...”循环多次，操作繁琐且 Gas 费极高。
    
-   **Flash Swap 解法**：
    
    -   **借**：直接从 Uniswap 借出你最终想要的总 ETH 数额。
        
    -   **存**：把这些 ETH 一次性存入 MakerDAO。
        
    -   **铸**：生成 DAI。
        
    -   **还**：用生成的 DAI 偿还 Uniswap 的闪电贷。
        
-   **意义**：把复杂的多步操作压缩进一个原子交易中，省钱、省心。
    

* * *

歇逼了，今天就先学到这了

-   **入门技术&深度技术任务**
    
    -   021 学习以太坊第 3 章✅
        
    -   [**Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs**](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)**⭕**
        
    -   [Uniswap V2 学习官方文档](https://docs.uniswap.org/contracts/v2/overview?utm_source=chatgpt.com)✅
        
-   **Rust基础**
    
    -   第八章 common collection✅
        
    -   第九章 error handling ✅
        
-   **杂项**
    
    -   把小登试卷er图那题改完吧⭕
        

要学会跟自己和解

明明今天好像一直都在学，但是怎么感觉进度那么慢？

嗷，好像是下午打牌去了

唉，唉唉

明天再加把劲吧

试卷再不改老登估计要催了

想一下

明天周三，后天周四

明天要把企业项目的方案整理一下，组会给老登看

然后还有论文的代码实验，拖到周五六日干吧

明天改卷子，明天必须要改卷子了

今天就先这样吧，明天再努力

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM5MWQwOGExNmRkYzE5ZTAxNzVlZWRmM2ZmYTllM2JfSGJxaHM0U0lRVXlha0NjSUVXbkNwSEkyQllyZEcxdmNfVG9rZW46UkVCTWJDUk91bzNxNzR4MHhENGNXelpwbkpoXzE3NjgzMTgxMDg6MTc2ODMyMTcwOF9WNA)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->






（叽里咕噜写了半天不小心点到白框外面的内容之后全部内容没有了，后续干脆直接把飞书文档上的学习记录复制粘贴过来吧）

总之，先给接下来的一段时间设定一个总体的目标吧，平常也有记录学习笔记的习惯，干脆一起记录吧，反正差不多也都算是沾点边的东西

## 四周目标

1.  完成入门技术学习任务
    
2.  完成深度技术学习任务
    
3.  完成论文实验（随缘吧，回家前做完就行）
    
4.  完成rust基础语法学习（争取第三周之前完成）
    
5.  尽量做一个reth二开的项目（或者说至少开始做）
    

## w1d1

### todo

-   **入门技术&深度技术任务**
    
    -   Web3 实习手册[「入门导读」](https://web3intern.xyz/zh/blockchain-basic/)部分
        
    -   Web3 实习手册[「安全与合规」](https://web3intern.xyz/zh/security/)部分
        
    -   021 学习以太坊第 1-3 章
        
    -   Ethereum 官网 [Overview](https://ethereum.org/learn/) 基础内容学习
        
    -   [**Day 1: A Developer’s Guide to Building on Ethereum**](https://www.youtube.com/watch?v=zuJ-elbo88E&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=1) - Intro
        
    -   [**Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs**](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)
        
    -   工具安装指南：[https://web3intern.xyz/zh/remote-work-guide/](https://web3intern.xyz/zh/remote-work-guide/)
        
    
    > 昨天装完了，这个不管了
    
    -   [Uniswap V2 学习官方文档](https://docs.uniswap.org/contracts/v2/overview?utm_source=chatgpt.com)
        
-   **Rust基础**
    
    -   第八章 common collection
        
    -   第九章 error handling
        
-   **杂项**
    
    -   把小登试卷er图那题改完吧
        

* * *

### Web3 实习手册[「入门导读」](https://web3intern.xyz/zh/blockchain-basic/)部分

大部分好像是之前已经了解到的内容

web3.0好像没怎么听说过，好像是给数据集打标签一样

最后看到作者好像还是熟人

**尝试“《我的第一个 NFT》：**[**https://nft.myfirst.io/”**](https://nft.myfirst.io/”)

-   捯饬了半天一直提示401，看后续的教程说需要**Gas Fee，**以为是因为钱包里面没钱导致认证不了等等
    

> 之后看到群里才知道不是我这边的问题

-   然后在币安买了 0.0003 个 eth ，本来想把币安的地址直接导入到 metamask ，但是找半天没有找到
    
-   之后想着直接把 0.0003 转到 metamask 的钱包，被告知“不足0.003无法转账”
    
-   索性又买了点，然后转账到 metamask 钱包
    
-   网站修复后发现需要的是 SepoliaETH ，糖丸了
    
-   然后又扒拉了会任务文档找到水龙头流了会，拿到测试币成功铸造了
    
-   然后顺便在群里找到别人的地址转账完成了另外一个任务
    

**以太坊结构**

Layer 1

-   以太坊主网：核心区块链，负责最终安全性与共识。
    
-   EVM：以太坊虚拟机，执行智能合约代码。
    
-   账户系统：外部账户（EOA）与合约账户（CA）共同构成网络基础。
    

Layer 2

-   Rollup：通过将交易批量处理后提交至 L1，降低 Gas 费。
    
    -   Optimistic Rollup：假设交易合法，仅在争议时验证。
        
    -   ZK Rollup：通过零知识证明验证交易，无需链上争议。
        

> **L1 是负责“提供”共识机制和安全性的层（不做改变）。L2 是负责“剥离”计算工作，利用 L1 的共识进行最终确认的层。**
> 
> L2 并不是让 L1 的共识机制本身变快了（L1 该慢还是慢），而是**通过减少 L1 需要处理的工作量**，变相实现了效率的提升。
> 
> 这块之前一直没弄的特别细，虽然知道 L2 是干什么的，但是两个层的区别一直模模糊糊

### 021 学习以太坊第 1-3 章

我天，这个量好大

不过大部分好像都是已经了解的内容，跳着看吧

  第一章：认识以太坊

-   智能合约
    
-   dApp
    
-   Tokens
    
-   PoS
    
-   Gas
    
-   Proto-Danksharding（EIP-4844）与 Dencun 升级
    
    -       主要引入了 blob
        
    -       什么是 blob？临时数据结构，存储在执行层
        
    -       简单来说，就是一些用完了之后，共识节点可以直接删除的一些数据
        
-   分片与 Danksharding
    

  分片有两种方案，旧的分片方案是将以太坊分为64个链

  新的分片方案是在主链上挂载一个**超级巨大的数据，**存储更多的blob

  但是这样还存在一个问题，共识节点需要存放更多，Danksharding 存在是为了解决这个问题

-   叔块（Uncle / Ommer Block）
    

**gas费计算**

实际支付费用 ≈ (Base Fee + Priority Fee) × Gas Used

-   Base Fee：协议根据区块拥堵情况自动调整，并在执行后被销毁；
    
-   Priority Fee：用户自愿支付的小费，用于激励验证者优先打包；
    
-   钱包里看到的 maxFeePerGas / maxPriorityFeePerGas 是你愿意支 付的上限，实际扣费不会超过这两个上限组合对应的值。
    

第二章 网络结构与节点类型

**以太坊中节点通信**

1.  节点**通过 UDP 运行 Kademlia DHT 协议**来发现邻居
    
2.  建立 tcp 链接
    
3.  新交易通过 Gossip 协议扩散
    

**Kademlia**

-   每个分拨中心有一个“编号”（节点 ID）；
    
-   每个中心都记着“在不同距离区间内，离我最近的几个中心”；
    
-   当要把快递寄往一个目标编号时，会一步步转发给“离目标更近”的中 心，越转越接近收件人；
    
-   最终快递就被精准送到目的地。
    

> 感觉跟路由的那个算法差不多

**Gossip**

1.  当节点收到一笔新交易，验证通过后，随机选择一部分邻居发送交易哈希。
    
2.  邻居如果没有这笔交易，就会请求下载完整交易数据，然后再转发给它的邻居。
    

**归档节点**

就是超级全节点，全节点会定时清除太早的区块信息，归档节点不会

**开发者或机构运行全节点的必要性**

-   避免将用户 IP 和钱包地址暴露给第三方 RPC 服务商
    
-   摆脱公共节点的限流、封锁或宕机风险，确保业务在任何时候都能自主广播交易。
    
-   本地独立校验每一笔区块和交易的真实性
    
-   增强网络健壮性，增加独立节点和多样化客户端，防止单点故障
    
-   获得毫秒级的本地读写延迟和自定义 RPC 接口
    
-   支持搭建归档节点查询全量历史状态，满足合规审计、量化回测及复杂数据分析需求。
    
-   在网络升级或发生硬分叉时拥有自主选择权（用脚投票），而不必被动跟随服务商的路线。
    
-   可完全根据业务和合规要求，自由定制客户端类型、同步策略、日志留存及访问控制权限。
    

**执行客户端**

-   处理&检验交易，执行evm操作
    
-   维护世界状态
    
-   提供 RPC 接口
    
-   与其他节点交换数据
    

**共识客户端**

-   共识，出块
    
-   追踪链头与最终性，就是处理分叉的情况
    
-   管理验证者集与奖励 / 惩罚
    
-   维护 p2p 网络
    
-   Beacon API / 共识 RPC
    

**“出块 / 同步”流程**

1.  节点被选择为 proposer，执行客户端生成 execution payload
    
2.  执行客户端执行交易，返回完整 payload
    
3.  共识客户端将 execution payload 打包放入 block ，作为提议的区块，然后广播
    
4.  其他节点的公式客户端接收并验证区块，包括
    
    1.  验证 PoS 签名、slot/epoch、历史链等共识规则；
        
    2.  每个节点的执行客户端再次执行交易，验证合法性
        
    3.  所有通过则该块被正式发布，开始下一轮循环
        

调用 eth\_\* / 部署合约 / 查状态？

→ 找的是 执行客户端（EVM + JSON-RPC）。

质押 32 ETH 做验证者 / 关心 attestation、finality、slashing？

→ 这是 共识客户端 + 验证者客户端 的工作。

> 就先把前两章看完吧，剩下的明天再看，感觉好多东西都忘记了，打算再想办法补一下之前看的区块链课程的视频

### Rust

vector

基础用法

```Rust
fn main() {
    let v1: Vec<i32> = Vec::new();  // 创建一个空的动态数组,Vec必须指定类型
    let v2: Vec<i32> = vec![1, 2, 3, 4, 5];
    let mut v3 = Vec::new(); // 可变动态数组,类型由编译器推断,后续添加元素时确定类型
    v3.push(10); // 添加元素

    let third: &i32 = &v2[2]; // 使用索引访问元素,返回引用,如果索引越界会panic
    let third_opt: Option<&i32> = v2.get(2); // 使用get方法访问元素,返回Option类型,越界返回None。用 get 方法默认是不可变引用
    
}
```

```Rust
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
```

下面这个代码是错的

```Rust
fn main() {
  let v = vec![String::from("Hello ")];
  let mut s = v[0];
  s.push_str("world");
  println!("{s}");
}
```

其中`let mut s = v[0];` 错误

不能通过索引（Indexing）把值从集合中“搬走”（Move out）。

但是 i32 可以这样写，因为 i32 是直接拷贝

使用迭代器遍历vec

```Rust
    let mut v: Vec<i32> = vec![1, 2];
    let mut iter: Iter<'_, i32> = v.iter();
    let n1: &i32 = iter.next().unwrap();
    let n2: &i32 = iter.next().unwrap();
    let end: Option<&i32> = iter.next();
```

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI1MTY5NmU4ZjU3ZWQxMzNjNGRjNTRhOTA3YzQ5ZTJfam94MjdRakhGZ2swcjVYSTFrS0dsbmJ0YWJqN0JYZUVfVG9rZW46S05FSWJ4bmZ5b1AxQlB4ZUFpY2NFV2dNbkdjXzE3NjgyMzEyMDg6MTc2ODIzNDgwOF9WNA)

next() 方法的逻辑是：先返回当前元素的引用，然后将迭代器内部的指针向后移动一位

类似cpp中的i++

使用索引遍历动态数组

```Rust
use std::ops::Range; 
let mut v: Vec<i32>        = vec![1, 2];
let mut iter: Range<usize> = 0 .. v.len();
let i1: usize              = iter.next().unwrap();
let n1: &i32               = &v[i1];
```

在 vec 里面镶一个 enum 可以让 vec 中存不同类型的元素

```Rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
```

```Rust
fn main() {
  let mut v: Vec<i32> = vec![1, 2, 3];
  let mut v2: Vec<&mut i32> = Vec::new();
  for i in &mut v {
    v2.push(i);
  }
  *v2[0] = 5;
  let a = *v2[0];
  let b = v[0];
  println!("{a} {b}");
}
```

v2 存放 v 每个元素的引用，读写权在 v2

`*v2[0] = 5;` 修改 v\[0\]

`let a = *v2[0]; let b = v[0];`两句因为是 i32 数据类型，直接复制，换别的数据类型会 move 导致报错，然后v2在后续没有使用，v 重新获得读写权

## 杂项

rust是对的，冲！

web3招聘平台

-   SmartDeer
    
-   Web3.carrer
    
-   Remote3
    
-   CryptoJobsList
    

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRhNmU4YTZlZGRlMWE3Zjk1OGUyM2JlYmVkNDIyZDlfT1RyM3E4aWRqMm1rTVNRSThhNWw5OU5jdUp6Rnk5M2hfVG9rZW46WHhsRGJnbG95bzBOTHp4OVdtamM4OGhyblhnXzE3NjgyMzEyMDg6MTc2ODIzNDgwOF9WNA)

如何进入web3

-   从web2迁移
    
    -   英文！
        
    -   独立交付项目成果
        
-   从生态侧接入
    
    -   DAO 中接任务
        
    -   开源社区贡献代码
        

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=MWY2ZjJiN2Q0MzIwZDZlYWE5OWI2YjBkMzhjMDY3ZGZfczZtMmY2U0pLbkJLZTNBVWl2VWxzY1BZQks5anBzYzFfVG9rZW46TXY0emJZZ21mbzdMQWN4bXlscWNIYURlbkZnXzE3NjgyMzEyMDg6MTc2ODIzNDgwOF9WNA)

Rust是对的！！！！！！

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=MDgwZjRiODZlMDA4OGY4OTg2MjY5ZGU2YWQ2NWI4MjBfWHVHVUpMMGpWdEtvYXJ5UTlFSU1EUzNSM25TcEpuTHVfVG9rZW46THI4c2J0Vkdqb2Z1QWx4QW9SMWN1U3lXbnRkXzE3NjgyMzEyMDg6MTc2ODIzNDgwOF9WNA)

## 今日总结

-   **入门技术&深度技术任务**
    
    -   Web3 实习手册[「入门导读」](https://web3intern.xyz/zh/blockchain-basic/)部分✅
        
    -   Web3 实习手册[「安全与合规」](https://web3intern.xyz/zh/security/)部分✅
        
    -   021 学习以太坊第 1-3 章⭕
        
    
    > 太多了，有点高估自己了，只看完前两章，明天再努力吧
    
    -   Ethereum 官网 [Overview](https://ethereum.org/learn/) 基础内容学习✅
        
    -   [**Day 1: A Developer's Guide to Building on Ethereum**](https://www.youtube.com/watch?v=zuJ-elbo88E&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=1) - Intro✅
        
    -   [**Day 2: Becoming a Power User - Wallets, Mnemonics, Keypairs**](https://www.youtube.com/watch?v=_GjPeRLCREA&list=PLJz1HruEnenAf80uOfDwBPqaliJkjKg69&index=2)**⭕**
        
    
    > 学不完了
    
    -   工具安装指南：[https://web3intern.xyz/zh/remote-work-guide/✅](https://web3intern.xyz/zh/remote-work-guide/✅)
        
    
    > 昨天装完了，这个不管了
    
    -   [Uniswap V2 学习官方文档](https://docs.uniswap.org/contracts/v2/overview?utm_source=chatgpt.com)⭕
        
    
    > 相信明天的自己吧还是
    
-   **Rust基础**
    
    -   第八章 common collection⭕
        
    -   第九章 error handling ⭕
        
    
    > 😭😭😭rust，我的rust
    
-   **杂项**
    
    -   把小登试卷er图那题改完吧
        
    
    > 明天再干
    

感觉今天大概是开会占的时间有点太多了）

唉，明天再加油吧

![](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDJlMDQ5NDgxYTE3ZTA2MjYxOGEwMzY0MDU4OWQzZjNfZWp5OVZmV2NRMWtJODQ5R3lGWVAwenlvTUFSb3pxOElfVG9rZW46WWhKRmI4QlU1b0xaelV4aFlMWmNMNDhYbnBoXzE3NjgyMzEyMDg6MTc2ODIzNDgwOF9WNA)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
