---
timezone: UTC+8
---

# xinyuuum2

**GitHub ID:** xinyuuum2

**Telegram:** @michelleeee98

## Self-introduction

这里是Xinyu 可以叫我Michelle~
Base上海 美本美硕 工作三年DS/DA
小白转web3 很高兴认识大家~一起学习~

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
## Gas 优化

在以太坊中，Gas 是衡量 EVM 执行计算和状态变更成本的单位。合约的每一次执行，都会因为指令类型不同而消耗不同数量的 gas。

在所有操作中，storage（链上存储）是最昂贵的：

-   读取 storage 成本高
    
-   写入 storage 成本更高
    
-   memory 和 calldata 的读写成本则低得多
    

尽量减少对 storage 的访问次数，把能在 memory 中完成的计算留在 memory 中完成。

在实际开发中，Gas 优化通常体现在：

-   减少重复的 storage 读取
    
-   合并 storage 写入
    
-   合理选择函数可见性（external / public）
    
-   在循环和批量操作中避免隐式的重复计算
    

* * *

## 举例

合约记录用户的操作次数，每次调用 `ping`，该用户的计数加一。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CounterBad {
    mapping(address => uint256) public counter;

    function ping() public {
        counter[msg.sender] = counter[msg.sender] + 1;
    }
}
```

-   `counter[msg.sender]` 被访问了两次
    
-   每一次访问都会触发一次 storage 读取
    
-   随着函数被高频调用，gas 消耗会不断累积
    

优化后：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CounterOptimized {
    mapping(address => uint256) public counter;

    function ping() external {
        uint256 current = counter[msg.sender];
        counter[msg.sender] = current + 1;
    }
}
```
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->


大家都好厉害哈哈哈…打算周末review一下这周的内容，把技术方向的做一下。这两天太忙了，周末努力补补课。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->



## DAPP

### 核心架构思维 (Mental Model)

-   **所有权**：Web2：数据归平台，随时可能被封号）；Web3：私钥即所有权，数据在链上，不可篡改
    
-   **去信任**：Dapp 像自动贩卖机。不需要信任运营者的人品，只需要信任代码逻辑（Code is Law）。只要投币（Gas），就自动执行逻辑。
    
-   **Dapp 三要素**：
    
    1.  **智能合约**：铁面无私的裁判，负责逻辑执行。
        
    2.  **区块链**：不可篡改的分布式账本。
        
    3.  **代币**：系统的燃料与治理凭证。
        

### 现代开发技术栈：混合架构 (Hybrid Stack)

结合 **Foundry** 和 **Hardhat** 的长处。

-   **Foundry (Rust编写，计算密集型)**：
    
    -   **优势**：编译和测试速度极快（比 Hardhat 快约 20 倍）。
        
    -   **Fuzzing (模糊测试)**：能自动生成成千上万个随机边缘数据（如零地址、溢出数值）轰炸合约，发现人脑难以预判的 Bug。
        
    -   **用途**：核心合约逻辑编写、单元测试、暴力美学测试。
        
-   **Hardhat (JS/TS生态，交互密集型)**：
    
    -   **优势**：拥有最丰富的插件生态，JS/TS 脚本编写灵活。
        
    -   **用途**：编写复杂的**部署脚本**、任务管理、以及模拟前端与合约交互的集成测试。
        
    -   **声明式部署**：解决脚本跑到一半断网的问题，确保部署的幂等性（Idempotency），防止重复部署。
        

### 智能合约开发与安全模式

-   **CEI 模式 (防重入黄金法则)**：
    
    1.  **Checks (检查)**：权限与条件。
        
    2.  **Effects (生效)**：**先**修改内部状态（如扣除余额）。
        
    3.  **Interactions (交互)**：**最后**再进行外部调用（如发送 ETH）。如果顺序反了（先转账后改余额），黑客可在收到钱的瞬间回调合约再次提款。
        
-   **Gas 优化**：使用 `Custom Error` (自定义错误) 替代 `require` 的长字符串报错。链上存储字符串很贵，自定义错误只是一个 4 字节的哈希，极其便宜。
    
-   **事件 (Events)**：区块链是黑盒，前端必须依靠监听带有 `indexed` 关键字的事件来构建用户数据的索引（如“查询某用户的所有历史操作”）。
    

### 全栈前端集成 (Next.js + Wagmi + Viem)

-   **数据类型陷阱 (BigInt)**：
    
    -   JS 的 `number` 最大安全整数 ($2^{53}-1$) 远小于以太坊的 `uint256`。
        
    -   **必须**使用 `BigInt` 处理链上数值（如 `100n`），但在 `JSON.stringify` 时会报错，需转为字符串处理。
        
-   **水合错误 (Hydration Error)**：
    
    -   **现象**：Next.js 服务端渲染 (SSR) 时不知道用户装了 MetaMask（显示“未连接”），但浏览器端渲染时读到了钱包（显示“已连接”），导致 DOM 不匹配报错和闪烁。
        
    -   **解法**：将连接状态存入 Cookie 或 LocalStorage，或者使用 `useEffect` 确保仅在客户端渲染特定组件。
        
-   **交互体验 (UX)**：
    
    -   写操作比读操作复杂。不能只看钱包“弹出”或“没报错”就认为成功。
        
    -   **完整链路**：点击 -> 等待签名 -> 交易发送至内存池 (Mining) -> **等待回执 (Receipt)**。必须等待 `wait()` 返回 Receipt 才算真正的链上确认。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->




### EVM 与数据存储 (The "Hard" Parts)

-   **四大存储区域 (EVM Memory Model)**:
    

-   **Storage (存储)**: **最昂贵**。数据永久保存在链上。
    
    -   _成本细节_: 初始化一个新槽位（从 0 到非 0）大约消耗 **20,000 Gas**；修改已有的槽位大约消耗 **5,000 Gas**。
        
    -   _优化原则_: 能不存就不存，能用 Event 存就别用 Storage 存。
        
-   **Memory (内存)**: **临时**。函数执行期间存在，执行完即销毁。成本随使用量线性（甚至二次方）增长，但远低于 Storage。
    
-   **Calldata**: **只读**且**极其廉价**。用于存放函数调用的参数。
    

-   _技巧_: 如果函数参数只读不改，使用 `calldata` 而非 `memory` 可以节省 Gas。
    

-   **Stack (栈)**: EVM 是栈式虚拟机，用于运算（如 `1+1`），深度限制 1024 层。
    

### Solidity 核心语法与陷阱

-   **基础类型**:
    
    -   **uint256**: 默认整数类型。Solidity 0.8+ 版本已内置溢出检查（Overflow Protection），不再需要 `SafeMath` 库。
        
    -   **Address**: 20 字节。区分 `address` (不可转账) 和 `address payable` (可接收 ETH)。
        
-   **Mapping (映射)**:
    
    -   `mapping(key => value)`。
        
    -   **关键特性**: **无法遍历**。你无法直接获取 mapping 的所有 key。
        
    -   _解决方案_: 如果需要遍历（例如“获取所有用户列表”），必须额外维护一个数组来记录 Key。
        
-   **函数修饰符 (Modifiers)**:
    
    -   用于在函数执行前或后插入逻辑（如权限检查 `onlyOwner`）。
        
    -   `_;` 符号代表“继续执行函数体代码”。
        
-   **全局变量与上下文**:
    
    -   `msg.sender`: **当前**调用者的地址（最常用）。
        
    -   `tx.origin`: **交易原始发起人**（EOA）。
        
        -   _安全警告_: **禁止**使用 `tx.origin` 做权限验证，这会导致中间人攻击（钓鱼合约攻击）。
            
    -   `msg.value`: 随调用发送的 ETH 数量（单位 Wei）。
        

### 资金处理与安全模式 (Critical)

-   **接收 ETH**:
    
    -   `payable` **关键字**: 函数若要接收 ETH，**必须**标记为 `payable`，否则交易会 Revert。
        
    -   `receive()` **/** `fallback()`: 合约若要接收直接转账（不调用特定函数），必须实现 `receive() external payable`。
        
-   **发送 ETH**:
    
    -   **推荐写法**: `(bool success, ) = recipient.call{value: amount}("")`。
        
    -   _废弃写法_: 避免使用 `transfer` 或 `send`，因为它们限制了 2300 Gas，可能导致接收方（如果是合约钱包）逻辑执行失败。
        
-   **重入攻击 (Reentrancy) 与防御**:
    
    -   _原理_: 攻击者合约在接收 ETH 的 `receive()` 函数中回调原合约的 `withdraw()`，在余额扣除前重复提款。
        
    -   _防御范式 (CEI)_: **Check (检查)** -> **Effect (生效/扣款)** -> **Interaction (交互/转账)**。必须先扣除余额，再发送 ETH。
        

### 脚本交互 (Ethers.js & Hardhat)

-   **Provider vs Signer**:
    
    -   **Provider**: **只读**连接。用于获取区块号、查询余额、读取合约状态（Call）。不需要私钥。
        
    -   **Signer**: **可写**连接。持有私钥，用于签名并发送交易（Transaction）。
        
-   **BigNumber (大数处理)**:
    
    -   JS 无法处理 18 位精度的数字。
        
    -   **User -> Blockchain**: `ethers.utils.parseEther("1.0")` (将 "1.0" 转为 Wei)。
        
    -   **Blockchain -> User**: `ethers.utils.formatEther(balance)` (将 Wei 转为 "1.0")。
        
-   **ABI (应用二进制接口)**:
    
    -   合约的“说明书”。前端通过 ABI 知道如何把数据编码成 EVM 能读懂的字节码（Call Data）。
        

### 开发工具流

-   **Hardhat**: 本地开发环境。
    
    -   `npx hardhat node`: 启动本地虚拟区块链。
        
    -   `console.log` (在 Solidity 中): 可以在合约里打印日志到终端，调试神技。
        
-   **Scaffold-ETH**: **Tinker (捣鼓) 神器**。
    
    -   **Burner Wallet (燃烧钱包)**: 浏览器自动生成临时私钥，无需 MetaMask 频繁弹窗确认，极大加速测试流程。
        
    -   **Debug UI**: 部署合约后，前端自动生成所有读写函数的 UI，无需写前端代码即可测试交互。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->





今天听了Solidity的初步介绍，学习了一些语法。因为加班的原因，笔记明天看了回放再补上啊啊啊…还熟悉了一下Remix的环境，尝试了一些简单的代码。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->






今天和大佬讨论了一下昨天的课，感觉理解又深了一些。

**现状：**一个固定的账户（地址）。想在 Uniswap 上卖币，必须先发一笔交易叫 `Approve`（授权）。就像跟银行签了协议：“我允许 Uniswap 随时从我卡里扣钱，上限是无限大”。

**优势：** 签一次字（Approve），以后每次交易只要点“Swap”，合约就能自动把你的钱划走，不用每次都重新授权

ERC-7962 （UTXO-like / One-time Key）：

-   移除了 approve 和 allowance 函数。
    
-   没有固定账户，资金绑定在一个 **Key Hash**（一次性密码锁）上。
    
-   每次交易，你必须提供这个锁的钥匙（签名）。交易一旦完成，**旧锁作废，生成一把新锁（Key Rotation）**。
    

既然 ERC-7962 没有 Approve，那现在的 Uniswap、OpenSea、借贷协议只要是基于 `transferFrom`（代扣）逻辑写的，全都无法直接操作 ERC-7962 的资产。这相当于“颠覆”了现有的基础设施。

ERC-7962 的设计者也承认这一点：**它是不向后兼容的**。它并不是要直接替换掉现在的 ERC-20，而是作为一种**补充标准**存在。

**三种方式：**

1.  交互逻辑的改变：从“拉（Pull）”变成“推（Push）”
    

-   以前（Uniswap）： 你授权 -> Uniswap 合约调用 `transferFrom` 把你的币拿走。
    
-   现在（ERC-7962 模式）： 你不需要授权。你直接对一笔交易进行链下签名（比如：“我同意用这把钥匙里的资产去换 100 个 USDC”）。
    
    -   Relayer（中继者） 拿到你的签名，把它提交给智能合约。
        
    -   智能合约验证签名无误，直接执行转账。
        
-   优势： 这其实更安全。你不需要给某个协议“无限授权”（Infinite Approve），避免了协议被黑客攻击后你钱包被掏空的风险。每次交易都是单次授权。
    

2.  批量操作（Batching）解决“繁琐”问题
    

ERC-7962 的架构天然支持批量交易。

比如要把 10 个 NFT 卖掉。在旧模式下，你可能要 Approve 几次。在 7962 模式下，你可以在钱包里一次性签 10 个名（或者对一个包含 10 笔转账的列表签一次名），然后 Relayer 一次性打包上链。对用户来说，依然只是点了一下“确认”。

3.  兼容性方案：封装（Wrapper）与新协议
    

既然老协议（如现在的 Uniswap V3）不支持，那怎么去那上面交易？

1.  封装（Wrapper）： 这是一个经典的兼容手段。可以做一个“中间人合约”。你把 ERC-7962 存进去，它给你吐出标准的 ERC-20 代币。你拿这个 ERC-20 去 DeFi 里玩。等你玩够了，把 ERC-20 销毁，取回隐私的 ERC-7962。
    
2.  新一代协议： 更有可能的是，会出现专门支持 ERC-7962 的新交易市场（Marketplace）。
    
    -   GitHub 上的讨论提到，这套标准目前主要针对 会员身份验证、隐私支付 等特定场景，而不是为了马上替代通用的 DeFi 代币。
        
    -   比如 DDC (DataDanceChain) 的实现中，就是通过 Relayer 来中心化地解决一部分交互问题。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->







今天试试notebooklm。

### **一、 为什么要升级 ERC-721？**

目前的 NFT 主流标准（ERC-721）在实际应用，尤其是 Web2 向 Web3 迁移的商业场景中，存在两个主要缺陷：

-   **隐私：**
    
    -   链上数据完全透明。持有者的钱包地址（Address）是公开的，所有交易记录可被追溯。
        
    -   **后果：** 通过图谱分析，可以关联出地址背后的资产状况、消费习惯等，导致商业机密（如会员名单）和个人隐私泄露,。
        
-   **使用门槛：**
    
    -   用户必须安装钱包、管理私钥/助记词，且必须持有原生代币（如 ETH）来支付 Gas 费。
        
    -   **后果**：习惯了 Web2 免费、便捷操作的用户难以进入，限制了商业推广。
        

### **二、 解决方案：ERC-7962 标准**

ERC-7962 是一种新的 NFT 协议，旨在实现“隐私保护”与“极致易用性”的平衡。

1.  **技术核心：K-Hash 与一次性密钥**
    

-   **机制改变：** 资产的所有权不再绑定在固定的“钱包地址”上，而是通过 **K-Hash**（公钥的哈希值）来标记。
    
-   **UTXO 模型借鉴：** 类似于比特币的 UTXO（未花费交易输出）机制。每次交易后，旧的 Key 作废，生成一个新的 Key（一次性轮换）。
    
-   **隐私原理：** 由于每次交易的标识（Key）都在变化，外部观察者无法将多次交易关联到同一个人，从而切断了链上的追踪链路
    

2.  **交互优化：账户抽象与代付（Gas Sponsorship）**
    

-   **角色解耦：** 将“资产所有者”（Owner）与“交易发起者”（Initiator）分离。
    
    -   **所有者：** 只需要提供**数字签名**来表达意图，证明对资产的控制权，无需持有 ETH。
        
    -   **中继者（Relayer）：** 可以是项目方（如星巴克），负责将用户的签名打包上链，并代付 Gas 费,。
        
-   **用户体验：** 用户在 App 中的操作体验与 Web2 无异，无需感知 Gas 费和复杂的链上交互。
    

3.  **理论基础：零知识证明（ZK）思想**
    

-   **核心逻辑：** 在不暴露具体信息（如私钥、真实身份）的情况下，向第三方证明某个陈述是真实的（如“我是会员”）。
    
-   **应用方式：** ERC-7962 利用哈希验证作为一种简化的 ZK 实现，即验证了凭证的有效性，又隐藏了凭证背后的持久性身份。
    

### **三、 类比case**

**场景：星巴克会员 x 机场贵宾厅**

-   **需求：** 机场需要验证旅客是否为星巴克高级会员以提供服务，但星巴克不能泄露客户名单，旅客也不愿公开钱包地址。
    
-   **ERC-7962 流程：**
    
    -   用户在星巴克 App 中生成一个加密证明（基于 K-Hash）。
        
    -   机场验证该证明有效，确认会员资格。
        
-   **结果：** 机场确认了资格，但不知道用户具体是谁；星巴克保护了数据；用户获得服务且未支付gas fee
    

### **四、 总结与思考**

-   **技术本质：** ERC-7962 是一套通过**密码学签名**控制所有权、通过**一次性哈希**切断追踪、通过**中继代付**降低门槛的 NFT 标准。
    
-   **价值判断：** 该标准是 Web3 技术向主流商业社会（Web2 用户）普及的重要桥梁。它牺牲了一丁点“去中心化”（依赖 Relayer 发起交易），换取了极大的隐私性和易用性,。
    
-   **安全警示：** 虽然体验上接近 Web2 账号密码，但底层依然基于私钥签名。如果私钥/助记词丢失，资产依然无法找回。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->








今天用gemini老师辅助学了一下remix。记录一下，明天继续。

## 一、 Remix 操作全流程

### 1\. 编写 (Development)

在 `contracts` 文件夹新建 `.sol` 文件。这是定义“规则”的地方。

### 2\. 编译 (Compilation)

-   **动作**：点击左侧第二个图标（S形），点击 **Compile**。
    
-   **结果**：将人类能读懂的 Solidity 代码变成区块链能运行的 **Bytecode（字节码）**。
    
-   **注意**：只要改了代码（哪怕只是加个空格），都要重新 Compile。
    

### 3\. 部署 (Deployment)

-   **动作**：点击左侧第三个图标（以太坊形），点击 **Deploy**。
    
-   **结果**：在模拟的区块链环境（Remix VM）中，为代码创建一个**实例**。
    
-   **重要**：每次 Deploy 都会生成一个**全新的、带唯一地址**的合约。
    

### 4\. 交互 (Interaction)

-   **橙色按钮 (Functions)**：如 `set`、`increment`。它们是**动作**，会改写数据，需要消耗 Gas。
    
-   **蓝色按钮 (Variables/Getters)**：如 `storedData`。它们是**状态**，点一下就是“看一眼”当前数值。
    

* * *

## 二、 核心概念深挖：`storedData` 与 `increment`

### 1\. `storedData` 是“状态变量” (State Variable)

-   **定义**：它是永久存储在区块链“硬盘”上的数据。
    
-   **类比**：它是数据库表里的一个 **Cell（单元格）**。
    
-   **可见性**：因为标记了 `public`，Remix 会自动给它配一个**蓝色按钮**，让你随时查询它的值。
    

### 2\. `increment` 是“改变状态的函数” (State-Changing Function)

-   **定义**：它是一段计算逻辑。
    
-   **逻辑**：它执行的是 `新值 = 旧值 + 1`，然后把新值覆写回 `storedData`。
    
-   **异步感**：在链上，你点完 `increment`，数据确实变了，但你屏幕上的 `storedData` 按钮显示的还是旧值。你必须**再点一下蓝色按钮**手动“刷新”视图。
    

* * *

## 三、 一个更全面的例子

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 这个合约模拟了一个“全球计费/打卡系统”
contract AdvancedStorage {
    // 1. 数据存储
    uint256 public totalCount;        // 总计数值
    address public lastUser;         // 记录最后一个操作的人的钱包地址
    address public owner;            // 合约的所有者（管理员）

    // 2. 事件：这是给 Dune 这种分析工具看的“信号发射器”
    event NumberUpdated(address indexed operator, uint256 newValue);

    // 构造函数：只在合约第一次部署时运行一次，确定谁是管理员
    constructor() {
        owner = msg.sender; // 谁部署的合约，谁就是 owner
    }

    // 3. 修改数据的函数（橙色按钮）
    function increment() public {
        totalCount = totalCount + 1;
        lastUser = msg.sender; // msg.sender 是一个内置变量，代表当前点按钮的人
        
        // 发射信号，Dune 就能抓到这条流水了
        emit NumberUpdated(msg.sender, totalCount);
    }

    // 带有权限限制的设置函数
    function adminSet(uint256 x) public {
        // 只有管理员能点这个按钮，其他人点会报错（变红）
        require(msg.sender == owner, "Only owner can change this!");
        totalCount = x;
        lastUser = msg.sender;
        emit NumberUpdated(msg.sender, x);
    }

    // 4. 重置函数
    function reset() public {
        totalCount = 0;
    }
}
```

* * *

## 四、 操练步骤

1.  **准备环境**：清空左下角所有的旧合约（点垃圾桶）。
    
2.  **部署**：用 **Account A** 部署这个合约。`owner` 按钮显示的是 Account A 的地址。
    
3.  **身份记录测试**：
    
    -   保持在 **Account A**，点击 `increment`。
        
    -   点击 `totalCount` 看到 `1`。
        
    -   点击 `lastUser` 看到 **Account A** 的地址。
        
4.  **多账号协作测试**：
    
    -   切换到 **Account B**。
        
    -   点击 `increment`。
        
    -   再次点击 `totalCount` 看到 `2`。
        
    -   **关键点**：点击 `lastUser`，发现它变成了 **Account B** 的地址！这证明了合约精准记录了“谁是最后一个修改者”。
        
5.  **权限挑战（报错测试）**：
    
    -   依然保持在 **Account B**，尝试在 `adminSet` 旁边输入 `999` 并点击。
        
    -   **结果**：右下角黑窗报错，提示 `"Only owner can change this!"`。
        
    -   **意义**：你通过代码实现了“数据访问权限控制”。
        

* * *

## 五、 总结

-   **合约** = 一个永远在线、不可收买的**后台逻辑 + 数据库**
    
-   **钱包地址 (msg.sender)** = 每个人的**唯一 ID**
    
-   **Require** = **业务守则**
    
-   **Event** = **埋点数据**
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->









打算利用周末时间吧这周的内容再熟悉一下。今天没有大课，听了同学们的sharing，发现也有几个和我差不多年龄的朋友们。可能大家之前都是小白，但是现在对于行业的了解已经颇有深度。还是要抓紧练习呀。周末要好好把这周内容总结一下。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->










今天没机会参加直播，看了群里小伙伴总结的txt，先简单写一个笔记。

碎碎念：下午的colearning上，有同学说到感觉内容太多&有点焦虑，差不多也是我这两天的感觉吧。大部分同学好像都是大学生哈哈哈，而且大家都很努力很认真，让我这个以及上班三年的人很汗颜哈哈。但是如果和自己比较的话，每天完成全职工作的情况下，下班能抽出时间再来学习也已经很不容易啦。虽然这两天的知识有点多，材料都要看完的话也有点累，相信自己不久之后就可以成为老司机！加油！！不忘初心，希望以后可以把这个变成自己的全职工作！

### AI 与 Web3 融合

一、 从 LLM 到 Agentic AI

-   传统 LLM 局限：无状态（Stateless）、无工具（Toolless）、无身份（Identity-less）。
    
-   AI Agent 架构：
    
    -   推理引擎 (LLM)：执行复杂指令与计划制定。
        
    -   私有记忆 (RAG)：通过向量数据库（Vector DB）实现长短期上下文记忆。
        
    -   行动能力 (Tools)：集成 Function Calling 或 MCP 协议，实现对 API 的闭环调用。
        

二、 Web3 技术赋能：构建 AI 经济体系

Web3 是 AI Agent 从“辅助工具”转向“经济主体”的必经之路：

-   身份可验证：通过链上协议解决 AI 身份欺诈与归属权问题。
    
-   行为可审计：将 AI 决策哈希存证上链，确保操作不可篡改，满足合规审计需求。
    
-   支付微量化：传统金融体系无法支撑机器间高频、微额（如 $0.0001）的即时结算。
    

三、 专业术语解析 (Technical Terms)

-   ERC-8004（AI 链上身份标准）：
    
    -   定义：基于 ERC-721 实现的 AI Agent 身份协议。
        
    -   核心功能：为每个 AI 铸造唯一的 NFT 身份（护照），并关联其能力声明、模型哈希与声誉注册表。
        
    -   价值：实现 AI 的准入控制与信任评级，防止女巫攻击（Sybil Attack）。
        
-   HTTP 402（支付状态码应用）：
    
    -   定义：HTTP 协议中预留的“Payment Required”状态码。
        
    -   Web3 应用：在 AI 交互中实现原生支付。当 AI 请求资源时，通过该状态码自动触发链上转账，实现机器间的自动结算。
        
-   ZKML（零知识机器学习）：
    
    -   核心逻辑：利用零知识证明技术，在不泄露模型参数和输入数据的前提下，证明 AI 推理结果的真实性与模型一致性。
        
-   Spoon OS 架构：
    
    -   定位：AI Agent 的操作系统/集成 SDK。
        
    -   作用：封装私钥托管、身份注册、支付网关等复杂逻辑，让开发者能通过统一 API 快速构建具备 Web3 能力的智能体。
        

AI Agent 的未来在于感知经济（Sense Economy）。Web3 为其提供了不可篡改的“身份证”与可编程的“银行账户”。只有在去中心化的信任架构下，AI 才能真正代表人类或组织进行独立决策、资产管理与价值交换。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->











今天信息量有点大了……内容有点硬核了……

### 一、 法律合规

-   如果项目涉及非法集资、洗钱或传销，开发者会被列为“共同犯罪”或“帮信罪”。
    
-   **境内“高压线”场景**：
    
    -   **ICO/IDO**：任何向境内公众募集资金（或代币）的行为。
        
    -   **经营交易所**：提供买卖撮合、币币兑换服务。
        
    -   **变相赌博**：具有“充值—抽奖—提现”闭环的链游。
        
    -   **多级传销**：超过三级、以发展人头为计酬依据的推广模式。
        
-   **薪酬风险**：
    
    -   **工资法偿性**：中国法律要求工资必须以人民币支付，代币支付在法律上可能被视为无效。
        
    -   **黑钱风险**：USDT 出金时若收到电信诈骗资金，会导致银行卡被封甚至刑事牵连。
        

* * *

### 二、 网络安全

1\. 钱包管理

-   **助记词离线化**：**禁止**截图、**禁止**存入网盘、**禁止**发给微信/电报好友。只能物理手抄。
    
-   **钱包分级**：
    
    -   **冷钱包/主钱包**：存放巨额资产，绝不连接任何网页。
        
    -   **热钱包/交互钱包**：只放少量 Gas 费，用于参与项目测试，出事不心疼。
        

2\. 面试与软件防诈

-   **拒绝“专用插件/软件”**：大厂面试只用 Zoom、Meet。凡是要求下载 `.zip` 压缩包或安装特定面试软件的，全是木马。
    
-   **木马后果**：一旦运行，黑客能在 1 秒内通过浏览器 Cookie 登录你的交易所、电报、邮箱，并洗空钱包。
    

3\. 交互与授权安全

-   **签名不盲签**：签名（Sign）或批准（Approve）前，看清权限。
    
-   **定期撤销**：使用 `Revoke.cash` 定期清理对不明协议的无限授权。
    
-   **防地址劫持**：复制粘贴地址后，**务必手动核对前 6 位和后 4 位**，防止剪贴板木马篡改地址。
    

* * *

### 三、 三个忠告

1.  **慢即是快**：在 Web3，你不了解的每一个按钮都可能让你破产。
    
2.  **默认有毒**：默认所有私聊你的 HR、学长、管理员都是骗子，所有空投链接都是钓鱼。
    
3.  **合规意识**：在参与项目前，先看该项目是否面向中国用户。如果全是中文群且承诺高额返利，请立刻远离。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->












**Day 1: A Developer's Guide to Building on Ethereum - Intro 笔记**  

**区块链技术的解释**

-   区块链是一个**去中心化的点对点网络**，成千上万个节点在没有中央控制的情况下进行通信。
    
-   当前共识机制：**工作量证明 (PoW)**，正在向**权益证明 (PoS)** 转型。
    
-   账本是一个共享状态，记录价值转移交易（例如：Alice 转账给 Bob）。
    
-   强调**网络弹性**：所有节点遵循相同规则运行；即使许多节点掉线，网络仍能继续运行，确保了抗审查性。
    
-   用户通过生成**私钥**和对应的公钥地址参与，无需通过中心化中介（银行）。
    
-   私钥是一个巨大的数字；安全性取决于对它的妥善保护。
    

**智能合约与信任最小化**

-   通过**托管 (Escrow)** 概念引入：一种信任最小化的机制，使互不信任的两方（Alice 和 Bob）能安全交易。
    
-   智能合约就像可编程的自动售货机，执行“如果发生 A，则执行 B”的规则，无需中介即可实现托管功能。
    
-   这种机制赋能了许多应用：收藏品、去中心化交易所 (DEX)、代币兑换等。
    
-   核心创新：**只需信任代码**，降低了对人的信任要求。
    

**智能合约中的激励与自动化**

-   与传统 Web (Web 2) 运行计划任务的 cron jobs 不同，Web3 合约依赖**激励对齐的参与**来完成周期性任务。
    
-   **例子：** 一个设计好的智能合约允许任何人在每 24 小时触发一次操作，触发者将获得奖励。
    
-   这创建了一个去中心化系统，网络参与者由于经济激励的一致性，会自发维护合约功能的运行。
    

**智能合约的不可停止性与冗余**

-   一旦正确部署，智能合约就是**不可篡改且不可停止的** —— 即使是其创建者也无法关停它。
    
-   整个以太坊网络充当了**冗余基础设施**，每个节点都保存着智能合约状态和代码的完整副本。
    
-   合约状态的更新会同步到所有节点，确保一致性和高可用性。
    
-   **“代码即法律” (Code is law)** 范式意味着信任建立在代码的正确性之上。
    
-   传统开发者需要转变思维模型才能完全理解这些概念。
    

**当前以太坊用例与应用**

-   **去中心化金融 (DeFi)：** 用户将代币锁定在流动性池 (LP) 中以赚取手续费和年化收益 (APY)；涉及借贷和流动性挖矿。
    
-   **去中心化自治组织 (DAO)：** 通过 Snapshot 和 Tally 等应用管理代币投票治理。
    
-   **非同质化代币 (NFT)：** 收藏品、代币门槛内容，以及直接从智能合约渲染图形的创新型链上 SVG NFT。
    
-   承认以太坊的**局限性与挑战**：高成本、交易慢、异步性以及私钥丢失后的不可逆性。
    
-   **解决方案：** 带有恢复机制的**多重签名钱包**和 Layer 2 扩容技术。
    

**课程深度与易得性**

-   课程涵盖了多签钱包、DAO、Layer 2 等复杂话题，并在每段视频中循序渐进地讲解。
    
-   第 1 周侧重于以太坊产品的实际操作 —— 即使是非开发人员也至关重要。
    
-   鼓励所有学习者先成为**高级用户**，在编写代码前建立基础知识。
    

**切入点：成为高级用户的重要性**

-   理解钱包、交易、Gas 费和私钥对于参与以太坊生态（DeFi, DAOs, NFTs）至关重要。
    
-   第 1 周同时面向开发者和非开发者，为进入该领域提供了广泛的入口。
    
-   课程节奏经过精心设计，涵盖了常见的坑和实际操作中的障碍，以打下坚实基础。
    

**区块链技术的愿景与潜在影响**

-   **区块链作为一种全球协作机制**，有可能在国家层面运行。
    
-   设想智能合约管理复杂的无须信任的交互（例如：军事预算），通过激励和博弈论强制执行协作或惩罚。
    
-   强调区块链在超越传统信任体系的**协作变革力量**。
    
-   这项技术激发了开发者的使命感，让他们有机会显著影响世界。
    

* * *

### 核心概念

| 术语 | 定义 |
| 区块链 | 一个去中心化的点对点网络，维护着一个共享的、不可篡改的交易账本。 |
| 智能合约 | 运行在区块链上的可编程合约，可自动执行无须信任的交易并强制执行规则。 |
| 信任最小化 | 通过信任代码和经济激励来减少对“人”的信任依赖。 |
| 托管 (Escrow) | 一种由中立第三方（或代码）持有资产，直到交易双方满足特定条件为止的机制。 |
| Gas | 在以太坊上执行交易或计算所需的费用。 |
| 工作量证明 (PoW) | 一种需要通过计算工作来验证交易的共识机制（正被逐步淘汰）。 |
| 权益证明 (PoS) | 一种验证者通过质押代币来保障网络安全的共识机制（以太坊目前的升级方向）。 |
| DEX (去中心化交易所) | 无需中介即可进行点对点代币交易的平台。 |
| DAO (去中心化自治组织) | 由代币持有者投票治理、通过智能合约运行的组织。 |
| NFT (非同质化代币) | 区块链上代表唯一资产的数字凭证，常用于收藏品或准入令牌。 |

* * *

### Key points

-   **Web3 开发需要范式转变：** 相比传统编程，它更强调信任最小化、激励机制和去中心化。
    
-   **成为高级用户是基础：** 在编写代码之前，理解钱包、Gas 和 dApp 是与以太坊进行有意义交互的关键。
    
-   **智能合约实现无须信任的协作：** 通过公正、自主地执行规则，智能合约类似于可编程的托管服务。
    
-   **经济激励不可或缺：** 激励机制维持了去中心化系统的运转，取代了中心化的调度器或受信任方。
    
-   **以太坊的冗余性确保了“不可停止”的应用：** 具有极强的抗审查和抗故障能力。
    
-   **理论与实操排障并重：** 课程反映了现实世界的复杂性，鼓励在错误中学习。
    
-   **未来潜力超越金融：** 扩展到全球协作、治理和复杂的多方交互
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->













先补一下昨天没能参加的开营。

### 三个path：

-   **运营**：重点在于行业认知、内容表达能力以及活动执行力。鼓励学生在各种平台上运营个人 IP，成为 Web3 领域的 KOL。
    
-   **技术入门**：面向完全零基础的同学，目标是掌握区块链底层逻辑，并能写出简单的智能合约。
    
-   **深度技术**：面向有开发背景的同学，侧重于协议级研究、ZK（零知识证明）、跨链协议等前沿技术。
    

### **打卡**：

-   **请假限制**：一周内**连续超过两次**不打卡=fail
    

### Schedule

-   **行业overview与岗位概览**
    
-   **安全与反钓鱼**
    
-   **法律合规**
    
-   **黑客松**：这是一次模拟真实项目开发的实战。运营学生需组织活动，技术学生需交付产品原型。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
