---
timezone: UTC+8
---

# beetroot42

**GitHub ID:** beetroot42

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->
## 1\. 什么是 Uniswap V2

**Uniswap V2** 是运行在以太坊区块链上的开源去中心化交易协议，属于自动化做市商（AMM）模型的一种实现。它允许用户无需传统订单簿，就可以自动交换 ERC-20 代币，并通过流动性池实现交易和做市。

Uniswap V2 是继 **V1** 之后的重大升级版本，它修复了早期的一些限制并引入了更多功能，同时为后续的 V3 版本奠定了基础。

* * *

## 2\. 核心机制：自动化做市商

### 核心公式：恒定乘积公式

Uniswap 的核心是 **恒定乘积公式**：

> **x × y = k**

其中：

-   x 和 y 代表池内两种代币的储备数量；
    
-   k 是常数。
    

这个公式保证交易完成后，流动性池的资产乘积不变（忽略手续费等影响），从而实现 **无需订单簿的自动定价**。

交易时价格由池中的代币比例自动调整：当一种代币被买入（数量减少），另一种代币数量增加，从而改变价格并提供流动性深度。

* * *

## 3\. 核心组成架构

Uniswap V2 主要由以下智能合约构成：

### 工厂合约

-   负责创建和管理所有交易对（Pair 合约）。
    
-   每生成一个新的交易对，就会部署一个对应的 Pair 合约地址，并记录下来。
    

### 交易对合约

每个交易对（比如 USDC/ETH）对应一个 Pair：

-   管理池内两种资产储备；
    
-   实现 `swap`（交易）、`mint`（添加流动性）、`burn`（撤回流动性）等逻辑；
    
-   按恒定乘积公式处理每笔交易。
    

### 路由合约

-   为用户提供更方便的交互；
    
-   处理跨多个交易对的路径交换（如 USDT → DAI → ETH）；
    
-   计算交易数量、执行费用和滑点等。
    

### LP 代币

当用户添加流动性后，会收到代表其池内份额的 LP Token，流动性撤回时销毁该代币并返还资产。

* * *

## 4\. 关键功能与流程

### 交易 Swap（代币交换）

1.  用户将一种代币发送到 Pair 合约；
    
2.  合约按当前储备比例和手续费（0.3%）计算可输出的另一种代币数量；
    
3.  新的储备必须满足恒定乘积公式约束。
    

手续费直接留在池子中，作为流动性提供者的奖励。

* * *

### 添加流动性

用户存入相等价值的两种代币到池中，从而获得 LP Token，并开始获得交易手续费分成。

* * *

### 移除流动性

用户销毁 LP Token，按其份额取回池中对应数量的两种代币。

* * *

### 多池路由交易

如果两个代币没有直接的池，Router 会找出一个“路径”，比如通过 ETH 做桥，完成交换。

* * *

## 5\. 重要改进与特点（相比 Uniswap V1）

### 任意 ERC-20 交易对

V2 支持任意两个 ERC-20 代币之间直接创建交易对，不再必须通过 ETH 桥接交易，从而减少手续费和滑点。

* * *

### 价格预言机

Uniswap V2 内置时间加权平均价格预言机（TWAP）机制，可以让其他合约获取较难操纵的链上价格数据，用于去中心化衍生品、借贷等场景。

* * *

### 协议手续费

协议支持一个可选的收费开关（留给协议方一部分手续费），默认关闭。开启后协议可收取每笔交易的 0.05%，剩余 0.25% 分给 LP。

* * *

## 6\. 经济与风险

### 滑点与无常损失

-   **滑点**：交易量较大时，代币比例变动较大，导致价格偏离预期；
    
-   **无常损失**：流动性提供者在价格大幅波动时，相对持币不动可能面临损失。
    

这些都是 AMM 运作的自然现象，主要通过池深规模和交易设置（如最低输出量限制）来缓解。

* * *

## 7\. 协议优势

🔹 **无需信任、无需许可**：任何人都能提供流动性或交易，无需 KYC 或中间人。  
🔹 **开源与透明**：所有逻辑公开可审计。  
🔹 **自动定价机制**：流动性池按比例自动调节价格，无需订单簿。  
🔹 **可组合性强**：可与其他 DeFi 协议组合使用，如借贷、衍生品等。

* * *

## 8\. 总结

Uniswap V2 是去中心化交换协议的核心基础之一，通过 **自动做市商机制、简单高效的合约架构和开放性设计**，为 DeFi 生态带来了交易自由化和流动性创新。它的许多设计思想至今仍被其他 AMM 协议借鉴。
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->

# 一、ERC-20 —— 同质化代币标准（DeFi 基石）

## 设计目的

ERC-20 的目标只有一个：

> **让“代币”在以太坊上具备统一的行为规范**

在 ERC-20 出现前，每个项目的代币接口都不一样，钱包和交易所根本没法通用支持。

* * *

## 什么叫「同质化」

同质化 = **每一个单位都完全等价**

-   你手里的 1 USDT
    
-   和我手里的 1 USDT
    
-   在价值和属性上完全一致
    

就像人民币：你的一百元和我的一百元没有任何区别。

* * *

## 核心接口（非常重要）

### 必须实现的函数

```
function totalSupply() external view returns (uint256);
function balanceOf(address owner) external view returns (uint256);
function transfer(address to, uint256 value) external returns (bool);
function approve(address spender, uint256 value) external returns (bool);
function transferFrom(address from, address to, uint256 value) external returns (bool);
```

### 授权机制（ERC-20 的灵魂）

-   `approve`：允许某个合约花你的钱
    
-   `transferFrom`：合约代你转账
    

**所有 DeFi（DEX、借贷、质押）都依赖它**

* * *

## 使用场景

-   稳定币（USDT / USDC / DAI）
    
-   治理代币（UNI / AAVE）
    
-   流动性凭证（LP Token）
    
-   项目融资（ICO / IDO）
    

* * *

## 优点与缺点

### 优点

-   生态最成熟
    
-   所有钱包、交易所支持
    
-   DeFi 标准货币
    

### 缺点

-   不能区分单个 Token
    
-   不适合 NFT
    
-   授权存在“无限授权”安全隐患
    

* * *

# 二、ERC-721 —— 非同质化代币（NFT 的本体）

## 设计目的

ERC-721 的目标是：

> **在区块链上表示“唯一资产”**

现实世界中：

-   一幅画
    
-   一块土地
    
-   一个域名
    

它们都不可互换，ERC-20 完全不适合。

* * *

## 什么叫「非同质化」

每个 Token 都有：

-   **唯一的 tokenId**
    
-   独立的所有权
    
-   不同的属性和意义
    

即：

> CryptoPunk #5822 ≠ CryptoPunk #3100

* * *

## 核心结构

### 所有权映射

```
mapping(uint256 => address) private _owners;
```

### 关键函数

```
function ownerOf(uint256 tokenId) external view returns (address);
function safeTransferFrom(address from, address to, uint256 tokenId) external;
```

### 元数据（NFT 图片的来源）

```
tokenURI(tokenId) → JSON → image / attributes
```

* * *

## 使用场景

-   NFT 艺术品
    
-   游戏角色
    
-   虚拟土地
    
-   ENS 域名
    
-   数字身份（DID）
    

* * *

## 优点与缺点

### 优点

-   真正的唯一性
    
-   所有权清晰
    
-   非常适合收藏品
    

### 缺点

-   每个 NFT 单独转账，Gas 高
    
-   不适合大量资产
    
-   扩展性较差
    

* * *

# 三、ERC-1155 —— 多代币标准（效率之王）

## 设计背景

ERC-1155 是为了解决 ERC-721 的两个痛点：

1.  NFT 数量多 → Gas 爆炸
    
2.  游戏中既有金币（ERC-20）又有道具（ERC-721）
    

**那就统一管理**

* * *

## 核心思想

> **一个合约 + 多种 Token ID + 每个 ID 有数量**

```
mapping(uint256 => mapping(address => uint256)) balances;
```

-   Token ID = 1（金币，可同质）
    
-   Token ID = 2（剑，可半同质）
    
-   Token ID = 10001（传奇装备，唯一）
    

* * *

## 最大杀手锏：批量操作

```
safeBatchTransferFrom(
  address from,
  address to,
  uint256[] ids,
  uint256[] amounts
)
```

一笔交易转 100 个 NFT  
**Gas 省到爆**

## 使用场景

-   区块链游戏
    
-   大规模 NFT 项目
    
-   门票 / 道具系统
    
-   元宇宙资产
    

* * *

## 优点与缺点

### 优点

-   超省 Gas
    
-   同时支持 FT + NFT
    
-   批量铸造、转账
    

### 缺点

-   实现复杂
    
-   不如 ERC-721 直观
    
-   初学者理解成本高
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->


# **核心理念与设计哲学**

SpoonOS 的每一个架构决策都源于一套清晰且坚定的设计哲学。这套哲学不仅是技术实现的指导方针，更是我们对未来 AI 智能体在自主性、协作性和经济性方面核心需求的深刻回应。我们认为，一个卓越的操作系统必须拥有一个强大的理念内核。SpoonOS 的设计哲学，正是围绕以下三大不可动摇的核心原则构建而成。

**1 面向感知经济**

SpoonOS 的首要设计目标是服务于感知经济。这意味着系统的每一个组件都必须为支持能够感知环境、进行复杂推理、制定周密计划并最终执行物理或数字世界任务的“感知型”智能体而构建。这远非传统自动化脚本的线性执行逻辑，SpoonOS 的智能体被赋予了模块化的感知、推理、规划和执行能力，使其能够适应动态和不确定的现实世界。对于开发者，这意味着能够构建真正具备自主决策能力的应用程序；对于企业，则意味着能够部署可自主完成端到端复杂业务流程的数字劳动力。

**2 原生可组合性**

我们的架构性论点是，未来的复杂智能应用将由无数个专注于特定领域的、可互操作的智能体协同组合而成。为此，我们刻意摒弃了看似简单的单体式智能体设计，转而拥抱一种高度模块化、原生可组合的架构。单体式方法虽在初期易于实现，但不可避免地会导致技术债和适应性僵化。SpoonOS 的“乐高积木”哲学，确保了系统的复杂性能够随着其能力的增长而线性扩展，而非指数级增长。开发者可以自由地将不同的工具、模型和代理逻辑组合，快速构建强大的复合型智能体，这在去中心化金融（DeFi）、创作者经济等需要复杂策略与多方协作的领域，释放了前所未有的潜力。

**3 Web3 互操作性**

一个由自主经济实体构成的感知经济，必然要求一个无需许可、无需信任的底层基础设施。因此，SpoonOS 将 Web3 作为其信任和协作的基座，致力于实现真正的“Web3 原生互操作性”。我们通过深度集成 DID（分布式身份）和 ZKML（零知识机器学习）等前沿协议，使来自不同生态、由不同实体创建的 AI 代理，能够在密码学保障下安全、可信地进行通信与协调。这不仅打破了传统 AI 应用的数据孤岛，更为构建一个跨平台、跨链的复杂智能体协作网络提供了坚实的技术地基，为开发者和企业开辟了广阔的创新空间。

这些设计原则共同塑造了 SpoonOS 的核心特性，并直接体现在其先进的系统架构之中。

# **系统核心架构解析**

SpoonOS 的整体架构是其设计哲学的直接体现，秉承了模块化、可扩展和高可用的原则。

**1 统一大语言模型架构**

SpoonOS 设计了一套统一的大语言模型（LLM）基础架构，其核心目标是将智能体的推理核心与底层模型实现完全解耦。该架构的核心优势体现在以下几个方面：

• **模型提供商无关:** 开发者可在 OpenAI、Anthropic、Gemini 等不同 LLM 提供商之间无缝切换，或集成私有模型，而无需修改任何上层业务逻辑。

• **自动故障切换 :** 系统内置了可配置的“回退链”（Fallback Chain）。这不仅是为了保证高可用性，更是为了实现战略性的成本管理。架构师可以设计出高性价比的策略，例如将常规任务路由至廉价模型，同时为复杂推理保留高级模型，并通过自动故障切换确保服务不中断——这是单一提供商方案无法企及的运营控制水平。

• **负载均衡:** 支持将请求智能分发到多个模型实例，有效平衡系统负载，保证在高并发场景下的稳定性能。

• **全面的监控:** 提供完善的请求日志、性能指标和错误追踪功能，帮助开发者实时掌握模型服务的运行状态。

**2 模型上下文协议**

模型上下文协议（MCP）通过将智能体的推理核心与其执行能力解耦，解决了智能体能力扩展的根本性难题。这一设计模式彻底根除了硬编码工具依赖这种脆弱的“反模式”，将系统从一个静态的二进制文件转变为一个能够实时获取新技能而无需服务中断的动态、自适应实体。其核心价值在于：

• **运行时工具发现与执行：** AI 智能体可在运行时通过 `stdio`、`http` 或 `websocket` 等传输方式，动态发现并调用其完成任务所需的工具，无需任何预先编码或服务重启。

• **可扩展的数据访问能力：** 与 MCP 相结合，SpoonOS 提供了一套可扩展的数据访问层，使智能体能够无缝接入各类结构化和非结构化数据源，包括数据库、Web3 RPC 节点及外部 API，极大地拓宽了其能力边界。

**3 增强图系统**

虽然简单的智能体循环足以应付线性任务，但多智能体集群的协同编排则需要一个更为强大的抽象层。SpoonOS 的增强图系统通过一个正式的 StateGraph 架构提供了这一能力。这是我们相对于简单的有向无环图（DAG）或顺序调度器所做出的一个审慎的设计抉择，因为它能够支持条件路由、状态恢复（检查点）和人机协作（Human-in-the-Loop）等关键的企业级模式——这些对于构建可靠、长时运行的自主流程而言，是不可或缺的。

• **StateGraph 架构:** 开发者可通过定义节点（Nodes）、边（Edges）和条件路由来构建具有清晰状态管理的工作流。

• **多智能体协调:** 支持主管（Supervisor）模式和智能体路由，能够有效协调多个智能体共同完成复杂任务。

• **人机协作模式 (Human-in-the-Loop):** 内置中断和恢复机制，支持需要人工审批或干预的关键节点，实现人与 AI 的无缝协作。

• **状态持久化:** 支持检查点（Checkpointing）和工作流恢复，确保长时间运行的任务在意外中断后能从上一个已知状态继续执行。

**3.4 模块化代理框架 (Modular Agent Framework)**

SpoonOS 的核心吸引力在于其高度的模块化和可扩展性，而这一切都建立在其模块化代理框架之上。该框架提供了一系列精心设计的基类（如 `BaseTool` 和 `ToolCallAgent`），开发者可以轻松继承这些基类来创建遵循统一接口规范的自定义工具和代理。这一设计不仅极大地简化了开发流程，更重要的是，它为整个 SpoonOS 生态系统奠定了可组合性的基础，是实现我们“乐高积木”哲学的关键所在。
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->



# **Reactive Network 系统**

## **一、 定义**

Reactive Network 是一个**建立在以太坊生态之上的独立执行层（Parallel EVM）**，它的核心能力是能够以极低的延迟**监听任意兼容链上的事件（Logs）**，并自动根据预设逻辑触发**跨链回调**操作。

* * *

## **二、 核心痛点与解决方案**

在 Reactive Network 出现之前，Web3 生态存在两个巨大的痛点：

### **1\. 智能合约是被动的**

-   **痛点**：传统的智能合约（如 Uniswap）本身是“死”的，它们只能被动等待用户发送交易来唤醒。合约无法说“如果你现在的价格跌了 10%，就帮我卖出”。
    
-   **旧方案**：依赖中心化的 Keeper 网络（如 Gelato）或者自己在 AWS 上跑脚本。这引入了中心化风险和单点故障。
    
-   **Reactive 方案**：**Inversion of Control (控制反转)**。将控制权交给 Reactive 链上的“反应式合约”。一旦链上发生特定事件（如价格变动），立刻自动计算并执行后续操作。
    

### **2\. 跨链操作极其复杂且昂贵**

-   **痛点**：如果你想在 Polygon 上操作以太坊主网的资产，通常需要复杂的桥接、预言机和漫长的等待时间。
    
-   **Reactive 方案**：通过其独特的 **Reactive Smart Contracts (RSC)**，可以直接订阅源链（Origin Chain）的数据流，以较低的成本和延迟实现跨链逻辑闭环。
    

* * *

## **三、 系统架构与工作原理**

Reactive Network 的运行机制可以概括为 **“监听 -> 决策 -> 执行”** 的三步闭环：

### **1\. 监听**

-   **机制**：Reactive Network 的验证节点不仅仅验证自己的链，还作为一个**预言机网络**，实时监听其他链（如 Ethereum, Polygon, Arbitrum）产生的 Logs。
    
-   **特点**：
    
    -   **极低延迟**：直接同步区块头和 Logs，无需等待长时间的确认。
        
    -   **低成本**：不是所有数据都存，只订阅用户关心的 Event Topic（例如只监听 USDC 的转账事件）。
        

### **2\. 决策**

-   **机制**：当监听到关心的事件后，部署在 Reactive Network 上的 **Reactive Brain 合约** 会被自动唤醒。
    
-   **逻辑**：它会运行预先写好的 Solidity 代码（例如：“检查这笔转账是否大于 100 ETH” 或 “检查发送者是否要在黑名单里”）。
    
-   **优势**：这一步计算是在 Reactive 链上完成的，Gas 费远低于以太坊主网。
    

### **3\. 执行**

-   **机制**：一旦决策通过，Reactive Network 会生成一笔**回调交易（Callback Transaction）**，并将其广播到目标链（Destination Chain）上。
    
-   **结果**：目标链上的合约收到指令，执行最终操作（如：为了这笔大额入金铸造一个 VIP NFT，或者暂停被黑客攻击的协议）。
    

* * *

## **四、 核心价值**

对于不同角色，Reactive 带来了什么？

-   **对于开发者**：
    
    -   **无需维护后端**：不用再跑 node.js 脚本去监听链上事件，直接写个 Solidity 合约扔到 Reactive 上，永不掉线。
        
    -   **极简跨链**：把复杂的跨链通信抽象成了简单的“事件订阅”模型。
        
-   **对于用户 (UX)**：
    
    -   **自动化体验**：可以实现真正的“链上止损”、“自动复投”、“自动还款”，无需人工盯着。
        
    -   **更安全**：所有逻辑都由去中心化网络执行，而不是某个项目方的私人服务器。
        

* * *

## **五、 典型应用场景**

1.  **自动化 DeFi 交易**
    
    -   **场景**：Uniswap 止损单。
        
    -   **逻辑**：Reactive 监听 Uniswap 的价格事件，一旦价格跌破阈值，自动发送指令卖出 Token。
        
    -   **亮点**：无需将资产托管给中心化交易所，真正去中心化的限价单/止损单。
        
2.  **无感 UX 优化**
    
    -   **场景**：自动授权与充值。
        
    -   **逻辑**：用户往某个新游戏里充值 ETH，Reactive 监听到入金后，自动帮用户在后台完成 Approve 和 Mint 操作。
        
    -   **亮点**：用户只需发一笔交易，省去了繁琐的“授权-等待-再交易”流程。
        
3.  **多链会员/权益系统**
    
    -   **场景**：持仓 NFT 享受跨链权益。
        
    -   **逻辑**：用户在以太坊持有一个 BAYC，Reactive 监听到持有权后，自动在 Polygon 的游戏里给他发放 VIP 道具。
        
    -   **亮点**：不需要跨链桥转移 NFT 本身，只同步权益。
        
4.  **实时风控与安全**
    
    -   **场景**：黑客攻击阻断。
        
    -   **逻辑**：监听协议的大额流出事件，一旦发现异常（如 1秒内流出 80% 资金），Reactive 立即触发目标链上的暂停合约。
        
    -   **亮点**：比人工反应快得多，能挽救数百万美元的损失。
        

* * *

## **六、 总结**

Reactive Network填补了区块链“无法主动发起请求”的空白，让智能合约从“被动响应”进化为“主动反应”。对于 Web3 的大规模应用来说，这种去中心化的自动化能力是不可或缺的基础设施。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->




**链上所有权**

理解所有权是理解 NFT 的关键。在区块链的世界里，所有权是由代码严格定义的，清晰、透明且不可篡改。

下表总结了 ERC-721（NFT 标准）中关于所有权的核心功能：

| 功能 | 解释 |
| --- | --- |
| 所有权归属 | ownerOf(tokenId) 函数返回的地址就是该 NFT 的唯一所有者。 |
| 转移权限 | 只有 NFT 的所有者或其授权的地址才能转移它。 |
| 余额查询 | balanceOf(address) 函数可以查询一个地址拥有多少个 NFT。 |
| 授权 | approve 或 setApprovalForAll 允许你授权其他地址或合约来操作你的 NFT。 |

# **部署到 Sepolia 测试网**

## **部署你的智能合约**

按照以下步骤，将 NFT 合约部署到公共网络：

1\. **配置网络** 打开项目文件 `packages/hardhat/hardhat.config.ts`，找到 `defaultNetwork` 这一行，并将其值更改为 `sepolia`。

2\. **生成部署者钱包** 在终端中运行以下命令，它会为你创建一个用于部署合约的本地安全钱包。

3\. 系统会提示你设置一个密码，请务必记住它，后续部署时会用到。

4\. **查看钱包地址与余额**

5\. **获取测试币** 和本地网络一样，在 Sepolia 测试网上执行操作也需要 Gas 费（测试 ETH）。你需要从“水龙头 (Faucet)”获取一些免费的测试币。请将上一步生成的部署者地址复制下来，然后访问以下任一水龙头网站领取：

    ◦ [Alchemy Sepolia Faucet](https://www.google.com/url?sa=E&q=https%3A%2F%2Fsepoliafaucet.com%2F)

    ◦ [Infura Sepolia Faucet](https://www.google.com/url?sa=E&q=https%3A%2F%2Fwww.infura.io%2Ffaucet%2Fsepolia)

6\. **执行部署** 当你的部署者钱包收到测试币后，运行以下命令。这会将你的智能合约正式发布到 Sepolia 测试网上！

**2 上线你的前端应用**

合约已经上线，现在我们需要把用户界面也部署到公共服务器上，这样任何有网络的人都能访问它。

1\. **配置前端网络** 打开项目文件 `packages/nextjs/scaffold.config.ts`，找到 `targetNetwork` 这一行，并将其值设置为 `chains.sepolia`。

2\. **连接真实钱包** 由于应用已部署到公共网络，你需要连接一个真实的钱包（如 MetaMask）来进行交互。

3\. **部署到 Vercel** Vercel 是一个非常流行的前端应用托管服务。在终端中运行以下命令，并根据提示操作即可轻松部署。

4\. 部署完成后，你会得到一个公开的 URL 链接。

# **验证合约并分享你的成果**

**在 Etherscan 上验证合约**

运行以下命令来验证你的合约：

```
yarn verify --network sepolia
```

**为什么要验证合约？** 验证能将你可读的 Solidity 源代码与部署在区块链上的机器代码（字节码）关联起来。这向全世界证明了你的合约功能与代码完全一致，从而建立起关键的信任，防止他人指责你的项目是骗局。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->





作为智能合约编程新手，初遇ethernaut经常有一种摸不到头脑不知从何开始的感觉，所以大致总结了一些可能可以使用的解题思路。就用最简单的第一关作为演示。

### 1\. 寻找终点：我的目标是什么？

通常这类关卡的最终目的只有两个：

-   **成为 Owner**（夺取最高权限）。
    
-   **把钱取光**（让 `address(this).balance` 归零）。
    

在这个 `Fallback` 合约中，能看到 `withdraw` 函数：

```solidity
function withdraw() public onlyOwner {
    payable(owner).transfer(address(this).balance);
}
```

这里的 `onlyOwner` 告诉我们：只有 Owner 能提款。所以，我们的**终极目标**变成了：**“如何把变量** `owner` **修改成我的地址？”**

### 2\. 寻找修改点：谁能改变 `owner`？

在代码中搜索所有出现 `owner =` 的地方。在代码里有三个地方：

1.  `constructor`：
    
    -   `owner = msg.sender;`
        
    -   _分析：_ 只有部署时运行一次，我们改不了。
        
2.  `contribute` **函数**：
    
    -   `if (contributions[msg.sender] > contributions[owner]) { owner = msg.sender; }`
        
    -   _分析：_ 需要我的钱比原 Owner 更多。查看 `constructor` 发现原 Owner 有 1000 ETH，太难了，放弃。
        
3.  `receive` **函数**：
    
    -   `owner = msg.sender;`
        
    -   _分析：_ **这是突破口！** 只要触发这个函数，我就能直接变身 Owner。
        

### 3\. 破解门槛：触发条件是什么？

既然锁定了 `receive` 函数，我们要看它运行的前提条件（`require`）：

```solidity
receive() external payable {
    require(msg.value > 0 && contributions[msg.sender] > 0); // 门槛在这里
    owner = msg.sender;
}
```

要把这个门槛拆解成动作：

-   **动作 A：**`msg.value > 0` 意思是：我给合约转账时，金额必须大于 0。
    
-   **动作 B：**`contributions[msg.sender] > 0`
    
    -   意思是：我在合约里的“捐款记录”必须大于 0。
        

### 4\. 制定攻略：我该按什么顺序操作？

通过上面的倒推，攻略方法就出来了：

1.  **满足动作 B**：调用 `contribute()` 捐一点点钱（比如 0.0001 ETH）。这样我的捐款记录就不是 0 了。
    
2.  **满足动作 A**：直接往合约地址转 1 wei（最微小的单位）。这会触发 `receive` 函数。
    
3.  **结果**：由于满足了两个条件，代码执行 `owner = msg.sender`，你成功夺权。
    
4.  **收割**：调用 `withdraw()`，把钱拿走。
    

# 漏洞总结

## 伪随机问题

```solidity
uint256 blockValue = uint256(blockhash(block.number - 1));
```

-   **逻辑**：它获取**上一个区块的哈希值**作为随机数的种子。
    
-   **用途**：区块链上一切都是确定的，没有真正的随机数。这里试图利用区块哈希的不可预测性。
    

虽然它用了`blockhash`看起来像随机，但对于区块链上的**攻击者合约**来说，**这也是完全透明的**。

如果写一个攻击合约：

1.  在攻击函数里，先自己照抄一遍上面的公式计算出\*\*`side`\*\*（因为在同一个交易里，`block.number` 和 `blockhash` 是一样的）。
    
2.  算出必然正确的结果。
    
3.  把这个必胜的`side` 传给 `flip()` 函数。
    
4.  你就能 100% 连胜。
    

# JavaScript注意事项

## receive特殊函数

`receive` **函数在 JavaScript 中不能像普通函数那样调用。**

### 为什么会报错？

在 Solidity 中，`receive()` 是一个**特殊函数**。它没有名字（在 ABI 接口中不显示），它的存在是为了处理那些“只发钱、不传数据”的交易。

-   **普通函数：** 比如 `contribute()`，你在 JS 里写 `contract.contribute()`，系统知道去调用名为 "contribute" 的代码块。
    
-   **特殊函数：** `receive()` 是一个“自动备选方案”。当你直接给合约地址转账，且没有指定要调用哪个函数名时，以太坊网络会自动去运行 `receive()` 里的逻辑。
    

所以，在控制台输入 `contract.receive()` 是行不通的，因为在 JS 对象的函数列表里根本找不到这个名字。

### 正确的操作方式：直接转账

要触发 `receive()`，你需要发送一笔“纯转账交易”。在 Ethernaut 的控制台中，最标准的写法是：

```solidity
await contract.sendTransaction({
  value: toWei("0.0001")
})
```
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->






# 事件

`Solidity`**中的事件（**`event`）是\*\*`EVM`\*\*上日志的抽象，它具有两个特点：

-   响应：应用程序（`ethers.js`）可以通过\*\*`RPC`\*\*接口订阅和监听这些事件，并在前端做响应。
    
-   经济：事件是\*\*`EVM`\*\*上比较经济的存储数据的方式，每个大概消耗2,000 `gas`；相比之下，链上存储一个新变量至少需要20,000 `gas`。
    

# 继承

## **一、多重继承**

**一个合约可以同时继承多个父合约！**

```solidity
solidity

// 爷爷
contract Yeye {
    function hip() public pure virtual returns(string memory) {
        return "Yeye";
    }
}

// 爸爸 继承 爷爷
contract Baba is Yeye {
    function hip() public pure virtual override returns(string memory) {
        return "Baba";
    }

    function pop() public pure virtual returns(string memory) {
        return "Baba";
    }
}

// 儿子 同时继承 爷爷 和 爸爸
contract Erzi is Yeye, Baba {
    // 必须 override 所有父合约中同名的函数
    function hip() public pure override(Yeye, Baba) returns(string memory) {
        return "Erzi";
    }

    function pop() public pure override returns(string memory) {
        return "Erzi";
    }
}

```

* * *

### **⚠️ 关键规则：继承顺序**

**必须按辈分从高到低写！**

```solidity
solidity

// ✅ 正确：Yeye(爷爷) 在 Baba(爸爸) 前面
contract Erzi is Yeye, Baba { }

// ❌ 错误：辈分顺序反了
contract Erzi is Baba, Yeye { }  // 编译报错！

```

### **图解继承顺序**

```

Yeye (辈分最高)
          ↑
        Baba (中间)
          ↑
        Erzi (辈分最低)

继承声明：contract Erzi is Yeye, Baba
                           ↑      ↑
                          高 → → 低

```

* * *

### `virtual` **和** `override` **关键字**

| 关键字 | 作用 | 用在哪 |
| --- | --- | --- |
| virtual | "我允许被子合约重写" | 父合约的函数 |
| override | "我正在重写父合约的函数" | 子合约的函数 |

```solidity
solidity

contract Yeye {
    // virtual = 可以被重写
    function hip() public pure virtual returns(string memory) {
        return "Yeye";
    }
}

contract Baba is Yeye {
    // override = 我重写了    virtual = 我的子合约也可以重写我
    function hip() public pure virtual override returns(string memory) {
        return "Baba";
    }
}

contract Erzi is Baba {
    // override = 我重写了 (没加virtual = 到此为止，不能再被重写)
    function hip() public pure override returns(string memory) {
        return "Erzi";
    }
}

```

* * *

### **多个父合约有同名函数？**

必须用

```solidity
override(Parent1, Parent2)
```

指明重写了谁：

```solidity
solidity

contract Erzi is Yeye, Baba {
    // 必须写明 override 了哪些合约
    function hip() public pure override(Yeye, Baba) returns(string memory) {
        return "Erzi";
    }
}

```

* * *

## **二、修饰器 (Modifier) 继承**

**Modifier 也可以被继承和重写！**

```solidity
solidity

contract Base {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // 父合约定义 modifier，加 virtual 允许重写
    modifier onlyOwner() virtual {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function changeOwner(address newOwner) external onlyOwner {
        owner = newOwner;
    }
}

contract Child is Base {
    // 重写 modifier：添加额外检查
    modifier onlyOwner() override {
        require(msg.sender == owner, "Not owner");
        require(owner != address(0), "Owner not set");  // 新增检查
        _;
    }

    // 这个函数使用的是 Child 版本的 onlyOwner
    function doSomething() external onlyOwner {
        // ...
    }
}

```

* * *

### **不重写也能直接用**

```solidity
solidity

contract Base {
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}

contract Child is Base {
    // 没有重写 onlyOwner，直接继承使用

    function foo() external onlyOwner {  // ← 直接用父合约的 modifier
        // ...
    }
}

```

* * *

## **什么是菱形继承？**

继承关系形成了一个**菱形**：

```

┌───────┐
        │  God  │   ← 最顶层的祖先
        └───┬───┘
           ╱ ╲
          ╱   ╲
    ┌────┴─┐ ┌─┴────┐
    │ Adam │ │ Eve  │  ← 两个中间层，都继承God
    └────┬─┘ └─┬────┘
          ╲   ╱
           ╲ ╱
        ┌───┴───┐
        │ Human │  ← 底层，同时继承Adam和Eve
        └───────┘

形状像菱形 ◇ 所以叫菱形继承

```

* * *

## **问题在哪？**

假设 `God` 有个函数 `foo()`，`Adam` 和 `Eve` 都重写了它：

```solidity
contract God {
    function foo() public pure virtual returns(string memory) {
        return "God";
    }
}

contract Adam is God {
    function foo() public pure virtual override returns(string memory) {
        return "Adam";
    }
}

contract Eve is God {
    function foo() public pure virtual override returns(string memory) {
        return "Eve";
    }
}

// Human 继承了 Adam 和 Eve
// 问题：调用 foo() 时，用 Adam 的还是 Eve 的？
contract Human is Adam, Eve {
    function foo() public pure override(Adam, Eve) returns(string memory) {
        return "Human";
    }
}

```

**问题：** 如果 Human 调用`super.foo()`，会调用谁的？Adam？Eve？还是两个都调用？

* * *

## **Solidity 的解决方案：C3 线性化**

Solidity 使用 **C3 线性化算法**，把菱形"拉平"成一条线：

```

继承声明：contract Human is Adam, Eve

线性化顺序（从右到左）：
Human → Eve → Adam → God

调用 super.foo() 的顺序：
Human.foo() → super → Eve.foo() → super → Adam.foo() → super → God.foo()

```

* * *

## **代码演示**

```solidity
solidity

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract God {
    event Log(string message);

    function foo() public virtual {
        emit Log("God.foo");
    }

    function bar() public virtual {
        emit Log("God.bar");
    }
}

contract Adam is God {
    function foo() public virtual override {
        emit Log("Adam.foo");
        super.foo();  // 调用上一层
    }

    function bar() public virtual override {
        emit Log("Adam.bar");
        super.bar();
    }
}

contract Eve is God {
    function foo() public virtual override {
        emit Log("Eve.foo");
        super.foo();  // 调用上一层
    }

    function bar() public virtual override {
        emit Log("Eve.bar");
        super.bar();
    }
}

// 注意顺序：Adam, Eve（辈分相同时，按声明顺序）
contract Human is Adam, Eve {
    function foo() public override(Adam, Eve) {
        emit Log("Human.foo");
        super.foo();  // 调用上一层
    }

    function bar() public override(Adam, Eve) {
        emit Log("Human.bar");
        super.bar();
    }
}

```

### **调用** `Human.foo()` **的输出顺序：**

```

1. "Human.foo"   ← Human
2. "Eve.foo"     ← super 调用 Eve（声明中最右边）
3. "Adam.foo"    ← super 调用 Adam
4. "God.foo"     ← super 调用 God

每个合约只被调用一次！不会重复调用 God！

```

* * *

## **图解 C3 线性化**

```

声明: contract Human is Adam, Eve

菱形结构：              线性化后：
    God                 Human → Eve → Adam → God
   ╱   ╲                  │       │      │      │
 Adam   Eve    ───→       ↓       ↓      ↓      ↓
   ╲   ╱                super   super  super  (结束)
   Human

调用 super.foo() 时，按线性顺序依次执行

```

* * *

## **关键规则**

| 规则 | 说明 |
| --- | --- |
| 继承顺序 | 从辈分高到低： |

`is God, Adam, Eve` ❌

`is Adam, Eve` ✅ | | super 调用顺序 | 按声明**从右到左**：Eve → Adam → God | | 每个合约只调用一次 | God 不会被重复调用！ |

* * *

## **为什么要关心这个？**

1.  **避免重复执行** - God 的代码只执行一次
    
2.  **可预测的行为** - 你知道 super 会按什么顺序调用
    
3.  **写继承时要小心顺序** - 顺序不同，行为可能不同
    

* * *

## **一句话总结**

> 菱形继承 = 多个父合约有共同祖先 Solidity 解决方案 = C3 线性化，把菱形拉成一条线，super 按线性顺序调用，每个合约只调用一次
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->







# 函数

```solidity
function <function name>([parameter types[, ...]]) {internal|external|public|private} [pure|view|payable] [virtual|override] [<modifiers>]
[returns (<return types>)]{ <function body> }
```

-   `function`：声明函数时的固定用法。要编写函数，就需要以 `function` 关键字开头。
    
-   `<function name>`：函数名。
    
-   `([parameter types[, ...]])`：圆括号内写入函数的参数，即输入到函数的变量类型和名称。
    
-   `{internal|external|public|private}`：函数可见性说明符，共有4种。
    
    -   `public`：内部和外部均可见。
        
    -   `private`：只能从本合约内部访问，继承的合约也不能使用。
        
    -   `external`：只能从合约外部访问（但内部可以通过 `this.f()` 来调用，\*\*`f`\*\*是函数名）。
        
    -   `internal`: 只能从合约内部访问，继承的合约可以用。
        

**注意 1**：合约中定义的函数需要明确指定可见性，它们没有默认值。

**注意 2**：`public|private|internal` 也可用于修饰状态变量(定义可参考[WTF Solidity 第5讲的相关内容](https://www.wtf.academy/zh/course/solidity101/%5B../05_DataStorage/readme.md#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%5D\(https://github.com/AmazingAng/WTF-Solidity/tree/main/05_DataStorage#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F\)))。`public`**变量会自动生成同名的**`getter`**函数，用于查询数值。未标明可见性类型的状态变量，默认为**`internal`。

</aside>

-   `[pure|view|payable]`：决定函数权限/功能的关键字。`payable`（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。
    
-   `[virtual|override]`: 方法是否可以被重写，或者是否是重写方法。\*\*`virtual`**用在父合约上，标识的方法可以被子合约重写。**`override`\*\*用在自合约上，表名方法重写了父合约的方法。
    
-   `<modifiers>`: 自定义的修饰器，可以有0个或多个修饰器。
    
-   `[returns ()]`：函数返回的变量类型和名称。
    
-   `<function body>`: 函数体。
    

## `Pure` **和**`View`

`solidity` 引入这两个关键字主要是因为 以太坊交易需要支付气费（gas fee）。合约的状态变量存储在链上，gas fee 很贵，如果计算不改变链上状态，就可以不用付 `gas`。包含 `pure` 和 `view` 关键字的函数是不改写链上状态的，因此用户直接调用它们是不需要付 gas 的。

注意，合约中非 `pure`/`view` 函数调用 `pure`/`view` 函数时需要付gas

在以太坊中，以下语句被视为修改链上状态：

1.  写入状态变量。
    
2.  释放事件。
    
3.  创建其他合约。
    
4.  使用 `selfdestruct`.
    
5.  通过调用发送以太币。
    
6.  调用任何未标记 `view` 或 `pure` 的函数。
    
7.  使用低级调用（low-level calls）。
    
8.  使用包含某些操作码的内联汇编。
    

## **状态变量 vs 函数参数**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract FunctionTypes {
    uint256 public number = 5;  // ← 这是「状态变量」，存储在区块链上！
    
    // ❌ 错误！pure 不能读取状态变量 number
    function addPure_Wrong() external pure returns(uint256) {
        return number + 1;  // 编译报错！
    }
    
    // ✅ 正确！_number 是「函数参数」，不是链上状态
    function addPure(uint256 _number) external pure returns(uint256 new_number) {
        new_number = _number + 1;  // 完全OK！
    }
}
```

| 对比项 | number (状态变量) | _number (函数参数) |
| --- | --- | --- |
| 存储位置 | 区块链上 (storage) | 内存中 (memory/stack) |
| 生命周期 | 永久存在 | 函数执行时临时存在 |
| 读取成本 | 需要访问链上状态 | 不需要访问链 |
| pure 能用？ | ❌ 不能 | ✅ 可以 |

### **用现实世界类比**

想象pure函数是一个「无窗密室」里的计算器：

-   **状态变量**  = 墙外面的公告牌上写的数字`number`
    
    -   密室里看不到外面，所以 `pure` 不能读取
        
-   **函数参数**  = 你带进密室的纸条上的数字`_number`
    
    -   这是你自己带进来的，不需要看外面，所以 `pure` 可以用
        

### **总结**

`pure`的规则很简单：

> 不能读取或修改任何链上状态

-   ❌ 状态变量 → 是链上状态
    
-   ✅ 函数参数 → 是调用时传入的临时值，不算链上状态
    
-   ✅ 局部变量 → 函数内部创建的临时值，也不算链上状态
    

## 引用

```solidity
uint[] x = [1,2,3];  // 状态变量，存在区块链上 (storage

function fStorage() public {
    uint[] storage xStorage = x;  // 👈 xStorage 是 x 的「指针」，不是复制！
    xStorage[0] = 100;            // 修改 xStorage = 修改 x
}
执行后结果：x = [100, 2, 3]
```

**用 C 语言对比**

```solidity
// C 语言版本 - 完全等价！
int x[3] = {1, 2, 3};  // 原始数组
void fStorage() {
int* xStorage = x;   // xStorage 是指向 x 的指针
xStorage[0] = 100;   // 通过指针修改，x 也变了！
}
// 执行后：x = {100, 2, 3}
```

**完全一样的逻辑！**

`storage` 关键字告诉编译器：这是一个引用，不是复制。

### **快速记忆表**

| 关键字 | 含义 | C 语言类比 | 修改会影响原数据？ |
| --- | --- | --- | --- |
| storage | 引用 | 指针 int* p = x | ✅ 会 |
| memory | 复制 | memcpy() | ❌ 不会 |
| calldata | 只读复制 | const 参数 | ❌ 不能改 |
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->








### 引言：从公开的数字藏品到隐私的会员身份

ERC-721 标准的诞生，开启了数字所有权的新纪元。它使得艺术品、收藏品等独一无二的数字物品，能够作为NFT（非同质化代币）在区块链上拥有不可篡改的所有权记录。我们可以向全世界证明：“这幅数字画作是我的。”

然而，ERC-721 的一个核心特点是它的**完全公开性**。每一枚NFT的所有权都直接与一个公开的以太坊地址绑定。任何人都可以查询到，某个地址下拥有哪些NFT，某个NFT又属于哪个地址。

这就引出了一个核心问题：当我们想要标记的资产并非一件需要公开炫耀的艺术品，而是一种需要保护隐私的身份凭证，例如**商业会员资格**时，ERC-721 的公开性就成了一个巨大的挑战。ERC-7962 标准的提出，正是为了精准地解决这一痛点，为链上资产的隐私保护和用户体验的提升，开辟了一条全新的进化路径。值得一提的是，该标准并非空中楼阁，而是源于真实商业场景（如`datad`的会员体系实践）中遇到的具体挑战，是为解决实际问题而生的技术结晶。

## 1\. ERC-721的世界：公开的所有权与隐私的困境

### 1.1 ERC-721 如何标识所有权？

在 ERC-721 标准中，一个NFT的所有者（Owner）就是一个具体的、公开的链上地址（`address`）。

智能合约提供了一个名为 `ownerOf` 的公共查询函数。这意味着，**任何人、在任何时间**，都可以调用这个函数，传入一个NFT的ID，从而准确地知道这个NFT当前归属于哪一个以太坊地址。这种设计保证了所有权的透明和可验证性，但也牺牲了所有者的隐私。

### 1.2 公开性带来的“隐私图谱”问题

由于所有资产和地址的关联都是公开的，任何人都可以追踪一个地址的所有交易记录和资产持有情况。这种完全的透明性会带来一个严重的问题：

攻击者或数据分析者可以轻易地将一个地址所拥有的NFT、同质化代币（ERC-20）以及历史交易行为关联起来，描绘出一个详细的“用户画像”或“隐私图谱”。

这种强关联性，对于需要保密的商业场景是致命的。例如，如果一个人的会员身份与其持有的巨额加密资产被关联起来，他的个人财富状况和消费习惯将被完全暴露。

## 2\. 问题的提出：当会员卡需要“隐身”时

### 2.1 一个生动的例子：星巴克与机场贵宾厅

想象这样一个商业合作场景：星巴克希望为它的高级会员提供一项福利——免费使用机场的贵宾休息厅。在这个场景中，三方的需求和困境交织在一起：

-   **星巴克（发行方）**
    
    -   **需求**：希望与机场合作为会员提供增值服务。
        
    -   **困境**：受限于隐私法规和商业道德，星巴克**不能**将完整的会员名单（即持有会员NFT的地址列表）直接共享给机场。这既是法律要求，也是对用户隐私的尊重。
        
-   **机场贵宾厅（验证方）**
    
    -   **需求**：需要一种可靠的方法来验证前来休息的旅客**是否真的是星巴克会员**。
        
    -   **困境**：机场**不关心也不想**存储所有星巴克会员的完整信息。它只需要在旅客出示凭证时，能够进行一次性的、准确的身份验证。
        
-   **会员本人（持有者）**
    
    -   **需求**：希望在机场贵宾厅方便地证明自己的会员身份，从而享受服务。
        
    -   **困境**：会员**不希望**自己的个人信息（尤其是关联了大量资产的链上地址）在验证过程中被机场获取或被公开泄露。
        

这个例子清晰地揭示了ERC-721在处理这类隐私敏感型资产时的局限性。我们需要一种全新的技术范式，来满足这种“有条件的匿名验证”需求。为了解决这个现实问题，ERC-7962 引入了革命性的设计理念。

## 3\. ERC-7962的解决方案：引入两大核心设计

ERC-7962 通过两个巧妙的核心设计，完美地解决了上述困境，实现了隐私保护和用户体验的飞跃。

### 3.1 核心设计一：用“密钥哈希”替代“地址”

ERC-7962 的第一个关键创新，是重新定义了“所有者”的标识。

在 ERC-7962 中，资产的所有权标识不再是公开的`address`，而是一个\*\*`Key Hash`\*\*（公钥的哈希值）。

对于初学者而言，“哈希”可以理解为一种单向的数学运算。它具有以下特点：

-   **单向性**：可以从公钥轻松计算出其对应的哈希值。
    
-   **不可逆性**：**无法**从哈希值反向推导出原始的公钥。
    

这意味着，在资产未发生交易的“静默状态”下，智能合约中只记录了这个无法反推的 `Key Hash`。外界观察者只能看到一串无意义的哈希值，完全无法得知其背后的真实公钥，更不用说关联到具体的地址了，从而在源头上保护了所有者的身份隐私。

### 3.2 核心设计二：交易发起与所有权“解绑”

ERC-7962 的第二个关键创新，是将**资产所有权**与**交易发起方**（即`msg.sender`）彻底解耦。

在 ERC-721 的世界里，如果你想转移一个NFT，你必须亲自用你的地址发起这笔交易。但在 ERC-7962 中，流程发生了根本性的变化：

1.  **所有者签名**：资产的真正所有者只需对自己的交易意图（例如“将这个NFT转移给某个新的`Key Hash`”）进行数字签名。这个签名行为可以在链下完成，完全不消耗Gas。
    
2.  **第三方提交**：所有者可以将这个签名后的消息交给**任何一个第三方**（称为 Relayer，中继者）来代为提交上链。
    
3.  **合约验证**：智能合约的核心验证逻辑发生了改变：它**只验证签名**是否与当前资产的`Key Hash`匹配，而**完全不关心**这笔交易是由谁（即`msg.sender`）提交的。无论是资产所有者、项目方还是任何第三方中继者，只要能提供有效签名，交易就会被执行。
    

这个设计是实现高级隐私保护和改善用户体验的基石。理解了这两个核心设计后，我们就能清晰地看到 ERC-7962 相对于 ERC-721 的巨大进步。

## 4\. 核心差异对比：一次清晰的技术升级

为了更直观地理解这次技术演进，我们可以通过一个表格来清晰地对比 ERC-721 和 ERC-7962 在几个核心维度上的根本不同。

更进一步，ERC-7962借鉴了比特币UTXO模型的核心思想来增强抗关联性。在交易后，一个`Key Hash`不会被复用。例如，如果一个`Key Hash`拥有100个代币，并转出30个，那么剩余的70个代币会被发送到一个\*\*全新的、与之前毫无关联的`Key Hash`\*\*中。由于每次交易都会更换‘锁’，外部观察者无法将这些孤立的`Key Hash`串联起来，从而彻底切断了交易历史的追踪路径。

| 特性维度 | ERC-721 标准 | ERC-7962 解决方案 |
| --- | --- | --- |
| 所有权标识 | 使用公开的以太坊地址 (address)，任何人都可以查询，隐私性差。 | 使用公钥的哈希值 (Key Hash)，在交易发生前有效隐藏了所有者的真实身份。 |
| 交易发起方式 | 资产所有者必须是交易发起方 (msg.sender)，需要自己持有原生代币来支付Gas费。 | 所有权与交易发起方解耦。所有者只需签名，可由**任意第三方（Relayer）**代为提交交易和支付Gas费。 |
| 隐私保护机制 | 链上完全公开，资产和地址强关联，容易被追踪和分析，形成“隐私图谱”。 | 通过Key Hash隐藏静态所有权，并利用UTXO式的一次性密钥机制（交易后更换Key Hash），彻底切断地址关联，防止交易图谱被追踪。 |

ERC-7962 的价值远不止于隐私保护。它所带来的“所有权与交易发起解绑”模型，为Web3的用户体验（UX）带来了革命性的变化，让Web3应用真正有机会走向主流用户。

## 5\. ERC-7962带来的变革：从“硬核”走向“友好”

### 5.1 为Web2用户铺平道路

长期以来，复杂的钱包管理和Gas费概念是阻碍Web2用户进入Web3世界的巨大门槛。ERC-7962 极大地降低了这一门槛，为新用户带来了三大核心好处：

1.  **无需管理Gas费** 用户不再需要先去交易所购买和持有原生代币（如ETH）来支付交易费用。得益于所有权与交易发起方解耦的设计，项目方或服务方可以扮演\*\*“中继者”（Relayer）**的角色，代用户提交交易并支付Gas费，从而实现对用户完全无感的**Gas Sponsorship\*\*（Gas费赞助）。
    
2.  **无需理解复杂钱包** 用户可以像使用传统App一样，通过简单的签名操作来表达意图。他们无需深入理解私钥、公钥、地址和链上交互等复杂概念，大大降低了认知负荷。
    
3.  **资产操作流程简化** 复杂的链上交互逻辑可以被完全后台化。呈现在用户面前的，可以是一个极其流畅、无感的交互体验，与他们熟悉的Web2应用别无二致。
    

### 5.2 增强的灵活性与可扩展性

由于交易发起和所有权的分离，ERC-7962 模型天然地支持**批量交易**和\*\*账户抽象（Account Abstraction, AA）\*\*等高级应用场景。这为企业级应用（例如需要向成千上万个用户进行会员卡空投）提供了极大的便利和效率提升。

## 6\. 总结：通往Web3大规模应用的一座桥梁

回顾从 ERC-721 到 ERC-7962 的演进路径，我们看到了一条清晰的技术进化脉络：

-   **ERC-721** 开创了公开、透明、可验证的数字所有权时代，为NFT的爆发奠定了基础。
    
-   **ERC-7962** 则在此基础上，通过引入**密钥哈希（Key Hash）所有权与交易发起解耦**两大核心设计，精准地解决了公开性带来的隐私痛点，并彻底革新了用户与区块链的交互方式。
    

因此，ERC-7962 不仅仅是一个新的代币标准，它更像是一座连接Web2用户与Web3世界的重要桥梁。它通过解决隐私和用户体验这两个最关键的瓶颈，为Web3技术走出极客圈，实现大规模的商业化应用，扫清了前进道路上的重要障碍。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->









本周，我的学习路径遵循了一个由宏观到微观的逻辑：首先，我从以太坊的宏大愿景出发，试图回答最根本的问题——“它是什么？”；接着，我潜入其底层架构，探索支撑这一切的 **网络结构** 是“如何运作的？”；最后，我将目光聚焦于网络中最核心的交互单元——两种不同的 **账户类型**，探究“谁在其中交互？”。

这次学习对我而言，远不止于理论知识的堆砌，更是一次思维模式的重塑。我深刻体会到，将以太坊的认知从“数字黄金”的单一维度，跃升到“全球可编程平台”即 **世界计算机** 的高度，是理解其所有技术魅力和生态创新的真正起点。

### **以太坊的真正身份——超越“数字黄金”的“世界计算机”**

理解以太坊的平台定位至关重要，因为这一定位是其所有技术特性和生态创新的根基。它解释了为什么以太坊不仅仅是一种货币，更是一个能够承载无限可能的基础设施。我提炼出三个核心要点，它们共同定义了以太坊的真正身份。

**“可编程”的革命性：** 以太坊的核心突破在于引入了“智能合约”和图灵完备的“以太坊虚拟机”（EVM）。教材中的一个比喻非常精妙：智能合约就像一台 **“数字世界的自动售货机”**，你投入代币（调用函数），它就自动执行预设的逻辑（完成交易）。正是这种可编程性，让以太坊从一个单纯的“记账系统”进化为一个能够运行DeFi、NFT和DAO等无限应用的平台。这不仅仅是技术的进步，更是创造了一个无需许可、自动执行的经济与协作新范式。

**比特币 vs. 以太坊的本质区别：** 这个对比深刻地反映了以太坊从命名之初的愿景——“以太”一词源于一种假设中遍布宇宙的无形介质，象征着它想成为一切应用的底层基础。如果说比特币是 **“数字黄金”**，那么以太坊就是 **“全球可编程计算机”**。这个对比揭示了两者根本的目标差异。比特币协议设计克制，优先考虑简单与安全，旨在成为一种去中心化的价值储存媒介，是“价值锚”。而以太坊的目标则是成为一个通用的应用平台，其原生代币ETH不仅是价值载体，更是驱动整个生态运转的“燃料”（Gas）。从发行机制（固定上限 vs. 低通胀+销毁）到应用生态的广度，两者走上了截然不同的道路，一个聚焦于“成为什么”，另一个则专注于“能做什么”。

**从PoW到PoS的进化意义：** 以太坊从工作量证明（PoW）转向权益证明（PoS）的“The Merge”升级，是一次深思熟虑的战略进化。这不仅仅意味着能耗降低约99.95%，更深层的意义在于安全机制的根本转变。PoW依赖于高昂的电力和硬件成本来保障安全，是一种“电力押注”；而PoS则通过验证者质押ETH来维护网络，作恶将导致质押资产被罚没（Slashing，即作恶者的部分或全部质押ETH将被协议销毁或罚没），这是一种“经济押注”。这种转变让以太坊的安全模型与其自身的经济价值深度绑定，为未来的可扩展性奠定了更可持续的基础。

### **节点如何构成去中心化的世界**

如果说“世界计算机”是愿景，那么由全球节点构成的P2P网络就是实现这一愿景的血肉。理解节点类型和网络结构，是真正领会以太坊“去中心化”如何从理论落到实地的关键。

| 节点类型 | 核心职能 | 源文比喻 |
| --- | --- | --- |
| 全节点 (Full Node) | 验证所有交易和区块，保存完整区块历史和近期状态（会裁剪旧状态），是网络安全和独立验证的基石。 | “大型公共图书馆” |
| 归档节点 (Archive Node) | 存储从创世块至今的每一个历史状态快照，不对历史状态做任何裁剪，是数据分析和历史回溯的“时间机器”。 | “国家档案馆” |
| 轻节点 (Light Node) | 只下载区块头，通过密码学证明（如Merkle证明）来验证数据，资源消耗极低，非常适合移动设备或资源受限的环境。 | “移动书柜/电子目录机” |

在“The Merge”之后，节点的内部架构也发生了根本性的变革，即 **执行客户端 (EL)** 与 **共识客户端 (CL)** 的分离。这种模块化设计是以太坊工程智慧的体现：

**执行客户端 (EL)** 负责处理交易、运行EVM和管理状态。它就像一个 **“书记员+案卷系统”**，专注于“算账”和记录。

**共识客户端 (CL)** 负责PoS共识逻辑，如提议区块和投票。它则像一位 **“法官”**，依据共识规则对书记员提交的结果进行“裁决”。

这两者通过一条名为 **Engine API** 的“专线电话”进行内部通信，协同工作，确保了执行与共识的分离，大大增强了系统的模块化、安全性和客户端多样性。

当网络稳定运行时，真正的交互便在两种核心账户之间展开。

### **谁在发起交易？谁在执行代码？**

理解以太坊上的两种账户类型，是掌握所有链上活动逻辑的起点。它们就像舞台上的两种角色：一种是主动的“行动者”，另一种则是被动的“自动机”。

外部拥有账户 (EOA)：由私钥驱动的“行动者”

**定义与控制：** 这是我们通过钱包（如MetaMask）创建和管理的账户，其唯一控制权源于对应的 **私钥/助记词**。

**核心能力：** EOA是网络中 **唯一能够主动发起交易** 的实体。无论是转账、部署合约还是调用合约，所有链上活动的起点都必须是一个由EOA签名的交易。

**结构特点：** 在其账户状态中，

code

 字段为空，意味着它自身不包含任何可执行的逻辑。

**生动比喻：** 正如教材所比喻的，EOA就像 **“人 + 银行卡”**，人（私钥持有者）决定如何使用这张卡。

合约账户：由代码驱动的“自动机”

**定义与控制：** 这是通过部署智能合约而创建的账户，它的行为完全由其内部存储的EVM字节码决定，没有私钥。

**核心特点：** 合约账户 **不能主动发起交易**，它只能被动地响应来自EOA或其他合约的调用。

**结构特点：** 其账户状态中包含 

code

（合约逻辑）和 

storage

（状态存储），是所有dApp复杂功能的载体。

**生动比喻：** 它就像一台 **“写死规则的自动售货机”**，只能根据接收到的指令（调用）来执行预设的程序。

在合约的创建流程上，**CREATE** 操作码产生的地址依赖于部署者的地址和

nonce

，而 **CREATE2** 则允许我们根据部署者地址、一个自定义的

salt

以及合约的初始化代码来 **预先计算出合约地址**。后者的战略价值巨大，它催生了如“钱包工厂”和“反事实合约”等高级应用，允许我们在合约部署前就与之交互。

理清了账户这个基本单元，以太坊世界的互动逻辑也变得清晰起来。

### **本周总结与展望**

回顾本周，我完成了一次从以太坊的宏观愿景到微观实现的全景式学习。从“世界计算机”的定位，到支撑其运行的节点网络，再到构成网络交互主体的两类账户，一个立体而精密的以太坊画像在我脑中逐渐清晰。

这让我深刻地认识到，这个精密的技术网络最终服务的，是“以代码点亮人类协作未来”的宏伟愿景。我最大的收获是明白了以太坊的去中心化并非一句空洞的口号，而是由账户设计、节点协作和共识机制共同编织的一张精密网络。每一个设计选择背后，都蕴含着对安全、效率和开放性的深刻权衡。

这仅仅是基础。下周，我将深入探索Solidity！
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->










# **智能合约——以太坊的可编程核心**

智能合约，其核心是**存储在区块链上的程序**。我们可以将其生动地比作一台自动售货机：当投入硬币（支付 Gas）并选择商品（调用合约函数）后，机器会自动执行既定逻辑，交付商品（执行转账或业务逻辑），整个过程无需任何人工干预。这种自动执行、无需中介的特性，正是智能合约的魅力所在。

智能合约的出现，是以太坊发展历程中的一个决定性飞跃。它将以太坊从一个单纯用于记账的“去中心化账本”提升为了一个名副其实的“**全球可编程区块链**”。正是基于智能合约，开发者才得以构建去中心化金融（DeFi）、非同质化代币（NFT）和去中心化自治组织（DAO）等一系列颠覆性的应用。

# **智能合约的诞生**

智能合约的创建始于高级编程语言。在以太坊生态系统中，**Solidity** 无疑是开发者社区中最主流、应用最广泛的选择，其语法与 JavaScript 和 C++ 相似，为开发者提供了强大的逻辑表达能力。当开发者完成合约代码的编写后，编译器会将其转化为以太坊虚拟机（EVM）能够理解和执行的格式，主要生成两大核心产物：字节码（Bytecode）和应用二进制接口（ABI）。

| 编译产物 | 功能与重要性 |
| --- | --- |
| 字节码 (Bytecode) | 这是合约在以太坊虚拟机（EVM）中实际执行的“机器语言”。它是一串由操作码 (OpCodes) 组成的底层指令，定义了合约的所有业务逻辑。当合约被部署到区块链上时，正是这段字节码被永久地存储在链上，构成了合约的实体。 |
| 应用二进制接口 (ABI) | ABI 是一个遵循特定 JSON 格式的“功能说明书”。它详细描述了合约对外暴露的所有函数、事件及其参数类型与返回值格式。外部世界，如前端应用（dApps）、钱包或其他智能合约，正是依赖 ABI 才能够正确地编码调用数据、解码返回值，从而与该合约进行无缝交互。 |

**核心作用评估：**字节码是合约得以在链上运行的“**肉体**”，而 ABI 则是其“**灵魂**”的对外接口。二者在开发流程中缺一不可，共同构成了智能合约与以太坊生态进行交互的完整基础。

# **部署流程与成本分析**

合约的部署，本质上是将编译后的字节码发布到以太坊网络的过程。一旦部署成功，这段代码便不再是静态文件，而是一个拥有独立地址、可被全网访问的链上实体。

合约部署的核心流程可拆解为以下几个关键步骤：

1\. **发起部署交易** 部署合约是通过发送一笔特殊的以太坊交易来完成的。这笔交易与普通转账交易的关键区别在于：

    ◦ `to` 地址字段为空（`null`）。

    ◦ `data` 字段则包含了合约的完整字节码（通常是 `init code`，包含了构造逻辑）。 当以太坊节点处理到这样一笔交易时，便会将其识别为一次合约创建请求。

2\. **获得合约地址与 ABI** 当部署交易被成功打包并确认后，以太坊网络会根据部署者地址和其交易计数器（`nonce`）等因素，为新创建的合约分配一个唯一的、可预测的地址。与此同时，开发者必须妥善保存好编译时生成的 ABI 文件，因为它是后续与该合约进行任何交互的“钥匙”——**没有它，前端应用或脚本将无法知道如何正确地调用合约函数**。

3\. **成本核算 (Gas)** 部署智能合约并非免费，它会消耗以太坊网络资源，因此需要支付相应的 Gas 费用。部署成本主要取决于两个核心因素：

    ◦ **合约字节码的大小：** 字节码越大，将其永久存储在链上所需的 Gas 就越多。

    ◦ **构造函数逻辑的复杂程度：** 构造函数（Constructor）是在部署时仅执行一次的初始化函数。其内部逻辑越复杂，执行时消耗的计算资源就越多，从而增加部署的 Gas 成本。

**经济行为分析：经济行为**。开发者需要消耗真实价值的 ETH 作为 Gas 费用，来换取合约在以太坊这个全球计算平台上的永久运行权。

一旦合约成功部署，它便获得了在传统软件世界中难以企及的一系列独特属性，这些链上特性深刻地影响着去中心化应用的设计与开发范式。

# **合约部署后的核心特性**

当智能合约被成功部署到区块链上，它便超越了普通程序的范畴，获得了由区块链赋予的深刻链上属性。这些特性既是其强大功能的基石，也对其开发和维护模式提出了独特的挑战。

• **公开性与可审计性** 合约的字节码一旦上链，便对全网公开，任何人都可以通过区块浏览器等工具查看和审计其代码逻辑。这一特性为去中心化应用（dApps）带来了前所未有的“**可验证的透明性**”。用户无需盲目信任项目方的承诺，只需信任公开且经过审计的代码。这种透明性是构建去中心化信任体系的基石。

• **不可篡改性** 已部署合约的逻辑默认是**无法修改**的。这意味着一旦代码发布，其规则便被固化下来，无法被任何人（包括合约的创建者）随意更改。这一特性是区块链安全与可信的根本保障，确保了合约将永远按照既定规则执行。然而，这也给修复潜在漏洞和进行功能升级带来了巨大的挑战。

• **升级模式的必要性** 正是由于不可篡改性带来的挑战，开发者社区探索出了一系列合约升级模式。其中，**代理模式（Proxy Pattern）** 是目前最主流的解决方案。该模式通过将数据存储与业务逻辑分离，允许开发者在不改变合约地址（即用户交互入口）的前提下，将核心逻辑指向一个新的实现合约，从而实现功能升级或漏洞修复，巧妙地平衡了不可篡改性与业务迭代的需求。

# **开发工具与安全防范**

高效且安全的智能合约开发，既依赖于成熟的工具链来提升效率，也离不开对常见安全漏洞的深刻理解和有效防范。正所谓“工欲善其事，必先利其器；器利，仍需防患于未然”。

| 核心开发工具 | 关键安全防范 |
| --- | --- |
| Remix IDE 一个功能强大的浏览器内集成开发环境（IDE）。它支持合约的编写、编译、部署与调试，无需复杂的本地环境配置。Remix 非常适合快速原型验证、教学和入门学习，是新手开发者进入智能合约世界的理想起点。Hardhat 一个主流的、基于 JavaScript/TypeScript 的本地开发与测试框架。它提供了脚本化部署、自动化单元测试、Gas 报告、主网分叉（Mainnet Forking）测试以及丰富的插件生态系统，是专业团队进行复杂 dApp 开发与测试的首选工具。 | * 重入攻击 (Reentrancy)这是智能合约领域最经典、最臭名昭著的安全漏洞之一。攻击原理： 当一个合约在向外部地址转账或调用外部函数时，如果在更新自身内部状态（如用户余额）之前，外部合约被恶意设计成可以递归地回调原合约的提款函数，攻击者便能反复提取资金，直至耗尽合约余额。核心防范措施： 最佳实践是遵循“检查-生效-交互”（Checks-Effects-Interactions）模式，即先完成所有内部状态的变更（如更新余额），再进行外部调用（如转账）。更稳妥的方式是使用经过社区广泛审计的安全库，例如 OpenZeppelin 提供的 nonReentrant 修饰器，它可以有效防止一个函数在执行完成前被重复进入。 |

对于智能合约开发者而言，熟练掌握 Remix 和 Hardhat 等开发工具是提升效率的基础，而将安全意识融入到编码的每一个环节，特别是防范像重入攻击这样的经典漏洞，则是保障项目和用户资产安全的生命线。

对这一整套理论基础——从编译原理到链上现实的深刻掌握，正是区分普通编码者与真正区块链架构师的分水岭，后者方能真正驾驭以太坊这台“世界计算机”的全部潜力。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->











# 以太坊账户类型与结构

在以太坊这个庞大的去中心化生态系统中，一切交互与价值流转都围绕着一个核心概念——**账户**。深刻理解以太坊的两种账户类型，即外部拥有账户 (Externally Owned Account, EOA) 与合约账户 (Contract Account)，是掌握其底层运作方式的基石。这两种账户在控制机制、能力和生命周期上存在根本性差异，正是这些差异决定了交易如何被发起、智能合约如何自主运行，并最终共同构成了整个去中心化应用 (dApp) 生态的骨架。

## **外部拥有账户 (EOA)**

外部拥有账户 (EOA) 是普通用户与以太坊网络交互的主要接口，也是我们通常所说的“钱包账户”。其重要性在于，它是以太坊网络中所有链上行为的唯一“触发器”。无论是简单的转账，还是复杂的DeFi协议调用，其源头都必须是一笔由EOA发起并签名的交易。

基于源文本，EOA的核心特征可归纳为以下几点：

• **私钥控制 (Private Key Control):** EOA的本质是由一个密码学上的公私钥对所控制。持有与账户地址对应的私钥，即意味着拥有该账户的绝对所有权和控制权。区块链不识人，只认签名。

• **交易发起能力 (Ability to Initiate Transactions):** 在以太坊的设计中，只有EOA能够主动创建、签名并广播交易。合约账户只能在接收到一笔交易或来自其他合约的调用后被动地执行其代码。

• **无代码属性 (No Associated Code):** EOA本身不包含任何可执行的智能合约代码。它是一个纯粹的价值容器和行为发起者，其行为由用户通过私钥驱动，而非预设的程序逻辑。

### **EOA的核心构成与状态**

在以太坊的“世界状态” (World State) 中，每一个EOA都由一组特定的字段来描述其当前状态。这些组件共同定义了一个EOA在区块链上的存在。

• **地址 (Address)** 这是一个通常从公钥派生出的20字节（40位十六进制字符）标识符，通常以`0x`开头。它扮演着类似银行卡号的角色，用于接收ETH及各类代币。

• **nonce (交易计数器)** 该字段记录了此EOA已发送的交易总数。`nonce`扮演着双重关键角色：首先，它是一种**防止重放攻击**的核心机制，确保每一笔签过名的交易（即使内容完全相同）都只能被网络成功处理一次；其次，它确保了由同一EOA发起的交易**按顺序处理**，因为一笔交易的`nonce`必须严格等于账户当前的`nonce`值，交易成功后，账户的`nonce`会自动加一。

• **balance (余额)** 此字段记录了该账户所持有的以太币 (ETH) 数量。在底层协议中，该值以最小单位 `wei` (1 ETH = 10¹⁸ wei) 进行存储和计算，以避免浮点数精度问题。

• **代码与存储 (Code and Storage)** 对于EOA而言，其`code`（代码）字段和`storage`（存储）字段**均为空**。这从数据结构层面凸显了其作为非编程实体的本质，与包含可执行代码和状态存储的合约账户形成鲜明对比。

### **EOA的控制机制与安全要点**

控制一个EOA并确保其安全，依赖于一套基于密码学的严谨机制。

1\. **私钥签名 (Private Key Signature):** 私钥是权力的最终来源。当用户发起一笔交易时，钱包软件会使用私钥对交易数据进行数字签名。网络中的任何节点都可以使用该账户的公钥来验证此签名，从而以密码学方式证明交易确实由账户所有者授权发起，且内容未被篡改。

2\. **助记词与派生路径 (Mnemonic Phrases and Derivation Paths):** 在现代钱包实践中，用户很少直接操作原始私钥。取而代之的是**助记词**，即一套由12或24个英文单词组成的序列。根据BIP-39标准，这组词可以生成一个唯一的种子，再通过BIP-44等分层确定性 (HD) 钱包标准，从该种子派生出几乎无限数量的私钥和地址。因此，妥善保管助记词的极端重要性不言而喻。

3\. **Gas费用机制 (Gas Fee Mechanism):** EOA发起的任何操作，无论是转账还是调用合约，都必须以ETH支付一笔名为“Gas”的费用。这构成了抵御网络垃圾信息和恶意程序滥用计算资源的经济屏障。若账户余额不足以支付预估的Gas费用，交易将被网络拒绝。

我们可以通过一个生动的“银行账户”类比来总结EOA的核心要素：

• **EOA地址**：就像你的银行卡号，可以公开告诉别人，用于接收转账。

• **私钥**：如同银行卡、密码和U盾的结合体，谁掌握了它，谁就能动用账户里的所有资金。

• **助记词**：则是一张能复刻你所有银行卡的“主密码纸”，一旦丢失或泄露，后果不堪设想，等于把所有银行卡的控制权拱手送人。

EOA为用户提供了直接控制权和发起链上行为的能力，但其功能相对简单。为了实现更复杂的自动化逻辑，以太坊引入了另一种截然不同的实体——代码驱动的合约账户。

## **合约账户**

合约账户可以被视为存在于以太坊区块链上的、拥有自主逻辑的自动化代理。与由用户私钥驱动的EOA不同，合约账户的行为完全由其在创建时部署到其地址的、不可变的智能合约代码所规定。它们是所有去中心化应用 (dApp)、去中心化自治组织 (DAO) 和去中心化金融 (DeFi) 协议的基石，负责执行复杂的、无需信任的业务逻辑。

## **合约账户的创建流程**

创建一个新的合约账户是一个精确且标准化的过程，其生命周期从代码编写开始，到最终在链上拥有一个确定的地址和状态为止。

1\. **编写与编译 (Writing and Compiling):** 开发者首先使用Solidity或Vyper等高级语言编写智能合约代码。随后，编译器将这些人类可读的代码转换成以太坊虚拟机 (EVM) 能够理解和执行的字节码。这份字节码通常包含两部分：`init code` (初始化代码) 和 `runtime code` (运行时代码)。

2\. **发起创建交易 (Initiating the Creation Transaction):** 接着，一个EOA（或另一个已存在的合约）会发起一笔特殊的交易来创建新合约。这笔交易具有两个显著特征：

    ◦ `to` 字段为空 (技术上是零地址 `0x0`)，以此向网络表明其意图是创建合约而非转账。

    ◦ `data` 字段则包含了编译后的`init code`以及任何构造函数所需的参数（经过编码）。

3\. **EVM执行 (EVM Execution):** 当节点处理这笔创建交易时，EVM会执行以下步骤：

    ◦ 首先，EVM运行`data`字段中的`init code`。这部分代码通常负责设置合约的初始状态，例如初始化状态变量、设置所有者等。

    ◦ `init code`执行完毕后，其返回值即为合约的`runtime code`。

    ◦ 最后，EVM将这段返回的`runtime code`与新生成的合约地址永久关联，并保存初始的存储状态。至此，合约账户便成功创建并“活”在了区块链上。

## **合约地址的确定性生成**

合约地址并非随机生成，而是通过确定性算法计算得出，确保了部署过程的可预测性。以太坊提供了两种主要的操作码来创建合约，它们生成地址的方式有所不同。

| 特性 (Feature) | CREATE 操作码 (CREATE Opcode) | CREATE2 操作码 (CREATE2 Opcode) |
| --- | --- | --- |
| 地址决定因素 (Address Determinants) | 由创建者地址 (sender) 和其当时nonce (交易/合约创建计数器) 共同决定。 | 由创建者地址 (deployer)、一个自定义的salt (盐值)，以及init_code的哈希值共同决定。 |
| 核心优势 (Core Advantage) | 简单直接，是标准的合约创建方式。 | 关键优势在于地址可在部署前被精确预计算，且与nonce无关。这使得反事实交互（即与尚未部署的合约交互）和在多条EVM链上部署到相同地址成为可能。 |
| 地址计算公式 (Address Formula) | last_20_bytes(keccak256(rlp([sender, nonce]))) | last_20_bytes(keccak256(0xff ++ deployer ++ salt ++ keccak256(init_code))) |

## **能力与限制**

合约账户作为以太坊的可编程组件，既拥有强大的能力，也受到一些根本性的限制。

• **能力 (Capabilities)**

    ◦ **持有资产：** 与EOA一样，可以持有和管理ETH及各类代币 (ERC-20, ERC-721等)。

    ◦ **执行复杂逻辑：** 其核心价值在于能够存储和执行代码，从而实现从去中心化交易所 (DEX) 到链上治理等任意复杂的业务逻辑。

    ◦ **与其他账户交互：** 可以在其代码执行过程中，调用其他合约的函数或向其他账户发送ETH。

• **限制 (Limitations)**

    ◦ **无法主动发起交易：** 这是最根本的限制。合约账户的行为必须由一笔源自EOA的外部交易来触发，它不能“自发”地开始一次链上交互。

    ◦ **高昂的部署成本：** 创建合约时，需要支付较高的Gas费用，因为其代码和初始状态需要被永久地存储在区块链上，这是一项昂贵的操作。

    ◦ **代码不可篡改：** 一旦合约被部署，其 `runtime code` 便是不可更改的。虽然这保证了规则的确定性，但也意味着修复漏洞或升级逻辑需要通过代理模式 (Proxy Patterns) 等高级设计模式来实现，而不能直接修改原合约。

合约账户通过其可编程性为以太坊注入了无限可能，但它必须与能够发起行动的EOA协同工作。

# **核心对比：EOA vs. 合约账户**

虽然外部拥有账户 (EOA) 和合约账户都能持有和转移资产，并在以太坊网络中拥有地址，但它们在控制方式、核心能力和创建方法上的根本差异，决定了它们在生态系统中所扮演的截然不同的角色。EOA是用户代理，而合约账户是自动化程序。

下表根据关键属性对两者进行了直接对比：

| 属性 (Attribute) | 外部拥有账户 (EOA) | 合约账户 (Contract Account) |
| --- | --- | --- |
| 控制方式 (Control Mechanism) | 由用户持有的私钥直接控制。 | 完全由其部署在链上的内部代码控制。 |
| 发起交易 (Initiating Transactions) | 能够主动创建、签名并发起交易，是所有链上活动的起点。 | 不能主动发起交易，只能在被调用后被动地执行代码。 |
| 关联代码 (Associated Code) | 没有关联的可执行代码。 | 拥有关联的EVM字节码，定义了其所有行为逻辑。 |
| 创建方式 (Creation Method) | 通过生成一个公私钥对来创建。 | 通过一笔特殊的合约创建交易（由EOA或其他合约发起）来部署。 |
| nonce的含义 (Meaning of nonce) | 该账户已发送的交易数量。 | 该账户已通过 CREATE/CREATE2 操作码创建的合约数量，而非其内部调用或消息发送次数。 |

这两种账户类型并非相互竞争，而是相互依存，共同构成了以太坊强大功能的基础。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->












# **1\. 节点**

自“合并”（The Merge）重大升级后，以太坊节点被重塑为一种模块化的“双核”架构，由执行层（Execution Layer, EL）和共识层（Consensus Layer, CL）两个独立的客户端协同工作。这种职责分离的设计，不仅提升了系统的灵活性与可维护性，也成为了理解现代以太坊运作模式的关键。

## 1.1 执行客户端（EL）

执行客户端与共识客户端各司其职，共同构成了完整的以太坊节点。它们的职责与典型软件实例如下表所示：

| 组件 | 核心职责 | 典型软件实例 |
| --- | --- | --- |
| 执行客户端 (EL) | 处理交易、执行EVM操作、维护世界状态、提供JSON-RPC接口 | Geth, Nethermind, Besu, Erigon, Reth |
| 共识客户端 (CL) | 运行PoS共识协议、管理验证者、选择链头并实现最终性 | Lighthouse, Prysm, Teku, Nimbus, Lodestar |

执行客户端（EL）可以被类比为“世界计算机”的“CPU + 内存 + 数据库”，它承担了所有与业务逻辑和状态管理相关的核心任务：

1\. **交易处理与EVM执行**：作为执行引擎，EL负责接收网络中广播的新交易，并在以太坊虚拟机（EVM）中逐条执行智能合约的字节码，计算状态变更。

2\. **世界状态维护**：EL是链上状态的守护者，它管理着一个庞大的数据库，记录了所有账户的余额、合约代码、存储变量等关键状态数据。

3\. **RPC接口服务**：EL通过标准的JSON-RPC接口对外提供服务，是dApp、钱包、脚本等应用与以太坊区块链交互的主要网关，允许它们查询链上数据或提交新交易。

## 1.2 共识客户端（CL）

共识客户端（CL）则像是网络的“裁判与选举委员会”，它不处理具体的交易执行，而是专注于保障网络的安全与一致性，其核心功能包括：

1\. **权益证明（PoS）共识**：CL是PoS协议的运行实体。它负责在每个时间槽（slot）中随机选择区块提议者，并组织其他验证者对提议的区块进行投票（attestation），从而形成链的共识。

2\. **链选择与最终性**：通过 LMD-GHOST 和 Casper FFG 等复杂的共识算法，CL负责确定哪条分叉链是“正统”链头，并在获得足够多的验证者投票后，为区块提供“最终性”（Finality）保证，使其不可逆转。

3\. **验证者管理**：CL追踪着整个网络的验证者集合，管理着他们的质押余额，并执行经济激励机制，包括发放诚实参与的奖励，以及对作恶或严重失职的验证者进行惩罚（Slashing）。

## 1.3 Engine API

Engine API 并非面向外部用户的通用接口，而是EL与CL之间协同工作的“专线电话”或“内部神经中枢”。这个标准化的内部通信协议，确保了两个独立运行的客户端能够无缝配合，共同完成区块的构建与验证。

在两个核心场景中，Engine API的双向协同作用尤为关键：

• **区块提议 (Proposer Scenario)**：CL作为“指挥者”发起流程。它首先调用 `engine_forkchoiceUpdated` 向EL表明其意图，即准备在某个特定的链头上构建新区块。随后，它调用 `engine_getPayload` _请求_ EL（作为“构建者”）从交易池中打包交易并生成一个完整的执行负载（Execution Payload）。

• **区块验证 (Validator Scenario)**：CL从网络接收到一个新区块后，扮演“验证者”的角色。它调用 `engine_newPayload` 将区块中的执行负载_推送_给EL进行验证。EL会重新执行其中的交易并返回一个状态（如 `VALID` 或 `INVALID`），这相当于为CL提供了一个“同意/拒绝”的信号，以决定是否对该区块进行投票（attest）。

# **2\. 节点间的发现、连接与通信**

以太坊的P2P网络就如一个动态的、自我组织的社交网络。节点间高效、可靠的发现、连接与通信机制，是保障全网同步、安全和去中心化的生命线。

## 2.1 节点发现与连接

一个新节点加入以太坊网络，需要经历一个从“陌生人”到拥有稳定“邻居”的完整流程：

1\. **发现阶段 (Discovery)**：新节点启动时，会首先联系几个内置的“引导节点”（Boot Nodes）。随后，它利用基于UDP的Kademlia分布式哈希表协议（discv4/discv5），通过不断发送 `Ping/Pong` 消息确认节点活性，并利用 `FindNode` 请求向已知节点索要更多“邻居”的联系方式，逐步建立起一个足够丰富的“邻居列表”。

2\. **连接阶段 (Connection)**：在发现足够多的潜在邻居后，节点会通过TCP协议与它们建立起稳定、可靠的双向连接。在TCP连接之上，以太坊使用RLPx协议来建立加密通信通道，并支持多路复用，允许在同一条连接上传输不同类型的子协议消息（如交易、区块等），确保通信的安全性与效率。

## 2.2 Gossip协议

一旦连接建立，新产生的交易和区块就需要一种机制在全网快速传播。以太坊采用的Gossip协议，其核心机制就像“办公室八卦”一样高效：当一个节点收到一条新信息（如一笔新交易），它不会向所有邻居广播，而是随机选择少数几个尚未收到该信息的邻居进行转发。这些邻居再以同样的方式继续扩散，最终使信息以近似指数级的速度传遍整个网络。

Gossip协议为以太坊网络带来了三大战略优势：

• **高可用与容错性**：信息通过多条随机路径传播，不依赖任何中心化服务器。即使部分节点离线或出现故障，信息依然可以通过其他路径抵达全网，表现出极强的鲁棒性。

• **可扩展性**：由于每个节点只需与有限的邻居通信，该协议能够有效支持上万个节点规模的网络而不会导致单个节点过载，为网络的去中心化提供了基础。

• **信息同步效率**：Gossip协议不仅用于广播交易，在PoS时代，它同样是传播共识消息（如attestations）的主力。这保证了全网验证者能够快速对链头状态达成共识，是实现快速最终性的关键。

# **3\. 全节点、归档节点与轻节点的权衡**

以太坊网络允许不同程度的参与，参与者可以根据自身的应用需求、硬件资源和安全考量，在“完全信任自我”和“依赖他人”的光谱之间，选择运行最适合自己的节点类型。

| 节点类型 | 核心特征与数据存储 | 典型应用场景与优缺点 |
| --- | --- | --- |
| 全节点 (Full Node) | 存储所有区块头和区块体，但会定期“裁剪”（prune）掉旧的历史状态（如典型的128个区块之前的状态），只保留最新的状态数据。 | 场景: 开发者、验证者、dApp后端、自托管钱包。优点: 能够独立验证所有交易和区块，实现最高级别的安全和抗审查性。缺点: 需要数百GB到数TB的快速SSD存储和稳定的带宽。 |
| 归档节点 (Archive Node) | 本质上是禁用了状态裁剪的全节点。它存储所有区块数据，并保留了从创世区块至今每一个区块高度下的完整历史状态快照。 | 场景: 区块浏览器（如Etherscan）、链上数据分析平台、需要进行历史回测的量化团队。优点: 能够即时查询任意历史时刻的任何账户状态。缺点: 资源消耗巨大（通常需要10TB以上的存储），维护成本极高。 |
| 轻节点 (Light Node) | 只存储区块头，不下载完整的区块体和状态数据。当需要特定数据时，它会向全节点请求，并利用区块头中的哈希根进行密码学验证。 | 场景: 手机钱包、浏览器插件等资源受限的设备。优点: 资源占用极低，启动快速。缺点: 功能受限，数据获取依赖于全节点，但仍能通过同步委员会机制实现安全验证。 |

可以用一个“图书馆”的类比来更生动地理解它们的区别：

• **全节点**就像一个**大型公共图书馆**。它拥有馆藏的所有书籍（所有区块），并且书架上摆放的是最新版本的图书（当前状态）。虽然旧版书不在架上，但可以通过查阅历史记录重新“复原”。

• **归档节点**则是一个**国家档案馆**。它不仅保存了所有书籍，还保存了每一本书的每一个历史版本。它是一台“时间机器”，可以即时回答“某本书在几十年前的某一页写了什么”，代价是占地面积和维护成本极其高昂。

• **轻节点**好比一个**移动书柜或电子目录机**。它只存放所有书籍的目录和索引（区块头）。当你想看某本书的具体内容时，它会向图书馆（全节点）请求，并对照目录核实拿到的书是否正确，实现了低资源下的安全查阅。

# **4\. 运行自有节点的战略价值**

尽管使用Infura、Alchemy等第三方RPC服务极为便捷，但这背后也隐藏着对隐私、安全和抗审查性的潜在妥协。对于追求最高安全标准和自主权的开发者与机构而言，运行自有全节点是实现真正“区块链主权”的关键一步。

1\. **隐私保护** 运行自有节点意味着所有与区块链的交互都发生在自己的服务器上。这可以有效避免将用户的IP地址、钱包地址以及交易行为等敏感元数据暴露给第三方服务商，从源头上保护了用户和应用的隐私。

2\. **抗审查与可用性** 完全依赖第三方RPC服务，意味着将应用的可用性与抗审查性交给了外部实体。服务商可能因政策、法规或自身故障而限制或中断对特定地区、特定合约的服务。自有节点则能完全规避这种“软审查”或单点故障风险，确保应用始终可以自由地广播交易。

3\. **实现真正的去信任化 (“Don’t trust, verify.”)** 这是以太坊安全哲学的核心。通过运行自己的全节点，应用可以独立地验证每一个区块和每一笔交易的合法性，而不必信任任何外部数据源。对于金融机构、交易所等需要高确定性的场景，这是保障数据完整性和安全性的基石。

4\. **增强网络健康度** 每一个运行的全节点都是对以太坊去中心化程度的直接贡献。特别地，有意识地选择运行少数派客户端（如Besu, Nethermind, Reth等），能够直接提升客户端多样性，降低因某个主流客户端出现严重bug而导致全网不稳定的风险。

5\. **性能与控制自由** 自有节点通常部署在本地或内网环境，能提供比公共服务更低的延迟和更高的稳定性。同时，它给予了运营者完全的控制权，可以根据业务需求自定义配置、优化性能、接入特定的监控或合规系统，满足专业化场景的特殊要求。

本质上，运行节点是一项战略决策，它用第三方服务的便利性来交换去中心化架构中不可妥协的原则：数据主权、抗审查性与可验证的信任。对于任何严肃的链上应用而言，这并非一个技术选项，而是一个 foundational one。

# **5\. 无需节点的替代数据分析路径**

对于许多数据分析师、研究人员和初创团队而言，从零开始搭建和维护一个归档节点成本过高。此时，直接利用成熟的公共数据平台，如同“站在巨人的肩膀上”，是更高效、更经济的链上分析选择。

• **SQL分析平台 (如 Dune, Flipside)**

    ◦ **核心特点:** 这些平台将复杂的链上原始数据预处理成结构化的关系型数据库表，提供“SQL即服务”的模式。

    ◦ **适用人群:** 数据分析师、研究人员、协议运营团队。

    ◦ **优势与局限:** 优势在于用户只需编写SQL查询即可快速分析并创建可视化的数据仪表盘。局限性在于数据模型由平台定义，且免费版有资源限制。

• **公共数据仓库 (如 Google BigQuery)**

    ◦ **核心特点:** Google等云服务商将以太坊等公链的完整历史数据同步到其数据仓库中，作为公共数据集开放，相当于一个“企业级的链上数据仓库”。

    ◦ **适用人群:** 拥有数据工程能力、需要将链上数据与自有业务数据（如用户数据、订单数据）进行深度整合的团队。

    ◦ **优势与局限:** 优势在于强大的查询能力和与企业自有数据的整合潜力。局限性在于需要一定的SQL和数据工程知识。

• **区块浏览器API (如 Etherscan API)**

    ◦ **核心特点:** 提供了一套标准化的API接口，用于查询特定地址的交易历史、代币余额、合约事件等基础信息。

    ◦ **适用人群:** 开发者进行小规模数据拉取、编写监控脚本或轻量级数据分析的场景。

    ◦ **优势与局限:** 优势是便捷易用，适合轻量级查询。局限性在于有调用频率限制，不适合大规模数据分析。

• **数据提供商API (如 Covalent, Bitquery)**

    ◦ **核心特点:** 这类服务在原始数据之上提供了更高阶、更结构化的数据视图，例如直接返回某个地址的投资组合、NFT持有列表或DEX交易历史，封装了复杂的解析逻辑。

    ◦ **适用人群:** 需要快速开发产品、对数据实时性和业务维度有较高要求的应用开发团队。

    ◦ **优势与局限:** 优势在于节省了数据解析的开发时间。局限性在于通常是付费服务，且依赖第三方的数据准确性。

在实践中，一种高效的**混合策略**是：利用**公共数据集（如BigQuery）托管RPC服务**来监听和处理最新的实时数据。这种策略能够在成本、开发速度和数据全面性之间取得极佳的平衡。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->













# Web3安全防护

作为一名Web3新手，在实习和日常操作中面临的风险主要可归为以下三类：

-   **心理操纵与信任滥用**：攻击者冒充HR、学长或伪造官方通知，滥用你的信任，诱导你做出危险行为。
    
-   **技术陷阱与恶意软件**：攻击者将恶意代码伪装成实用工具，在你毫无察觉的情况下窃取信息。
    
-   **个人信息与资产泄露**：一旦你的账号、密码或私钥泄露，将直接导致数字资产的永久性损失。
    

# **1\. 识别常见骗局：攻击者如何设下陷阱？**

## 1.1. 钓鱼攻击与社交工程

攻击者最擅长利用人性的弱点，通过伪造身份和场景来骗取你的信任。以下是几个针对学生的典型案例。

| 案例场景 | 攻击者的诱饵 | 新手的关键教训 |
| --- | --- | --- |
| 面试钓鱼 | HR要求安装名为技术面试助手.zip的“公司内部专用软件”，否则无法进行面试。 | 正规面试通常使用公开的会议软件（Zoom, 腾讯会议）。拒绝安装任何来路不明的“专用软件”，这是保护电脑的第一道关卡。 |
| 奖学金钓鱼 | 在学习交流群中，冒充学校合作方发布“奖学金空投”，要求连接钱包并签名以“验证学生身份”。 | 任何要求连接钱包并签名的“福利”活动都极度可疑。主钱包永远不要用于参与不确定的空投或活动。 |
| 社交平台假冒好友 | 在Telegram上，“学长”发来“内部推荐”机会，要求填写一个需要连接钱包的表单。 | 面对熟人的请求，尤其是涉及转账或钱包操作时，务必通过电话或其他渠道再次确认对方身份。 |

这类攻击的核心手法是：**利用权威、利益或信任，诱导你执行危险操作**。

## 1.2. 恶意软件与木马程序

恶意软件是潜伏在设备中的“间谍”，它们渗透的方式多种多样，且危害巨大。

-   **伪装成实用工具**：将木马包装成“专用会议软件”、“免费论文查重工具”或“破解软件”，诱导用户主动安装，从而窃取电脑中的钱包文件、密码和隐私数据。
    
-   **劫持剪贴板内容**：木马在后台静默运行，一旦检测到你复制了钱包地址，就会瞬间将其替换为攻击者的地址。这会导致你在转账时，资产被直接发送给黑客。
    
-   **植入浏览器插件后门**：攻击者开发看似实用的浏览器插件（如交易助手），并在其中植入恶意代码。一旦安装，插件便可窃取你在浏览器中输入的所有敏感信息，甚至篡改交易数据。
    

## 1.3. 高级钓鱼技巧

当钓鱼攻击变得越来越“高级”，我们需要更加锐利的双眼来识别它们。

| 技巧名称 | 识别要点 |
| --- | --- |
| 来自“官方”的钓鱼 | 攻击者使用与官方域名极其相似的域名（如trezor.us vs 官方trezor.io）发送钓鱼邮件，诱导用户访问假冒网站。 |
| Punycode钓鱼 | 攻击者在域名中使用特殊Unicode字符来伪造知名品牌域名，例如 trẹzor.com 中的 ẹ 并非英文字母 e。在浏览器地址栏中，它看起来与官方域名几乎一模一样。 |

**眼见不一定为实，务必仔细检查每一个字符**。

# **2\. 如何保护自己**

## 2.1. 面试与实习场景

-   **拒绝**安装任何来路不明的“专用面试软件”，坚持使用官方的Zoom、腾讯会议等公开工具。
    
-   **多方核实**面试邀请的邮件地址、域名和联系人信息。可以去官网或LinkedIn等平台查询确认。
    
-   遇到“提前下载资料包”等要求，**保持警惕**，先通过搜索引擎查询该文件或公司是否存在安全警告。
    

## 2.2. 软件与插件安装

-   **只从官网**或官方应用商店（如Chrome Web Store）下载软件和浏览器插件。
    
-   安装前，**检查**软件的口碑、用户数量和开发者信息，避免下载山寨或恶意应用。
    
-   **严格控制**浏览器插件数量，仅保留官方钱包、密码管理器等绝对必要的插件。
    
-   开启系统防火墙，并**审慎管理**各应用对摄像头、麦克风等敏感权限的请求。
    

## 2.3. 账号与密码安全

-   为所有重要账户**启用双因素认证（2FA）**，优先选择谷歌验证器（Google Authenticator）或硬件密钥，**因为短信验证码可能通过SIM卡劫持等手段被拦截**，而谷歌验证器等工具更为安全。
    
-   **使用密码管理器**（如1Password, Bitwarden）为每个平台设置独立且唯一的强密码，彻底告别“一个密码走天下”。
    
-   将邮箱和手机号视为最高安全级别的资产，**定期更换密码**，防止被劫持。
    

## 2.4. 钱包与转账操作

-   **离线保存**助记词和私钥，例如抄写在纸上并存放在安全的地方。绝不截图、上传云盘或通过任何网络工具发送给任何人。
    
-   转账前，**务必仔细核对**收款地址的前6位和后4位，以防范剪贴板劫持木马。
    
-   对于空投、福利等活动，**使用专门的测试钱包**参与，主钱包应保持“冷藏”状态，不与任何不信任的DApp交互。
    
-   **定期检查并取消**不必要的钱包授权。可使用 `Revoke.cash` 等工具，移除对旧的或可疑DApp的授权，防止潜在的资产盗窃。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->














# **Web3需要什么样的人才？**

## **人才需求的结构性变迁**

Web3的用人标准已经发生了根本性的转变。行业创始团队的画像也日趋精英化，大都是**传统互联网圈的前辈，或是95后海外名校毕业的年轻人**。这一变化直接导致了用人标准的全面升级。

-   **过去：** 在行业早期，一些角色，如活跃的社群“群主”，凭借热情和“圈内人”身份就能获得不错的机会。
    
-   **现在：** 随着机构入场和合规化成为主流，项目方极度青睐**复合型人才**——即那些能够同时理解合规要求、掌握核心技术、并具备传统商业逻辑的精英。
    
-   **结构性缺口：** 当前市场呈现出“冰火两重天”的极端两极分化：一个初级的智能合约开发岗位可能会被超过450份简历淹没，而项目方却愿意为顶尖的智能合约工程师和资深合规专家开出50%以上的溢价来激烈争夺。这背后的一个重要原因是，AI的崛起正在替代部分初级技术工作。AI几秒钟就能写出一个标准的小合约，若你只停留在初级开发水平，你的价值正面临被部分取代的风险。
    

## **全球热点区域与前沿赛道**

| 职业方向 | 重点区域 | 特点与机遇 |
| --- | --- | --- |
| 硬核技术开发 | 北美 (硅谷、纽约) | 全球开发者密度最高，依然是底层技术创新的绝对中心。 |
| 交易所、资管、市场运营 | 亚洲 (香港、新加坡) & 中东 (迪拜) | 香港政策利好，是连接东方资本的桥头堡；新加坡是成熟的华人Web3中心；迪拜凭借免税政策和地理优势，成为全球资本的过境地和商务拓展（BD）的热土。 |
| 行业投资重心 | 全球 | RWA、DePIN、AI融合等赛道，因其与现实世界紧密结合的特性，正受到传统金融和老牌投资机构的重点关注。 |

## **薪酬体系与职业发展路径**

### **薪酬金字塔：**

◦ **第一梯队 (技术与合规):** 智能合约开发、安全审计等岗位是项目的基石。即便是初级岗位，起薪也相对较高，高级职位月薪突破10万人民币并非难事。

◦ **第二梯队 (研究与产品):** 核心研究员是团队的“大脑”，负责洞察赛道、设计经济模型。他们的价值极高，未来有很大机会转型为投资人。

◦ **第三梯队 (运营与增长):** 这是一个“高方差”的领域。普通的社群运营可能拿着客服水平的薪水，但顶级的增长黑客能够为项目带来真实的用户和TVL，其奖金和代币分成可能远超开发人员。

### **长期职业规划：**

◦ **技术岗：** 可向项目CTO发展，或成为服务于多个DAO和协议的独立审计师。

◦ **运营岗：** 最终进化为拥有自有社区和流量资源的KOL，或成为专业的增长顾问。

◦ **研究岗：** 深入研究代币经济学，成为项目的核心策略师，是团队中不可或缺的“大脑”。

清晰了解岗位画像是求职成功的第一步。接下来，我们将对几个核心岗位进行更详细的拆解。

### **核心岗位解析**

**技术开发岗**

技术是Web3的骨架，也是薪酬金字塔的顶端。成功的技术转型需要清晰的战略规划。

-   **编程语言能力栈（两步走战略）：**
    

1. **第一步 - 掌握通用基础 (Solidity):** 它是目前应用最广泛的智能合约语言，是理解合约思维的逻辑起点，也是进入Web3开发领域的“通用语”。这是必须掌握的基础。

2. **第二步 - 构筑专业壁垒 (Rust, Move, Cairo等):** 在掌握Solidity之后，明智的选择是**挑选一个你看好的新兴生态，并深入钻研其核心语言**（如Layer2和Solana生态的Rust）。这种专业化能让你形成差异化竞争力，建立起他人难以逾越的专业护城河。

-   **超越编码的核心素养：** 现代Web3项目方极度看重开发人员的综合能力。除了编码，以下几点至关重要：**合约安全意识**、**系统设计能力**、**对DeFi和Layer2等复杂系统的深刻理解**。您不能只是一个代码执行者，而应成为一个能够预见风险、设计稳健架构的工程师。
    

**2\. 市场与运营岗**

市场与运营是连接项目与用户的桥梁，也是决定项目生死存亡的关键环节。

-   **必备经验与技能：**
    

◦ **经验偏好：** 有海外社区（如Discord, Telegram）和海外媒体（如Twitter/X）运营经验的候选人会得到优先考虑。

◦ **语言能力：** **英语口语能力**几乎是硬性要求。Web3团队通常是全球化、分布式协作，流利的英语是高效沟通的基础。

-   **从“发推”到“增长”：** 初级运营与高级运营的根本区别在于是否能带来有效增长。一个优秀的运营专家，不仅仅是写宣传推文，更需要具备以下能力：
    

◦ 深刻理解项目自身的**代币经济学** ，并能围绕其设计增长活动。

◦ 保持**链上活跃度**，自己就是产品的深度用户。

◦ 拥有**闭环转化**的实战经验，能通过具体策略为项目带来真实的用户增长和TVL提升。

**3\. 行业研究与产品岗：思想的灯塔**

这类岗位对候选人的综合素质要求极高，是团队的“大脑”和“舵手”。

-   **产品经理**
    

◦ **核心要求：** 必须具备“Web3 Sense”，深刻理解去中心化、代币激励和社区治理的逻辑，不能简单套用Web2的产品方法论。

◦ **加分项：** 拥有**计算机和金融领域的复合知识背景**几乎可以在面试中“横着走”。此外，有积分系统或游戏化系统设计经验的候选人会非常受欢迎。

-   **行业研究员:**
    

◦ **核心能力：** 具备强大的**信息搜集能力、逻辑分析能力**和**深度行业研究能力**。

◦ **新人敲门砖：** 必须能够产出高质量的**研究报告**作为你的作品集，并**熟练使用链上数据分析工具（如Dune Analytics, Nansen）**，用数据支撑观点。

◦ **进阶技能：** 具备基础的**代码阅读能力**会是一个巨大的竞争优势，它能让你从源头理解协议的运作机制，而非停留在表面。

了解了这些具体岗位的能力需求后，下一步就是掌握如何将自身能力有效地展示给项目方，成功开启你的Web3职业生涯。

## 新人如何求职？

Web3的求职规则与传统行业截然不同。在这里，“海投简历”的效率极低，而“精准建设”个人品牌和链上声誉则事半功倍。

### **求职渠道**

Web3的招聘渠道呈现出明显的“去中心化”特性，信息散布在社区和社交网络中。

-   **Web3垂直招聘平台：** 这是最直接的渠道，例如 `SmartD`、`Web3.career`、`CryptoJobs List` 等平台，汇集了大量行业内的招聘信息。
    
-   **社交网络与社区：** **Twitter(X)、Discord、Farcaster** 是获取一手招聘信息的核心阵地。许多项目创始人和核心成员会直接在个人社交媒体上发布招聘需求，关注他们是获得“内幕消息”的最佳方式。
    
-   **隐形渠道 - “链上简历”：** 这是Web3求职中最具特色的部分。资深的HR或项目方在评估候选人时，往往不只看重PDF简历。他们会通过你的**GitHub代码提交记录、Snapshot上的治理投票、Mirror上发表的文章**等链上足迹来评估你的能力和行业参与度。这些公开、透明、不可篡改的记录，比任何简历都更有说服力。
    

### **新手入场的三大路径**

1. **路径一：Web2能力迁移** 适合已有一定工作经验的转型者。在互联网大厂积累的技术架构、产品方法论、用户增长策略，尤其是有海外工作经验，在Web3行业非常受欢迎。关键在于将这些成熟的经验与Web3的特性相结合。

2. **路径二：从“无需许可的工作”切入** 适合从零开始、缺乏直接相关经验的新人。核心逻辑是“先贡献，再求职”。具体方式包括：

◦ 在DAO（去中心化自治组织）中领取并完成悬赏任务（Bounty）。

◦ 为感兴趣的开源社区贡献代码、修复Bug、撰写技术文档。

◦ 撰写并公开发布对某个赛道或项目的深度研究报告。

3. **路径三：建立个人链上声誉** 这是路径二的进阶版”。通过在Twitter、Farcaster等平台持续输出有深度、有价值的内容，积极参与线上活动（如AMA、Space），将自己打造成一个行业内的信息节点（KOL）。当你的声誉建立起来后，机会往往会主动找上门。

### **求职重要工具和风险意识**

在求职过程中，掌握以下技巧至关重要。

-   **熟练使用AI工具：** AI在Web3工作中是一个强大的效率放大器，而非思想的替代品。据统计，约70%的面试会考察候选人使用AI工具的能力。你需要展示如何利用AI进行辅助编码、内容创作、市场分析和方案构思，证明你具备驾驭先进工具的能力。
    
-   **学会“避坑”：** Web3行业机会与陷阱并存。在选择项目时，务必进行尽职调查，识别不靠谱的项目。一个简单的检查清单包括：
    

◦ 警惕**匿名、无风投、无代码更新**的“三无团队”。

◦ 检查项目的**GitHub代码提交频率**，长期不更新的项目风险极高。

◦ 调查项目的**投资机构背景**，有信誉良好的VC背书通常更可靠。

◦ 研究**创始人团队的过往履历**，警惕那些有不良项目历史的创始人。

### **常见问题与转型路径规划 (FAQ)**

**1\. 应届毕业生，应该先去互联网大厂“镀金”，还是直接进入Web3？**

这是一个需要权衡时间成本的问题。互联网大厂的背景之所以有价值，更多是针对那些**已经在大厂工作了3-5年、完整地落地过项目、并积累了丰富经验和行业资源**的资深人士。

-   **对于应届生：** 如果在大学期间已经对某个Web3赛道有了深入的研究和实践（例如，为开源项目做过贡献），那么直接进入Web3是一个非常好的选择，可以抢占先机。
    
-   **如果选择先去大厂：** 这意味着需要付出更多的时间成本。可能需要花2-3年的时间在大厂积累通用技能，同时利用业余时间持续关注和学习Web3，才能在未来转型时具备竞争力。
    

**2\. 问：完全没有相关背景，想转行做开发/研究，该如何起步？**

对于零基础转行者，行动胜于一切空谈。核心是**用作品集说话**。

-   **转技术开发：** 核心是**先搭建自己的作品集**。不要只是说你想学，而是要实际去做：
    

1. 自己组队或者独立完成一些小项目（DApp）。

2. 积极参与知名的开源社区，贡献代码、提交PR、寻找并修复Bug。

-   **转行业研究：** 核心是**用高质量的报告证明你的分析能力**。
    

1. 选择一个你真正感兴趣的赛道（如Layer2, DePIN, RWA）。

2. 组织一个线上学习小组，共同完成一份深度的赛道研究报告，从历史、现状、核心项目、数据对比、未来趋势等角度进行全面分析。

3. 必须学习并熟练使用链上数据分析工具，如 **Dune Analytics**、**Nansen** 等，用扎实的数据支撑你的观点。

# **以太坊的去中心化基石**

以太坊的去中心化并非单一技术的结果，而是一个由技术、经济、市场和社会层面共同构建的复杂保障体系。

## **1\. 网络与实现**

以太坊的网络层基于点对点（P2P）架构，无需中心化服务器即可运行。节点通过发现层（基于UDP）发现彼此，并通过通信层（基于TCP）交换区块与交易等数据。这种设计从根本上保证了网络的连接韧性。

更具战略意义的是以太坊社区长期坚持的 **“多客户端”文化**。协议规范与客户端实现是分离的，不同团队使用不同编程语言开发了多种客户端软件。

-   **执行层客户端 (EL)**：Geth, Nethermind, Besu, Erigon, Reth 等。
    
-   **共识层客户端 (CL)**：Lighthouse, Prysm, Teku, Nimbus, Lodestar 等。
    

这种多样性极大地降低了单点风险。即便某个市场份额较高的客户端出现严重漏洞，网络仍可由其他客户端维持运行，有效避免了“一个客户端出bug，全网一起躺平”的灾难性场景。

## **2\. 市场与扩容**

MEV的存在，天然地驱使区块生产者走向专业化和集中化，对网络的去中心化构成潜在威胁。为此，以太坊社区提出了 **“提议者-构建者分离（Proposer-Builder Separation, PBS）”** 的架构思路，并通过 MEV-Boost 等协议外（out-of-protocol）实现进行缓解。验证者将区块构建工作外包给一个竞争性的构建者市场，自己仅负责选择收益最高的有效区块进行提议，从而在一定程度上将 MEV 带来的中心化压力市场化和分散化。然而，当前MEV-Boost依赖于可信的中继（Relay），这引入了新的中心化风险点，因此社区正在积极研究 **内生PBS（enshrined PBS, ePBS）**，旨在未来将该机制直接写入核心协议，以进一步增强网络的去中心化。

此外，**“以太坊为中心的 Rollup 路线图”** 本身也是一种基于职责分离的去中心化策略。

-   **Layer 1 (L1) 主网** 聚焦于成为高度去中心化的结算层与数据可用性层。
    
-   **Layer 2 (L2) Rollups** 负责处理大规模的交易执行和应用创新。
    

这种分层架构将执行负载和创新压力分散到众多 L2 生态中，使得 L1 可以在支持扩容的同时，维持自身协议的简洁与高度去中心化。这一架构决策并非单纯的技术修复，而是以太坊的一项战略承诺：通过补贴一个蓬勃发展的L2生态系统的安全性，来巩固L1作为可信中立的结算层地位，从而将自身定位为多链世界的根本信任锚。

## **3.治理与社区**

以太坊的核心协议演进并非通过“1票1 COIN”的链上投票进行，而是依赖一套社会性的“粗共识”流程。

-   **开放讨论渠道**：以太坊改进提案（EIP）流程、定期的核心开发者会议（AllCoreDevs）以及以太坊魔术师论坛（Ethereum Magicians）等，为开发者、研究人员和社区用户提供了公开透明的讨论平台。
    
-   **粗共识与退出权**：重大协议升级的决策是在这些平台经过长期、充分的讨论后，由各方逐渐达成“粗共识”。最终，节点运营者通过选择是否升级其客户端软件来行使最终的制衡力量——即“退出权”。任何存在巨大争议的提案都难以被纳入主网。这种治理模式构成了最终的社会契约：协议的变更并非由代币加权投票强加，而是通过网络运营商的自愿同意来采纳，使其成为一个由说服而非强制力治理的系统。
    

这种深植于协议各层面的去中心化设计，为网络的开放参与奠定了坚实的基础。

# 无限制接入

以太坊的设计理念是“无需许可（permissionless）”，但这一理想在现实中必然面临物理约束。它正在积极地驾驭着无限制访问与物理限制之间的根本性权衡——这一核心挑战决定了其向模块化、多层次未来的架构演进。

## **1\. “无限制参与”的理想与现实挑战**

“任何人都可以运行节点”是以太坊开放性的核心原则。一个全节点独立验证所有交易和区块，是网络安全的基石。然而，运行一个功能完备的全节点面临着实实在在的挑战：

-   **存储空间**：需要存储完整的链上状态，空间需求从数百GB到数TB不等，且持续增长。归档节点的需求更是高达10TB以上。
    
-   **网络带宽**：为保持与网络的实时同步，推荐至少拥有 20–25 Mbps 的稳定带宽，且无流量上限。
    
-   **计算资源**：需要足够性能的CPU和内存（如4核CPU，16GB内存）来处理交易和验证区块。
    

这些要求构成了参与网络的物理门槛，虽然对技术爱好者而言可以实现，但对普通用户则是一大挑战。

## **2\. 分层扩容方案**

如果节点数量无限增多，节点间的通信和达成共识的效率将不可避免地下降。为了在不牺牲主链去中心化的前提下提升整个生态的性能，以太坊采用了分层扩容的思路。

-   **Layer 1 (L1) - 主链/基础层**：
    

◦ **定义**：指以太坊主网本身，是整个生态系统的安全和结算基础。

◦ **核心职责**：L1 专注于共识安全、最终结算和数据可用性。正如一个比喻所言，L1 扮演着 **“结算所+大法官”** 的角色，确保所有交易的最终性和不可篡改性。

-   **Layer 2 (L2) - 加速层**：
    

◦ **定义**：构建在 L1 之上的扩展协议，旨在提供更快、更便宜的交易体验。

◦ **核心职责**：L2 如同 **“高铁/支线”**，将大量的计算和交易处理任务从主链上剥离，仅将最终结果批量提交回 L1。

至关重要的是，“高铁”（L2）的安全性继承自“最高法院”（L1）；其交易最终由发布回以太坊主网的数据和证明来保障。

目前，**Rollups** 是主流的 L2 解决方案，其核心工作原理是将成百上千笔交易在链下（off-chain）执行，然后将压缩后的交易数据和一份有效性证明提交回 L1。根据证明方式的不同，主要分为 **Optimistic Rollups**（采用欺诈证明）和 **ZK Rollups**（采用零知识证明）两种类型。

正是这种分层、开放的网络架构，为DeFi、NFT和DAO等大规模链上应用的爆发创造了可能。

### **DeFi、NFT与DAO的生态爆发**

以太坊生态的繁荣，源于其作为可编程平台的无限可能性。

## **1\. 去中心化金融（DeFi）**

DeFi 利用智能合约构建了一套开放、透明且可组合的金融体系，其核心创新在于机制而非简单的数字化。

-   **自动做市商 (AMM)**：以 Uniswap 为代表的去中心化交易所（DEX）用 AMM 取代了传统的订单簿。任何人都可以向资金池提供流动性，交易价格由数学公式自动确定，实现了无需许可的、24/7 全天候的资产兑换。
    
-   **去中心化借贷**：Aave 等协议构建了非托管的借贷市场。用户存入资产赚取利息，或通过超额抵押借出其他资产。利率由算法根据市场供需自动调节，清算过程也由代码强制执行，消除了传统金融中的对手方风险。
    
-   **去中心化稳定币**：以 MakerDAO 发行的 DAI 为例，通过超额抵押链上资产，创造出与美元挂钩的稳定币。DAI 为整个 DeFi 生态提供了可靠的计价单位和价值储存工具，是金融“乐高”中不可或缺的一块积木。
    

## **2\. 非同质化代币（NFT）**

NFT的创新远不止于“链上JPG”，它正在从简单的数字所有权凭证，演变为构成链上经济与虚拟世界的互动资产。

-   **核心标准**：**ERC-721**是经典的“一物一证”标准，适用于独一无二的艺术品或收藏品。**ERC-1155**则是混合型标准，允许在同一合约内管理同质化和非同质化代币，更适用于游戏道具、门票等需要批量发行的场景。
    
-   **演进趋势：NFT生态的演进体现了其应用场景的深化。以2017年的CryptoKitties**为例，它开创了链上收藏与繁殖的先河，展示了NFT作为独特数字资产的潜力，但也因其火爆而暴露了当时以太坊主网的性能瓶颈。随后，以**Decentraland**为代表的虚拟世界项目，将NFT的应用从单一的收藏品扩展到了可交互的虚拟土地、道具和身份凭证，用户可以在一个持久的链上世界中拥有、建设和交易资产。这种演变标志着NFT正从静态的所有权证明，转变为构成复杂数字经济和沉浸式体验的基础构件。
    

### **3\. 去中心化自治组织（DAO）**

DAO 是利用智能合约进行管理的链上组织，其规则公开透明，决策由成员通过投票共同作出。不同类型的 DAO 展现了其多样化的创新价值。

| 类型 | 核心机制 | 治理目标 | 创新价值 |
| --- | --- | --- | --- |
| 协议DAO(如 Uniswap DAO) | 基于治理代币进行链上投票 | 协议参数调整、金库管理、协议升级决策 | 建立了一种渐进式去中心化的蓝图，即在产品市场契合度得到验证后，再将治理权移交给社区。 |
| 公共物品资助DAO(如 Gitcoin) | 采用二次方资助（Quadratic Funding）机制 | 为开源软件、公共基础设施和社区项目提供资金支持 | 通过放大“人头”而非“钱头”的权重，探索出一种更公平、更高效的公共物品激励方案。 |
| 创意型DAO(如 Nouns) | 每日拍卖一个NFT，收入进入公共金库，由成员投票决定资金用途 | 共同创作和管理一个IP，并资助相关衍生项目和公共物品 | 将IP创作、社区治理和金库管理无缝结合，创造了一种自下而上的、持续性的文化与品牌生成引擎。 |

# **社区与开发者生态**

如果将以太坊比作一座不断生长的“无限花园”，那么其社区与开发者生态就是辛勤的园丁。我们可以用一个核心比喻来理解他们的角色：**社区是“大脑+声音”**，负责确立价值观、形成共识并指引方向；而**开发生态则是“手和工具”**，负责将愿景转化为可运行的代码和应用。

### **1\. 社区：价值观的守护者与共识的形成者**

以太坊的治理结构是“多中心、强透明”的，协议升级并非由单一实体决定，而是在公开的讨论中逐步形成共识。

-   **核心治理渠道**：**核心开发者会议（AllCoreDevs）** 和 **以太坊魔术师论坛（Fellowship of Ethereum Magicians, FEM）** 是技术决策的核心场域。所有会议都公开直播并留有记录，任何 EIP 提案都会在论坛上经历社区长时间的审议和打磨。这种开放性确保了决策过程的透明度和包容性。
    

在长期的协作中，以太坊社区沉淀出了一套鲜明的核心价值观，它们是网络发展的“软性共识”：

-   **开源与透明**：协议、客户端和工具链大多开源，治理讨论在公开频道进行，鼓励审计与批评，拒绝“闭门决策”。
    
-   **去中心化与“管理而非控制”**：以太坊基金会（EF）等核心组织的角色是支持生态、填补空白，而非控制协议的发展路径，致力于维护网络的去中心化本质。
    
-   **协作优先而非零和竞争**：生态鼓励开发者和项目方之间相互协作，共享工具与最佳实践，共同建设公共基础设施，营造出一种正和博弈的氛围。
    

### **2\. 开发生态**

-   **工具与基础设施**：从浏览器内的**Remix IDE**到专业的**Hardhat**和**Foundry**框架，再到**Infura**、**Alchemy**等节点服务商，这个成熟的工具栈极大地降低了开发门槛。这种成熟的工具生态系统创造了强大的网络效应，降低了创新者的准入门槛，并加速了应用层需求与核心协议演进之间的反馈循环。
    
-   **教育与培训**：旗舰开发者大会**Devcon**和全球巡回的**ETHGlobal黑客松**系列活动，扮演着引入和培养新人的关键角色，每年都有成千上万的新项目和开发者通过这些平台进入生态。
    
-   **协议创新与反馈**：应用层开发者的实践需求是以太坊协议自下而上发展的核心驱动力。许多重要的EIP提案源于DeFi、NFT和L2的一线开发者为解决实际问题而提出的挑战，确保了核心协议能够紧跟生态的步伐。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->















# 开营仪式整理：

# **1\. 四周学习总览**

本次实习计划分为四个阶段，循序渐进，由浅入深。

| 周次 | 核心主题与目标 |
| --- | --- |
| 第一周 | 基础认知与技能学习：系统入门Web3的核心概念，掌握必备的基础知识和工具。 |
| 第二周 | 深度学习与技能进阶：在第一周的基础上，深入特定赛道（运营/技术），进行技能强化。 |
| 第三周 | 休闲黑客松：将理论付诸实践。运营赛道的同学将有机会组织和执行活动，技术赛道的同学则专注于动手构建和交付项目。 |
| 第四周 | 就业指导与岗位对接：完善个人简历，获取专业的求职指导，并对接优质的实习与工作机会。 |

# **2\. 每周日常活动总览**

| Mon | Tue | Wen | Thu | Fri |
| --- | --- | --- | --- | --- |
| 以太坊中文周会 | / | / | / | / |
| 线上co-learning | 线上co-learning | 线上co-learning | 线上co-learning | 线上co-learning |
| 主题分享会 | 主题分享会 | 主题分享会 | 主题分享会 | 每周例会 |

-   **线上共学（自习室）**
    

◦ **时间**：工作日下午 5:00 - 6:00

◦ **目的**：答疑

◦ **注意**：此环节**没有录屏**。

-   **主题分享会**
    

◦ **时间**：通常在晚上进行，具体时间关注日历。

◦ **目的**：邀请行业大咖和资深前辈，就Web3的不同领域进行深度分享。

◦ **注意**：**所有分享会都会有录屏**，并会在次日中午12:00前上传至Bilibili和YouTube。

-   **以太访中文周会**
    

◦ **时间**：每周一下午 2:00

◦ **目的**：跟进行业最新动态，解读前沿报告。

-   **周五例会**
    

◦ **时间**：每周五晚上

◦ **目的**：一周学习成果的展示与复盘。分享自己的学习进展、遇到的问题和思考。

# **3\. 关键行动与截止日期（重点注意）**

以下两件事是近期最重要的任务，务必按时完成。

## 1. **每日共学打卡**

◦ **开始时间**：**1月12日**起。

◦ **核心要求**：提交学习笔记来完成打卡。完成一次有效打卡即可获得**40分**积分。

◦ **严格规则**：**“每周（按自然周计算）累计超过两次未打卡，打卡功能将被禁用”**。

◦ **重要提醒**：因为笔记系统采用开源方式，你提交的所有笔记内容都将**在GitHub上公开可见**。请**绝对不要**在笔记中包含任何私钥、密码或敏感个人信息。

## 2. **选择助教**

◦ **目的**：每位学员都需要在学习平台上选择一位助教。

◦ **规则**：每位助教有**50个名额**，选择后需等待助教审核通过。

# **4\. 积分与奖励机制**

-   **排行榜系统**
    

◦ 本次实习共设有**八个排行榜**：

▪ **赛道榜（6个）**：运营、技术、深度技术三个赛道，每个赛道都分别设有**周榜**和**总榜**。适

▪ **总榜（2个）**：不分赛道，同样设有**周榜**和**总榜**。

-   **优秀学员奖励**
    

◦ 表现优异的学员将有机会获得：

▪ **OneKey** 赞助的**硬件钱包**

▪ **ETHPanda &LXDAO** 提供的**周边礼包**

▪ **N** 提供的 **Credits**

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208431895-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208451009-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208464710-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208476076-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208495152-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208518187-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208532101-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/beetroot42/images/2026-01-12-1768208566634-image.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
