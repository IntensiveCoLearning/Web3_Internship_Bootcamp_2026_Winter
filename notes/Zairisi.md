---
timezone: UTC+8
---

# Zairisi

**GitHub ID:** Zairisi

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->
今天进行了第一次的链上投票，以前都是在线下，进行中心化的投票，去中心化的投票早在本科阶段的课堂上听闻过，但是还没真正的去实践过，感谢LXDAO提供的一次宝贵的实践经历......  
在此重温一遍觉得需要复习的地方：  
零知识证明分为两种参与角色：其一，证明者，其二，验证者。证明者就是证明自身“合法”，但不需要出示详细的细节；验证者则是可以验证这个证明者的确“合法”但不需要知道具体的细节。放到实际的场景中就是：我向你证明我是Ryans（本人），但是我不需要向你提供我的身份证号码，对于验证者而言，就是不需要知道我具体的身份证号码，就可以验证我确实是本人。  
零知识证明应当满足三个性质：1.可靠性 2.完备性 3.零知识性
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->

今天构建了自己的第一个Nft。在构建的过程中，安装网站给的提示又温习了一遍之前学习过的知识，比如区块链，Nft这些基础知识。也学习了一些常见的钱包风险，要千万个小心！
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->


今天应该算是正式回归到web3的学习当中了…  
在时隔了一年后重新拿起区块链相关的学习资料，发现原先的小狐狸也没了，只好重新注册了一个，然后重新开始。在好心人的帮助下，领到了Ethereum Sepolia的测试币。

| 今天还看了好多老师发的推文，开阔了自己的视野，学到了很多闪光点，同时感叹他们的思考之深入，反思一下后，觉得自己的思考逻辑也要再度更新一下。 |
| 今天也看了一部分起号的教程，自己也萌生了起一个号的想法，逐步把这些想法付诸实际吧。 |
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->




今天学习了几种常见的算法，如：动态规划法、贪心法、回溯法以及分支限界法。

其中，在动态规划算法这一部分，重温了一遍关键路径的相关知识：关键路径是指完成工期所需要的最短时间，这是AOE网络中的最长路径。AOE常见的情境中会出现两个数组：earliest（i）和latest（i），分别表示：所有前驱节点的最早时间+活动的消耗时间的最大值，所有后继结点的最晚时间-活动消耗时间的最小值。earliest（i）-latest（i）=0时，这个节点代表的活动就是关键活动。  
其次就是求解最长公共子序列。通常先建立两个表格，一个是C\[\]，一个是s\[\]，分别表示相似度和路径，如果两个序列相同，那么对应在c表中的值是左上格的值+1，如果不想同，那么从上边和左边当中取一个最大的值，当上格和左格的值相同时，取上格的值。需要注意的是，最外层是0。s表的取值：根据c表取值而取值。比如，如果c表对应的值取得是左上角的，那么s表中对应位置是1，如果是取得上格，那么取2，如果是左格，那么取3。按照这样的规则更新两个表的数值。在找寻最优子序列时，从s表的最下方开始寻找，取s表中的值为1的所有序列，如此可以得到最优的子序列。

在贪心法中，学习了一般背包问题，掌握了解决一般背包问题的方法。主要是通过计算单位重量最大收益，优先分配给单位重量最大收益的物品。

在回溯法中，学习了0/1背包问题的解决思想。解决这类问题时，需要建立两个集合，s，m。其中，s代表加入某项物品后的最优质和不加入某项物品后的最优值，而m代表暂时性加入某一个物品后得到的最优值。s和m的更新规则如下：首先，s-1为【0,0】，，m0=s-1+第0项物品后的结果，s0为s-1∪m0；接着，m1=s0+加入第二项物品后的结果，s1=s0∪m1，以此类推...在更新时，要注意m，s集合内的元素应该符合重量递增、价值递增，否则将其删除，最终得到的最大收益的那个集合即为最优解。在判断取了哪些物品时，从后向前回溯判断。判断是否加入的依据是：m中有这个集合，且s中也有这个集合。  
除此之外，还学习了分支限界法。掌握了解决15迷问题的相关步骤。首先定义代价函数c（x）=f（x）+g（x），其中，f（x）为生成树的层数，而g（x）为挡在不在其位的非空格数量，每次选取c（x）值最小的那个节点，以他为根，不断向下生成子节点。子节点的生成在一开始时是分为了上下左右四个方面，再生成第三层时，不能再生成与之相反方向的节点。在计算不在其位的非空格数量时，空格直接跳过，但是可以认为空格·为下一个排序的值。  
下一步要再学一下矩阵连乘法和最小时限的序数法。先把算法基础打牢固。
<!-- DAILY_CHECKIN_2026-01-16_END -->
<!-- Content_END -->
