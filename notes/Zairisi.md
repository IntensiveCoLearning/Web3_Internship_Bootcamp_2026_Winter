---
timezone: UTC+8
---

# Zairisi

**GitHub ID:** Zairisi

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
今天学习了几种常见的算法，如：动态规划法、贪心法、回溯法以及分支限界法。

其中，在动态规划算法这一部分，重温了一遍关键路径的相关知识：关键路径是指完成工期所需要的最短时间，这是AOE网络中的最长路径。AOE常见的情境中会出现两个数组：earliest（i）和latest（i），分别表示：所有前驱节点的最早时间+活动的消耗时间的最大值，所有后继结点的最晚时间-活动消耗时间的最小值。earliest（i）-latest（i）=0时，这个节点代表的活动就是关键活动。  
其次就是求解最长公共子序列。通常先建立两个表格，一个是C\[\]，一个是s\[\]，分别表示相似度和路径，如果两个序列相同，那么对应在c表中的值是左上格的值+1，如果不想同，那么从上边和左边当中取一个最大的值，当上格和左格的值相同时，取上格的值。需要注意的是，最外层是0。s表的取值：根据c表取值而取值。比如，如果c表对应的值取得是左上角的，那么s表中对应位置是1，如果是取得上格，那么取2，如果是左格，那么取3。按照这样的规则更新两个表的数值。在找寻最优子序列时，从s表的最下方开始寻找，取s表中的值为1的所有序列，如此可以得到最优的子序列。

在贪心法中，学习了一般背包问题，掌握了解决一般背包问题的方法。主要是通过计算单位重量最大收益，优先分配给单位重量最大收益的物品。

在回溯法中，学习了0/1背包问题的解决思想。解决这类问题时，需要建立两个集合，s，m。其中，s代表加入某项物品后的最优质和不加入某项物品后的最优值，而m代表暂时性加入某一个物品后得到的最优值。s和m的更新规则如下：首先，s-1为【0,0】，，m0=s-1+第0项物品后的结果，s0为s-1∪m0；接着，m1=s0+加入第二项物品后的结果，s1=s0∪m1，以此类推...在更新时，要注意m，s集合内的元素应该符合重量递增、价值递增，否则将其删除，最终得到的最大收益的那个集合即为最优解。在判断取了哪些物品时，从后向前回溯判断。判断是否加入的依据是：m中有这个集合，且s中也有这个集合。  
除此之外，还学习了分支限界法。掌握了解决15迷问题的相关步骤。首先定义代价函数c（x）=f（x）+g（x），其中，f（x）为生成树的层数，而g（x）为挡在不在其位的非空格数量，每次选取c（x）值最小的那个节点，以他为根，不断向下生成子节点。子节点的生成在一开始时是分为了上下左右四个方面，再生成第三层时，不能再生成与之相反方向的节点。在计算不在其位的非空格数量时，空格直接跳过，但是可以认为空格·为下一个排序的值。  
下一步要再学一下矩阵连乘法和最小时限的序数法。先把算法基础打牢固。
<!-- DAILY_CHECKIN_2026-01-16_END -->
<!-- Content_END -->
