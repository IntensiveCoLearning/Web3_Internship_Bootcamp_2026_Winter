---
timezone: UTC+8
---

# kiki808121

**GitHub ID:** kiki808121

**Telegram:** @mamashiqi940

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
**什么是 Permit2 ？**

**Permit2 是 Uniswap 开发的一个智能合约系统,用于改进以太坊上的代币授权流程。**

Permit2 是一个代币授权管理合约,它解决了传统 ERC20 approve() 方法的几个问题:

**传统授权的问题:**

-   每次与新协议交互都需要单独的授权交易(消耗 gas)
    

-   授权通常是无限额度,存在安全风险
    

-   无法设置授权过期时间
    

-   撤销授权需要额外交易
    

**Permit2 的改进:**

-   用户只需授权一次给 Permit2 合约
    

-   之后可以通过签名(不消耗 gas)授权给不同的协议
    

-   支持设置授权额度和过期时间
    

-   更细粒度的权限控制
    

**Permit2 授权请求的工作流程**

1.  **一次性授权**: 用户将代币授权给 Permit2 合约(需要一次链上交易)
    
2.  **签名授权**: 当需要与 DApp 交互时,用户通过签名消息授权 Permit2 将特定数量的代币转移给特定协议
    
3.  **执行转账**: DApp 调用 Permit2 合约,使用用户的签名来执行代币转移
    

**签名内容通常包括:**

-   代币地址
    

-   授权数量
    

-   过期时间
    

-   接收方地址(协议地址)
    

-   nonce(防止重放攻击)
    

**Permit2 授权的特殊性**

**1\. 签名授权 vs 链上授权**

-   Permit2 使用**链下签名**授权
    

-   传统的 Etherscan Token Approval 页面主要查看**链上授权**
    

-   需要专门的工具来追踪和管理签名授权                                                            
    

2\. **专业工具的功能** ScamSniffer 和类似工具提供:

-   查看所有 Permit2 相关的签名授权
    

-   显示授权的详细信息（金额、过期时间、接收方）
    

-   撤销恶意授权
    

-   监控可疑的授权请求
    

3.    **管理方式** 管理 Permit2 授权需要：

  第一层: 撤销对 Permit2 合约的基础授权

   → 使用 [Revoke.cash](http://Revoke.cash) 或 Etherscan

   第二层: 管理具体的签名授权

   → 使用 ScamSniffer Permit2 Manager 等专业工具

具体场景说明

**场景 1: 你已经签署了恶意 Permit2 授权**

时间线:

1\. 你在钓鱼网站签署了恶意 Permit2 授权 ⚠️

2\. 骗子尝试调用 Permit2 转走你的 USDT

3\. 你撤销了 USDT 对 Permit2 合约的授权 🛡️

4\. 骗子的转账交易失败 ✅（资金安全）

**结果**: 即使骗子有你的签名，也无法转走代币，因为 Permit2 合约已经没有权限了。

**场景 2: 你正常使用 Uniswap 交易**

操作流程:

1\. 你在 Uniswap 尝试兑换 USDT → ETH

2\. Uniswap 请求使用 Permit2

3\. 但你已经撤销了 USDT 的 Permit2 授权

4\. 交易失败，显示"insufficient allowance" ❌

5\. 你需要重新授权 USDT 给 Permit2

6\. 然后才能完成交易

**两层授权机制**

理解 Permit2 的**两层结构**很重要：

第一层（链上基础授权）:

你的 USDT → 授权 → Permit2 合约

         ↑

    可以用 [Revoke.cash](http://Revoke.cash) 撤销

第二层（签名授权）:

Permit2 合约 → 根据你的签名 → 转账给特定 DApp

              ↑

         需要专业工具管理

**撤销第一层 = 第二层全部失效**

撤销 Permit2 基础授权的效果：

-   ✅ **立即保护**你的资产，所有 Permit2 授权失效
    
-   ❌ **暂时无法**使用集成 Permit2 的 DApp
    
-   🔄 **可以随时**重新授权恢复功能
    

**核心原则**：资产安全 > 使用便利。

### 什么是 Proxy（代理合约）？

### 问题的由来

**智能合约的困境：**

```
传统软件：
发现 bug → 修复 → 发布更新 → 用户更新

智能合约：
发现 bug → ？？？
合约部署后无法修改！代码永远在链上！
```

**这就很尴尬：**

-   代码有 bug 怎么办？
    
-   要添加新功能怎么办？
    
-   发现安全漏洞怎么办？
    

**解决方案：Proxy Pattern（代理模式）**

### Proxy 的工作原理

```
传统合约部署：
用户 → 直接调用合约A
      ↓
   合约A的代码（无法修改）

Proxy 模式：
用户 → Proxy合约 → 转发调用 → 实现合约（Implementation）
      ↓                        ↓
   存储数据                可以被替换！
   地址固定               (升级合约)
```

**具体流程：**

```javascript
// 1. 部署 Implementation 合约（实际逻辑）
Implementation V1: 0xAAA...
- function deposit()
- function withdraw()

// 2. 部署 Proxy 合约（代理/入口）
Proxy: 0xBBB...
- 存储用户数据
- 指向 Implementation V1 (0xAAA...)
- 所有调用转发到 V1

// 3. 用户交互
用户调用 0xBBB.deposit()
→ Proxy 转发到 0xAAA.deposit()
→ 数据存在 Proxy 里

// 4. 发现 bug，需要升级
部署新的 Implementation V2: 0xCCC...
→ Proxy 更新指针：0xAAA → 0xCCC
→ 用户继续调用 0xBBB（地址不变）
→ 但现在执行的是 V2 的代码
```

**优势：**

-   ✅ 可以修复 bug
    
-   ✅ 可以添加新功能
    
-   ✅ 用户不需要迁移（地址不变）
    
-   ✅ 数据保持连续性
    

**风险：**

-   ⚠️ 谁能升级合约？（权限问题）
    
-   ⚠️ 升级是否安全？（可能引入后门）
    
-   ⚠️ 用户如何知道？（透明度问题）
    

### DeFi Proxy Security Update 是什么？

这通常指：**DeFi 项目通过 Proxy 机制进行合约升级的公告和过程**。

### 典型场景

**场景 1：安全补丁**

```
"我们发现了一个潜在的安全漏洞，
已经部署了修复版本，
将在 48 小时后升级 Proxy 合约。"
```

**场景 2：功能更新**

```
"V2 版本增加了新的质押功能，
将通过 Proxy 升级实现，
不影响现有用户的资产。"
```

**场景 3：紧急响应**

```
"检测到攻击行为，
已紧急升级合约禁用漏洞函数，
用户资金安全。"
```

### Proxy 升级的安全风险

### 风险 1：中心化风险（Admin Key）

**谁能升级合约？**

```
最危险的情况：
单个私钥控制升级权限
↓
私钥被盗/管理员作恶
↓
替换成恶意合约
↓
盗走所有用户资金
```

**真实案例：**

-   **Parity 多签钱包**（2017）：库合约被"意外"删除，冻结了 $150M
    
-   **Paid Network**（2021）：私钥被盗，攻击者升级合约铸造假代币
    

### 风险 2：升级透明度不足

**用户不知道发生了什么：**

```
今天：
合约代码是安全的

明天：
项目方悄悄升级了
新代码有后门
用户完全不知道
```

### 风险 3：时间锁（Timelock）被绕过

**好的项目会用时间锁：**

```
提议升级 → 等待期（如 48 小时）→ 执行升级
           ↓
       用户有时间检查
       用户可以选择退出
```

**但如果：**

-   时间锁设置太短（1小时）
    
-   或者项目方能绕过时间锁
    
-   用户来不及反应
    

### 风险 4：存储冲突（Storage Collision）

**技术细节：**

```solidity
// Implementation V1
contract V1 {
    uint256 public balance;     // 存储槽 0
    address public owner;       // 存储槽 1
}

// 错误的 V2 升级
contract V2 {
    address public owner;       // 存储槽 0（冲突！）
    uint256 public balance;     // 存储槽 1（错位！）
}

结果：
balance 的值被解释为 address
owner 的值被解释为 uint256
→ 数据完全混乱！
```

### 如何评估 Proxy 升级的安全性？

**1\. 升级权限是如何控制的？**

```
🔴 红灯（危险）：
单个 EOA 地址（普通钱包）控制
"Owner: 0x1234..."

🟡 黄灯（需谨慎）：
多签控制，但阈值低
"3/5 multisig"（5个人里3个同意就能升级）

🟢 绿灯（相对安全）：
- 高阈值多签（如 7/10）
- 加上时间锁（48-72小时）
- 社区治理投票
```

**2\. 是否有时间锁？**

```
✅ 好的做法：
"提议升级 → 48小时等待 → 执行"
→ 给用户时间检查和撤出资金

❌ 危险的做法：
"立即升级"
→ 用户无法反应
```

**3\. 升级历史和透明度**

```
检查项目：
- 过去升级过几次？
- 每次升级都有详细公告吗？
- 代码审计了吗？
- 在链上可以验证吗？
```

### 实际检查方法

**在 Etherscan 上查看：**

```
步骤 1：找到合约地址
例如：Aave 的 LendingPool

步骤 2：查看 "Contract" 标签
看是否标记为 "Proxy"

步骤 3：查看 "Read as Proxy"
找到 implementation 地址

步骤 4：检查 admin/owner
看谁能升级合约

步骤 5：查看历史
"Internal Txns" 看升级记录
```

### 不同 Proxy 模式的对比

### 1\. Transparent Proxy

```
特点：
- Admin（管理员）和 User（用户）调用分离
- Admin 只能升级，不能调用业务函数
- 防止函数签名冲突

使用项目：
- Compound
- 很多早期 DeFi 项目
```

### 2\. UUPS (Universal Upgradeable Proxy Standard)

```
特点：
- 升级逻辑在 Implementation 里
- 更节省 gas
- 但需要确保升级函数不会被误删

使用项目：
- Aave V3
- 较新的项目
```

### 3\. Diamond Pattern (EIP-2535)

```
特点：
- 多个 Implementation
- 模块化，可以只升级部分功能
- 复杂但灵活

使用项目：
- 一些复杂的 DeFi 协议
```

## 真实案例分析

### 案例 1：Compound 的安全升级 ✅

```
2023年某次升级：
1. 提前 1 周公告
2. 代码开源并审计
3. 7/10 多签 + 48小时时间锁
4. 社区讨论充分
5. 升级后公示变更内容

结果：
用户信任度高，资金安全
```

### 案例 2：某小项目的恶意升级 ❌

```
2022年某项目：
1. 无公告，悄悄升级
2. 添加后门函数 backdoor()
3. 项目方提走所有 TVL
4. 用户损失数百万美元

问题：
- 单个地址控制升级权
- 无时间锁
- 无透明度
```

### 使用 DeFi 项目前检查：

```
安全检查清单：
□ 项目使用 Proxy 吗？
  └─ 在 Etherscan 上看 "Proxy" 标记
  
□ 谁能升级合约？
  └─ 多签？单人？治理？
  
□ 有时间锁吗？多长？
  └─ 48小时以上较安全
  
□ 过去升级历史如何？
  └─ 透明？频繁？突然？
  
□ 项目有审计吗？
  └─ 审计公司？报告公开？
```

### 看到升级公告时：

```
你应该：
1. 阅读升级说明
2. 检查代码变更（如果你懂）
3. 看社区反应
4. 决定是否：
   - 继续使用
   - 等待观察
   - 提前退出资金
```

### 红旗警告：

```
🚩 单个地址控制升级
🚩 无时间锁或时间锁很短（<24小时）
🚩 升级无公告
🚩 代码不开源
🚩 频繁升级（可能不稳定）
🚩 团队匿名 + 中心化控制
```

### 未来趋势：不可变合约

有些项目选择**放弃可升级性**：

```
Uniswap V2/V3 核心合约：
- 不可升级
- 代码固定在链上
- 优点：完全去中心化，无需信任
- 缺点：无法修复 bug

策略：
通过周边合约（Router）实现灵活性
核心保持不可变
```

## 总结

```
DeFi Proxy Security Update = 
通过代理合约机制升级 DeFi 协议

好处：
✅ 可以修 bug
✅ 可以加新功能
✅ 用户地址不变

风险：
⚠️ 中心化控制
⚠️ 可能引入漏洞
⚠️ 透明度不足
⚠️ 用户信任风险

关键点：
- 检查升级权限机制
- 关注时间锁
- 跟踪升级历史
- 评估项目透明度
```
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->

## 为什么我们的学习一定在测试网上，以及没有测试网会发生什么？

Web3 的世界里有一条铁律：链上错误不可撤销。

假设直接在 Ethereum Mainnet（主网）做开发：

### 1️⃣ 一次手滑，钱就真没了

• 写错一个地址

• 参数顺序写反

• 多转一个 0

在 Web2：

• 回滚

• 找客服

• 查日志

在 Web3 主网：

• ❌ 没有回滚

• ❌ 没有客服

• ❌ 没有管理员

### 2️⃣ 合约是“不可升级的程序”

普通程序：

• 写错 → 改 → 再部署

智能合约：

• 部署 = 永久存在

• 写错 = 永久 bug

主网部署一个有 bug 的合约，后果是：

• 资产被锁死

• 被套利

• 被黑客自动扫描

### 3️⃣ 测试网到底“测试”什么？以及其价值在哪里？

测试网 不是假链，而是规则与主网几乎一致，但资产无价值的平行链

以 Sepolia 为例：

| 项目 | 主网 | Sepolia\| |
| --- | --- | --- |
| EVM | ✔️ | ✔️ |
| Gas机制 | ✔️ | ✔️ |
| 合约字节码 | ✔️ | ✔️ |
| ETH价值 | 真钱 | 0 |
| 风险极高 | 极高 | 0 |

1\. 工程价值：验证代码是否真的能跑

在测试网可以：

• 部署合约

• 调试 gas

• 测试异常分支

• 模拟攻击路径

一句话：

测试网是 Web3 的“真实预演环境”。

2\. 经济价值：模拟真实博弈

Web3 ：

• 手续费高低

• 用户操作成本

• 激励是否有效

测试网可以逼你回答：

• 如果用户要花 0.002 ETH 才能点一次按钮，他还会点吗？

• 如果失败要烧 gas，这个 UX 合理吗？

这些只能在链上才能感受到。

3\. 安全价值：让黑客先找 bug

测试网是公开的：

• 所有人都能看合约

• 包括黑客

这不是坏事，而是预演真实世界：

• 测试网被攻击 → 好事

• 主网被攻击 → 灾难

### Etherscan tx link 是什么？

Etherscan tx link 就是一笔交易在区块链上的“官方公开档案链接”，指向某一笔交易（transaction）的区块链浏览器页面。

### 1️⃣ tx = transaction (交易)

### 在以太坊里，tx 是最小行动单位，包括但不限于：

• 转账 ETH

• 部署合约

• 调用合约函数

在链上做任何事，都会变成一笔 tx。

### 2️⃣ link = 浏览器页面地址

Etherscan 把这笔 tx：

• 解析

• 可视化

• 公开展示

于是得到一个页面，里面写清楚：

• 谁发的

• 发给谁

• 干了什么

• 花了多少 gas

• 有没有成功

这个页面的 URL，就叫 Etherscan tx link。

### tx link 里到底有什么信息

**基本信息**

• Transaction Hash（tx hash）

→ 这笔交易的唯一 ID

• Status

→ Success / Failed

• Block

→ 被打包进了哪个区块

**行为信息**

• From：发起地址

• To：接收地址 / 合约地址

• Value：转了多少 ETH

## 总结

用户 (私钥)

↓

钱包（MetaMask）1. 管私钥（不让用户直接接触）2. 核对交易 / 合约调用签名 3. 决定现在连的是哪条链（Mainnet / Sepolia）

↓

Web3 App（dApp）一个普通网页 + Web3 SDK，“前端 + 合约入口

↓

智能合约 部署在区块链上的程序，不能随便改，谁调它、怎么调，全链可查

↓

区块链（Ethereum / Sepolia), 全世界共用的数据库

↓

区块浏览器（Etherscan）

### 感悟

真的，尤其是在中国这种国家长大, 面对的环境是权力高度集中，规则可变、解释权集中，个人对系统的可见性极低，“为你好”的上级叙事。去中心化这个理念对我来说吸引

力实在是太大了。 不过我觉得这个理念最重要的一点还有就是要学会给自己负责 把自己打造成超级个体。以及我也发现去中心化 ≠ 解放，去中心化 = 极端责任制

在 Web3 里， 钱丢了 → 没人帮我找，私钥泄露 → 没人兜底，合约写错 → 损失真实发生，被钓鱼 → 只能怪自己，自由是用“无保护”换来的。

今天看到 wachi 老师说，" 这就是去中心化技术的魅力，你越了解它，越相信它。" 通过我一天的学习, 我发现确实是这样的, web3 太酷了！ wachi 老师太酷了。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
