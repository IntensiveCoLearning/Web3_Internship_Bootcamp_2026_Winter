---
timezone: UTC+8
---

# Twooweeks

**GitHub ID:** Twooweeks

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
第四章学习

-   evm不能随便调用外部的数据，可以调用通过oracle上链的数据，防止破坏共识。
    

-   opcode为bytecode最基本的构成，与汇编语言类似
    
-   为什么审计时，要细致到opcode代码，首先编译器有时候为了编译效率会调整opcode的执行顺序，我们需要知道当前状态和各项指标是否在安全的范围；合约中的有循环，通过逐行看opcode也能更好的算gas，攻击者可能利用特殊构造的gas炸弹，导致合法用户的交易无法成功，逐行opcode也可以更好定位gas炸弹。监控内存和堆栈的实时情况；在合约间相互调用的时候，防止存储位置不一致
    
-   gas的放攻击角度的设计，有gaslimit，你只能在规定的gas费用下执行步数，每一步的basegas都还是挺大的，创建合约的价格也变高防止大量创建合约，不同的opcode重新定价，以防操作定价过高或过低，过低操作被大量重复调用来攻击。
    
-   out of gasllimit会导致交易回滚，但是你的合约不会上链，只留下一条交易失败的记录，而且还是会扣你的gas
    
-   gas优化external参数优先 calldata;重复使用的storage先缓存到memory;mapping+索引，而不是大数组暴力遍历。多用mapping+索引，而不是大数组暴力遍历。合约结构上：引入代理/模块化/库，减少代码重复;利用constant/immutable存放不会改的配置;使用transientstorage存短期状态。避免不受控长度循环;能off-chain算的别on-chain算;慎用unchecked，用好短路逻辑和位运算。
    
-   当前能搬到L2的逻辑就尽量放到 Rollup 上，让主网只做“结算层”。可理解为让主网只做结算的工作，l2定期向主网提交证明。
    
-   常量不占storage的空间，在编译的时候直接嵌入合约的可执行代码（字节码）当中
    

-   节省gas的小技巧，storage变量都用s\_表示，在function开头将s\_变量用常量表示，这样不用每次都从storage中提取s\_变量
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

其实我有点迷茫，即将研二下学期，秋招就要来了，自己不确定在半年的开发学习中能不能找到一个web3的工作，每天茫茫多的信息扑面而来，自己现在也是想着走一步看一步，没有什么计划，还有就是学习rust开发，eth好像只能做solidity相关的智能合约开发，不管哪一个门槛都有点高，先干着吧，在这个web3实习期间也多多调研，今天co-learning也是自己第一次co-leanring听到一个巨好的例子，每天都接收到茫茫多信息，自己怎么知道哪些是自己需要的信息呢，老师举了个例子，刚开始开车的时候我们笨手笨脚的，可在进化成老司机后，我们就能获取到正确的道路信息去帮助我们驾驶，所以说还是得多练多调研，去丰富自己的认知。

-   creation bytecode和runtime bytecode的区别是什么？
    

creation bytecode含构造函数，给你一份说明说把椅子拼起来，过程只发生一次。

runtime bytecode不含构造函数，他就是装好的椅子，可执行多次，且存储在链上

-   部署交易哈希是什么？
    

相当于一个收据单号可以查询部署过程、状态、手续费，也可以查询到你的合约地址。

-   receive（）：用于收没有指令的钱；
    
-   修饰符的使用举例（在函数后面添加具体修饰符即可）：
    

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract MyContract {

address public owner;

constructor() {

owner = msg.sender; // 部署合约的人是管理员

}

// — 1. 定义修饰符 —

modifier onlyOwner() {

// 检查调用者是不是管理员

require(msg.sender == owner, “You are not the owner!”);

\_; // <— 重要！这里代表执行原函数的代码

}

// — 2. 使用修饰符 —

// 只有管理员能修改这个数值

uint public data;

function updateData(uint \_newVal) public onlyOwner {

data = \_newVal;

}

// 只有管理员能把钱提走

function withdraw() public onlyOwner {

payable(owner).transfer(address(this).balance);

}

}

-   原来solidity在整数溢出会“绕回” （wrap），即当数字增加到最大值后再加 1，它不会变成更大的数，而是直接归零，0-1直接变成255，现在不会了，检测到溢出会revert（）；
    
-   ZK Rollup：它的核心是“不信任”，不依赖于任何人的诚实。每次将一批交易（称为“批次”）发布到主网时，都必须附上一个零知识证明。主网合约只需要验证这个小小的证明，就能确信这批交易的所有计算都是正确执行的，就像完成了“数学上的绝对验算”。就那bitcion来说，轻节点可以通过全节点给出最少的，必需的信息，使得轻节点可以再通过merkle header来验证哈希值的·合法性。
    
-   web3与ai结合例子，web3给ai agent做身份证，用于监管ai的行为。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->



课堂分享：1，求职，一定要清楚项目方在国内是否有业务，可以看是否能用大陆的资料进行注册，不要只是ip的封禁；还要看是否有合法的拍照；合约、期权之类的开发不要碰。

搞懂eoa和合约账户的互动形式：

-   智能合约的地址形式：create：由你的地址+nonce决定；create2：同样的盐值（salt）可以使不同链上的合约地址一致。
    

-   为什么使用create2可以提前算出智能合约的地址，甚至合约此时还没上链：create2又四部分组成0xFF： 一个固定的常量前缀。部署者地址：谁来发起部署（通常是你的钱包或工厂合约地址）。盐值（Salt）：自己选的一个32位随机数。合约代码哈希： 你要部署的合约代码（Bytecode）计算出的指纹。四个部分已知就能算出地址。
    

-   智能合约(自动售货机)是没有私钥的，且部署上链是gas花费较高的一个操作，且不能主动发起外部交易。
    

-   每一个合约都有一个存储树用来记录一些关键的状态（例如用户的余额，资产的管理账户）。
    
-   传统的交易是你发送一份交易到池子里然后旷工打包，4337后有UserOp的概念，你可以构造并签名一个UserOp，然后发送到专门的Alt Mempool里，然后BUNDLER会把几个UserOp打包到一起当做是一个普通的交易；好处是，UserOp可以指定别人帮你付gas，callData可批量完成授权 + 交易 + 质押。UserOp还可以有社交恢复的功能，可通过守护者的签名证明你的身份。
    
-   以太坊中自己一个状态树，其它代币（ERC-20）又智能合约中的状态树决定，你账户上的余额是查这些合约的状态树找到的。
    
-   现在不能用SELFDESTRUC来直接删合约，除非该合约在同一个交易中被创建和删除，现在SELFDESTRUC只能把你里面的eth转走，为防止合约出问题，常见的方式用代理合约，代理合约指定的逻辑地址出问题时，你可以重新写一个合约，然后代理合约指向这个新地址，其次你可以在合约中加入暂停的功能，以防出错。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->




-   客户端是由软件实现的，相当与一个软件，节点是运行客户端的电脑，客户端又分执行客户端和共识客户端，若一个电脑跑着执行客户端和共识客户端则代表它是一个全节点（仅仅以太坊，比特币的全节点就一个客户端负责着交易验证、脚本执行和工作量证明共识规则验证的功能）。
    
    ![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-13-1768318550674-image.png)
-   多种子协议：你现在有多份不同版本的拼图说明书。它们描述的是同一个最终图案（你要下载的文件），但可能把拼图分成了不同大小、不同形状的碎片。你可以同时从多个卖家社区（多个Swarm）里收集碎片，速度大大提升，并且如果一个社区没人了，你还能从其他社区继续。
    
-   RLPx = 在一条 TCP 线上开很多“分机”是可以理解为，在一条线上传的的数据通过不同的报文达成不同的协议，还是说是在一条线上划出不同的路，然后不同路跑不同的协议。
    

路还是只有一条RLPx相当于一个管理机制，不同协议有自己的专线，就好像多了几条路一样。

-   全节点、归档节点、轻节点对比：
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-13-1768318447720-image.png)

-   使用链上数据的app就叫做dapp吗？
    

DApp的“D”（Decentralized，去中心化）指的是其核心逻辑和状态的控制权是去中心化的，其核心逻辑智能合约是不是在链上 的，其关键状态和资产也是储存在链上的。

-   DAPP可以理解为智能合约的可视化吗？
    

智能合约只是它核心中的一部分，它还包括去中心化验证和存储的功能。

-   一开始我在想DAPP是不是都是和金融相关的，只能做和金融相关的事，但又发现现在哪一个web2的应用不是有支付的接口呢，他们最大的区别还是存储数据的去中心化，一个在链上一个在服务器。
    
-   不想用公共的rpc就可以自己跑全节点，来获得你想要的状态信息。
    
-   以太坊怎么产生新的区块：在以太坊权益证明（PoS）机制下，系统每 12 秒通过随机算法选出一名验证者作为“提议者”来打包交易并生成新区块，随后由一组随机抽取的委员会成员对该区块进行投票验证，只要获得超过 2/3 的权重支持，该区块就会被永久记录在区块链账本上。
    
-   BEACON 信标：管理验证者：它是质押系统的账本。它记录了谁质押了32 ETH，谁在偷懒（离线），谁在作恶（被罚没资产），以及谁有资格参加接下来的出块抽签；分配任务： 它通过产生随机数，公平地决定哪个验证者在接下来的12秒内负责打包区块，以及哪些人组成委员会进行审查；维持共识： 它不处理具体的智能合约逻辑（那是执行层干的），它只负责同步各方的投票信号，确保全球成千上万个节点对哪一个区块是正确的达成统一意见。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->






-   什么是base费：每单位 Gas 的“协议强制最低价：由协议根据网络拥堵程度自动计算出来，所有交易都必须至少支付这部分费用；它不奖励给打包者/验证者，而是直接被销毁
    
-   为什么要摧毁base费，有三个原因：1) 防止验证者操纵“基础费”，让费用市场更干净，验证者只拿tip,激励单一，博弈更少；2）2) 锁定 ETH 的“货币属性”：只能用 ETH 付网络使用费，eth网络会一直消耗eth。3) 经济层面：用销毁对冲发行，降低通胀甚至形成通缩；
    
-   base费若给验证者博弈场景，验证者 A：故意少打包交易 → 当前区块偏空
    

让下一个区块 baseFee 降然后：在后续区块中多打包交易，从 baseFee 中获取更多收益

或者反过来：人为制造拥堵 → 推高 baseFee → 自己吃 baseFee 收益

-   什么是blob数据：简单理解主要是 Rollup 的批量交易数据/压缩后的 L2 数据，是一个**临时保险柜。**
    
-   **叔节点的奖励：挖矿奖励是每个区块3个以太币，叔节点的奖励如下：**
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-12-1768228753545-image.png)

只有**两个**叔节点能得到奖励，且叔节点是可以和爷爷节点同一个级别的，但由于叔节点的奖励是由**后代决定**的，也还是容易造成不公平分配。后代隔离的叔父倍数最多是**6倍**。叔父和后代要有共同的祖先(unclde reward)

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-12-1768228848240-image.png)

-   \- 叔父区块得不到gas费
    
    \- 包含叔父区块，但并不执行叔父区块里面的交易，叔父区块和父区块的交易会产生冲突
    
    \- 包含叔父区块，要检查区块是否是合法区块，是符合难度时挖出来的
    
    \- 叔父区块屁股的区块是得不到奖励的，要是有奖励的话会使分叉攻击的风险下降(就算不是最长链也能得到一点奖励)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
