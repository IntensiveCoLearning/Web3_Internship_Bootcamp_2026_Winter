---
timezone: UTC+8
---

# Twooweeks

**GitHub ID:** Twooweeks

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
中期总结：合约继承VRFComsumerBaseV2Plus,里面有一个s\_vrfCoordinator变量，变量中里面有requestRandomWords函数来与chainklinkVRF交互获得随机单词产生随机数，fulfillRandomWords接收产生的随机数，并采用自动化的方法，让整个合约可以自己发生

\- checkupkeep来定时检查，performupkekp到点执行

\- pure关键字的作用

![pure关键字.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-24-1769267637402-pure___.png)

\- `block` 这里表示的是一个 **全局内置对象**，它包含有关当前区块的各种信息，包括区块的时间戳、区块高度、矿工地址等。具体来说`block.chainid` 是 `block` 对象的一部分，它返回当前区块链的 **链ID**。

\- 什么时候要override

为什么必须 override?

因为接口中的函数是"抽象的"，必须由子合约实现。

Solidity的规则是:如果一个函数来自父接口/父合约，那你要实现它，就必须写 override否则Solidity无法确保你是正确地覆盖了一个父函数。

\- 什么时候要写\*\*mock\*\*，mock就是模拟合约进行，当你调用一些外部合约比如比如Chainlink VRF、外部oracle合约、第三方代币合约时，这些合约真实实现可能需要真实的区块链网络或其他资源，而模拟（mocking）它们则可以让你在本地测试合约的逻辑。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->


\- event是log中的一部分，日志的gas消耗很少

\- 构造函数不能被继承，只在部署函数的时候执行一次。父合约的构造函数不会自动执行，需要子类显示调用，即在子合约的构造函数中加入父合约的构造函数。

\- 继承合约中会有一些抽象函数，需要你要子合约中去实现

\- 如何实现随机数，手相向vrfchainlink发送请求，我们集成了随机数合约，随机数合约就能给我们调用函数调用外部chainlink产生随机数

\- 随机单词是chainlink产生的随机数的集合

\- 遵循check-effect-interation的设计模式以防止重入攻击：

**Check**：首先，合约检查所需的条件是否满足（例如，用户是否有足够的余额，是否满足执行条件等）。

**Effect**：然后，合约更新自己的状态（如转账金额、更新状态变量等）。

**Interaction**：最后，合约与外部系统或地址进行交互（如转账或调用外部合约）
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->



今天休闲玩了三关

![第二关.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-22-1769097172267-___.png)![第三关.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-22-1769097181069-___.png)![第一关.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-22-1769097187332-___.png)
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->




**V1**

(以 ETH 为中心)：V1 所有的代币池都必须是 **Token / ETH**。

\- 如果你想把 USDT 换成 USDC，系统必须先将 USDT 换成 ETH，再将 ETH 换成 USDC。

\- **代价：** 你需要付两次手续费，且面临两次滑点损失。

\## V2

**V2 (ERC-20 对 ERC-20)：** V2 允许创建\*\*任意两个 ERC-20 代币\*\*之间的流动性池（如 USDT/USDC, DAI/WBTC）。

\- **优势：** 减少了交易步骤，大幅提升了交易效率，降低了对 ETH 价格波动的依赖。

\- **V2 的改进：** 引入了 **“时间加权平均价格”（TWAP）**。它在每笔交易开始前（即上一个区块结束时）记录价格。黑客无法在同一区块内操纵这个记录，这使得操纵成本变得极高，极大地增强了 DeFi 生态的安全性。

\- 闪电交换：\*\* 允许你\*\*先从池子里拿走代币（不用付钱）\*\*，去其他地方执行套利或其他操作，只要你在\*\*同一笔原子交易\*\*结束前，把欠池子的钱（加一点手续费）还回来或者补足等值的另一种代币即可。

\- - **用闪电贷：** 你得先从 Aave 借 100 USDC -> 去 Uniswap 买 SOL -> 去 Raydium 卖 SOL 换成 110 USDC -> 还给 Aave 100 USDC。（去银行借钱）

\- **用闪电交换：** 你直接从 Uniswap 的 SOL/USDC 池子里“零本金”拿走1 个 SOL -> 去 Raydium 卖了换成 110 USDC -> 回到 Uniswap **付给它 100 USDC** 结账（去商店赊账）

\# v3

\- v3引入刻度的概念，而不是将你的资金分散到0到♾️，你可以引入区间，区间还可以集中流动性

\# v4

\- 将多个合约的流动池合并成一个合约，减少gas费，多个流动池可以通过钩子插入不同功能
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->





DEX学习

\# 交易解析

\## 解析前

\- 数据源：Helius、Ankr（数据提供商）

\- 数据获取：HTTP，Websocket（slot ）

\- 异步并发处理：数据提取/处理->解耦（channel）>生产消费者模型（携程监听）

\- 异常管理：1.丢块；2.解析异常；（落库➕重试）

\## 解析中

\- 首先是获取区块（判断是否为空区块，有没有我们需要的交易）

\- 调用api

\- 交易过滤

\- 指令过滤

\- 数据获取：（Anchor生成的IDL文件）

\- 元数据：token名称、图片地址、社交媒体信息...

\## 解析后

\- 落库（写表）：怎么做索引与表结构的设计

\- 优化（分表）：怎么继续表分类，比如说做TOP10、holder

\- redis：将热数据缓存

\# 交易构造

\## 构造前

\- 数据源的获取：各样的参数：买卖数据、优先费。防MEV、滑点的设计

\# 构造中

\- 构造方法：（交易数据结构）1.api调用；2.手写指令；

\- 交易核心特性：原子性（一个交易失败）+顺序性

\- 核心指令：优先费；jito；swap；ata；sol->wsol

\# 构造后

\- 交易签名

\- 交易上链（共享节点、自建节点（成本高））

\- 交易失败（自动滑点的设置）

\- 落库（表设计）

\# 知识补充

\- 交易的原子性一笔具有原子性的交易只有两种结果：

1\. **全部成功：** 交易中的每一个操作都顺利完成，修改被永久保存。

2\. **全部失败（回滚）：** 只要其中任何一个环节出了一点差错，整个交易都会“撤回”到还没开始前的状态，就像这笔交易从未发生过一样；

\- 1. 什么是“创建池子”交易 (Create Pool)

在代币能够被交易之前，必须先建立一个“储备金库”，这就是\*\*流动性池（Liquidity Pool）\*\*。

\- **含义：** 创建者（或系统）将一定数量的\*\*代币（Token）\*\*和等值的\*\*基础货币（通常是 SOL）\*\*存入一个智能合约中。

\- **作用：** **确立初始价格：** 存入的代币和 SOL 的比例决定了代币的初始开盘价。

\- **开启交易：** 有了这个池子，普通用户才能把 SOL 换成代币（买入），或把代币换回 SOL（卖出）。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->






今天是重拾solidity的第一天实在是太笨了自己，还是需要多多练习，才一个月很多东西都忘了差不多了，需要在这个实习计划中好好的学，把solidity捡起来，完成好入门技术的任务，试着去完成深度技术的任务。

今日笔记：

\- 版本的格式 pragma solidity >=0.8.18 <0.9.0,选择高版本的编译器可以兼容低版本的。

\- remix VM是一条虚拟链用于测试；

\- 变量、函数可见性分为四类，分别是:public:对外部和内部可见(为存储/状态变量创建一个getter函数);private:仅在当前合约中可见;external:仅对外可见(仅适用于函数)一一即只能通过this.func调用消息;internal:仅在内部可见

\- 函数还有两种状态，分别是view和pure，view函数\*\*只能\*\*从区块链上读取数据，pure函数可以更改区块链的状态。view和pure不改变区块链的状态，因此不消耗gas。但是调用view或者pure函数时，需要支付读取和调用这个检索函数的gas费用。

\- SOLIDITY对于结构体的定义与赋值与c语言一致；

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-19-1768836977255-image.png)

今天还把nft的任务做完了，明日继续加油

![3376d8e30bc46416a00928672b5e623f.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-19-1768837011858-3376d8e30bc46416a00928672b5e623f.png)![2b7500a8831abadbf4d9e43be12be7ea.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-19-1768837451578-2b7500a8831abadbf4d9e43be12be7ea.jpg)
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->








零知识证明

-   验证者V无需知晓证明者P所掌握知识的具体细节，仅通过持续向P提出针对性问题，就能验证P是否具备对应能力，而P在整个过程中只需证明自己拥有该能力，全程不泄露任何核心知识信息。这一原理可通过《阿里巴巴与四十大盗》的故事更直观地理解，其中两个经典场景恰好诠释了零知识证明的核心特质。
    
-   第一个场景是猜球验证。由于四十大盗都是色盲，无法分辨颜色，阿里巴巴需要向他们证明自己具备辨别球色的能力，同时又无需透露任何与辨色相关的额外信息。具体过程是，阿里巴巴先拿出一个红球和一个绿球，分别放到大盗的左手和右手中，之后大盗可自行决定是否交换手中的两个球，全程只有大盗自己清楚是否进行了交换。交换完成后，大盗将手中的球展示给阿里巴巴，阿里巴巴需准确判断出大盗是否交换过球——因为大盗明确自己是否交换，若阿里巴巴每次都能精准判断，就可证明他能辨别颜色，且全程没有泄露任何辨色的细节方法。需要注意的是，阿里巴巴必须从一开始就给出准确判断，若初始判断失误，会直接影响后续验证的有效性，导致大盗无法准确验证其能力。
    
-   第二个场景是开石门验证。故事中有一个环形山洞，设有A、B两个入口，两个入口之间隔着一道石门，只有掌握石门机关的人才能在山洞内自由穿梭于两个入口之间。验证时，阿里巴巴先随机选择一个入口（A或B）进入山洞并藏在石门后，随后四十大盗随机指定一个入口，要求阿里巴巴从该入口出来。若阿里巴巴真的掌握开启石门的方法，无论大盗指定哪个入口，他都能通过石门从指定入口顺利走出；若他不具备该能力，仅能从进入的入口走出，无法满足大盗随机指定的要求。通过多次重复这一过程，大盗无需知晓石门机关的具体原理，就能验证阿里巴巴是否掌握开启石门的能力，而阿里巴巴也始终没有泄露石门机关的任何细节，完美契合零知识证明“证明能力不泄露知识”的核心要求。
    
-   FOUNDRY学习
    
-   \- 找一个空文件夹 forge init
    
    \- 然后copy [https://github.com/Cyfrin/foundry-fund-me-cu/blob/main/src/FundMe.sol](https://github.com/Cyfrin/foundry-fund-me-cu/blob/main/src/FundMe.sol) 中的FundMe.sol 和 PriceConverter.sol
    
    \- 之后forge install smartcontractkit/chainlink-brownie-contracts
    
    \- homl文件中\*\*重新映射\*\*
    
    remappings = \[
    
    "@chainlink/contracts/=lib/chainlink-brownie-contracts/contracts/",
    
    "forge-std/=lib/forge-std/src/"\]
    
    \- 然后就可以forge compile了，按理来说编译完就没事了，但是我之前编译的时候说我有很多库没安装，我照着豆包安装一下，又重新compile就可以了，在forge init就有个默认的的Counter.col在src里，先不要删，因为compile的时候会先test，test测试的就是Counter.col
    
    \- 现在是编写FundMe.t.sol
    
    \- 测试文件和部署文件的编写，然后是forge test的讲解，怎么测试部署在其他链上
    
    \- 接着是怎么样部署在本地链上（anvil）
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->









第六章 共识机制与生态展望

-   在一开始以太坊就采用pow机制，彼时pos还处于实验室阶段，虽用的是语比特币相似的pow，但是以太坊在一开始就将挖矿能力ASIC转到GPU，使人人可挖矿，且以太坊一开始不会受大型ASIC拿捏。
    

1\. 长程攻击 (Long-Range Attack)

这是 PoS 共识机制特有的一种安全威胁。

定义：攻击者从区块链很久以前的一个区块（甚至从创世区块）开始，秘密地分叉出一条并行的长链。由于 PoS 不需要像 PoW 那样消耗真实的电力（算力），攻击者可以在极短的时间内“伪造”出一条包含大量区块的长链。

攻击手段：攻击者通过获取早期大量持有代币的私钥（可能是由于这些私钥已经过期或被卖出），在后台制造出一条看起来比主链更长的“合法”历史记录。

防御机制：网络会定期锁定状态，节点不接受回滚到太久远之前的分叉。

2\. 惰性攻击 (Liveness Attack / Inactivity)

这通常指验证者未能履行其职责，导致网络无法达成最终一致性。

定义：当大量验证者因为技术故障（如服务器宕机、断网）或恶意合谋，拒绝参与区块的投票和确认时，网络就会陷入“惰性”。

后果：如果超过 1/3 的验证者离线，以太坊网络就无法达成最终确定性（Finality），这意味着交易的安全确认会停滞。

应对方案：以太坊引入了不活跃惩罚机制。如果网络由于验证者不给力而无法结案，系统会自动削减那些离线验证者的余额，直到他们的权重降低到足以让在线验证者重新达成共识为止。

3\. 经济惩罚 (Slashing / Economic Penalty)

这是 PoS 维护纪律的“大棒”，旨在让违规成本远高于收益。

定义：当验证者表现出明显的恶意行为（而非简单的离线）时，系统会强制扣除其质押的 ETH 资产。

触发条件：

双重投票：在同一个高度为两个不同的区块投票。

环绕投票：试图修改已经提交的历史记录。

惩罚力度：

初始扣减：立即扣除一部分质押金。

强制退出：取消该验证者的资格。

关联惩罚：如果同一时间内有大量验证者同时违规（暗示是大规模合谋），惩罚金额会呈指数级增长。

-   ≥32eth就可以质押成为验证者，以太坊越多的人，那么它提议的概率也就越大，它打包区块的可能性也越大，那么它将会越来越有钱。
    
-   THE MEERGE主网继续保留原来的历史与状态，但把“谁来出块/投票决定链头”的权力，从 PoW 矿工切换为信标链上的 PoS 验证者。
    
-   共识客户端 收到新的 Beacon block → 取出 ExecutionPayload → 用 engine\_newPayload 让 执行客户端 复算；执行客户端 返回 VALID/INVALID；VALID 才会被 共识客户端 接入并投票支持。
    
-   rollup打包的信息原来放在calldata很贵，现在放在blob中，可blob是临时数据，那我打包的交易不都没了吗？
    

我们放在blob的数据是B。

A. 永远保留在链上的“小信息（元信息）”是什么？

这些像 快递单：不包含箱子里每件物品的细节，但包含能“对得上号”的关键信息，必须永久留在链上，否则以后没法证明这批数据对应的结果。

在 Rollup 的 L1 交易里，常见会永久保留：

batchCommitment（指纹/哈希）：这相当于快递单上的“封条编号/防伪码”。以后你拿到箱子里的内容，算一次哈希，看是不是等于这个编号，就能验证“内容没被换”。

newStateRoot（新状态根）：这相当于快递单上写“收货后仓库库存应该变成哪个总账摘要”。它是对“执行结果”的一个摘要。

batchIndex / 引用：

比如“这是第 105 批”。相当于快递单的单号。

这些东西都很小（几十到几百字节量级），链上永久存：因为它们是“公证记录”。

B. “很大的数据载荷（交易数据本体）”是什么？

这像 快递箱里的具体物品清单：每件物品是什么、数量多少、怎么摆放……对应到 Rollup，就是：

这 3 笔交易的具体内容：谁给谁转多少、签名、nonce、可能还有压缩编码等

甚至一大批可能是几千笔/几万笔交易

这部分会非常大：可能是 几十 KB、几百 KB（视 batch 大小而定）。

以前它只能放在 L1 交易的 calldata 里（贵）；

现在可以放到 blob 里（更便宜）。blob 就是“这笔 L1 交易随身带的一个大附件/大箱子”，专门用于公开数据给大家下载验证。

-   流动质押与再质押
    

流动质押等于你质押eth然后给你一个代币比如说LST，你可以拿LST去质押借贷，做其他事情。再质押就是lst还可以拿去质押，然后给你一个代币比如说avs，你又可以拿avs去干其他的金融活动。我感觉这风险性也太大了，这感觉之时吸引更多人玩金融的游戏。

-   如果区块主要由少数 builder/relay 控制，他们可能统一选择“不打包这类交易”（链上出现事实审查）。
    

The Scourge 想做的是：

用 PBS/ePBS 降低单一 builder/relay 的垄断与审查点；

用 MEV-burn/捐赠削弱 MEV 寡头化的经济驱动；

用轻客户端/Verkle 让更多验证者可以独立参与，不被迫依赖少数中介。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->











第四章学习

-   evm不能随便调用外部的数据，可以调用通过oracle上链的数据，防止破坏共识。
    
-   opcode为bytecode最基本的构成，与汇编语言类似
    
-   为什么审计时，要细致到opcode代码，首先编译器有时候为了编译效率会调整opcode的执行顺序，我们需要知道当前状态和各项指标是否在安全的范围；合约中的有循环，通过逐行看opcode也能更好的算gas，攻击者可能利用特殊构造的gas炸弹，导致合法用户的交易无法成功，逐行opcode也可以更好定位gas炸弹。监控内存和堆栈的实时情况；在合约间相互调用的时候，防止存储位置不一致
    
-   gas的放攻击角度的设计，有gaslimit，你只能在规定的gas费用下执行步数，每一步的basegas都还是挺大的，创建合约的价格也变高防止大量创建合约，不同的opcode重新定价，以防操作定价过高或过低，过低操作被大量重复调用来攻击。
    
-   out of gasllimit会导致交易回滚，但是你的合约不会上链，只留下一条交易失败的记录，而且还是会扣你的gas
    
-   gas优化external参数优先 calldata;重复使用的storage先缓存到memory;mapping+索引，而不是大数组暴力遍历。多用mapping+索引，而不是大数组暴力遍历。合约结构上：引入代理/模块化/库，减少代码重复;利用constant/immutable存放不会改的配置;使用transientstorage存短期状态。避免不受控长度循环;能off-chain算的别on-chain算;慎用unchecked，用好短路逻辑和位运算。
    
-   当前能搬到L2的逻辑就尽量放到 Rollup 上，让主网只做“结算层”。可理解为让主网只做结算的工作，l2定期向主网提交证明。
    
-   常量不占storage的空间，在编译的时候直接嵌入合约的可执行代码（字节码）当中
    
-   节省gas的小技巧，storage变量都用s\_表示，在function开头将s\_变量用常量表示，这样不用每次都从storage中提取s\_变量
    

单词背诵：

![b59393729fa85b39750a644115b10c33.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-16-1768577614592-b59393729fa85b39750a644115b10c33.jpg)
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->













其实我有点迷茫，即将研二下学期，秋招就要来了，自己不确定在半年的开发学习中能不能找到一个web3的工作，每天茫茫多的信息扑面而来，自己现在也是想着走一步看一步，没有什么计划，还有就是学习rust开发，eth好像只能做solidity相关的智能合约开发，不管哪一个门槛都有点高，先干着吧，在这个web3实习期间也多多调研，今天co-learning也是自己第一次co-leanring听到一个巨好的例子，每天都接收到茫茫多信息，自己怎么知道哪些是自己需要的信息呢，老师举了个例子，刚开始开车的时候我们笨手笨脚的，可在进化成老司机后，我们就能获取到正确的道路信息去帮助我们驾驶，所以说还是得多练多调研，去丰富自己的认知。

-   creation bytecode和runtime bytecode的区别是什么？
    

creation bytecode含构造函数，给你一份说明说把椅子拼起来，过程只发生一次。

runtime bytecode不含构造函数，他就是装好的椅子，可执行多次，且存储在链上

-   部署交易哈希是什么？
    

相当于一个收据单号可以查询部署过程、状态、手续费，也可以查询到你的合约地址。

-   receive（）：用于收没有指令的钱；
    
-   修饰符的使用举例（在函数后面添加具体修饰符即可）：
    

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract MyContract {

address public owner;

constructor() {

owner = msg.sender; // 部署合约的人是管理员

}

// — 1. 定义修饰符 —

modifier onlyOwner() {

// 检查调用者是不是管理员

require(msg.sender == owner, “You are not the owner!”);

\_; // <— 重要！这里代表执行原函数的代码

}

// — 2. 使用修饰符 —

// 只有管理员能修改这个数值

uint public data;

function updateData(uint \_newVal) public onlyOwner {

data = \_newVal;

}

// 只有管理员能把钱提走

function withdraw() public onlyOwner {

payable(owner).transfer(address(this).balance);

}

}

-   原来solidity在整数溢出会“绕回” （wrap），即当数字增加到最大值后再加 1，它不会变成更大的数，而是直接归零，0-1直接变成255，现在不会了，检测到溢出会revert（）；
    
-   ZK Rollup：它的核心是“不信任”，不依赖于任何人的诚实。每次将一批交易（称为“批次”）发布到主网时，都必须附上一个零知识证明。主网合约只需要验证这个小小的证明，就能确信这批交易的所有计算都是正确执行的，就像完成了“数学上的绝对验算”。就那bitcion来说，轻节点可以通过全节点给出最少的，必需的信息，使得轻节点可以再通过merkle header来验证哈希值的·合法性。
    
-   web3与ai结合例子，web3给ai agent做身份证，用于监管ai的行为。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->















课堂分享：1，求职，一定要清楚项目方在国内是否有业务，可以看是否能用大陆的资料进行注册，不要只是ip的封禁；还要看是否有合法的拍照；合约、期权之类的开发不要碰。

搞懂eoa和合约账户的互动形式：

-   智能合约的地址形式：create：由你的地址+nonce决定；create2：同样的盐值（salt）可以使不同链上的合约地址一致。
    

-   为什么使用create2可以提前算出智能合约的地址，甚至合约此时还没上链：create2又四部分组成0xFF： 一个固定的常量前缀。部署者地址：谁来发起部署（通常是你的钱包或工厂合约地址）。盐值（Salt）：自己选的一个32位随机数。合约代码哈希： 你要部署的合约代码（Bytecode）计算出的指纹。四个部分已知就能算出地址。
    

-   智能合约(自动售货机)是没有私钥的，且部署上链是gas花费较高的一个操作，且不能主动发起外部交易。
    

-   每一个合约都有一个存储树用来记录一些关键的状态（例如用户的余额，资产的管理账户）。
    
-   传统的交易是你发送一份交易到池子里然后旷工打包，4337后有UserOp的概念，你可以构造并签名一个UserOp，然后发送到专门的Alt Mempool里，然后BUNDLER会把几个UserOp打包到一起当做是一个普通的交易；好处是，UserOp可以指定别人帮你付gas，callData可批量完成授权 + 交易 + 质押。UserOp还可以有社交恢复的功能，可通过守护者的签名证明你的身份。
    
-   以太坊中自己一个状态树，其它代币（ERC-20）又智能合约中的状态树决定，你账户上的余额是查这些合约的状态树找到的。
    
-   现在不能用SELFDESTRUC来直接删合约，除非该合约在同一个交易中被创建和删除，现在SELFDESTRUC只能把你里面的eth转走，为防止合约出问题，常见的方式用代理合约，代理合约指定的逻辑地址出问题时，你可以重新写一个合约，然后代理合约指向这个新地址，其次你可以在合约中加入暂停的功能，以防出错。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
















-   客户端是由软件实现的，相当与一个软件，节点是运行客户端的电脑，客户端又分执行客户端和共识客户端，若一个电脑跑着执行客户端和共识客户端则代表它是一个全节点（仅仅以太坊，比特币的全节点就一个客户端负责着交易验证、脚本执行和工作量证明共识规则验证的功能）。
    
    ![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-13-1768318550674-image.png)
-   多种子协议：你现在有多份不同版本的拼图说明书。它们描述的是同一个最终图案（你要下载的文件），但可能把拼图分成了不同大小、不同形状的碎片。你可以同时从多个卖家社区（多个Swarm）里收集碎片，速度大大提升，并且如果一个社区没人了，你还能从其他社区继续。
    
-   RLPx = 在一条 TCP 线上开很多“分机”是可以理解为，在一条线上传的的数据通过不同的报文达成不同的协议，还是说是在一条线上划出不同的路，然后不同路跑不同的协议。
    

路还是只有一条RLPx相当于一个管理机制，不同协议有自己的专线，就好像多了几条路一样。

-   全节点、归档节点、轻节点对比：
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-13-1768318447720-image.png)

-   使用链上数据的app就叫做dapp吗？
    

DApp的“D”（Decentralized，去中心化）指的是其核心逻辑和状态的控制权是去中心化的，其核心逻辑智能合约是不是在链上 的，其关键状态和资产也是储存在链上的。

-   DAPP可以理解为智能合约的可视化吗？
    

智能合约只是它核心中的一部分，它还包括去中心化验证和存储的功能。

-   一开始我在想DAPP是不是都是和金融相关的，只能做和金融相关的事，但又发现现在哪一个web2的应用不是有支付的接口呢，他们最大的区别还是存储数据的去中心化，一个在链上一个在服务器。
    
-   不想用公共的rpc就可以自己跑全节点，来获得你想要的状态信息。
    
-   以太坊怎么产生新的区块：在以太坊权益证明（PoS）机制下，系统每 12 秒通过随机算法选出一名验证者作为“提议者”来打包交易并生成新区块，随后由一组随机抽取的委员会成员对该区块进行投票验证，只要获得超过 2/3 的权重支持，该区块就会被永久记录在区块链账本上。
    
-   BEACON 信标：管理验证者：它是质押系统的账本。它记录了谁质押了32 ETH，谁在偷懒（离线），谁在作恶（被罚没资产），以及谁有资格参加接下来的出块抽签；分配任务： 它通过产生随机数，公平地决定哪个验证者在接下来的12秒内负责打包区块，以及哪些人组成委员会进行审查；维持共识： 它不处理具体的智能合约逻辑（那是执行层干的），它只负责同步各方的投票信号，确保全球成千上万个节点对哪一个区块是正确的达成统一意见。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


















-   什么是base费：每单位 Gas 的“协议强制最低价：由协议根据网络拥堵程度自动计算出来，所有交易都必须至少支付这部分费用；它不奖励给打包者/验证者，而是直接被销毁
    
-   为什么要摧毁base费，有三个原因：1) 防止验证者操纵“基础费”，让费用市场更干净，验证者只拿tip,激励单一，博弈更少；2）2) 锁定 ETH 的“货币属性”：只能用 ETH 付网络使用费，eth网络会一直消耗eth。3) 经济层面：用销毁对冲发行，降低通胀甚至形成通缩；
    
-   base费若给验证者博弈场景，验证者 A：故意少打包交易 → 当前区块偏空
    

让下一个区块 baseFee 降然后：在后续区块中多打包交易，从 baseFee 中获取更多收益

或者反过来：人为制造拥堵 → 推高 baseFee → 自己吃 baseFee 收益

-   什么是blob数据：简单理解主要是 Rollup 的批量交易数据/压缩后的 L2 数据，是一个**临时保险柜。**
    
-   **叔节点的奖励：挖矿奖励是每个区块3个以太币，叔节点的奖励如下：**
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-12-1768228753545-image.png)

只有**两个**叔节点能得到奖励，且叔节点是可以和爷爷节点同一个级别的，但由于叔节点的奖励是由**后代决定**的，也还是容易造成不公平分配。后代隔离的叔父倍数最多是**6倍**。叔父和后代要有共同的祖先(unclde reward)

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Twooweeks/images/2026-01-12-1768228848240-image.png)

-   \- 叔父区块得不到gas费
    
    \- 包含叔父区块，但并不执行叔父区块里面的交易，叔父区块和父区块的交易会产生冲突
    
    \- 包含叔父区块，要检查区块是否是合法区块，是符合难度时挖出来的
    
    \- 叔父区块屁股的区块是得不到奖励的，要是有奖励的话会使分叉攻击的风险下降(就算不是最长链也能得到一点奖励)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
