---
timezone: UTC+8
---

# lynn

**GitHub ID:** skelitalynn

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->
![Gas优化.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/skelitalynn/images/2026-01-23-1769180449447-Gas__.png)
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->

今天主要学习了TypeScript的基本语法

![TypeScript-1基础篇.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/skelitalynn/images/2026-01-22-1769087732888-TypeScript-1___.png)
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->


![Uniswap工作原理0121.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/skelitalynn/images/2026-01-21-1769009851233-Uniswap____0121.png)
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->



\# Solidity 笔记总结（进阶与 ERC20 / EVM 篇）

\## 一、EVM 与智能合约运行环境

\### 1. EVM 的本质

EVM 是以太坊生态中所有智能合约的运行环境，本质是一个\*\*栈式虚拟机\*\*。

Solidity 编写的代码最终都会被编译为 EVM 字节码，在 EVM 中按指令顺序执行。

理解 EVM 是理解 Solidity 性能优化、安全问题和存储设计的前提。

\---

\### 2. EVM 的四大执行区（存储区）

\#### Stack（栈）

\- EVM 采用栈式执行模型

\- 操作数和指令按顺序入栈、出栈执行

\- 用于计算，不存储长期数据

\#### Storage（链上存储）

\- 合约的\*\*永久存储区\*\*

\- 所有状态变量最终都存储在 storage

\- Gas 成本最高，是合约优化的核心关注点

\#### Memory（运行时内存）

\- 函数调用期间使用

\- 生命周期仅限一次调用

\- 不上链，成本低于 storage

\#### Calldata（调用数据）

\- 外部调用合约时传入的参数

\- 只读

\- 常用于 external 函数参数

类比理解：

\- storage 类似硬盘

\- memory / calldata 类似运行时内存

\---

\## 二、Gas 成本与合约优化核心

Gas 成本主要来自 **storage 的读写**：

\- 第一次写入 storage：约 20,000 gas

\- 修改已有 storage：约 5,000 gas（量级）

优化目标：

\- 尽量少存

\- 尽量少改

\- 减少不必要的 storage 读写

\---

\## 三、Solidity 开发环境与版本意识

\- 推荐使用 Remix 作为学习和调试工具

\- 支持私有链、编译、部署和调试

\- 可查看 memory / storage 变化

Solidity 版本更新频繁：

\- 不同版本在安全机制和内存管理上有差异

\- 教学以 ^0.8.20 为基准

\- 阅读协议源码时必须关注 Solidity 版本

\---

\## 四、Solidity 数据类型体系

\### 1. 值类型（Value Types）

直接存值，存储成本相对较低：

\- bool

\- int / uint（支持不同位宽，位宽越小越省 gas）

\- address（有类型校验，不要用 string 存地址）

\- bytes32（常用于定长非地址数据）

\### 2. 引用类型（Reference Types）

存储的是引用，通常更消耗 storage：

\- string

\- 动态数组

\- bytes / bytes\[\]

\- mapping

mapping 常用于账本结构：

\- address => uint：余额

\- address => address => uint：授权关系

\---

\## 五、ERC20 合约的核心结构设计

\### 1. ERC20 的定位

ERC20 是以太坊代币的标准接口规范。

满足该标准的合约具备通用的代币能力。

\### 2. 核心链上存储数据

以下数据必须存储在 storage：

\- name：代币名称

\- symbol：代币符号

\- decimals：精度（链上无浮点数）

\- totalSupply：总发行量

\- owner：合约拥有者

\### 3. 账本结构

ERC20 的两本核心账本：

\- 余额账本`mapping(address => uint256) balances`

\- 授权账本`mapping(address => mapping(address => uint256)) allowance`

\---

\## 六、Constructor 与初始化逻辑

constructor 在合约部署时执行：

\- 接收部署参数

\- 初始化 name / symbol / decimals

\- 设置 owner = msg.sender

\- 可在构造函数中直接 mint 初始代币

纯工具型合约可以不写 constructor。

\---

\## 七、函数设计与可见性

\### 1. 函数可见性

\- external：外部调用

\- public：内外皆可

\- internal：合约内部

\- private：仅当前合约

\### 2. 状态可变性修饰符

\- view：读取链上状态但不修改

\- pure：既不读也不改链上状态

\---

\## 八、ERC20 核心方法逻辑

\### totalSupply

\- 只读方法

\- 使用 view

\- 返回 uint256

\### balanceOf

\- 读取 balances mapping

\- 参数为 address

\- 返回余额

\### transfer

\- 参数：to、amount

\- external 方法

\- 不使用 view / pure

\- require 校验：

\- amount > 0

\- to 不是零地址

\- 余额充足

\- 更新余额账本

\- emit Transfer 事件

\### approve

\- 修改授权账本 allowance

\- emit Approval 事件

\- dApp 交互的第一步

\---

\## 九、事件（Event）与链上日志

事件用于链上到链下同步：

\- Transfer

\- Approval

\- Mint

特点：

\- 可 indexed（最多三个）

\- DEX 等协议主要依赖事件，而非频繁读取 storage

\- 事件是链下系统确认状态变更的主要方式

\---

\## 十、Mint 与 internal / external 分层设计

常见设计模式：

\- external 函数负责权限校验

\- internal 函数负责状态变更

mint 通常设计为 internal：

\- 防止任何用户随意铸币

\- 外部接口通过权限控制调用 internal mint

\---

\## 十一、Remix 中的编译、部署与调用

\- 编译：检查语法与逻辑错误

\- 部署：

\- 合约代码 → 字节码 → 链上

\- constructor 在部署时执行

\- 调用：

\- view / pure 不消耗 gas

\- 写操作需要交易和 gas

\- 私有链模式适合快速调试

\---

\## 十二、错误与回滚机制

\- require：条件校验 + 字符串错误信息（gas 较高）

\- revert：主动回滚，可配合自定义 error

\- assert：逻辑上不应失败的断言，失败消耗全部剩余 gas

推荐：

\- 使用自定义 error 替代字符串，节省 gas

\---

\## 十三、unchecked 与溢出检查

\- Solidity 0.8+ 默认开启溢出检查

\- unchecked 可跳过检查，节省少量 gas

\- 初学阶段不建议使用

\---

\## 十四、modifier（修饰符）机制

modifier 用于抽象前置条件：

\- 将 require 逻辑集中复用

\- 常见：onlyOwner、重入保护

\- 降低重复代码与部署成本

\---

\## 十五、助记词陷阱与抢跑机制

常见两类风险：

1\. 合约层限制

\- 使用 modifier 限制转账权限

\- 表面有余额，实际无法转出

2\. 抢跑 Bot

\- 监听交易或事件

\- 检测到转入 gas 后，用更高 gas 抢先转走

\- 本质是链上可见性 + 优先级机制

\---

\## 十六、EVM 执行模型与安全问题

\- EVM 是单线程、顺序执行

\- 不存在 Web2 意义上的并发

\- 主要风险是\*\*重入攻击\*\*

\- 通过重入锁或 modifier 防护
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->




# Solidity 学习笔记

## **一、基础语法与核心概念**

### 1\. 合约与函数

-   `contract`：合约，类似 Python 的 class
    
-   `function`：函数
    

### 2\. 函数可见性（访问权限）

-   `public`：合约内外都可调用
    
-   `external`：只能被外部账户或其他合约调用，**合约内部不能调用**，更省 Gas
    
-   `internal / private`：合约内部使用（本笔记未展开）
    

* * *

## **二、函数修饰符：pure / view / 无修饰**

判断顺序（从严格 → 宽松）：

NaN.  是否**修改状态变量**
      
      -   是 → **不能用** `pure` **/** `view`
          
NaN.  是否**读取状态变量**
      
      -   是 → `view`
          
NaN.  是否只使用**局部变量或参数**
      
      -   是 → `pure`
          

总结：

-   改状态：无修饰
    
-   读状态不改：`view`
    
-   只计算不上链：`pure`
    

* * *

## **三、状态变量 vs 局部变量**

-   **状态变量**
    
    -   存在于区块链上
        
    -   合约不销毁就永久存在
        
    -   修改需要 Gas，且不可逆
        
-   **局部变量**
    
    -   仅在函数执行期间存在
        
    -   不上链，不消耗存储 Gas
        

Solidity 特点：

-   函数内可直接读写状态变量
    
-   不需要像 Python 那样声明 `global`
    

* * *

## **四、基础数据类型与默认值**

-   `bool`：`false`
    
-   `uint / int`：`0`
    
-   `address`：`0x0`
    
-   `bytes32`：`0x0...0`
    

所有类型都有**默认值**，未赋值 ≠ 不存在。

* * *

## **五、Gas 优化：constant 常量**

-   使用 `constant` 定义的变量：
    
    -   不占用存储
        
    -   读取更省 Gas
        
-   只读函数本身不消耗 Gas
    
-   **在写函数中读取变量仍然消耗 Gas**
    
-   在写函数中读取 `constant` 比普通状态变量省很多 Gas
    

* * *

## **六、流程控制**

### 1\. 条件判断

-   `if / else`
    
-   三元表达式 `condition ? a : b`
    
-   与传统语言逻辑一致
    

### 2\. 循环

-   `for / while`
    
-   ⚠️ 区块链中循环 = 钱
    
-   禁止 `while(true)`
    
-   必须限制最大循环次数
    

* * *

## **七、错误处理机制**

### require

-   条件成立 → 继续执行
    
-   不成立 → 抛错 + 回滚 + 退还剩余 Gas
    
-   用途：校验外部输入 / 前置条件
    

### revert

-   命中“错误条件” → 主动抛错
    
-   写法类似 `if + throw`
    
-   适合复杂判断逻辑
    

### assert

-   用于校验**内部不变量**
    
-   失败代表合约存在 Bug
    
-   不退还剩余 Gas
    
-   不用于校验外部输入
    

总结：

-   `require`：防用户
    
-   `revert`：控流程
    
-   `assert`：查 Bug
    

* * *

## **八、自定义错误（Solidity 0.8+）**

```
error MyError(address caller, uint value);
revert MyError(msg.sender, _i);
```
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->





# Web3求职分享会笔记——技术岗

**一、总体认知**

总体分为三类：

NaN.  智能合约 / 协议开发（偏底层，门槛最高）
      
NaN.  链上应用 / 后端工程（最适合 Web2 后端转入）
      
NaN.  安全 / 基础设施 / 工具链方向（偏中高级）
      

当前市场的真实情况：初级Solidity开发严重饱和，很多Web3项目 70% 代码仍然是 Web2 后端，知识数据可信性、资产逻辑、权限模型发生了变化。

## **二、我的个人情况**

我的技术栈是java、python，之前主要做后端开发，现在正在转agent开发。对我来说，我不用all in写合约，现在对我来说更稳健的路线是：Web2 后端 → Web3 后端 → 合约协作开发。

## **三、技术岗隐形门槛**

### 1，Github

-   真实代码
    
-   持续提交
    
-   参与Web3项目或工具
    

### 2，链上记录

-   真实用过DeFi
    
-   参与测试网
    
-   和真实合约交互
    

### 3，英文+自学能力

-   雅思
    

### 四、学习方向

### 1，Github项目

链上数据同步服务

-   监听链上 Event / Transaction
    
-   将链上数据同步到数据库
    
-   提供查询 API（地址、交易、资产等）
    

带钱包登录的 DApp 后端

-   钱包签名登录（Signature Login）
    
-   地址 ↔ 用户体系映射
    
-   基础权限与业务接口
    

简单 DeFi / NFT Demo

-   简单合约（Mint / Swap / Stake 任一即可）
    
-   后端配合合约完成完整流程
    
-   不追求复杂功能，追求结构完整
    

### 2， Web3 工程能力

-   链上事件监听（Event / Log）
    
-   异步任务 & 数据一致性
    
-   幂等性、防重复处理
    
-   钱包地址作为身份体系
    
-   资产相关逻辑的安全处
    
-   Web3 SDK / RPC 使用
    

## **五、接下来四周的学习与实践规划**

### 第 1 周：Web3 后端最小工程骨架 + 链上数据理解

主要投入方向：

-   系统性理解一次完整链上交易的生命周期： 从交易发起 → 上链 → 事件产生 → RPC 获取 → 本地处理
    
-   熟悉主流 RPC、Web3 SDK 的使用方式（以 EVM 链为主）
    
-   搭建一个最基础的后端工程骨架（Java / Python ），包含：
    
    -   基础项目结构
        
    -   RPC 连接
        
    -   简单的链上数据查询（区块 / 交易 / Receipt）
        

### 第 2 周：链上数据同步服务

重点是做一个**链上数据同步服务 Demo**。

核心任务包括：

-   监听链上 Event / Transaction（指定合约或指定地址即可）
    
-   将关键数据同步到本地数据库
    
-   处理基础的工程问题：
    
    -   异步任务
        
    -   幂等性（防止重复处理同一笔交易）
        
    -   简单异常处理与重试逻辑
        

这一周结束时，希望我能：

-   在 GitHub 上提交一个清晰的、可读的 Web3 后端项目
    
-   在 README 中说明：
    
    -   项目做什么
        
    -   架构设计思路
        
    -   哪些地方是 Web3 特有的问题
        

### 第 3 周：钱包签名登录 + Web3 身份模型

-   钱包签名登录流程（Signature Login）
    
-   地址 ↔ 用户体系的映射设计
    
-   理解并实现：
    
    -   为什么 Web3 不需要传统账号密码
        
    -   如何防止签名重放
        
    -   地址即身份带来的权限模型变化
        

### 第 4 周：简单合约协作 + 项目整理与输出

主要任务：

-   写或复用一个合约（Mint / Stake / Swap 任一）
    
-   后端配合合约完成一次完整业务流程
    
-   对前 3 周的项目进行整理：
    
    -   补充文档
        
    -   重构混乱代码
        
    -   明确哪些是“展示用核心能力”
        

如果时间允许，可以：

-   写一篇技术总结（博客或 X / Notion）
    
-   明确哪些内容可以直接写进简历
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->






![第一次例会.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/skelitalynn/images/2026-01-16-1768578807139-_____.jpg)
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->







![AI及其基础概念.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/skelitalynn/images/2026-01-15-1768491304447-AI______.jpg)
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->








今天的学习内容明显比前几天要“现实”很多，也让我心态发生了一些变化。这一部分不再是讲 Web3 有多前沿、多有想象力，而是直接把合规和刑事风险摆在台面上，告诉你：这个行业不是踩在真空里运行的，一旦和钱、用户、跨境流动产生关系，就一定会被现有法律框架审视。

我之前对“大陆 Web3 合规”的理解，其实是模糊的，总觉得它处在灰色地带，规则不清晰就意味着有操作空间。但今天听完之后才意识到，真正的风险恰恰来自这种“不清晰”。在大陆，很多 Web3 行为并不会等专门的区块链法律出台，而是直接用非法集资、非法经营、帮信罪、洗钱相关条款来套。一旦被定性，讨论你是不是“技术创新”基本没有意义，更多看的是资金流向、参与角色和实际后果。关于发币和融资的部分，对我冲击很大。无论是 ICO、IEO 还是各种 Meme Coin，只要涉及向不特定对象募集资金，本身就站在极其危险的位置。项目是不是开源、愿景写得多宏大，在法律判断中并不是关键，关键是有没有公开募资、有没有收益预期、有没有资金盘或跑路的风险。一旦踩线，责任往往不是只落在“发起人”身上，连技术开发、协助推广、早期参与的人都可能被追责。这让我第一次认真思考：很多所谓的“早期红利”，本质上是风险高度集中在个体身上的。

中心化交易所、托管和出入金相关的风险，也让我对“合规”这个词有了更清醒的认识。表面上看，CEX 好像比 DeFi 安全、正规，但一旦涉及资金托管、法币通道、跨境转移，就不可避免地进入反洗钱和外汇监管的核心地带。在大陆背景下，只要被认定为协助资金转移、掩盖来源，即使只是“按流程操作”，也可能被认定为帮信或洗钱。这让我意识到，Web3 里并不存在真正意义上的“纯打工人安全区”。

个人层面的风险同样真实。无论是用卡、U 卡、跑分、代收代付，还是撸毛、空投，只要资金路径复杂、不透明，就很容易被风控。账户冻结之后，往往不是一句“我没干坏事”就能解决，而是需要长时间自证，成本极高，结果还不一定理想。这些细节让我明白，Web3 给了个人更多自由，同时也把风险和责任原封不动地压回到个人身上。

在就业和职业选择上，这节内容也让我更冷静。高薪、远程、币薪听起来很诱人，但背后往往是合同不清晰、劳动关系模糊、维权困难。一旦出现纠纷，很难用传统方式解决。有些岗位在大陆语境下本身就处在合规边缘，即使技术本身没问题，也可能因为业务属性整体被否定。

整体学下来，我最大的感受不是恐慌，而是“清醒”。Web3 并不是一个可以只靠热情和技术往前冲的行业，它对风险判断的要求甚至高于很多传统领域。如果我真的要往这个方向继续走，就不能只盯着机会、叙事和收益，而是要主动理解规则、识别红线、学会自我保护。这节课算是给我泼了一盆冷水，但也是很有必要的一盆。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->









今天的学习让我对 Web3 的运行原理有了一个更清晰、也更现实的认识。相比之前停留在概念层面的理解，这次更多是在理解“它到底是怎么跑起来的”。从钱包生成、私钥和助记词开始，我第一次真正意识到安全并不是一句口号，而是使用 Web3 的前提条件。私钥一旦泄露，资产几乎不可追回，这种“完全自我负责”的模式既赋权，也极度考验个人的安全意识。

在交易和签名部分，我逐渐理解了为什么区块链交易不可篡改却又需要等待确认时间。交易不是发出去就立刻“绝对安全”，而是要经过广播、打包、共识，直到区块被最终确认。这让我意识到，Web3 在设计上更追求系统整体的可信，而不是单次操作的即时性。Gas 机制和抢跑原理也让我看到，所谓“去中心化”，依然是一个用经济激励来约束行为的系统。

对区块、节点、共识机制的理解，让我开始从“系统工程”的角度看 Web3。无论是 PoW 还是 PoS，本质都是在不信任环境下寻找一个大家都能接受的规则。节点的地理分布、客户端的多样性、质押和惩罚机制，都是为了降低单点失效和作恶的概率。这种设计思路让我感觉，Web3 并不是单纯的技术创新，而是技术、经济和治理的结合体。

最后，对智能合约和以太坊升级机制的了解，也让我对“代码即规则”这句话有了更深的体会。规则写进合约，就意味着透明、可验证、难以随意更改，但同时也要求设计时足够谨慎。整体来看，这次学习让我不再把 Web3 简单理解为“炒币”或“风口”，而是把它当成一个仍在演进、但逻辑自洽的基础系统。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->










今天的学习让我第一次比较系统地把 Web3 行业全面地去理解，而不再只是零散地听概念、追热点。最直观的感受是，Web3 并不是一个突然出现的新东西，而是经历了从比特币到以太坊、再到 DeFi、NFT、L2、合规化这一整条清晰演化路径。这样回头看，很多曾经觉得“炒作味很重”的方向，其实都有各自出现的时代背景和技术原因。

在行业现状和求职部分，我的心态也发生了一些变化。以前会下意识觉得 Web3 人很多、很卷，但今天的数据反而让我意识到：这个行业整体人并不多，只是单位人才的要求极高。岗位少、简历多、报录比夸张，本质上是因为团队规模小、每个人都要能直接创造价值。这让我开始反思，自己如果想进入这个行业，必须尽早摆脱“学生思维”和“等别人给我机会”的状态。

关于岗位的理解也更具体了。无论是技术、运营、产品还是投研，本质上都不是换个行业就能直接平移的岗位，而是要围绕“链上逻辑”“代币机制”“全球化用户”重新构建能力模型。尤其是“作品大于履历”这一点给我冲击很大。在 Web3，简历不只是 PDF，而是你在 GitHub 上的提交、在链上的交互、你公开输出过的研究和观点。这种“用事实说话”的筛选方式，反而让我觉得更公平。

以太坊中文周会的内容让我感受到，底层技术并不像外界想象的那样已经定型，而是仍在不断试错和演进。无论是扩容升级带来的新问题，还是安全事件频繁发生，都说明这个行业仍然处在快速变化和高风险并存的阶段。这让我意识到，学习 Web3 不能只停留在“机会”和“叙事”，还要具备对风险、技术限制和现实博弈的清醒认知。

今天最大的收获，可能是对“如何进入 Web3”的路径有了更现实的判断。不是等一份完美的 JD 出现，而是先在生态里留下痕迹：学东西、做东西、参与讨论、留下记录。当你真的能持续输出、能被搜索到、能被验证，机会反而会主动靠近你。这让我对接下来的学习不再那么焦虑，而是更清楚自己下一步该往哪里用力。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
