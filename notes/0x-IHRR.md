---
timezone: UTC+8
---

# .小白

**GitHub ID:** 0x-IHRR

**Telegram:** @Ox_IHRR

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->
状态变量就是链上的信息，改状态变量就是改链上的数据

数据类型一般是有默认值的：

bool 默认是 false

uint 默认是 0

int 默认是 0

address 默认是 0x1e16

bytes32 默认是 0x1e32

还有一些没学到…

如果在一个文件里面定义了多个contract，在Deploy的时候，默认只会部署第一个contract，这个时候，需要在编译器的CONTRACT那个框框里面去单独选择其它合约Deploy，我还奇怪为什么写了两个contract，Deploy之后却只有一个contract

有一个常量的概念，事先我们是知道一些变量的固定值的，这些变量本身是不能被任何的合约所修改的，比如调用者address或者是一些特殊的编码，这些就会通常定义为常量，可以节省Gas，一般常量命名用大写，这是有一个 **constant** 的修饰符，是专门用来定义常量的，我尝试了一下，使用 constant 定义后的常量读取地址的Gas是 **373** ，没有用 constant 定义的读取地址的Gas是 **2485** ，这个差距有点大，但比起升级之前的Gas来说，已经可以算九牛一毛了，但这里有一个概念没弄明白，最开始是说只读方法可以不用消耗Gas的，但这里是说，常量在写入函数中还会再读取的， 这个时候就会按照是否定义常量来消耗Gas，这里我的理解就是如果不在写入函数，就是在不修改链上状态的情况下，是不用消耗Gas的

if else 条件判断

这个不难理解，修饰符搭配好就行

\`\`\`

function example(uint \_x) external pure returns (uint) {

if (\_x < 10) {

return 1;

} else if (\_x < 20) {

return 2;

}

return 3; // 这里默认返回3，可以加 return ，也可以不加

}

function ternary(uint \_x) external pure returns (uint) {

return \_x < 10 ? 1 : 2; // 三元表达式，这样写比较简洁， ？ 是满足就输出1，：是默认，也就是不满足条件就输出2

}

\`\`\`

循环：这里又学会一个新单词 pools

for循环 and while循环

这个跟python的逻辑是一样的，倒不用花多少时间重新理解，不过这里要注意的一点是while不能用true，这个不像其它语言在一些实时监控场景上可以用到，在区块链上用true会造成Gas无用消耗，就算加个break，最好也限制循环次数，毕竟Gas就是钱

!\[\[Pasted image 20260114110843.png\]\]

这几种错误判断让我迷糊了一下

require、revert、assert

!\[\[Pasted image 20260114114445.png\]\]

**require** 的判断逻辑是：\*\*满足条件就继续执行，不满足条件才抛出错误并且回滚\*\*

在上面截图中是

\`\`\`

require(\_i <= 10, “i > 10”);

// Code

\`\`\`

这里的判断逻辑是如果 \_i 小于并且等于10 ，就会去继续执行下面的代码，但如果不满足这个条件，就直接抛出 “i > 10“的报错信息并且回滚之前的操作，退还多余的Gas，但是已经执行了步骤消耗的Gas是不会退回的。

revert\*\* 的判断逻辑是：\*\*先通过代码判断条件，只要满足【定义的错误条件】，就主动抛出错误并回滚；不满足错误条件，就继续执行，这个就跟python差不多理解了，反正是条件满足就执行里面的语句\*\*

大白话解释：\*\*if(错误条件) { revert("错误提示");} 【我先检查是不是出现了某个错误情况，如果确实出现了，就直接报错，函数啥也不干了，之前的操作全部撤销；如果没出现这个错误情况，就继续执行后面的逻辑】\*\*

\`\`\`

if (\_i > 10) {

revert("i > 10"); // 关键逻辑

}

// More Code 只有 i <= 10 才会执行

\`\`\`

require是满足就执行后续代码，revert是满足就抛出报错，有点意思，反着来

**assert** 的判断逻辑是：\*\*校验一个【内部逻辑上绝对应该成立的条件】，只要这个条件成立，就继续执行；如果条件不成立（说明合约有bug），就强制报错并回滚，且不退还剩余Gas----这也就是断言吧\*\*

大白话解释：\*\*assert（正常条件） 【我这里的逻辑绝对没问题，这个条件肯定成立；如果居然不成立，那就是我的合约写崩了，直接报错终止，所有操作回滚，而且剩下的Gas全部消耗掉（提醒开发者赶紧查bug）】\*\*

\`\`\`

uint public num = 123; // 初始值

// 因为这个读取了状态变量，所以用的view

function testAssert() public view {

assert(num == 123); // 关键校验

// More Code 只有num == 123 才会执行

}

\`\`\`

如果满足条件，也就是断言成功，就不会报错，继续执行下面的代码，如果条件不满足，也就是被其它代码改动了初始值，断言没成功，就会弹系统默认提示，函数停止，这是一个bug，必须要修复。

assert不是用来校验外部输入的，而且用来校验【内部逻辑的不变性】，对内查bug用的，触发了就是代码有问题，去老老实实修bug就行了。

**自定义报错** ：这可以用来节省Gas，因为有些报错信息会很长，会浪费很多Gas，这时就可以用自定义报错，对于我这种英文不好的，我觉得更适合，弄成对中文开发者比较友好的报错信息，就是不知道中文字符会不会比英文字符所消耗的Gas更多。

\`\`\`

error MyError(address caller, uint i); // 这里面还可以加变量参数呢，可以知道当时报错时的值（比如谁触发的错误，参数值是多少） error是关键字，MyError是错误名称

function testCustomError() public view {

if (\_i > 10) {

revert MyError(msg.sender, \_i); // msg.sender(调用者的地址) i(传入的参数值)作为参数传给错误，相当于“报错时带上具体信息”

}

}

\`\`\`

自定义错误有几个好处：更省Gas、更灵活、更规范
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->

public 代表公开

\## 类型和值

bool ：布尔值 true和false

uint ：无符号整型，有uint256、uint8、uint16（往上加8就行）

int ：整型，-2 **256 to 2** 255 - 1

.min : 最小值

.max : 最大值（这些内置函数跟python一样）

address : solidity独特的变量类型，内容就是个16进制数字

bytes32 ：比地址类型长，是32位数字

contract : 合约，后面接函数名

function ：函数

external ： 访问权限关键词，作用跟public一样，控制谁可以调用这个函数，但它只允许外部账户（比如我自己的钱包地址或者其他合约），当前合约内部的其他函数不能够调用

pure ：纯函数类型，不能够读、也不能够写状态变量，只能局部变量，概念还不是很懂，就说是不能对链上进行任何的读写操作

状态变量约等于python的全局变量，但是solidity的状态变量是存储在区块链上的，区块链不死，就可以一直存在，操作不可逆，修改要gas，而python是存储在系统内存中的，随时可以改，程序一关，变量就没了

在函数局部里面，可以直接修改状态变量，这里跟python不同，不需要加global之类的关键字，因为solidity需要便捷的操作它，所以简化了“访问/修改权限”的声明，但是这里有一个要注意的点：如果要修改状态变量，在函数名后的修饰符那里，就不能用 pure 或者 view，pure是不能读也不能写，view是只读不写，如果加了这两个修饰符，就会报错，保持默认或者根据需要加 public / external权限

原来external、internal、public这些关键字是为了省gas来分场景使用的，public内外都可以调用，所以会占用更多空间，external只有外部能调用，所以把内部空间省下了，在高频外部调用场景中，很好用

pure、view和无修饰符，是强制约束 + gas优化，我还以为可以从宽松到严格随便使用

如果只使用局部变量 / 输入参数 ：必须用 pure

如果只读状态变量但不修改 ： 必须用 view

如果需要改状态变量 ：不能用 pure / view

按“从严格到宽松”的顺序来判断：

先看是否改状态（改则无修饰符） 》》不改的话，看是否会读状态（读则 view ，不读则 pure）
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


今天是实习计划月的第一天，上午把入门计划全部过了一遍，因为在开营之前就把实习的一些教学材料看过一遍，今天才发现原来是那些东西，所以学习压力不算很大，除了视频还没有全部看完，第一周的任务差不多完成了。  
就个人而言的话，很多知识已经有过初步的了解，因为自己对web3很感兴趣，所以也自己摸索了两年，比较明显的缺点就是对于行业没有一个系统的全面了解，一直是东学一点、西学一点，好处是所有赛道都了解一点，坏处就是都了解的不深，这次来这里，主要也是想补齐这个短板，另外关于行业通识这一块，比较有收获的就是行业工作形式和法律合规这一块，对自己的未来道路如何走也有很大的指导作用，特别是准备学走开发一块的话，原来涉及空投逻辑的代码也有可能触及法律。  
如果进度快的话，通识应该有个两三天的时间就可以简单掌握，接下来的计划，也是我认为的难点，就是编码这一块，只有一个python的基础，对于web3来说，肯定是远远不够的，光是语法这一块，就得花很大精力，任重道远啊
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
