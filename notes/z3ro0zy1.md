---
timezone: UTC+8
---

# RonnaldL

**GitHub ID:** z3ro0zy1

**Telegram:** @ronaldl3e

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
# 图灵完备

图灵完备是计算机科学中最核心的概念之一。

通俗点讲：**只要给它足够的时间和内存，图灵完备的系统可以解决任何可以被算法化的问题。**

* * *

**以太坊 EVM**：

支持循环，是图灵完备的。_代价_：它面临著名的**停机问题**。

* * *

## 停机问题

图灵证明了一个数学定理：**不存在一个_通用的程序_，能够判断任意一个程序是否会在_有限时间内运行结束_，还是会陷入_死循环_。**

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/z3ro0zy1/images/2026-01-16-1768568945517-image.png)

由于停机问题在逻辑上是不可解的，以太坊这种图灵完备的系统面临一个风险：如果有人在智能合约里写了一个死循环，全网的矿工/验证者都会因为运行这个合约而卡死。

> **_以太坊的解决方案：Gas 机制_**
> 
> **_以太坊并没有从算法上解决停机问题（因为不可能），而是从经济学上解决了它。每一步计算都要花钱（Gas），如果你写了死循环，你的 Gas 很快就会扣光，程序会被强制停止。_**

# 以太坊深入：L1与L2

## 1\. 以太坊区块的核心构成

一个完整的以太坊区块可以划分为三个逻辑层：

### A. Block Header (区块头)

-   **Parent Hash**: 父区块的哈希值，构成了“链”的物理结构。
    

* * *

**State Root（状态根）**: 最关键的字段。它是一个 **Merkle Patricia Trie** 的根哈希，代表了所有交易执行完毕后，整个以太坊网络，包括所有账户、余额、合约状态的全局状态快照。

**Transactions Root**: 当前区块中所有交易构成的默克尔树根。

**Receipts Root**: 交易收据（如产生的 Log、消耗的 Gas）构成的树根。

**_上面这三棵树相比起Bitcoin中只有交易树不一样！_**

**State Trie (状态树)**：

**Key**: 账户地址的哈希。

**Value**: 包含 `nonce`, `balance`, `storageRoot`, `codeHash` 的编码。

**意义**：这使得以太坊成为“全状态”机器，节点只需根据这个根就能验证任何账户的状态，而不需要回溯所有历史。

**Transactions Trie (交易树)**：

记录本区块内交易的顺序和内容。

**Receipts Trie (收据树)**：

记录交易执行的结果（成功/失败）和生成的事件日志（Logs）。

* * *

-   **Base Fee Per Gas**: EIP-1559 引入的基础费用，随网络拥堵情况动态调整。
    
-   **Withdrawals Root**: 记录了从共识层提取质押奖励到执行层的操作。
    
-   **Blob Gas 相关字段**: 记录当前区块处理了多少 Blob 数据。
    

### B. Execution Payload (执行负载)

这是区块的“躯干”，包含了实际要执行的数据：

-   **Transactions**: 本区块打包的所有交易列表。
    
-   **Withdrawals**: 验证者提现记录列表。
    

### C. Blobs (Binary Large Objects) —— 扩展层

这是 Dencun 升级（EIP-4844）后的核心产物。为了给 Layer 2 降费，区块现在可以挂载额外的临时数据空间（Blobs）。

* * *

## 默克尔树入门：

### 为什么用默克尔树验证很容易？

假设一个区块里有 8 笔交易。我想证明交易T3确实在这个区块里。

只需要给验证者提供以下 **3 个** 哈希值:

1.  **H4**
    
2.  **H12**
    
3.  **H58**
    

作为结果我可以自行计算H34 -> H1234 -> H12345678(This is the Merkle root)

**Then compare the calculated Merkle root with original root.**

* * *

这对于区块链的和L2 扩容至关重要。

| 交易总数 (n) | 线性扫描 (发送整个区块) | 默克尔证明 (发送 Proof) |
| 16 | 16 条交易数据 | 4 个哈希值 |
| 1,024 | 1,024 条交易数据 | 10 个哈希值 |
| 1,048,576 | 约 100 万条数据 | 仅 20 个哈希值 |

即使区块里有 100 万笔交易，证明其中一笔交易存在的成本也极低。

依旧备考IELTS 😭 昨天还漏了一天打卡
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->

# **CEX入门研究**

```
最近Hyperliquid，lighter，aster都挺热门的，所以今天研究一下。
```

| 特性 | DEX (去中心化) | CEX (中心化) |
| 资金存放 | 用户钱包（安全归个人） | 平台钱包 |
| KYC 要求 | 通常不需要（保护隐私） | 强制要求（符合监管） |
| 交易成本 | 极低 Gas + 少量手续费 | 固定手续费 + 出入金损耗 |
| 资产范围 | 极广（涵盖所有新币/RWA） | 较窄（需审核上市） |
| 技术门槛 | 较高（需管理助记词） | 较低（邮箱注册即可） |

_我觉得真的吸引人的有以下两大块_

### **性能飞跃：**

极高吞吐量：新一代 DEX，如 Hyperliquid，采用原生 L1 或并行执行技术，可支持每秒数万甚至十万次以上的交易处理。

亚秒级结算：交易确认延迟缩短至毫秒级，操作手感已非常接近币安等中心化巨头。

零/低 Gas 费：随着 Hyperliquid 这种交易模型和 Solana 等低成本链的普及，链上交易的摩擦成本已大幅低于传统模式。

### **产品创新：**

**极致杠杆与资产多样性：** 某些永续合约 DEX 提供高达 1,001 倍的杠杆，并支持美股、大宗商品等现实世界资产的代币化交易。

如图中的黄金perps：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/z3ro0zy1/images/2026-01-14-1768400442921-image.png)

# Meme入门了解：

**_感觉是纯赌场，看谁手段多信息快，然后把别人割了。_**

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/z3ro0zy1/images/2026-01-14-1768400515366-image.png)

暂时不喜欢这个内容，感觉就是纯互相割韭菜。

不过大多数散户都被KOL喊单整治了

# React入门学习

## 函数的传递：引用 vs 调用

| 语法 | 行为类型 | 后果 |
| onSquareClick={handleClick(i)} | 立即调用 | 渲染时直接触发，导致组件更新，进而引发无限循环。 |
| onSquareClick={() => handleClick(i)} | 匿名函数包装 | 创建一个“包装盒”，只有在真实点击发生时，才执行内部代码。 |

* * *

## React 核心编程思想

### 声明式 vs 命令式

**命令式（面向过程）**：你告诉浏览器“去找到那个按钮，把它变红”。

**声明式（React）**：你告诉 React “如果被选中了，它应该是红色的”。你只管维护 **状态 (State)**，UI 会自动根据状态“重画”。

### 不变性

在修改 `squares` 数组时，我们使用 `slice()` 复制一份新数组，而不是直接修改原数组：

**原因**：React 通过比对新旧数组的内存地址来判断是否需要更新。如果地址没变，React 可能认为数据没变，从而不刷新界面。**性能**：这种比对（引用比对）极快，比遍历整个数组检查内容要高效得多。

* * *

## 底层运作原理

### DOM (文档对象模型)

**什么是 DOM**：浏览器将 HTML 转化成的一棵可编程的对象树。

**虚拟 DOM**：React 在内存中运行的一套轻量级假 DOM。它会找出真正需要改变的部分，最后一次性更新到真实 DOM 上。

### 为什么 TS/JS 运行很快？

**编译 vs 解释**：TS 在运行前会编译成 JS，并删除所有类型信息，运行负担小。

**V8 引擎**：现代浏览器使用 JIT 编译技术，将频繁运行的 JS 代码直接转化成底层机器码，速度接近 C++。

依旧备考语言中。。 😭
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->


# 以太坊零知识证明学习与回顾

```
本科学的密码学基础此时稍微派上了点用场，起码看得懂RSA和模运算等东西了（虽然忘了很多东西）
```

## 1\. PoW

Miner实际上在寻找一个Nouce，使得：

SHA256(SHA256(Block Header + Nonce)) < Target，其成功概率为 P= Target/2^256

这个纯靠大力出奇迹

## 2.PoS

在 PoS 中，你被选为记账人的概率P正比于质押的代币S， 同时为了防止富有者通过频繁出块获得更多奖励，导致系统迅速中心化，通常会引入币龄**，**随机信标来增加随机性。

## 3.零知识证明 (ZKP)：代数几何的巅峰

```
可惜，由于本身数学水平局限于非数学专业本科生水平，短期无法看懂其包含抽象代数与代数几何等抽象高深内容。
```

**_因此我暂且通过传统的简单色盲猜球来理解。_**

# React入门回顾Day1

```
（大学学过Vue，现在忘了，现在学一下react前端，为全栈打个基础）
```

## 一、 TSX 与组件本质

**组件即函数**：在 TSX 中，组件是一个返回 HTML 标记（JSX）的 JavaScript 函数。

**关注点分离**：不再追求 HTML 和 JS 文件分离，而是按**功能单元**封装代码。

**命名规范**：组件函数名必须**首字母大写**（如 `MyButton`），以便 React 区分原生 HTML 标签。

**TS 类型加持**：通过 `interface` 定义 Props 的形状，确保在编写组件时获得精准的自动补全和纠错。

## 二、 Props：组件间的“参数传递”

-   **本质**：Props 就像函数的形参，是外部向组件内部传递数据的唯一通道。
    
-   **单向数据流**：数据总是从父组件通过 Props 流向子组件。
    
-   **只读性**：组件内部不能修改接收到的 Props，只能读取。
    
-   **解构赋值**：常用 `const { count } = props` 或直接在参数位 `{ count }: Props` 解构。
    

## 三、 useState：组件的“记忆体”

**语法**：`const [state, setState] = useState(initialValue);`解构机制：`useState` 返回一个数组，第一个是当前快照值，第二个是更新函数。

**异步快照更新**：调用 `setState` 不会立刻改变当前函数作用域内的变量。React 会等当前函数执行结束后，才进行“批处理”更新并触发重新渲染。

**金句**：_“当前函数里的状态变量永远代表过去，只有下一次渲染它才会变成未来。”_

## 四、 作用域与状态提升

**同步逻辑**：若多个组件需要共享数据并保持同步，需将状态定义在它们共同的**父级作用域**中（状态提升）。

**独立逻辑**：若组件需互不干扰，则将 `useState` 定义在组件内部。

## 五、 React 更新机制

**虚拟 DOM**：React 在内存中对比新旧树的差异，仅对真实的浏览器 DOM 进行精准修改。

**局部更新**：虽然逻辑上感觉像重新跑了整个 App，但物理上只更新了变化的那一小块 DOM，因此性能极高。

**组件拆分的必要性**：将状态下放到小组件，可以避免整个大页面跟着无谓的重新渲染。**代码解耦**：避免 `App.tsx` 逻辑过载，提高复用性。

## 六、 交互监听与受控组件

**onChange**：在 React 中是实时触发的（每打一个字触发一次），常用于捕获用户输入并同步到 `state`。

**受控组件模式**：表单的值由 `state` 驱动（`value={count}`），通过 `onChange` 更新 `state`，形成闭环控制。

同样，最近忙于准备IELTS考试，阅读英语令人头疼🤕，第一周笔记暂且短一点。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->



# **实习手册入门导读**

## 1\. Bitcoin入门

### **1.1 Block Header**

**版本号，Previous Blcok Header Hash， 默克尔根，时间戳，难度目标，随机数。、**

**其中，默克尔根是把许多交易浓缩为32字节，方便后续计算Hash。 而对于时间戳来说，从和Gemini的交流中发现，他被允许大于前11个区块的中位数，于是可能会出现Timestamp（N）< Timestamp（N-1）的情况。 这种倒挂是一种逻辑顺序优先的原则。**

**至于难度与随机数**

```
nonce = 0
header_fixed = version + prev_hash + merkle_root + timestamp + nbits  \\ 头信息
while hash(header_fixed + nonce) >= target: \\hash头信息
    nonce += 1
    if nonce > 0xFFFFFFFF:
        # Nonce 溢出了
        update_other_fields()
```

### 1.2 Block Body

Transactions + Signature，还有默克尔树。

比特币的思路和其他新兴公链有极大的类似，因此我认为深度研究BTC技术问题对学习ETH，Solana等有很大帮助。

### 1.3 关于BTC的一些其他问题以及与AI的探讨：

-   **Merkle Tree 到底是怎么把几千笔交易压缩成一个哈希值的？**
    

**最底层：** 对每笔交易(Transaction)进行哈希运算（SHA-256），得到一组哈希值：H1,H2,H3,H4。

**中间层：** 将相邻的两个哈希值拼在一起再哈希。比如：H12=SHA(H1+H2)

**最顶层：** 继续合并。H1234=SHA(H12+H34)。这个最终得到的唯一哈希值就是 **Merkle Root**。

-   **如果两个矿工同时挖出了不同的区块（分叉），网络如何决定听谁的？**
    

最长链原则，网络此时一分为二，矿工们会基于自己先收到的那个区块继续挖矿。但是这种竞争通常在下一个区块就会结束。如果基于区块 A 的矿工先挖出了下一个区块C，那么 A + C 这条链就比 B 链长了。 被抛弃的区块 B ，里面原本打包的交易如果没在 A 链中出现，会重新回到内存池等待下次打包。

## 2\. ETH入门

### 2.1 智能合约

上文提到BTC内是纯粹的交易信息，比如Alice给了Bob 100元，这是一种纯粹的金额加减。

而对于ETH的智能合约而言：

它是一段存储在以太坊区块链上的**代码和数据**。

它有自己的地址，但没有私钥，只有代码逻辑。

它平时是静止的。只有当外部账户向它发送一笔交易，或者另一个合约调用它时，它才会执行。

其核心特性：

**不可篡改性**：一旦部署到链上，任何人（包括开发者）都无法修改代码逻辑。

**确定性**：同样的输入，在任何时间、由任何节点运行，结果都必须完全一致。

**自执行性**：不需要中介。如果代码说“周五下午三点把钱转给 A”，那么时间一到，只要有触发条件，钱就会自动转走

### 2.2 以太坊虚拟机EVM，全球统一的引擎

EVM 是一个完全隔离的虚拟环境。合约代码在 EVM 内部运行，无法访问宿主机的文件系统或网络。

这种隔离保证了即使合约有漏洞或恶意代码，也不会拖垮节点电脑。

开发者通常使用 **Solidity** 语言编写合约。但 EVM 听不懂 Solidity，它只能看懂**字节码**。

今天先这样，忙于IELTS考试中 😭
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
