---
timezone: UTC+8
---

# RonnaldL

**GitHub ID:** z3ro0zy1

**Telegram:** @ronaldl3e

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
# 以太坊零知识证明学习与回顾

```
本科学的密码学基础此时稍微派上了点用场，起码看得懂RSA和模运算等东西了（虽然忘了很多东西）
```

## 1\. PoW

Miner实际上在寻找一个Nouce，使得：

SHA256(SHA256(Block Header + Nonce)) < Target，其成功概率为 P= Target/2^256

这个纯靠大力出奇迹

## 2.PoS

在 PoS 中，你被选为记账人的概率P正比于质押的代币S， 同时为了防止富有者通过频繁出块获得更多奖励，导致系统迅速中心化，通常会引入币龄**，**随机信标来增加随机性。

## 3.零知识证明 (ZKP)：代数几何的巅峰

```
可惜，由于本身数学水平局限于非数学专业本科生水平，短期无法看懂其包含抽象代数与代数几何等抽象高深内容。
```

**_因此我暂且通过传统的简单色盲猜球来理解。_**

# React入门回顾Day1

```
（大学学过Vue，现在忘了，现在学一下react前端，为全栈打个基础）
```

## 一、 TSX 与组件本质

**组件即函数**：在 TSX 中，组件是一个返回 HTML 标记（JSX）的 JavaScript 函数。

**关注点分离**：不再追求 HTML 和 JS 文件分离，而是按**功能单元**封装代码。

**命名规范**：组件函数名必须**首字母大写**（如 `MyButton`），以便 React 区分原生 HTML 标签。

**TS 类型加持**：通过 `interface` 定义 Props 的形状，确保在编写组件时获得精准的自动补全和纠错。

## 二、 Props：组件间的“参数传递”

-   **本质**：Props 就像函数的形参，是外部向组件内部传递数据的唯一通道。
    
-   **单向数据流**：数据总是从父组件通过 Props 流向子组件。
    
-   **只读性**：组件内部不能修改接收到的 Props，只能读取。
    
-   **解构赋值**：常用 `const { count } = props` 或直接在参数位 `{ count }: Props` 解构。
    

## 三、 useState：组件的“记忆体”

**语法**：`const [state, setState] = useState(initialValue);`解构机制：`useState` 返回一个数组，第一个是当前快照值，第二个是更新函数。

**异步快照更新**：调用 `setState` 不会立刻改变当前函数作用域内的变量。React 会等当前函数执行结束后，才进行“批处理”更新并触发重新渲染。

**金句**：_“当前函数里的状态变量永远代表过去，只有下一次渲染它才会变成未来。”_

## 四、 作用域与状态提升

**同步逻辑**：若多个组件需要共享数据并保持同步，需将状态定义在它们共同的**父级作用域**中（状态提升）。

**独立逻辑**：若组件需互不干扰，则将 `useState` 定义在组件内部。

## 五、 React 更新机制

**虚拟 DOM**：React 在内存中对比新旧树的差异，仅对真实的浏览器 DOM 进行精准修改。

**局部更新**：虽然逻辑上感觉像重新跑了整个 App，但物理上只更新了变化的那一小块 DOM，因此性能极高。

**组件拆分的必要性**：将状态下放到小组件，可以避免整个大页面跟着无谓的重新渲染。**代码解耦**：避免 `App.tsx` 逻辑过载，提高复用性。

## 六、 交互监听与受控组件

**onChange**：在 React 中是实时触发的（每打一个字触发一次），常用于捕获用户输入并同步到 `state`。

**受控组件模式**：表单的值由 `state` 驱动（`value={count}`），通过 `onChange` 更新 `state`，形成闭环控制。

同样，最近忙于准备IELTS考试，阅读英语令人头疼🤕，第一周笔记暂且短一点。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->

# **实习手册入门导读**

## 1\. Bitcoin入门

### **1.1 Block Header**

**版本号，Previous Blcok Header Hash， 默克尔根，时间戳，难度目标，随机数。、**

**其中，默克尔根是把许多交易浓缩为32字节，方便后续计算Hash。 而对于时间戳来说，从和Gemini的交流中发现，他被允许大于前11个区块的中位数，于是可能会出现Timestamp（N）< Timestamp（N-1）的情况。 这种倒挂是一种逻辑顺序优先的原则。**

**至于难度与随机数**

```
nonce = 0
header_fixed = version + prev_hash + merkle_root + timestamp + nbits  \\ 头信息
while hash(header_fixed + nonce) >= target: \\hash头信息
    nonce += 1
    if nonce > 0xFFFFFFFF:
        # Nonce 溢出了
        update_other_fields()
```

### 1.2 Block Body

Transactions + Signature，还有默克尔树。

比特币的思路和其他新兴公链有极大的类似，因此我认为深度研究BTC技术问题对学习ETH，Solana等有很大帮助。

### 1.3 关于BTC的一些其他问题以及与AI的探讨：

-   **Merkle Tree 到底是怎么把几千笔交易压缩成一个哈希值的？**
    

**最底层：** 对每笔交易(Transaction)进行哈希运算（SHA-256），得到一组哈希值：H1,H2,H3,H4。

**中间层：** 将相邻的两个哈希值拼在一起再哈希。比如：H12=SHA(H1+H2)

**最顶层：** 继续合并。H1234=SHA(H12+H34)。这个最终得到的唯一哈希值就是 **Merkle Root**。

-   **如果两个矿工同时挖出了不同的区块（分叉），网络如何决定听谁的？**
    

最长链原则，网络此时一分为二，矿工们会基于自己先收到的那个区块继续挖矿。但是这种竞争通常在下一个区块就会结束。如果基于区块 A 的矿工先挖出了下一个区块C，那么 A + C 这条链就比 B 链长了。 被抛弃的区块 B ，里面原本打包的交易如果没在 A 链中出现，会重新回到内存池等待下次打包。

## 2\. ETH入门

### 2.1 智能合约

上文提到BTC内是纯粹的交易信息，比如Alice给了Bob 100元，这是一种纯粹的金额加减。

而对于ETH的智能合约而言：

它是一段存储在以太坊区块链上的**代码和数据**。

它有自己的地址，但没有私钥，只有代码逻辑。

它平时是静止的。只有当外部账户向它发送一笔交易，或者另一个合约调用它时，它才会执行。

其核心特性：

**不可篡改性**：一旦部署到链上，任何人（包括开发者）都无法修改代码逻辑。

**确定性**：同样的输入，在任何时间、由任何节点运行，结果都必须完全一致。

**自执行性**：不需要中介。如果代码说“周五下午三点把钱转给 A”，那么时间一到，只要有触发条件，钱就会自动转走

### 2.2 以太坊虚拟机EVM，全球统一的引擎

EVM 是一个完全隔离的虚拟环境。合约代码在 EVM 内部运行，无法访问宿主机的文件系统或网络。

这种隔离保证了即使合约有漏洞或恶意代码，也不会拖垮节点电脑。

开发者通常使用 **Solidity** 语言编写合约。但 EVM 听不懂 Solidity，它只能看懂**字节码**。

今天先这样，忙于IELTS考试中 😭
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
