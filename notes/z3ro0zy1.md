---
timezone: UTC+8
---

# RonnaldL

**GitHub ID:** z3ro0zy1

**Telegram:** @ronaldl3e

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->
# **CEX入门研究**

```
最近Hyperliquid，lighter，aster都挺热门的，所以今天研究一下。
```

| 特性 | DEX (去中心化) | CEX (中心化) |
| 资金存放 | 用户钱包（安全归个人） | 平台钱包 |
| KYC 要求 | 通常不需要（保护隐私） | 强制要求（符合监管） |
| 交易成本 | 极低 Gas + 少量手续费 | 固定手续费 + 出入金损耗 |
| 资产范围 | 极广（涵盖所有新币/RWA） | 较窄（需审核上市） |
| 技术门槛 | 较高（需管理助记词） | 较低（邮箱注册即可） |

_我觉得真的吸引人的有以下两大块_

### **性能飞跃：**

极高吞吐量：新一代 DEX，如 Hyperliquid，采用原生 L1 或并行执行技术，可支持每秒数万甚至十万次以上的交易处理。

亚秒级结算：交易确认延迟缩短至毫秒级，操作手感已非常接近币安等中心化巨头。

零/低 Gas 费：随着 Hyperliquid 这种交易模型和 Solana 等低成本链的普及，链上交易的摩擦成本已大幅低于传统模式。

### **产品创新：**

**极致杠杆与资产多样性：** 某些永续合约 DEX 提供高达 1,001 倍的杠杆，并支持美股、大宗商品等现实世界资产的代币化交易。

如图中的黄金perps：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/z3ro0zy1/images/2026-01-14-1768400442921-image.png)

# Meme入门了解：

**_感觉是纯赌场，看谁手段多信息快，然后把别人割了。_**

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/z3ro0zy1/images/2026-01-14-1768400515366-image.png)

暂时不喜欢这个内容，感觉就是纯互相割韭菜。

不过大多数散户都被KOL喊单整治了

# React入门学习

## 函数的传递：引用 vs 调用

| 语法 | 行为类型 | 后果 |
| onSquareClick={handleClick(i)} | 立即调用 | 渲染时直接触发，导致组件更新，进而引发无限循环。 |
| onSquareClick={() => handleClick(i)} | 匿名函数包装 | 创建一个“包装盒”，只有在真实点击发生时，才执行内部代码。 |

* * *

## React 核心编程思想

### 声明式 vs 命令式

**命令式（面向过程）**：你告诉浏览器“去找到那个按钮，把它变红”。

**声明式（React）**：你告诉 React “如果被选中了，它应该是红色的”。你只管维护 **状态 (State)**，UI 会自动根据状态“重画”。

### 不变性

在修改 `squares` 数组时，我们使用 `slice()` 复制一份新数组，而不是直接修改原数组：

**原因**：React 通过比对新旧数组的内存地址来判断是否需要更新。如果地址没变，React 可能认为数据没变，从而不刷新界面。**性能**：这种比对（引用比对）极快，比遍历整个数组检查内容要高效得多。

* * *

## 底层运作原理

### DOM (文档对象模型)

**什么是 DOM**：浏览器将 HTML 转化成的一棵可编程的对象树。

**虚拟 DOM**：React 在内存中运行的一套轻量级假 DOM。它会找出真正需要改变的部分，最后一次性更新到真实 DOM 上。

### 为什么 TS/JS 运行很快？

**编译 vs 解释**：TS 在运行前会编译成 JS，并删除所有类型信息，运行负担小。

**V8 引擎**：现代浏览器使用 JIT 编译技术，将频繁运行的 JS 代码直接转化成底层机器码，速度接近 C++。

依旧备考语言中。。 😭
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->

# 以太坊零知识证明学习与回顾

```
本科学的密码学基础此时稍微派上了点用场，起码看得懂RSA和模运算等东西了（虽然忘了很多东西）
```

## 1\. PoW

Miner实际上在寻找一个Nouce，使得：

SHA256(SHA256(Block Header + Nonce)) < Target，其成功概率为 P= Target/2^256

这个纯靠大力出奇迹

## 2.PoS

在 PoS 中，你被选为记账人的概率P正比于质押的代币S， 同时为了防止富有者通过频繁出块获得更多奖励，导致系统迅速中心化，通常会引入币龄**，**随机信标来增加随机性。

## 3.零知识证明 (ZKP)：代数几何的巅峰

```
可惜，由于本身数学水平局限于非数学专业本科生水平，短期无法看懂其包含抽象代数与代数几何等抽象高深内容。
```

**_因此我暂且通过传统的简单色盲猜球来理解。_**

# React入门回顾Day1

```
（大学学过Vue，现在忘了，现在学一下react前端，为全栈打个基础）
```

## 一、 TSX 与组件本质

**组件即函数**：在 TSX 中，组件是一个返回 HTML 标记（JSX）的 JavaScript 函数。

**关注点分离**：不再追求 HTML 和 JS 文件分离，而是按**功能单元**封装代码。

**命名规范**：组件函数名必须**首字母大写**（如 `MyButton`），以便 React 区分原生 HTML 标签。

**TS 类型加持**：通过 `interface` 定义 Props 的形状，确保在编写组件时获得精准的自动补全和纠错。

## 二、 Props：组件间的“参数传递”

-   **本质**：Props 就像函数的形参，是外部向组件内部传递数据的唯一通道。
    
-   **单向数据流**：数据总是从父组件通过 Props 流向子组件。
    
-   **只读性**：组件内部不能修改接收到的 Props，只能读取。
    
-   **解构赋值**：常用 `const { count } = props` 或直接在参数位 `{ count }: Props` 解构。
    

## 三、 useState：组件的“记忆体”

**语法**：`const [state, setState] = useState(initialValue);`解构机制：`useState` 返回一个数组，第一个是当前快照值，第二个是更新函数。

**异步快照更新**：调用 `setState` 不会立刻改变当前函数作用域内的变量。React 会等当前函数执行结束后，才进行“批处理”更新并触发重新渲染。

**金句**：_“当前函数里的状态变量永远代表过去，只有下一次渲染它才会变成未来。”_

## 四、 作用域与状态提升

**同步逻辑**：若多个组件需要共享数据并保持同步，需将状态定义在它们共同的**父级作用域**中（状态提升）。

**独立逻辑**：若组件需互不干扰，则将 `useState` 定义在组件内部。

## 五、 React 更新机制

**虚拟 DOM**：React 在内存中对比新旧树的差异，仅对真实的浏览器 DOM 进行精准修改。

**局部更新**：虽然逻辑上感觉像重新跑了整个 App，但物理上只更新了变化的那一小块 DOM，因此性能极高。

**组件拆分的必要性**：将状态下放到小组件，可以避免整个大页面跟着无谓的重新渲染。**代码解耦**：避免 `App.tsx` 逻辑过载，提高复用性。

## 六、 交互监听与受控组件

**onChange**：在 React 中是实时触发的（每打一个字触发一次），常用于捕获用户输入并同步到 `state`。

**受控组件模式**：表单的值由 `state` 驱动（`value={count}`），通过 `onChange` 更新 `state`，形成闭环控制。

同样，最近忙于准备IELTS考试，阅读英语令人头疼🤕，第一周笔记暂且短一点。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


# **实习手册入门导读**

## 1\. Bitcoin入门

### **1.1 Block Header**

**版本号，Previous Blcok Header Hash， 默克尔根，时间戳，难度目标，随机数。、**

**其中，默克尔根是把许多交易浓缩为32字节，方便后续计算Hash。 而对于时间戳来说，从和Gemini的交流中发现，他被允许大于前11个区块的中位数，于是可能会出现Timestamp（N）< Timestamp（N-1）的情况。 这种倒挂是一种逻辑顺序优先的原则。**

**至于难度与随机数**

```
nonce = 0
header_fixed = version + prev_hash + merkle_root + timestamp + nbits  \\ 头信息
while hash(header_fixed + nonce) >= target: \\hash头信息
    nonce += 1
    if nonce > 0xFFFFFFFF:
        # Nonce 溢出了
        update_other_fields()
```

### 1.2 Block Body

Transactions + Signature，还有默克尔树。

比特币的思路和其他新兴公链有极大的类似，因此我认为深度研究BTC技术问题对学习ETH，Solana等有很大帮助。

### 1.3 关于BTC的一些其他问题以及与AI的探讨：

-   **Merkle Tree 到底是怎么把几千笔交易压缩成一个哈希值的？**
    

**最底层：** 对每笔交易(Transaction)进行哈希运算（SHA-256），得到一组哈希值：H1,H2,H3,H4。

**中间层：** 将相邻的两个哈希值拼在一起再哈希。比如：H12=SHA(H1+H2)

**最顶层：** 继续合并。H1234=SHA(H12+H34)。这个最终得到的唯一哈希值就是 **Merkle Root**。

-   **如果两个矿工同时挖出了不同的区块（分叉），网络如何决定听谁的？**
    

最长链原则，网络此时一分为二，矿工们会基于自己先收到的那个区块继续挖矿。但是这种竞争通常在下一个区块就会结束。如果基于区块 A 的矿工先挖出了下一个区块C，那么 A + C 这条链就比 B 链长了。 被抛弃的区块 B ，里面原本打包的交易如果没在 A 链中出现，会重新回到内存池等待下次打包。

## 2\. ETH入门

### 2.1 智能合约

上文提到BTC内是纯粹的交易信息，比如Alice给了Bob 100元，这是一种纯粹的金额加减。

而对于ETH的智能合约而言：

它是一段存储在以太坊区块链上的**代码和数据**。

它有自己的地址，但没有私钥，只有代码逻辑。

它平时是静止的。只有当外部账户向它发送一笔交易，或者另一个合约调用它时，它才会执行。

其核心特性：

**不可篡改性**：一旦部署到链上，任何人（包括开发者）都无法修改代码逻辑。

**确定性**：同样的输入，在任何时间、由任何节点运行，结果都必须完全一致。

**自执行性**：不需要中介。如果代码说“周五下午三点把钱转给 A”，那么时间一到，只要有触发条件，钱就会自动转走

### 2.2 以太坊虚拟机EVM，全球统一的引擎

EVM 是一个完全隔离的虚拟环境。合约代码在 EVM 内部运行，无法访问宿主机的文件系统或网络。

这种隔离保证了即使合约有漏洞或恶意代码，也不会拖垮节点电脑。

开发者通常使用 **Solidity** 语言编写合约。但 EVM 听不懂 Solidity，它只能看懂**字节码**。

今天先这样，忙于IELTS考试中 😭
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
