---
timezone: UTC-12
---

# Eeeeye

**GitHub ID:** Eeeeye

**Telegram:** @Eeeeye

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-27
<!-- DAILY_CHECKIN_2026-01-27_START -->
## 1\. 概念辨析：EIP vs ERC

在深入代码前，需厘清两个概念：

-   **EIP (Ethereum Improvement Proposal)**: 以太坊改进提案。包括核心协议修改（如由 PoW 转 PoS）、网络层改动等。
    
-   **ERC (Ethereum Request for Comments)**: EIP 的一个子类，专门针对**应用层标准**。
    
    -   **本质**: 约定好的接口定义 (Interface)。
        
    -   **目的**: 让钱包、交易所、DeFi 协议能无缝调用你的合约，无需知道你内部怎么写的。
        

* * *

## 2\. 资产类标准 (Token Standards)

这是构建经济模型的基础积木。

### ERC-20: 同质化代币 (Fungible Token)

-   **类比**: 货币。你手里的一张 100 元和我手里的一张 100 元没有任何区别。
    
-   **核心功能**: 转账 (`transfer`)、授权 (`approve`)、通过授权转账 (`transferFrom`)。
    
-   **安全痛点 (非常重要)**:
    
    -   **授权机制**: `approve(spender, amount)` 模式是 DeFi 的基石，但也是风险之源。用户习惯无限授权 (`type(uint256).max`)，一旦协议被黑，用户钱包会被清空。
        
    -   **假充值**: 某些恶意代币在 `transfer` 失败时不会 Revert 而是返回 `false`，如果合约没检查返回值，会导致记账错误（USDT 就曾有此问题，这也是为什么我们要用 `SafeERC20` 库）。
        

### ERC-721: 非同质化代币 (NFT)

-   **类比**: 房产证、身份证、艺术品。每个 Token 都有唯一的 `tokenId`。
    
-   **核心差异**:
    
    -   引入了 `ownerOf(tokenId)`。
        
    -   `safeTransferFrom`: 这是一个极其重要的改进。它会检查接收方如果是一个合约，是否实现了 `onERC721Received` 接口。如果接收方合约没实现（说明它无法处理 NFT），交易会 Revert。防止 NFT 永久锁死在不兼容的合约里。
        

### ERC-1155: 多重代币标准 (Multi-Token)

-   **类比**: 游戏道具库。一个合约里既有“金币”（同质化），又有“屠龙刀”（非同质化）。
    
-   **痛点解决**:
    
    -   **Gas 优化**: ERC-20 和 ERC-721 都是“一个合约一种资产”。如果你要发 10 种装备，得部署 10 个 ERC-721 合约。ERC-1155 允许在一个合约里管理无数种 ID 的资产。
        
    -   **批量操作**: 支持 `safeBatchTransferFrom`，一次交易转移 10 种不同的道具，极大节省 Gas。
        

| 特性 | ERC-20 | ERC-721 | ERC-1155 | | 资产性质 | 同质化 (货币) | 非同质化 (唯一物品) | 混合 (半同质化/混合) | | ID 管理 | 无 ID (只有余额) | 唯一 ID | ID + 数量 (Balance) | | 元数据 | 合约级 | 基于 Token ID | 基于 Token ID | | 典型场景 | 稳定币, 治理代币 | PFP, 域名 | 游戏道具, 现实资产(RWA) |

* * *

## 3\. DeFi 增强标准 (DeFi Legos)

随着 DeFi 的发展，基础的 ERC-20 已经不够用了，以下是目前最实用的进阶标准。

### ERC-2612: 带有签名的代币 (Permit)

-   **背景**: 在传统 ERC-20 中，用户想把币存入 Uniswap，必须发两笔交易：1. `approve` (花 Gas)，2. `deposit` (花 Gas)。体验极差。
    
-   **解决方案**: 引入 `permit` 函数。用户在链下对“授权”这个行为签名（不花 Gas）。任何人（通常是中继器或目标合约）拿着这个签名上链调用 `permit`，就完成了授权。
    
-   **结果**: **Gasless Transaction**（无 Gas 交易）的基础，实现了“一键存款”。
    

### ERC-4626: 代币化金库标准 (Tokenized Vaults)

-   **背景**: 以前每个 DeFi 协议（Compound, Aave, Yearn）都有自己的生息代币逻辑（cToken, aToken, yToken），开发者想做一个聚合器，得给每个协议写适配器。
    
-   **解决方案**: 定义了一套标准的接口：存入资产 (Asset) -> 获得份额 (Share)。
    
-   **核心公式**: `assets = shares * totalAssets() / totalSupply()`
    
-   **地位**: 现在的 DeFi 开发必修课。如果你在写 Yield Farming（流动性挖矿）或借贷协议，**必须**遵循此标准。
    

* * *

## 4\. 账户与安全标准

### ERC-4337: 账户抽象 (Account Abstraction)

-   **颠覆性**: 这是一个不需要硬分叉协议层的标准。
    
-   **核心**: 将外部账户 (EOA, 你的 MetaMask 地址) 和 合约账户 (CA) 的界限模糊化。
    
-   **能力**: 社交恢复钱包（丢了私钥能找回）、代付 Gas、指纹/面容支付。这是 Web3 走向 Mass Adoption 的关键。
    

### ERC-165: 接口检测

-   **功能**: 一个非常底层但常用的标准。它允许智能合约“自省”。
    
-   **用途**: “你支持 ERC-721 吗？” 合约回答：“支持”。这样调用者就知道可以安全地跟你交互了。
    

* * *
<!-- DAILY_CHECKIN_2026-01-27_END -->

# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->


🛡️ **Web3 安全实战笔记：重入攻击 (Reentrancy) 与 The DAO 的教训**

Gas 优化决定你的利润，而安全性决定你的生死。 今天复现了以太坊历史上最著名的漏洞——重入攻击（导致以太坊硬分叉的元凶）。

**1\. 漏洞本质：信任了不该信任的人** 在 Solidity 中，给合约转账 (`call{value: ...}`) 不仅仅是资产转移，它还会**移交控制权**。 接收方合约可以通过 `receive()` 或 `fallback()` 函数立刻执行代码。 如果此时你的合约状态（余额）还没有更新，攻击者就可以回头调用你的函数。

**🏦 通俗比喻：故障的 ATM**

1.  坏人插卡取 100 块。
    
2.  ATM 吐出钞票（但还没来得及扣账）。
    
3.  坏人拿到钱的瞬间，大喊：“我再取 100 块！”
    
4.  ATM 查账本：“余额没扣，确实还有钱”，于是又吐钱。
    
5.  循环直到 ATM 被掏空。
    

**2\. 致命代码模式 (The Anti-Pattern)** ❌ **先转账，后扣款**

Solidity

```
// 危险！
msg.sender.call{value: balance}(""); // 1. 交互：控制权交出去了
balances[msg.sender] = 0;            // 2. 生效：太晚了，攻击者已经递归进来了
```

**3\. 黄金防御法则：CEI 模式** **C**hecks (检查) -> **E**ffects (生效) -> **I**nteractions (交互)

这是所有智能合约开发者的生存法则。必须先修改这一笔交易的所有状态，最后再和外部世界交互。

✅ **安全写法**

Solidity

```
// 1. Checks
require(balances[msg.sender] > 0);

// 2. Effects (关键！先扣款/清零)
uint256 amount = balances[msg.sender];
balances[msg.sender] = 0; 

// 3. Interactions (最后转账)
(bool success, ) = msg.sender.call{value: amount}("");
```

_原理：当攻击者试图递归调用 withdraw 时，他在步骤 1 的检查中就会失败（因为步骤 2 已经把余额清零了）。_

**4\. 双重保险：互斥锁 (Mutex)** 除了 CEI，工业界标准做法是加上 OpenZeppelin 的 `ReentrancyGuard`。 它就像给 ATM 加了个旋转门，只要里面有人（交易未结束），外面的人绝对进不来。

Solidity

```
modifier nonReentrant() {
    require(_status != ENTERED, "ReentrancyGuard: reentrant call");
    _status = ENTERED;
    _;
    _status = NOT_ENTERED;
}
```

**💡 总结** 不要假设外部调用是安全的。每一次 `call` 都是在把自家的钥匙交给陌生人。 记住：**先改账本，再给钱。**
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->




⛽️ **Solidity Gas 优化实战笔记：如何将 Gas 消耗降低 77%？**

今天用 Foundry 对一个经典的“批量空投”合约进行了极致的 Gas 审计和优化。数据很真实，分享几个核心的底层逻辑。

**📊 测试环境：** 向 100 个地址分发代币。 • 原始版 (Guzzler): **2,378,779 Gas** • 优化版 (Optimizer): **541,000 Gas** 📉 **降幅：~77%**

**1\. 最大的杀手：循环内的 SSTORE** 原始代码在 `for` 循环中每次都执行 `totalDistributed += amount`。 EVM 中写存储（Storage）是最贵的操作。 **✅ 优化方案：** 读写分离。先在 Memory 中计算总量，循环结束后一次性写入 Storage。单这一项贡献了绝大部分的 Gas 节省。

**2\. 内存陷阱：Memory vs Calldata** 当函数参数是数组且只读时，使用 `memory` 会强制 EVM 将数据从交易输入复制到内存，产生拷贝成本和内存扩展成本。 **✅ 优化方案：** 改用 `calldata`。零拷贝，直接切片读取交易原始数据。对于大数组，效果立竿见影。

**3\. 编译器与信任：Unchecked** Solidity 0.8+ 自带溢出检查。但在受 Block Gas Limit 限制的循环中，索引 `i` 不可能溢出 `uint256`。 **✅ 优化方案：** 使用 `unchecked { ++i; }`。虽然单次节省微小，但在高频循环中积少成多。

**4\. 一个务实的发现：“刚性成本”** 即便优化到底，Gas 依然有 54w。为什么不能更低？ 因为业务逻辑要求必须给 100 个新地址写入余额（`balances[recipient] += amount`）。 这 100 次 SSTORE 初始化（2.21w Gas/次）是**业务刚性成本**。

**💡 结论：** 代码层面的优化（Unchecked, Calldata）只能消除“计算浪费”，无法消除“存储成本”。 真正想进一步降低成本，只能改架构（如 Merkle Tree 空投）来减少链上写入次数。
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->






### 📋 Vibe Coding：新时代的编程范式笔记

1\. 核心定义：什么是 Vibe Coding？

-   **不仅仅是代码，更是“感觉”：** Vibe Coding 指的是开发者不再纠结于具体的语法细节或代码实现，而是通过 AI 助手（如 Cursor, Claude Code, Windsurf）以一种**高层次、意图导向**的方式进行开发。
    
-   **从“写代码”到“调氛围”：** 开发者更像是一个“导演”或“指挥家”，通过对话描述需求和愿景（Vibes），由 AI 负责底层的逻辑实现。
    

2\. Affaan Mustafa 分享的关键实操技巧（基于推文系列）

-   **完全交付（Surrender to AI）：** 接受 AI 生成的所有代码，不再逐行审阅（Reviewing diffs），而是通过运行结果来验证“Vibe”是否正确。
    
-   **报错驱动开发：** 遇到错误时直接将报错信息喂回给 AI。不要尝试自己修复，而是让 AI 在当前的“氛围”中自我修正。
    
-   **上下文管理：**
    
    -   使用 `.rules` 或 `CLAUDE.md` 等规则文件，为 AI 划定开发的“品味”和“准则”。
        
    -   利用 MCP（Model Context Protocol）连接外部工具（如数据库、API文档），让 AI 的“感知力”超越编辑器本身。
        
-   **并行化思考：** 开发者可以同时开启多个任务流（Parallel workflows），让 AI 在后台构建组件，自己则负责顶层的逻辑串联。
    

3\. 为什么 Vibe Coding 在 Web3 领域极其重要？

-   **快速原型设计（MVP）：** Web3 项目（如 DeFi 协议的前端或 NFT 铸造页）迭代极快。通过 Vibe Coding，开发者可以在几小时内把一个想法变成链上可运行的 DApp。
    
-   **降低跨语言门槛：** 开发者可能精通 Solidity 但不熟悉 Rust。Vibe Coding 允许你用熟悉的逻辑描述合约安全性，由 AI 生成复杂的 Solana 原生程序。
    
-   **安全审计的“助手”：** 虽然 Vibe Coding 强调“接受一切”，但在 Web3 中，我们利用这种方式快速生成测试用例（Unit Tests）和边缘情况模拟，以“氛围”来包围和捕获潜在的逻辑漏洞。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->







今天了解了一下构建一个完整 DApp（去中心化应用）所需的技术栈，从合约编写到前端交互。

* * *

理解一个 DApp 的数据流向：

1.  **前端 (Frontend)**: 用户界面 (Next.js)。
    
2.  **交互层 (SDK)**: 前端与链对话的翻译官 (Wagmi/Viem)。
    
3.  **智能合约 (Contract)**: 部署在区块链上的后端逻辑 (Solidity)。
    
4.  **节点 (RPC Node)**: 应用通过它连接区块链网络 (Alchemy/Infura)。
    

* * *

### 二、 智能合约开发框架 (Backend)

DApp 的地基，负责编写、编译、测试和部署合约。

| 框架 | 语言 | 核心特点 | 适用场景 |   |
| Foundry | Solidity (测试用) | 🚀 极速 (Rust编写)；支持用 Solidity 写测试用例；自带 Fuzzing (模糊测试)。 | 核心合约开发、安全审计 |   |
| Hardhat | JS / TS | 🏢 生态丰富；插件系统强大；适合写复杂的部署脚本和全栈集成。 | 复杂项目部署、脚本编写 |   |
| Truffle | JS | 💀 已过时；编译慢，维护少。 | 维护旧项目 |   |

* * *

### 三、 前端交互层 (Middleware)

DApp 开发中最繁琐的部分（处理钱包连接、ABI 解析、交易签名）。

1\. 底层库：Viem vs Ethers.js

-   **Ethers.js (v5/v6)**: 老牌霸主，对象导向 (OOP)。虽然经典，但包体积大，非 TypeScript 原生。
    
-   **Viem (新标准)**: 函数式编程，**Tree-shaking 友好 (体积小)**，对 TypeScript 支持极其完美。
    

2\. React 封装库：Wagmi

-   **定义**: 它是 React Hooks 集合。
    
-   **作用**: 把复杂的链上操作变成简单的 Hook。
    
-   **代码示例**:
    
    TypeScript
    
    ```
    // 读取钱包余额
    const { address, isConnected } = useAccount();
    const { data: balance } = useBalance({ address });
    ```
    

* * *

### 四、 钱包接入与用户体验 (Onboarding)

如何让用户优雅地连上你的应用？

-   **RainbowKit**: 🌈 目前最好看的 UI 组件库。开箱即用，支持自定义主题。
    
-   **Privy**: 📧 **Web2 友好型**。支持邮箱、Twitter 登录并自动生成钱包。做面向大众的 Consumer Crypto 应用必选。
    

* * *

### 五、 数据索引 (Indexing)

**痛点**: 区块链不适合做复杂的查询（例如：查询某个系列 NFT 成交额最高的 10 笔交易）。

-   **The Graph**: 去中心化索引协议。你需要写 `GraphQL` 架构和 `AssemblyScript` 映射代码。虽然是标准，但稍微有点重。
    
-   **Ponder**: 🐎 **后起之秀**。完全用 TypeScript 编写，本地开发体验极佳，速度比 The Graph 快很多。
    
-   通常小项目或黑客松用 Ponder，大型去中心化协议用 The Graph。
    

* * *

### 总结

1.  **合约端**: **Solidity** + **Foundry**
    
2.  **Web 框架**: **Next.js** (App Router) + **TypeScript**
    
3.  **连接层**: **RainbowKit** + **Wagmi** + **Viem**
    
4.  **UI 库**: **Tailwind CSS** + **Shadcn/ui** (Web3 应用通常追求极简风格)
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->








### 1\. Uniswap v2: 恒积做市商 (CPMM) — AMM 的基石

核心公式 $x \\cdot y = k$：

这是 v2 的核心。$x$ 和 $y$ 分别代表两种代币的数量，它们的乘积 $k$ 必须保持恒定。

交易原理：

当你用一种代币换另一种时，池子里的 $x$ 增加，$y$ 必须减少，以保持 $k$ 不变，从而推高被买走代币的价格。

**关键概念：**

-   **价格影响 (Price Impact) vs. 滑点 (Slippage)：** PPT 区分了两者。价格影响是交易本身改变了池子比例（$x \\cdot y = k$ 曲线移动）造成的，取决于池子深度；而滑点是预设价格与实际成交价格的偏差，通常由交易顺序或 MEV（最大可提取价值）导致。
    
-   **无常损失 (Impermanent Loss)：** 这是流动性提供者 (LP) 最痛的点。PPT 通过具体算式展示了：当 ETH 价格从 3000 涨到 3200 时，做 LP 的资产总值虽然涨了，但比直接持有代币（不做 LP）要少。这就是“无常损失”。
    
-   **TWAP 预言机：** v2 引入了时间加权平均价格，防止价格瞬间被操纵。
    

* * *

### 2\. Uniswap v3: 集中流动性做市商 (CLMM) — 资金效率的飞跃

v2 的问题是资金利用率低（流动性铺满 $0$ 到 $\\infty$）。v3 解决了这个问题。

集中流动性 (Concentrated Liquidity)：

LP 不再需要把钱铺满整个价格曲线，而是可以选择在特定的价格区间（例如 0.98 - 1.02 USDC/USDT）提供流动性。这意味着在常交易的价格区间内，资金效率极高。

Tick (价格刻度)：

为了实现区间管理，v3 把价格分割成一个个离散的 "Tick"（刻度）。

-   **Tick Spacing：** 不同的池子有不同的刻度间距。比如稳定币对（0.01% 手续费）的间距很小（1），而波动大的币对间距大。
    

技术挑战：

PPT 提到了当 Swap 跨越不同 Tick 时，合约需要轮询计算每一个 Tick 区间的流动性变化，这对算法要求很高。

* * *

### 3\. Uniswap v4: 可程式化流动性做市商 (PLMM) — 极致的定制化

v4 是架构层面的重构，目标是让开发者能在 Uniswap 之上构建任何功能的 DEX。

Hooks (钩子)：

这是 v4 的灵魂。它允许开发者在交易生命周期的关键节点（如：交易前/后、添加流动性前/后）插入自定义逻辑。

-   **应用场景：** 这让开发者可以创造出“动态费率”、“链上限价单”、“KYC 验证”等功能，而不需要重新写一个 DEX。
    

**架构优化：**

-   **Singleton (单体合约)：** v2/v3 每个交易对都是一个独立合约，v4 把所有池子都放在一个合约里，大大节省了 Gas。
    
-   **Flash Accounting (闪电记账)：** 交易过程中不再每一步都转账代币，而是只更新余额账本，直到最后统一结算净额。这极大地降低了 Gas 消耗。
    
-   **Native ETH：** v4 重新支持了原生 ETH，不再强制通过 WETH 交易，进一步降低成本。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->









### 1\. Uniswap v2: 恒积做市商 (CPMM) — AMM 的基石

去中心化交易所（DEX）最经典的自动做市商模型。

核心公式 y\*x=k：

这是 v2 的核心。$x$ 和 $y$ 分别代表两种代币的数量，它们的乘积 $k$ 必须保持恒定。

交易原理：

当你用一种代币换另一种时，池子里的 $x$ 增加，$y$ 必须减少，以保持 $k$ 不变，从而推高被买走代币的价格。

**关键概念：**

-   **价格影响 (Price Impact) vs. 滑点 (Slippage)：** PPT 区分了两者。价格影响是交易本身改变了池子比例（ $x \\cdot y = k$ 曲线移动）造成的，取决于池子深度；而滑点是预设价格与实际成交价格的偏差，通常由交易顺序或 MEV（最大可提取价值）导致。
    
-   **无常损失 (Impermanent Loss)：** 这是流动性提供者 (LP) 最痛的点。PPT 通过具体算式展示了：当 ETH 价格从 3000 涨到 3200 时，做 LP 的资产总值虽然涨了，但比直接持有代币（不做 LP）要少。这就是“无常损失”。
    
-   **TWAP 预言机：** v2 引入了时间加权平均价格，防止价格瞬间被操纵。
    

* * *

### 2\. Uniswap v3: 集中流动性做市商 (CLMM) — 资金效率的飞跃

v2 的问题是资金利用率低（流动性铺满 $0$ 到 $\\infty$）。v3 解决了这个问题。

集中流动性 (Concentrated Liquidity)：

LP 不再需要把钱铺满整个价格曲线，而是可以选择在特定的价格区间（例如 0.98 - 1.02 USDC/USDT）提供流动性。这意味着在常交易的价格区间内，资金效率极高。

Tick (价格刻度)：

为了实现区间管理，v3 把价格分割成一个个离散的 "Tick"（刻度）。

-   **Tick Spacing：** 不同的池子有不同的刻度间距。比如稳定币对（0.01% 手续费）的间距很小（1），而波动大的币对间距大。
    

技术挑战：

PPT 提到了当 Swap 跨越不同 Tick 时，合约需要轮询计算每一个 Tick 区间的流动性变化，这对算法要求很高。

* * *

### 3\. Uniswap v4: 可程式化流动性做市商 (PLMM) — 极致的定制化

v4 是架构层面的重构，目标是让开发者能在 Uniswap 之上构建任何功能的 DEX。

Hooks (钩子)：

这是 v4 的灵魂。它允许开发者在交易生命周期的关键节点（如：交易前/后、添加流动性前/后）插入自定义逻辑。

-   **应用场景：** 这让开发者可以创造出“动态费率”、“链上限价单”、“KYC 验证”等功能，而不需要重新写一个 DEX。
    

**架构优化：**

-   **Singleton (单体合约)：** v2/v3 每个交易对都是一个独立合约，v4 把所有池子都放在一个合约里，大大节省了 Gas。
    
-   **Flash Accounting (闪电记账)：** 交易过程中不再每一步都转账代币，而是只更新余额账本，直到最后统一结算净额。这极大地降低了 Gas 消耗。
    
-   **Native ETH：** v4 重新支持了原生 ETH，不再强制通过 WETH 交易，进一步降低成本。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->










每个 Solidity 文件通常包含这三个部分。

Solidity

```
// 1. SPDX 许可证标识 (必须，否则编译器会警告)
// SPDX-License-Identifier: MIT

// 2. 版本指令 (锁定版本以避免兼容性问题)
pragma solidity ^0.8.20;

// 3. 合约定义 (类似于面向对象语言中的 Class)
contract MyFirstContract {
    // ... 逻辑代码
}
```

* * *

### 2\. 数据类型与存储 (Data & Storage)

2.1 核心数据位置 (Data Locations)

Solidity 中引用类型（数组、结构体、映射）必须声明存储位置：

-   `storage`: 永久存储在区块链上（贵，就像写在硬盘里）。状态变量默认是这个。
    
-   `memory`: 临时存储，函数执行完即销毁（便宜，就像写在内存里）。
    
-   `calldata`: 类似于 memory，但**只读**且不可修改。常用于 `external` 函数的参数，最省 Gas。
    

2.2 常用值类型 (Value Types)

-   `uint256`: 无符号整数（最常用）。`uint` 默认就是 `uint256`。
    
-   `int256`: 有符号整数。
    
-   `bool`: `true` / `false`。
    
-   `address`: 存储 20 字节的以太坊地址。
    
    -   `address payable`: 多了 `transfer` 和 `send` 方法，可以接收 ETH。
        
-   `bytes32`: 固定长度字节数组，比 `string` 更省 Gas，适合存哈希值。
    

2.3 引用类型 (Reference Types)

Solidity

```
// 1. 数组 (Array)
uint[] public arr;          // 动态数组
uint[10] public fixedArr;   // 固定长度数组

// 2. 映射 (Mapping) - 类似哈希表，最常用的存储结构
// Key 不能是 struct、array 或 mapping
mapping(address => uint) public balances;

// 3. 结构体 (Struct) - 自定义数据结构
struct User {
    string name;
    uint score;
}
User[] public users;
```

* * *

### 3\. 函数与修饰符 (Functions & Modifiers)

### 3.1 函数可见性 (Visibility) - 决定谁能调用

-   `public`: 所有人都能调用（内部 + 外部）。会自动生成 Getter 函数。
    
-   `private`: 只有**当前合约**能调用。继承的合约都不能调。
    
-   `internal`: 当前合约 + **继承的合约**能调用（状态变量默认是这个）。
    
-   `external`: 只有**外部**能调用（内部要调用需用 `this.f()`）。数据量大时，用 `calldata` 传参比 `public` 省 Gas。
    

3.2 状态变更能力 (Mutability)

-   `view`: 只读。读取状态变量，但不修改。不消耗 Gas（除非是被合约内部调用）。
    
-   `pure`: 纯函数。**既不读取也不修改**状态变量（例如只做数学计算）。
    
-   `payable`: **允许接收 ETH**。如果函数没有这个关键字，转账给它会报错。
    

3.3 函数修饰符 (Modifiers)

用于在函数执行前/后添加逻辑，常用于权限控制。

Solidity

```
modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _; // 下划线代表“继续执行函数主体代码”
}

function withdraw() public onlyOwner {
    // 只有 owner 能运行这行
}
```

* * *

### 4\. 核心全局变量 (Global Variables)

-   `msg.sender` (address): 当前调用者的地址（最重要！）。
    
-   `msg.value` (uint): 调用时发送的 ETH 数量（单位是 wei）。
    
-   `block.timestamp` (uint): 当前区块的时间戳（注意：矿工可在小范围内操纵，不完全安全）。
    
-   `tx.origin` (address): 交易发起的原始地址（**安全警告**：尽量少用，易导致钓鱼攻击）。
    

* * *

### 5\. 错误处理 (Error Handling)

Solidity 的错误处理采用“回滚（Revert）”机制：一旦报错，之前的所有状态改变全部撤销，且剩余 Gas 返还。

-   `require(condition, "Error Message")`: 最常用。用于检查输入条件、变量是否合法。条件为 `false` 时回滚。
    
-   `revert("Error Message")`: 适用于复杂的逻辑判断结构（如嵌套 `if`）。
    
-   `assert(condition)`: 用于检查**代码逻辑内部错误**（如除以零、溢出）。正常情况下不应触发，一旦触发会扣光所有 Gas。
    

* * *

### 6\. 代码模版

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleCrowdfunding {
    // 状态变量 (存链上)
    address public owner;
    mapping(address => uint) public contributions;
    uint public totalRaised;
    
    // 事件 (用于前端监听)
    event Donated(address indexed contributor, uint amount);

    // 构造函数 (部署时执行一次)
    constructor() {
        owner = msg.sender;
    }

    // 接收 ETH 的函数
    function donate() external payable {
        require(msg.value > 0, "Donation must be > 0");
        
        contributions[msg.sender] += msg.value;
        totalRaised += msg.value;
        
        emit Donated(msg.sender, msg.value);
    }

    // 提款函数
    function withdraw() external {
        require(msg.sender == owner, "Only owner");
        
        uint balance = address(this).balance;
        // 使用 call 发送 ETH 是目前推荐的做法，比 transfer/send 更安全
        (bool success, ) = owner.call{value: balance}("");
        require(success, "Transfer failed");
    }
}
```
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->













## 今天学习了ZK零知识证明  
链上投票的核心痛点与解决方案

### 1.1 传统链上投票 (Traditional On-chain Voting)

**解决了什么？**

-   **去信任化 (Trustless)**：不再依赖中心化服务器计票，杜绝了黑箱操作。
    
-   **不可篡改 (Immutability)**：基于区块链账本，历史记录无法回滚。
    
-   **公开审计 (Public Auditability)**：任何人都可以通过 Input Data 验证计票逻辑。
    

**带来了什么风险？**

-   **隐私裸奔**：`Wallet Address` 和 `Voting Choice` 强绑定。
    
-   **治理攻击**：
    
    -   **贿选 (Bribery)**：因为投票可见，买票者可以确认你是否履约。
        
    -   **报复 (Retaliation)**：在 DAO 或企业投票中，持不同政见者容易被追踪和针对。
        

### 1.2 ZK 投票的价值主张

**核心理念**：将“验证资格”与“揭露身份”解耦。

-   **Public**：我投了一张有效票。
    
-   **Private**：我是谁（Which Address），我投了什么（What Option）。
    

* * *

## 二、 零知识证明在投票系统中的“三大支柱”

在 ZKVote 系统中，ZKP 不是为了“加密数据”，而是为了“证明事实”。

| 责任 | 技术实现原理 | 专家注解 |
| 1. 身份隐私 (你是谁？) | Merkle Tree Inclusion Proof | 我不告诉你我是名单里的哪一行，但我证明我的 Identity Commitment 存在于 Merkle Root 之中。 |
| 2. 资格验证 (你有权吗？) | Knowledge of Secret | 我拥有生成该 Commitment 的 Identity Secret（私钥），证明我是该凭证的合法持有者。 |
| 3. 防双花 (你投过没？) | Nullifier (无效化符) | 这是最天才的设计。利用确定性哈希生成一个唯一标记，一旦上链，再次提交相同的标记会被合约拒绝。 |

* * *

## 三、 系统全流程解析 (Lifecycle)

这是一个基于 `zk-SNARK` 的标准隐私投票生命周期：

### 阶段 1：身份注册 (Registration)

-   **行为**：用户本地生成随机秘密 $Secret$。
    
-   **计算**：$IdentityCommitment = Hash(Secret)$。
    
-   **上链**：将 `IdentityCommitment` 发送给智能合约，合约将其插入 **Merkle Tree**。
    
-   **状态**：链上知道“有人注册了”，但不知道 $Secret$ 是什么。
    

### 阶段 2：本地生成证明 (Proving) - _最耗时的步骤_

用户在浏览器端（链下）运行电路代码，输入以下数据：

-   **Private Input (Witness)**：
    
    -   $Secret$ (只有我知道)
        
    -   $Merkle Path$ (我的位置)
        
    -   $Vote Option$ (我的选择)
        
-   **Public Input**：
    
    -   $Merkle Root$ (当前的合法名单根节点)
        
    -   $Election ID$ (当前投票活动ID)
        
-   **Output**：
    
    -   **Proof** (一串类似于乱码的字节流)
        
    -   **Nullifier Hash** = $Hash(Secret, ElectionID)$
        

### 阶段 3：合约验证 (On-chain Verification)

用户发起交易，调用 `vote()` 函数。

-   **Input Data**：`Proof`, `Nullifier`, `Root`。
    
-   **合约逻辑**：
    
    1.  **Check 1**: `Verifier.verify(Proof, PublicInputs)`。如果 Proof 是伪造的，交易 Revert。
        
    2.  **Check 2**: `mapping(nullifier => bool)`。如果该 Nullifier 已经为 `true`，说明投过票了，交易 Revert。
        
    3.  **Action**: 记录 Nullifier 为 `true`，票数 +1。
        

### 阶段 4：公共审计 (Audit)

-   任何人观察链上数据，只能看到一堆有效的 Proof 和 Nullifier。
    
-   结论：**“有一个合法选民投了一票，且没有重复投票。”** —— 这种信任是基于数学（密码学）而非基于对机构的信任。
    

* * *

## 四、 工程实践与安全边界

作为开发者，部署这套系统时必须注意以下关键点：

### 4.1 关键假设

1.  **前端安全**：用户的 $Secret$ 是在浏览器生成的。如果前端被植入恶意脚本，Secret 可能被窃取。
    
2.  **Relayer (中继器) 的必要性**：
    
    -   即使投票内容是 ZK 的，但如果你用**注册时的钱包**去发送**投票交易**并支付 Gas，链上分析仍然可以将两个行为关联起来（时间戳、IP、Gas 来源）。
        
    -   **解决方案**：使用 Relayer 代付 Gas，或者使用全新的匿名钱包提交 Proof。
        
3.  **可信设置 (Trusted Setup)**：
    
    -   Groth16 算法需要生成 `Proving Key` 和 `Verification Key`。如果生成过程中的“有毒废料” (Toxic Waste) 未被销毁，掌握者可以伪造任意 Proof（伪造假票）。
        

### 4.2 性能瓶颈

-   **Merkle Tree 深度**：树越高，支持的用户越多，但生成 Proof 时的计算量（Merkle Path 校验）呈对数级增长。
    
-   **浏览器算力**：在移动端生成 ZK Proof 可能非常慢，影响用户体验 (UX)
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->














复盘了计算机网络底层，发现很多链上交互的痛点（延迟、丢包、监听失败），本质上都是网络层协议特性的投射。

1\. 交易传播与 Mempool 机制（应用层/传输层）

-   **网络原理**：P2P 网络的 Gossip 协议。
    
-   **实战痛点**：为什么交易发出去后长时间 Pending 甚至消失？
    
-   **技术归因**：交易不是点对点直接给矿工的，而是像病毒一样在节点间“泛洪”（Flooding）。网络延迟会导致你的交易未能及时同步到打包者的 Mempool。
    
-   **开发启示**：
    
    -   **Gas 策略**：提高 Gas Price 不仅是为了贿赂矿工，更是为了提高节点转发的优先级（许多节点会丢弃低 Gas 的 Pending 交易以节省内存）。
        
    -   **覆盖网络**：在做 MEV Bot 或高频交易时，必须直连多个地理位置分散的节点，最大化 Gossip 覆盖范围，减少传播跳数。
        

2\. RPC 交互：HTTP vs WebSocket（应用层）

-   **网络原理**：短连接 vs 长连接。
    
-   **实战痛点**：前端监听链上事件（如 `Transfer`）延迟极高，或者频繁请求导致节点被 Infura/Alchemy 封 IP。
    
-   **技术归因**：
    
    -   **HTTP (REST)**：无状态，每次请求都要重新握手。轮询（Polling）效率极低，浪费 TCP 资源。
        
    -   **WebSocket**：全双工通信，维持长连接。
        
-   **开发启示**：
    
    -   **查询状态**：用 HTTP（如 `eth_getBalance`），适合一次性读取。
        
    -   **监听事件**：必须用 WSS（如 `eth_subscribe`）。在代码中必须处理 WebSocket 的**断线重连（Heartbeat/Keep-alive）**，这是 Web3 前端最容易踩的坑，导致监听静默失效。
        

3\. 节点发现与端口映射（传输层 TCP/UDP）

-   **网络原理**：Kademlia DHT (分布式哈希表) 与 传输协议差异。
    
-   **实战痛点**：自建 Geth/Reth 节点时，发现 Peers 数量一直是 0，无法同步区块。
    
-   **技术归因**：
    
    -   区块链节点通常使用 **UDP** 进行节点发现（Discovery），使用 **TCP** 进行数据传输（RLPx）。
        
    -   如果云服务器的安全组只开了 TCP，节点能“说话”但“找不到人”。
        
-   **开发启示**：
    
    -   **运维配置**：部署节点时，必须同时放行 `30303` 端口的 TCP 和 UDP 流量。
        
    -   **NAT 穿透**：由于 P2P 特性，家庭宽带跑节点由于没有公网 IP，极度依赖 UPnP 或手动端口映射，否则只能作为被动节点。
        

4\. 最终性与网络分区（网络拓扑）

-   **网络原理**：CAP 理论中的 P（分区容错性）。
    
-   **实战痛点**：交易所充值到账慢，或者 DApp 提示“区块重组（Reorg）”。
    
-   **技术归因**：全球网络并非瞬间同步。当网络延迟 > 出块时间，不同地理区域的节点可能暂时维护不同的链分叉（Fork）。
    
-   **开发启示**：
    
    -   **确认数设定**：在处理跨链桥或大额转账后端逻辑时，不要轻信“最新区块”。以太坊 PoS 后虽然有了 Finality 概念，但为了安全，后端监听服务通常需延迟 2-3 个 Epoch 确认状态。
        
    -   **L2 排序器风险**：Arbitrum/Optimism 的 Sequencer 是中心化服务器，如果它出现网络故障，L2 交易会直接停摆，需在前端做好异常降级处理。
        

5\. 安全实战：前端劫持与 DNS

-   **网络原理**：DNS 解析与 BGP 路由。
    
-   **实战痛点**：用户访问了正确的 URL（如 [curve.fi](http://curve.fi)），却与黑客的合约交互。
    
-   **技术归因**：Web3 的去中心化止步于前端。DNS 劫持或 BGP 路由劫持可以将流量导向钓鱼服务器。
    
-   **开发启示**：
    
    -   **IPFS/ENS 部署**：作为开发者，除了部署 AWS/Vercel，应提供 IPFS 哈希版本的备用前端入口，绕过传统的 DNS/CA 体系，实现真正的抗审查和防劫持。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->















昨天例会大家都分享了自己的一些学习中的独到见解，今天周末就想写一写我的学习心得吧。本次实习计划中包含大密度的知识，由于web3的知识广度实在太大，难免遇到自己不擅长的方面。我个人倾向于在学习一个比较陌生的知识面时使用**递归**的方式进行深挖，可能速度上来看会偏慢一些，但是这样带来的理解是更深刻的，我认为这是很值得的一笔交换。作为web3小白，希望能够慢慢用适合自己的方式构建起自己的web3知识网络。下面以NFT为例子来进行说明：

* * *

# 如何通过“递归式学习”看透 NFT 与 IPFS

### 什么是“递归式学习”？

在编程中，递归（Recursion）是指函数调用自身来解决更小的问题。

在学习 Web3 的过程中，我发现线性学习是行不通的。当我试图理解 NFT 时，撞上了“存储”的墙；当试图理解 IPFS 时，又撞上了“哈希”的墙。

于是选择向下递归——暂停当前层级，去补齐缺失的底层拼图（Base Case），再带着答案回归（Return）上层。

* * *

## 最初的误解与困惑

一开始，我和大多数人一样，认为：

-   **NFT** = 一张很贵的图片。
    
-   **IPFS** = 一个去中心化的云盘，永远不会丢失数据。
    

直到我遇到了一个逻辑悖论：

> “如果我把图片原件复制一份，发一个新的 NFT，这两个看起来一模一样，为什么大家说前一个是真的，后一个是假的？计算机怎么分辨图片长得一样？”

这个问题让我卡住了。我意识到，如果不理解底层，永远只是在玩弄概念。于是，开启了**第一次向下递归**。

* * *

## 补全缺失的地基

为了回答上面的问题，获取了相应的资料补充了下面的几个知识点：

### 1\. 哈希 (Hash)：数据的数字指纹

相当于一个碎纸机

-   **原理：** 把任何数据（无论是一本书还是一张图）扔进去，都会生成一串固定的字符（比如 `QmXoy...`）。
    
-   **雪崩效应：** 最神奇的是，只要我把输入数据改动**一个像素**，哪怕只是把字母 `A` 改成 `a`，输出的哈希值就会面目全非。
    
-   **结论：** 计算机不看“图片长得像不像”，只比对“哈希值是否一致”。
    

### 2\. 键值对 (Key-Value) 与 映射 (Mapping)

学会了最基础的数据存储方式：**查字典**。

-   **Key (键)：** 唯一的索引（比如学号）。
    
-   **Value (值)：** 对应的内容（比如名字）。
    
-   理解了数据库和智能合约其实就是一大本“字典”。
    

### 3\. P2P 网络：没有“房东”的互联网

Web2 是我们要去“房东”（服务器）家里拿东西；Web3 是我们在广场上（P2P 节点）互相喊：“谁有这个东西？给我复制一份。”

区别就在于是否需要一个中心化的服务器来完成一系列操作

* * *

## 🔄 The Return

基础补齐后，重新审视 NFT 和 IPFS

### 1\. 重新定义 NFT：它不是图片，是“账本”

对于NFT 不再看到图片，而是看到了**代码层面的哈希表 (Mapping)**。

-   **NFT 的真身：** 在以太坊的智能合约里，有一个巨大的表格：
    
    Plaintext
    
    ```
    Key (Token ID)   =>   Value (拥有者地址)
    --------------------------------------
    #8888            =>   0xUserA...
    ```
    
-   **所谓的“转账”：** 并不是图片飞到了你的钱包，仅仅是合约把表格里的 `Value` 从 `UserA` 改成了 `UserB`。
    
-   **所谓的“确权”：** 依靠**公钥私钥**技术。只有拥有私钥的人，才有权限命令合约去修改这个表格。
    

### 2\. 重新定义 IPFS：它不是硬盘，是“指纹库”

为什么 NFT 的图片防篡改？答案在于 **IPFS 的“内容寻址”**。

-   **传统 HTTP (Web2)：** 按**位置**找。
    
    -   `https://server.com/monkey.png`
        
    -   _风险：_ 房东（服务器）有权限进行篡改。
        
-   **IPFS (Web3)：** 按**哈希 (内容)**找。
    
    -   `ipfs://QmXoy...` (这个乱码就是图片的哈希)
        
    -   _安全：_ 因为哈希的“雪崩效应”，只要图片被换成猪，哈希值一定会变。所以，**只要哈希对得上，你就绝对不可能买到假货。**
        

* * *

## **The Synthesis**

一个标准的 NFT 系统是这样的：

1.  **左边（链上）：** 智能合约记录“所有权” (`ID => Owner`)。
    
2.  **右边（链下）：** IPFS 存储“内容” (`Hash => Picture`)。
    
3.  **中间（桥梁）：** 这是一个叫 `TokenURI` 的指针。
    

最危险的地方不是左边（无法篡改），也不是右边（无法篡改），而是中间的连接处

> 如果项目方在合约里留了一个“后门”函数，允许管理员修改 `TokenURI` 的指向，那么即便图片存在 IPFS 上也是徒劳的。项目方随时可以把指针从“真猴子”移到“假猴子”上。这就是传说中的 **Rug Pull（卷款跑路）** 的技术原理。

* * *
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
















### **以太坊核心架构与原理深度研读笔记（第2-4章）**

通过对第2至4章的系统性学习，我从底层的网络拓扑、状态模型以及执行环境三个维度，重新构建了对以太坊基础设施的认知。这不再仅仅是对概念的理解，而是涉及如何构建安全、高效的去中心化应用的工程基础。

**一、 网络层：节点架构与客户端机制（第2章）**

本章的核心在于理解“合并（The Merge）”后的以太坊节点架构演进，以及不同节点类型在实际业务场景中的选择策略。

**1\. 执行层与共识层的解耦架构** 现在的以太坊节点架构已从单体转向了模块化。运行一个完整的以太坊节点，必须同时维护两个相互协作的客户端：

-   **执行客户端（Execution Client, EL）：** 负责处理交易、维护内存池（Mempool）、执行 EVM 状态转换以及管理最新的状态树。主要实现包括 Geth、Nethermind 等。
    
-   **共识客户端（Consensus Client, CL）：** 也就是所谓的信标节点（Beacon Node），负责权益证明（PoS）共识逻辑、验证区块签名以及跟踪链头。主要实现包括 Prysm、Lighthouse 等。
    
-   **Engine API：** 两者之间通过 Engine API 进行加密通信，形成了一个“执行有效负载”与“共识验证”的闭环。
    

**2\. 节点类型的工程选择** 在实际开发或部署基础设施时，必须根据业务需求（如数据分析、交易发送、历史回溯）选择正确的节点类型：

-   **全节点（Full Node）：** 同步并验证区块链头和区块体，维护当前状态。虽然会修剪旧的历史状态数据，但能够验证数据的有效性，适合大多数 DApp 的后端接入。
    
-   **归档节点（Archive Node）：** 存储了从创世区块开始的所有中间状态（State Trie 的每一次变更）。在需要进行历史余额查询（Trace 调用）或复杂的链上数据分析时是必须的，但存储成本极高。
    
-   **轻节点（Light Node）：** 仅下载区块头，通过默克尔证明（Merkle Proof）向全节点请求特定数据。这是未来去中心化钱包和移动端应用实现“无信任验证”的关键路径。
    

**3\. 同步策略的优化** 传统的 Full Sync（全量同步）耗时过长，现代节点主要采用 **Snap Sync（快照同步）**。该模式通过下载最近的区块头和状态快照（State Snapshot），而非逐个执行历史交易，极大缩短了节点启动和加入网络的时间。

* * *

**二、 数据层：账户模型与状态管理（第3章）**

与比特币的 UTXO 模型不同，以太坊采用了更利于构建智能合约的 **账户模型（Account-based Model）**。理解这一层的关键在于掌握状态（State）是如何被存储和更新的。

**1\. 账户结构的底层字段** 以太坊的“世界状态”实际上是一个巨大的键值对映射（Map），每个地址对应一个账户对象，包含四个核心字段：

-   `nonce`：用于防止重放攻击的计数器。对 EOA 是交易序号，对合约是合约创建序号。在开发交易发送模块时，管理 nonce 是并发控制的核心痛点。
    
-   `balance`：以 Wei 为单位的 ETH 余额。
    
-   `storageRoot`：账户存储树（Storage Trie）的根哈希。这是合约存储持久化数据的入口，是 DeFi 协议巨量数据的栖息地。
    
-   `codeHash`：合约代码的哈希值。EOA 账户此字段为空，一旦部署，合约代码逻辑不可更改（即哈希固定）。
    

**2\. EOA 与合约账户的本质区别**

-   **EOA（外部拥有账户）：** 由私钥控制，是交易发起的唯一原点。
    
-   **CA（合约账户）：** 由代码逻辑控制，无法主动发起交易，只能被动响应。
    
-   **技术启示：** 随着 ERC-4337 账户抽象（Account Abstraction）的发展，未来 EOA 和 CA 的界限在应用层将逐渐模糊，智能合约钱包将成为主流。
    

**3\. 合约地址生成的确定性** 合约地址并非随机生成，而是具备严格的确定性，这对 Layer 2 充值地址生成和反事实部署至关重要：

-   **CREATE 操作码：** `Hash(Sender + Nonce)`。地址依赖于部署者的 Nonce，通过此方式很难预测未来的合约地址。
    
-   **CREATE2 操作码：** `Hash(0xff + Sender + Salt + InitCode)`。地址与 Nonce 无关，依赖于 `Salt` 和代码本身。这允许我们在合约部署前就预知地址，是构建“未部署即可充值”的交易所钱包工厂的核心原理。
    

* * *

**三、 执行层：智能合约与 EVM 机制（第4章）**

本章深入探讨了以太坊的计算引擎——EVM，以及智能合约从代码到链上执行的生命周期。

**1\. EVM 的图灵完备与 Gas 机制** EVM 是一个基于堆栈的虚拟机。为了解决停机问题（Halting Problem）并防止资源滥用，引入了 **Gas 机制**。

-   **指令计价：** 每个操作码（Opcode）都有固定的 Gas 成本（如 `SSTORE` 写入存储极其昂贵，`ADD` 计算极其便宜）。
    
-   **Gas 优化方向：** 开发者必须理解底层的存储布局（Storage Layout），尽量减少状态写入，利用 `calldata` 代替 `memory` 等技巧来降低用户交互成本。
    

**2\. 编译与 ABI 接口** Solidity 代码本身无法被 EVM 识别，必须经过编译流程：

-   **Bytecode（字节码）：** 分为“部署字节码（Creation Code）”和“运行时字节码（Runtime Code）”。部署代码包含构造函数逻辑，执行完后返回运行时字节码存储在链上。
    
-   **ABI（应用二进制接口）：** 定义了函数签名和参数编码规则。前端与合约交互、合约与合约交互，本质上都是对 data 字段进行 ABI 编码（Encoding）和解码（Decoding）的过程。
    

**3\. 不可篡改性与升级方案** “代码即法律”意味着合约一旦部署，逻辑无法直接修改。但在工程实践中，业务迭代是刚需。

-   **代理模式（Proxy Pattern）：** 这是当前主流的合约升级方案。通过 `DELEGATECALL` 操作码，将数据存储在代理合约（Proxy），逻辑执行委托给逻辑合约（Implementation）。升级时，只需修改代理合约指向的逻辑合约地址，从而在保留状态的前提下更新逻辑。
    

* * *

### **学习总结与行动项**

这三章的内容构成了 Web3 开发的基石。我深刻理解到：以太坊不仅仅是一个支付网络，更是一个由状态机驱动的全球计算平台。其设计的核心在于**确定性**（通过哈希链接一切）和**资源受限性**（Gas 机制）。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

















今天的学习内容主要包括NFT、uniswap V2

## NFT

### NFT如何保持唯一性

**【NFT 唯一性原理】** NFT 的唯一性并不在于“图片文件”本身（图片确实可以被复制并绑定到新的合约地址），而在于**“官方合约地址 + Token ID”**这一链上组合的不可篡改性。从技术本质看，NFT 是链上记录所有权的凭证，它指向图片的存放位置（Metadata）。当你把原图**绑定到自己创建的新地址**时，虽然视觉画面相同，但合约地址（出处）不同，这就像“卢浮宫里的蒙娜丽莎真迹”与“纪念品店的高清海报”的区别。**区块链浏览器**和交易平台只认可由官方合约发行的资产，因此 NFT 交易的核心价值在于**可溯源的官方背书**与确权凭证\*\*，而非图片数据本身。

### IPFS

| 特性 | HTTP (Web2) | IPFS (Web3) |
| 寻址方式 | 基于位置 (Location-based) | 基于内容 (Content-based) |
| 查找逻辑 | 找“服务器 IP”或“域名” | 找“文件的哈希值 (Hash)” |
| 例子 | 去图书馆第3排第5层找书 | 根据“书的内容指纹”找书 |
| 缺点/风险 | 服务器挂了/跑路 = 404 | 文件一旦修改 = 哈希变了 (地址变了) |
| 优点 | 简单、中心化控制 | 防篡改、去中心化 |

### 关键技术概念

-   **CID (Content Identifier)：** 内容标识符。上传文件到 IPFS 后生成的唯一哈希地址（例如 `QmXoy...`）。
    
-   **防篡改机制：** 只要文件改动一个像素，生成的 CID 就会完全改变。因此，如果不改合约，没人能悄悄替换 NFT 的图片
    

### IPFS 在 NFT 中的工作流

NFT 并不是把图片存在链上，而是存了一个“指针”。

1.  **存储：** 将图片 (`ape.png`) 上传至 IPFS ➡️ 生成 `CID-1`。
    
2.  **元数据：** 创建 JSON 文件（包含 `name` 和指向 `ipfs://CID-1` 的链接）➡️ 上传至 IPFS ➡️ 生成 `CID-2`。
    
3.  **上链：** 智能合约铸造 (Mint) 时，将 `TokenURI` 设置为 `ipfs://CID-2`。
    
    -   _链上验证权属 ➡️ 读取链上 URI ➡️ 索引到 IPFS 上的元数据 ➡️ 展示图片。_
        

## Uniswap

## 1\. 核心特性 (Key Features)

### 1.1 任意 ERC-20 交易对 (Arbitrary Pairs)

-   **机制**：允许任意两个 ERC-20 代币直接创建流动性池，不再像 v1 那样必须以 ETH 为中介。
    
-   **优势**：
    
    -   **减少滑点与费用**：直接交易对（如 DAI/USDC）让交易者只需支付一次手续费，承受一次滑点。
        
    -   **降低无常损失 (IL)**：对于相关性强的资产（如稳定币对），直接组对的无常损失通常低于与 ETH 组对。
        

### 1.2 价格预言机 (Price Oracle)

-   **抗操纵设计**：v2 在每个区块的第一笔交易之前测量并记录价格（即上一个区块的收盘价）。这使得攻击者必须控制至少两个区块才能操纵价格，极大增加了攻击成本。
    
-   **TWAP (时间加权平均价)**：核心合约维护一个累加器 (Accumulator)，记录每秒的价格总和。
    
    -   外部合约只需读取 t1 和 t2 两个时间点的快照，即可计算出该时间段的平均价格。
        
    -   计算逻辑：(t2时刻的累加值 - t1时刻的累加值) / (t2 - t1)。
        
-   **精度**：使用 UQ112.112 定点数格式存储价格，保证了极高的计算精度。
    

### 1.3 闪电换 (Flash Swaps)

-   **定义**：允许用户先收到代币并使用，只要在同一笔原子交易结束前归还（或支付等值资产）即可。
    
-   **机制**：乐观转账。合约先转出代币，然后执行用户定义的回调函数，最后检查 k 值常数是否满足（扣除费用后）。
    
-   **用途**：无资本套利、借贷协议清算等。
    

## 2\. 经济模型 (Economic Model)

### 2.1 手续费结构

-   **总费用**：交易者支付 0.30% 的费用。
    
-   **协议费开关 (Protocol Fee)**：
    
    -   硬编码了一个开关，可以开启 0.05% 的协议费。
        
    -   如果开启：LP 获得 0.25%，协议获得 0.05% (即总费用的 1/6)。
        
-   **收取方式**：不在每笔交易中收取（为了节省 Gas），而是在流动性存取 (Deposit/Withdraw) 时，通过增发 LP Token 的方式收取。计算基于 k 值的平方根增长量。
    

### 2.2 初始流动性份额 (Initial Supply)

-   **v1 问题**：v1 初始份额等于存入的 ETH 数量，依赖于初始存入的比例，可能被操纵。
    
-   **v2 改进**：初始铸造的份额等于存入两资产数量的几何平均数：sqrt(x \* y)。
    
-   **防尘攻击**：首次铸造时，会永久销毁前 10^-15 (MINIMUM\_LIQUIDITY) 的份额，防止有人通过极小额存款抬高单个 Share 的价值。
    

## 3\. 系统架构与安全 (Architecture & Security)

### 3.1 核心架构

-   **语言**：从 Vyper (v1) 迁移到了 Solidity。
    
-   **Core / Router 分离**：核心合约 (UniswapV2Pair) 只负责最基础的逻辑（存钱、算价格），以减少攻击面；复杂逻辑移至 Router 合约。
    
-   **确定性地址**：使用 CREATE2 操作码生成 Pair 合约，可以在链下计算出交易对合约地址。
    

### 3.2 边缘情况处理

-   **支持非标准代币**：如果 transfer() 函数没有返回值（如 USDT），v2 视其为成功，防止交易失败。
    
-   **支持通缩/变基代币**：
    
    -   sync()：强制更新储备量以匹配当前余额（处理通缩或空投）。
        
    -   skim()：允许提取超出 uint112 存储上限或被强制打入合约的代币。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->


















今天参加了web3安全和合规的分享会 收获颇丰 结合Web3 实习手册[「安全与合规」](https://web3intern.xyz/zh/security/)部分 以下是学习内容：

## 第一部分：法律与合规风险

这部分主要讲的是在国内从业必须知道的“红线”。虽说Web3是去中心化的，但人是中心化的，只要人在国内，就必须遵守法律。

### 1\. 国内监管的三大“高压线”

-   **融资红线（ICO/IDO/IEO）**：
    
    -   **核心逻辑**：不管叫“积分”、“治理代币”还是“凭证”，只要具备**融资功能**和**二级市场流动性**，就可能被定性为非法集资或非法发行证券。
        
    -   **避坑点**：即使是技术人员，如果参与了代币模型设计（Tokenomics）、空投合约编写，也可能被视为“共同犯罪”，不能单纯用“我只是写代码的”来甩锅。
        
-   **涉赌与传销风险**：
    
    -   **链游（GameFi）**：如果设计成“充值 -> 抽盲盒/转盘（概率性） -> 提现”，很容易被认定为**开设赌场罪**。
        
    -   **推广模式**：DAO或社群如果涉及“多级返佣”、“拉人头计酬”，极易触犯**组织、领导传销活动罪**。
        
-   **OTC（场外交易）与洗钱**：
    
    -   **风险**：如果出金（卖U变现）收到了电信诈骗或赌博的黑钱，银行卡会被冻结（“冻卡”），甚至可能涉嫌**帮信罪**（帮助信息网络犯罪活动罪）或**掩饰、隐瞒犯罪所得罪**。
        
    -   **对策**：不随意在不明来源的场外群交易，尽量走正规合规渠道。
        

### 2\. 国际监管趋势（Global Trends）

-   **FATF（金融行动特别工作组）**：全球反洗钱标准的制定者。他们推行的**Travel Rule（旅行规则）**要求交易所必须收集转账双方的信息（类似银行转账），这对DeFi的隐私性是巨大挑战。
    
-   **稳定币监管**：
    
    -   **美国/欧盟（MiCA法案）**：越来越严格，要求发行商必须有1:1的资产储备。
        
    -   **香港**：正在推行VASP（虚拟资产服务提供商）牌照制度，以后在香港无牌经营交易所也是违法的。
        
-   **结论**：全球都在从“野蛮生长”走向“合规化”，以后合规赛道（如RWA、合规稳定币）会有大机会。
    

* * *

## 第二部分：Web3 打工人的自我修养——职场与劳动风险

学完才发现很多坑以前完全没意识到。

### 1\. 脆弱的雇佣关系

-   **远程办公的代价**：很多Web3项目都在海外（新加坡、BVI等），在国内没有实体公司。这意味着：
    
    -   **没有社保公积金**：这对落户、买房、看病影响巨大。
        
    -   **劳动合同无效**：如果发生纠纷（裁员不赔偿），国内劳动法很难保护你，因为雇主主体在海外。
        
-   **EOR（名义雇主）**：有些靠谱项目会委托国内第三方公司签约发工资，这种相对有保障。
    

### 2\. 薪酬里的“猫腻”

-   **U本位工资（USDT/Token支付）**：
    
    -   **法律风险**：国内规定工资必须以人民币支付。收U在法律上可能不被认定为“工资”，影响社保基数。
        
    -   **归零风险**：如果是收项目方自己的Token（期权/代币），一旦项目归零，打工一年等于白干。
        
-   **出金难**：工资发了U，自己去换人民币时，又回到了上面提到的“冻卡风险”。
    
    -   **笔记重点**：入职前一定要谈好薪资结构，最好保留部分法币（人民币）收入以维持生活，减少出金频率。
        

* * *

## 第三部分：技术安全与防骗（补充整理）

### 1\. 钱包安全（私钥 = 资产）

-   **助记词管理**：绝不截图、不存微信收藏夹、不存云盘。最好是用物理介质（纸、金属板）抄写并离线保管。
    
-   **冷热分离**：大资金放冷钱包（Ledger/Trezor），日常交互用热钱包（MetaMask），且里面只放少量资金。
    

### 2\. 交互陷阱

-   **授权（Approve）骗局**：很多钓鱼网站会伪装成空投页面，让你签名一个`SetApprovalForAll`或者无限授权。
    
    -   **对策**：使用插件（如Rabby Wallet、Scam Sniffer）预执行交易，看清楚到底授权了什么权限。
        
-   **签名钓鱼**：有些签名请求不是交易，而是“签名登录”或者Permit签名，一旦签了，黑客不需要私钥就能转走代币。
    

### 3\. 社会工程学

-   **电报/Discord私信**：所有主动私信你的“客服”、“管理员”100%是骗子。
    
-   **虚假链接**：不要点不明链接，官方推特也可能被黑，一切以多方交叉验证为准。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



















### 1\. 概念辨析：Web3 的认识论 (Epistemology)

-   **Web 3.0 (Semantic Web, 1999)**:
    
    -   **提出者**: Tim Berners-Lee.
        
    -   **核心逻辑**: **数据互操作性**。通过 RDF/OWL 等标准，使非结构化数据转变为机器可理解的“知识图谱”，旨在解决信息孤岛。
        
-   **Web3 (Decentralized Web, 2014)**:
    
    -   **提出者**: Gavin Wood.
        
    -   **核心逻辑**: **状态持久性与所有权**。基于密码学背书的分布式账本，构建一个去信任（Trustless）的价值传输协议。
        
    -   **本质**: 它是对互联网协议栈（TCP/IP）的一层“价值补丁”，实现了**信息流与价值流的原子化绑定**。
        

### 2\. 以太坊本体论：准图灵完备的单例状态机

从计算机科学视角定义，以太坊不仅是区块链，而是一个 “全球单例状态机” (Global Singleton State Machine)。

-   **状态转换函数**: 以太坊的本质由公式 `σ_{t+1} ≡ Υ(σ_t, T)` 定义。
    
    -   `σ` (Sigma): 全局状态（账户余额、合约存储）。
        
    -   `T`: 交易（即经过签名的指令）。
        
    -   `Υ`: 状态转换函数（即 EVM 的规则）。
        
-   **Gas 的计算理论基础**: Gas 机制并非单纯的经济收费设计，而是为了解决计算机科学中的\*\*“停机问题” (Halting Problem)\*\*。
    
    -   由于 EVM 是图灵完备的，无法预知一段代码是否会无限循环。
        
    -   Gas 引入了强制的“执行边界”，确保任何计算过程在有限步骤内必然终止（无论成功或由于 Gas 耗尽而失败），从而保证网络的**活性 (Liveness)**。
        

### 3\. 共识机制

共识机制不仅是达成一致的算法，更是分布式系统中的**抗女巫攻击 (Sybil Resistance)** 方案与**分叉选择规则 (Fork Choice Rule)** 的结合。

-   **PoW (Work)**: 基于**热力学**的安全性。
    
    -   利用物理世界的稀缺资源（能源/硬件）构建攻击成本。
        
    -   **局限性**: 仅具备**概率性最终确定性 (Probabilistic Finality)**，安全性随区块深度线性增加，无法在协议层杜绝回滚。
        
-   **PoS (Stake)**: 基于**内生博弈论**的安全性。
    
    -   利用**虚拟化的稀缺资源**（原生代币 ETH）构建验证门槛。
        
    -   **Casper FFG 协议**: 引入了**经济罚没 (Slashing)** 机制，使得攻击者的成本是显性的、可量化的资产销毁。
        
    -   **确定性 (Finality)**: 引入 Checkpoint 机制，使得区块状态在经过 2 个 Epoch 后达到“经济上不可逆”的绝对安全状态。
        

### 4\. 系统语言范式：Rust 的工程必要性

在底层基础设施（Layer 1/Layer 2 节点、ZK 电路）的构建中，Rust 正在取代 Go/C++ 成为标准，其核心驱动力源于**系统安全性**需求。

-   **内存安全 (Memory Safety)**: Rust 的所有权 (Ownership) 模型在编译阶段杜绝了空指针、数据竞争等内存错误，这对处理千亿美金资产的区块链节点至关重要。
    
-   **确定性与零抽象成本**: 区块链要求严格的**确定性执行 (Deterministic Execution)**。Rust 无垃圾回收 (No-GC) 的特性避免了运行时（Runtime）的不确定性停顿，同时在零知识证明（ZK）涉及的大量多项式运算中提供了极致性能。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->




















## **1/12**

### **以太坊中文周会**

![image-20260112140428024.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Eeeeye/images/2026-01-12-1768227646059-image-20260112140428024.png)

完整看完周会，发现内容相对深入且相对前沿，观看门槛较高，希望可以通过持续学习适应周会的知识密度

## **Faucet**

由于先前注册过Metamask, 故直接前往Faucet网站输入metamask钱包Ethereum网络地址，获取Sepolia ETH（0.05）,并测试给陌生钱包地址转账：

![截图 2026-01-12 21-41-30.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Eeeeye/images/2026-01-12-1768227659898-___2026-01-12_21-41-30.png)

交易完成后 获取tx link，在区块浏览器上查看结果：

![image-20260112215007110.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Eeeeye/images/2026-01-12-1768227679997-image-20260112215007110.png)

## **My First NFT**

[https://nft.myfirst.io/](https://nft.myfirst.io/)

进入LXDAO的教学网站，连接至metamask钱包，直接使用网站的前端页面进行铸造，使用前面领的Sepolia ETH作为gas，成功铸造

![image-20260112220713587.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Eeeeye/images/2026-01-12-1768227694172-image-20260112220713587.png)

## **Unphishable 钓鱼攻防挑战**

### **No.0x0001**

这一章是简单的钱包注册，以及测试币领取，前面已完成

![image-20260112221309750.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Eeeeye/images/2026-01-12-1768227707961-image-20260112221309750.png)

### **No.0x0002**

第二章是一个钓鱼网站的模拟，通过恢复钱包帮助的方式欺骗，诱导输入私钥，拒绝输入即可通过

![image-20260112221811624.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/Eeeeye/images/2026-01-12-1768227729308-image-20260112221811624.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
