---
timezone: UTC+8
---

# zhangzw0622-sketch

**GitHub ID:** zhangzw0622-sketch

**Telegram:** @Aureliano1209

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->
**Figma 运营设计速成笔记**

**1\. 快速起步：建立画布 (Frame)**

Figma 的“画板”叫做 **Frame**。

-   **操作**：按快捷键 `F`。
    
-   **右侧选择**：在右侧面板选择 `Social Media` -> `Twitter Post` (1600 x 900) 或 `Instagram Post` (1080 x 1080)。
    
-   _运营场景：Twitter 是 Web3 主阵地，建议默认使用 1600x900 的尺寸，保证在手机和电脑上都不被裁切。_
    

**2\. 核心工具：做海报只需要这 4 招**

**A. 矩形与图片 (R)**

-   **快捷键**：`R` (画矩形)。
    
-   **填充图片**：选中矩形 -> 右侧 `Fill` -> 点击颜色方块 -> 顶部下拉选择 `Image` -> 上传图片。
    
-   **小技巧**：直接把图片文件从电脑桌面拖进 Figma 画布最快。
    

**B. 文本排版 (T)**

-   **快捷键**：`T`。
    
-   **属性调整**：右侧 `Text` 面板。
    
    -   **Font**：英文推荐 _Inter_ 或 _Roboto_（Web3 常用科技感字体）；中文推荐 _Noto Sans SC_（思源黑图）。
        
    -   **Line height**：行高设置在 120%-140% 读起来最舒服。
        

**C. 圆形头像与遮罩 (Masking) —— _做 AMA 嘉宾海报必用_**

Web3 海报通常需要放 4-5 个圆形的嘉宾头像，**不要**去截圆形的图，要用遮罩：

1.  按 `O` 画一个正圆。
    
2.  把嘉宾照片拖进来，放在圆形的**上方**。
    
3.  同时选中“照片”和“圆形”。
    
4.  点击顶部工具栏中间的 **月牙形状图标 (Use as mask)**。
    
5.  _结果：照片就变成了圆形，且可以随意拖动调整位置。_
    

**D. 自动对齐 (Auto Layout) —— _排版多个 Logo/嘉宾名必用_**

当你有一排赞助商 Logo 或一排嘉宾名字时，手动对齐很累，用这个：

1.  选中所有 Logo。
    
2.  按 `Shift + A`。
    
3.  它们会自动排成一行。
    
4.  在右侧 `Auto Layout` 面板调整 `Gap` (间距) 数值，一键调整所有 Logo 的距离。
    

**3\. 效率神器：社区插件 (Plugins)**

点击左上角“资源”图标（方块+加号）-> `Plugins`，搜索并运行：

-   **Unsplash**：找高质量的背景图（搜索 "Technology", "Abstract", "Crypto"）。
    
-   **Iconify**：找图标（搜索 "Twitter", "Ethereum", "Calendar" 等 Icon 直接拖入）。
    
-   **Remove BG**：一键以此扣除人像背景（做嘉宾介绍图神器）。
    
-   **Blobs**：生成不规则流体形状（用作 Web3 风格的背景装饰）。
    

**4\. 导出 (Export)**

做好的图要发推特，导出很关键：

1.  选中你的 Frame。
    
2.  看右下角 `Export` 面板。
    
3.  **关键设置**：将 `1x` 改为 `2x` (两倍图)。
    
    -   _原因：推特会压缩画质，导出 2 倍图能保证文字在手机上看起来清晰锐利。_
        
4.  格式选择 `PNG` 或 `JPG`，点击 Export
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->

# **Figma 学习笔记**

**1\. 核心概念与界面布局**

Figma 是基于浏览器的云端设计工具，实时协作是其最大优势。

-   **界面分区**：
    
    -   **左侧面板 (Layers & Assets)**：管理图层层级、页面 (Pages) 和组件库 (Assets)。
        
    -   **中间画布 (Canvas)**：主要工作区，无限大。
        
    -   **右侧面板 (Design/Prototype/Inspect)**：
        
        -   **Design**：调整颜色、尺寸、字体、对齐方式。
            
        -   **Prototype**：制作交互动效。
            
        -   **Dev Mode (开发模式)**：查看代码标注（CSS/iOS/Android）。
            

**2\. 基础操作与工具**

-   **Frame (画板/框架) vs Group (编组)**：
    
    -   **Frame (**`F` **或** `A`**)**：Figma 的核心。不仅仅是画板，还可以嵌套。**具有独立属性**（如裁剪内容 Clip content、布局网格 Layout Grid）。
        
    -   **Group (**`Ctrl/Cmd + G`**)**：仅仅是将图层打包，属性跟随子元素变化。
        
    -   _笔记建议：尽量使用 Frame 代替 Group，以便使用 Auto Layout。_
        
-   **常用快捷键 (必须以此提高效率)**：
    
    -   **移动**：`V`
        
    -   **画板**：`F` 或 `A`
        
    -   **矩形**：`R` | **圆形**：`O` | **文本**：`T`
        
    -   **吸管**：`I`
        
    -   **复制拖拽**：按住 `Alt` (Win) / `Option` (Mac) 拖动。
        
    -   **测距**：选中一个物体，按住 `Alt` / `Option` 指向另一个物体。
        

**3\. 进阶核心功能 (重难点)**

**A. Auto Layout (自动布局)** `Shift + A`

这是 Figma 最强大的功能，模拟了前端代码（Flexbox）的布局逻辑。

-   **作用**：让容器根据内容自动伸缩，或自动排列子元素。
    
-   **关键属性**：
    
    -   **Direction**：水平或垂直排列。
        
    -   **Padding**：内边距（上下左右）。
        
    -   **Gap**：子元素之间的间距。
        
    -   **Resizing (响应式调整)**：
        
        -   `Fixed`：固定宽高。
            
        -   `Hug contents`：包裹内容（随内容变大变小）。
            
        -   `Fill container`：充满容器（随父级容器变大变小）。
            

**B. Components (组件) & Variants (变体)**

-   **Component (**`Ctrl/Cmd + Alt/Option + K`**)**：
    
    -   **Main Component (母版)**：修改它，所有副本都会变。图标是菱形 ◇。
        
    -   **Instance (实例)**：母版的副本。图标是空心菱形。
        
-   **Variants (变体)**：
    
    -   将相似组件（如按钮的不同状态：默认、悬停、点击）合并为一个组件集，通过右侧属性面板下拉切换，无需手动查找。
        

**C. Styles (样式库)**

-   **作用**：统一管理颜色、字体、阴影。
    
-   **操作**：点击属性旁的四个小点图标 `::` -> `+` 号创建。
    
-   _笔记建议：项目开始前先定义好 Color Styles (Primary, Secondary, Neutral) 和 Text Styles (H1, H2, Body)。_
    

**4\. 原型与交互 (Prototyping)**

-   **连接**：切换到 Prototype 面板，拖拽元素边框上的“小圆点”到目标页面。
    
-   **常用交互 (Interaction)**：
    
    -   `On Click`：点击跳转。
        
    -   `While Hovering`：悬停效果（常用于按钮）。
        
    -   `Smart Animate`：智能动画。Figma 会自动补间两个页面中同名图层的变化（如位置移动、透明度变化）。
        

**5\. 插件推荐 (Plugins)**

点击工具栏的“资源”图标 (方块+加号) -> Plugins。

-   **Unsplash**：快速填充高质量图片。
    
-   **Iconify**：海量免费图标库，直接拖入使用。
    
-   **Remove BG**：一键以此扣除图片背景。
    
-   **Lorem Ipsum**：快速生成乱数假文（占位文本）。
    

**6\. 交付 (Handoff)**

-   可以直接分享链接给开发人员。
    
-   开发人员开启 **Dev Mode** 可以直接复制 CSS 代码，查看 Padding 和 Margin 数值。
    

* * *
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->


# 从透明链上投票到 ZK 匿名投票

## 1\. 核心矛盾：透明性 vs. 隐私性

区块链投票系统天然具有**端到端可验证性 (End-to-End Verifiability)**，但也带来了隐私困境。

### 传统的链上投票

-   **机制：** 用户直接使用钱包调用合约（如 `vote(proposalId, optionId)`）。
    
-   **优点：**
    
    -   **公开透明：** 任何人可查、可复算。
        
    -   **不可篡改：** 历史记录无法回滚。
        
    -   **自动执行：** 智能合约自动计票。
        
-   **缺点（隐私泄露）：**
    
    -   **数据裸奔：** 交易的 `Input Data` 直接暴露投票选项。
        
    -   **身份关联：** 钱包地址（`msg.sender`）与投票偏好永久绑定。
        
    -   **社会工程：** 如果钱包地址关联了现实身份（ENS, 交易所），则实现了实名投票，可能导致胁迫或贿选。
        

### ZK 匿名投票 (ZKVote)

-   **目标：** 在保持**可验证性**的同时，实现**匿名性**。
    
-   **核心逻辑：**
    
    > “我向链上证明我有资格投票，且没有投过票，但我绝不透露我是谁，也不透露我具体投了什么（视实现而定）。”
    

* * *

## 2\. ZK 投票系统架构详解

ZK 投票不再是简单的“签名 -> 发送”，而是一个分阶段的密码学协议。

### 2.1 角色模型 (Prover / Verifier)

-   **Prover (证明者 - 用户):** 拥有秘密（私钥、投票意向），在**浏览器本地**生成证明。
    
-   **Verifier (验证者 - 智能合约):** 不知道秘密，只检查证明（Proof）是否合法。
    

### 2.2 核心数据结构

| 概念 | 作用 | 类比 |
| Identity Secret | 用户的私有身份密钥，仅存本地。 | 银行卡密码 |
| Identity Commitment | $Hash(Secret)$，公开上链。 | 银行卡号 |
| Merkle Tree | 存储所有合法选民 Commitment 的树。 | 选民花名册 |
| Merkle Path | 证明某个 Commitment 在树上的路径。 | 证明你在这个花名册里的证据 |
| Nullifier (无效符) | $Hash(Secret, ElectionID)$，用于防重。 | 投票后的墨水标记 (防止一人多投) |
| Proof | 最终生成的二进制凭证。 | “准考证” |

### 2.3 完整工作流 (Workflow)

第一步：身份注册 (Registration)

1.  用户本地生成随机数 `Identity Secret`。
    
2.  计算 `Identity Commitment` 并提交上链。
    
3.  合约将其加入 **Merkle Tree**，用户成为合法选民一员。
    

第二步：本地生成证明 (Local Proving)

这是最耗时的一步（2-5秒），也是隐私保护的关键。

用户在浏览器中，将以下数据输入 ZK 电路：

-   **私有输入 (Private Witness):** `Identity Secret`、`Merkle Path`、真实投票选项。
    
-   **公开输入 (Public Inputs):** 当前 Merkle Root、选举 ID (`ElectionId`)。
    

电路在不泄露私有输入的情况下，生成：

1.  **Proof:** 证明“我知道一个 Secret，它对应树上的一个叶子节点”。
    
2.  **Nullifier:** 确定性的防重哈希。
    

第三步：链上验证与计票 (On-chain Verification)

用户提交交易，包含 `Proof`、`Root`、`Nullifier`（**注意：交易发送者可以是任意地址，甚至是用 Relayer 代付 Gas，从而切断 IP/EOA 关联**）。

合约执行逻辑：

Solidity

```
function vote(bytes memory proof, bytes32 nullifier, ...) {
    // 1. 检查 Nullifier 是否已存在 (防止双花/重复投票)
    require(!nullifierUsed[nullifier], "Already voted");
    
    // 2. 验证 ZK Proof (验证资格)
    require(verifier.verifyProof(proof, root, nullifier), "Invalid proof");
    
    // 3. 记录 Nullifier 并计票
    nullifierUsed[nullifier] = true;
    _countVote(...); 
}
```

* * *

## 3\. 关键技术点与 QA

### 为什么需要 Nullifier (无效符)？

由于 ZK 证明不包含身份信息，合约无法知道“谁”投了票。如果没有 Nullifier，用户可以为同一个 `Secret` 生成无数个合法的 Proof 进行刷票。

-   **原理：** Nullifier 与 `Secret` 和 `ElectionId` 确定性绑定。只要 `Secret` 没变，生成的 Nullifier 永远一样。合约只需记录“该 Nullifier 已使用”，即可阻止二次投票，同时无法反推 `Secret`。
    

### 链上能看到什么？

-   **能看到：** 谁提交了交易（Relayer 或用户小号）、Merkle Root、Proof 数据、Nullifier。
    
-   **看不到：** 这个 Proof 对应 Merkle Tree 里的哪一个叶子节点（即不知道是哪个注册用户）。
    

### zk-SNARK 性质回顾

-   **完备性 (Completeness):** 真的假不了（只要你是合法的，证明一定能过）。
    
-   **可靠性 (Soundness):** 假的真不了（非成员无法伪造证明）。
    
-   **零知识性 (Zero-Knowledge):** 啥都不知道（验证者只知道结果为真，不知道任何细节）。
    

* * *

## 4\. 总结：传统 vs. ZK 投票对比

| 特性 | 传统链上投票 | ZK 匿名投票 |
| 身份隐私 | ❌ 暴露 (绑定钱包地址) | ✅ 匿名 (仅证明集合成员资格) |
| 投票内容 | ❌ 公开 (Input Data 可读) | ✅/⚠️ 可选 (可结合同态加密隐藏) |
| 防刷票机制 | 检查 msg.sender | 检查 Nullifier |
| 计算成本 | 低 (简单的存储更新) | 高 (链下生成证明，链上验证 Proof) |
| 用户体验 | 快 (签名即发) | 慢 (需等待本地生成 Proof) |

* * *
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->



1\. 语言基础与开发范式

Solidity 是面向对象的高级语言，运行于以太坊虚拟机 (EVM) 上，具有静态类型和类继承特性。

-   **基本数据类型**：
    
    -   **数值**：`bool`, `uint/int` (如 `uint256`, 范围 $0 \\sim 2^{256}-1$), `address` (20字节), `bytes` (固定/动态)。
        
    -   **复合类型**：`string`, `array` (固定 `T[k]` / 动态 `T[]`), `struct` (自定义结构), `enum` (枚举), `mapping` (键值对 `Key => Value`)。
        
-   **函数修饰符 (Modifiers)**：
    
    -   **可见性**：
        
        -   `public` (全域可见)
            
        -   `external` (仅外部调用，Gas 更优)
            
        -   `internal` (合约内部 + 继承子类)
            
        -   `private` (仅本合约内部)
            
    -   **状态操作**：
        
        -   `pure` (不读不写链上状态)
            
        -   `view` (只读不写)
            
        -   `payable` (允许接收 ETH)
            
        -   无修饰 (可读可写)
            

2\. 合约结构与高级特性

智能合约本质是**状态机**，通过交易触发函数来改变状态。

-   **基本结构**：
    
    -   **Pragma**：版本声明 (e.g., `pragma solidity ^0.8.0;`)。
        
    -   **状态变量**：永久存储在链上的数据。
        
    -   **构造函数 (**`constructor`**)**：部署时执行一次，用于初始化状态。
        
    -   **函数 (**`function`**)**：业务逻辑执行单元，支持多返回值和命名返回值。
        
-   **核心机制**：
    
    -   **修饰器 (**`modifier`**)**：用于函数执行前的检查（如 `onlyOwner` 权限控制），减少代码冗余。
        
    -   **事件 (**`event`**)**：链上日志记录机制（`emit`），便于前端 DApp 监听状态变化，且比存储变量更节省 Gas。
        
    -   **继承与多态**：支持单/多重继承 (`is`)，子类可重写 (`override`) 父类虚函数 (`virtual`)。
        
    -   **接口 (**`interface`**)**：定义交互标准（如 ERC20），不含实现逻辑。
        

3\. 关键安全实践 (Security)

合约一旦部署不可篡改，安全漏洞会导致资金永久丢失。

| 风险类型 | 攻击原理 | 防护措施 (最佳实践) |
| 重入攻击 (Reentrancy) | 攻击者在合约更新状态前，利用 fallback 回调再次调用提款函数，循环套利。 | 1. CEI 模式：先检查(Check)，再生效/扣款(Effect)，最后交互/转账(Interaction)。2. 使用 ReentrancyGuard 修饰符 (重入锁)。 |
| 访问控制失效 | 敏感函数（如提款、铸币）未加权限限制，任何人均可调用。 | 1. 显式添加 require(msg.sender == owner)。2. 使用 OpenZeppelin 的 Ownable 或 AccessControl 库。 |
| 整数溢出 | 数值超出类型范围（如 uint8 超过 255）导致回绕至 0。 | 1. 使用 Solidity 0.8+（内置自动溢出检查）。2. 旧版本需使用 SafeMath 库。 |

* * *
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->




RPC (Remote Procedure Call) 是连接 **前端应用 (DApp)** 与 **区块链网络** 的桥梁。区块链节点本身维护着账本数据，RPC 节点则是允许外部访问这些数据的“网关”。

> **💡 通俗理解：银行 ATM 模型**
> 
> -   **RPC 节点 = ATM 机**：它是用户交互的终端。
>     
> -   **区块链网络 = 银行核心系统**：存储资金和账本的底层。
>     
> -   **操作**：你可以通过 ATM (RPC) 查询余额 (读数据) 或 转账 (写数据/发交易)。
>     

### 主要职责

-   **读 (Read)**：查询余额、区块高度、Gas 价格、读取合约状态。
    
-   **写 (Write)**：广播签名后的交易到网络。
    
-   **听 (Listen)**：通过 WebSocket 监听链上事件 (Events) 和状态变化。
    

* * *

## 2\. 通信协议：JSON-RPC 2.0

以太坊及兼容链的标准通信格式。所有交互均通过发送 JSON 请求完成。

-   **传输方式**：HTTP (请求/响应模式) 或 WebSocket (长连接/推送模式)。
    
-   **常用方法速查**：
    

| 方法名 | 功能 | 备注 |
| eth_getBalance | 查询余额 | 需提供地址和区块标签 (如 "latest") |
| eth_blockNumber | 获取最新区块号 | 检查链同步状态常用 |
| eth_sendTransaction | 发送交易 | 将签名交易广播出去 |
| eth_call | 模拟调用 | 只读操作，不消耗 Gas |
| eth_getLogs | 查询日志 | 用于检索历史事件 |

* * *

## 3\. RPC 服务商选择指南

自建节点成本高昂，绝大多数开发者选择第三方服务。

| 服务商 | 免费额度 | 适用场景 | 核心特点 |
| Alchemy | 3亿次/月 | 生产环境/企业 | 稳定性极高，工具链完善，Debug 功能强 |
| Infura | 10万次/月 | 开发测试 | 老牌服务商 (ConsenSys)，基础稳固 |
| QuickNode | 有限 | 高频交易 | 低延迟，高性能，支持多链 |
| Ankr | 有限 | 多链应用 | 去中心化网络，支持链种类丰富 |
| Public Node | 无限制 | 学习/演示 | 完全免费，但不稳定，有速率限制 |

**🚀 建议：** 开发阶段用 Infura/Public，生产环境强烈推荐 **Alchemy** 或 **QuickNode** 以保证 SLA。

* * *

## 4\. 开发实战与配置

### 获取端点 (Endpoint)

1.  注册服务商 (如 Alchemy)。
    
2.  创建 App (选择主网或测试网)。
    
3.  获取 HTTPS URL (例如 `https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY`).
    

### 代码集成 (推荐库)

-   **Viem (推荐)**：现代、轻量级，类型安全。
    
-   **Ethers.js**：生态最成熟，文档丰富。
    
-   **Web3.js**：历史最悠久。
    

### Hardhat 安全配置

**永远不要**将 API Key 硬编码在代码中。

1.  **安装 dotenv**: `npm install dotenv`
    
2.  **创建** `.env` **文件**:
    
    Code snippet
    
    ```
    MAINNET_RPC_URL=https://...
    PRIVATE_KEY=your_private_key
    ```
    
3.  **配置** `hardhat.config.js`:
    
    JavaScript
    
    ```
    require("dotenv").config();
    module.exports = {
      networks: {
        mainnet: {
          url: process.env.MAINNET_RPC_URL,
          accounts: [process.env.PRIVATE_KEY],
        }
      }
    };
    ```
    

* * *

## 5\. 最佳实践

### 🛡️ 安全第一

-   **Git 隔离**：确保 `.env` 文件在 `.gitignore` 列表中。
    
-   **Key 轮换**：如果怀疑 Key 泄露，立即在服务商后台重置。
    
-   **后端代理**：在生产环境中，尽量避免在前端直接暴露 API Key，可通过后端服务器转发请求。
    

### ⚙️ 稳定性管理

-   **重试机制 (Retry)**：网络抖动是常态，代码必须处理超时和失败重试。
    
-   **多节点备份 (Failover)**：配置多个 RPC URL (如 Alchemy + Infura)。如果主节点失败，自动切换到备用节点。
    
-   **速率限制 (Rate Limit)**：注意服务商的每秒请求数限制 (RPS)，必要时在代码中实现请求队列或节流。
    

### 🛠️ 本地开发

-   使用 **Hardhat Node** 或 **Anvil (Foundry)** 开启本地 RPC。
    
-   **优点**：速度极快、无 Gas 消耗、可随时重置状态、无速率限制。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->





### 一、 DApp 核心架构

与传统 Web2 应用不同，Web3 应用的后端逻辑运行在去中心化网络上。

-   **前端 (Frontend)**：使用 React/Vue 构建，通过钱包（如 MetaMask）和 RPC 节点与区块链交互。
    
-   **智能合约 (Smart Contracts)**：部署在链上的业务逻辑（“后端”），负责状态存储和规则执行。
    
-   **数据检索器 (Indexer)**：弥补链上数据查询困难的问题，监听链上事件（Event），存入传统数据库供前端快速读取（如 The Graph, Ponder）。
    
-   **存储 (Storage)**：使用 IPFS/Arweave 存储图片等大文件，保证去中心化。
    

### 二、 开发环境与工具栈

-   **基础环境**：Node.js (管理依赖), Git (版本控制)。
    
-   **开发框架**：
    
    -   **Hardhat**：基于 JS/TS，生态成熟，适合新手和企业级开发（推荐）。
        
    -   **Foundry**：基于 Rust，速度极快，测试功能强大（进阶推荐）。
        
    -   **Remix IDE**：浏览器端工具，零配置，适合快速测试和教学。
        
-   **钱包**：MetaMask（浏览器插件），用于管理账户和签名交易。
    

### 三、 基础设施：RPC 与节点

-   **RPC (远程过程调用)**：连接前端/脚本与区块链网络的桥梁（类似 ATM 机连接银行系统）。
    
-   **服务商**：Alchemy, Infura, QuickNode（提供稳定的节点服务，避免自建节点的复杂性）。
    
-   **交互库**：
    
    -   **Viem/Wagmi**：现代、轻量、TypeScript 支持好（推荐）。
        
    -   **Ethers.js / Web3.js**：老牌库，使用广泛。
        

### 四、 智能合约开发 (Solidity)

-   **基础语法**：
    
    -   **变量**：状态变量（存链上，费钱）、局部变量（存内存，便宜）。
        
    -   **数据类型**：`uint256`, `address`, `mapping`, `struct`, `event`。
        
    -   **函数修饰符**：`public/private` (可见性), `view/pure` (读操作), `payable` (接收资产)。
        
-   **关键机制**：
    
    -   **Event (事件)**：低成本记录日志，供链下检索器监听。
        
    -   **Gas 机制**：每一行代码执行都需要付费，计算越复杂越贵。
        
-   **实战流程 (以留言板为例)**：编写 (`.sol`) -> 编译 (Bytecode/ABI) -> 部署 (Deploy) -> 交互 (Call/Transact)。
    

### 五、 部署与测试网

-   **测试网 (Testnet)**：如 **Sepolia**。环境与主网一致，但代币无价值，用于零成本测试。
    
-   **部署工具**：使用 Hardhat 脚本或 Remix 注入 Web3 (Injected Provider)。
    
-   **验证**：通过 **Etherscan** 区块浏览器查看合约代码、交易哈希 (Tx Hash) 和状态变化。
    

### 六、 前端集成 (Web3 Integration)

-   **连接流程**：
    
    1.  **Connect**：前端请求 MetaMask 授权。
        
    2.  **Instance**：利用合约地址 + ABI (接口描述文件) 创建合约实例。
        
    3.  **Interact**：
        
        -   **读 (Call)**：免费，瞬间返回（如查询余额）。
            
        -   **写 (Send)**：付费，需钱包签名，需等待区块确认（如提交留言）。
            

### 七、 高阶安全与优化

-   **Gas 优化**：
    
    -   少写 Storage（昂贵），多用 Memory。
        
    -   使用 `unchecked` 代码块（Solidity 0.8+）处理确定不会溢出的计算。
        
-   **安全防护**：
    
    -   **重入攻击 (Reentrancy)**：最经典漏洞。**防御**：使用“检查-生效-交互” (CEI) 模式，先扣款/改状态，再转账；或使用 `ReentrancyGuard`。
        
    -   **访问控制**：关键函数必须加 `onlyOwner` 或权限修饰符。
        
    -   **整数溢出**：Solidity 0.8+ 已内置检查，旧版本需用 SafeMath。
        
-   **审计**：上线前必须经过静态分析 (Slither) 和人工审计。
    

### 八、 扩容方案 (Layer 2)

为了解决以太坊主网拥堵和昂贵的问题：

-   **Optimistic Rollup** (如 Arbitrum, Optimism)：假设交易有效，有挑战期。
    
-   **ZK Rollup** (如 zkSync, Starknet)：使用零知识证明，安全性更高，技术更复杂。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->






这是一份纯文字版的 Remix IDE 学习笔记总结：

**Remix IDE 学习笔记**

一、工具定位

Remix 是 Web3 开发的首选入门工具，核心特点是免安装、零配置，在浏览器中打开即用，适合快速测试智能合约。

**二、核心界面（左侧功能区）**

1.  **文件管理器**：用于新建、重命名和管理文件夹及代码文件。
    
2.  **编译器**：用于检查代码语法错误，并将其翻译成机器能懂的字节码。
    
3.  **部署与运行**：用于连接模拟或真实区块链环境，发布合约并进行功能测试。
    

**三、开发全流程（四步法）**

1.  **新建**：在 contracts 文件夹下创建文件，必须以 .sol 为后缀。
    
2.  **编写**：在编辑区输入 Solidity 代码，包含变量（状态）和函数（逻辑）。
    
3.  **编译**：建议勾选 Auto compile（自动编译），确保出现绿色的成功提示。
    
4.  **部署**：
    
    -   环境选择 Remix VM（浏览器内存模拟，速度快，无需真钱）。
        
    -   点击 Deploy 按钮，在下方生成的合约实例中进行交互。
        

**四、交互按钮颜色含义（计费逻辑）**

1.  **蓝色按钮**：代表读取数据（Read）。此类操作不消耗 Gas，完全免费，结果瞬间返回。
    
2.  **橙色按钮**：代表修改数据（Write）。此类操作消耗 Gas，需要付费，且需要等待区块打包。
    
3.  **红色按钮**：代表涉及转账（Payable）。此类操作既消耗 Gas 又转移资产。
    

-   **简记**：蓝色免费，橙色付费，红色打钱。
    

**五、关键避坑指南**

1.  **防丢失**：Remix 默认将代码存储在浏览器缓存中。刷新网页或清理缓存会导致代码丢失，重要代码务必复制到本地备份。
    
2.  **排错**：如果部署按钮是灰色的，说明代码有 Bug 导致编译未通过，需先修复错误。
    
3.  **不可篡改性**：智能合约一旦部署，代码即无法修改。如果改动了源码，必须重新编译并重新部署，这会生成一个全新的合约地址，旧合约依然存在且不会变化。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->







### **1\. 节点的“新架构”：执行层 + 共识层**

自从“合并”（The Merge）以后，一个完整的以太坊节点不再是单一的软件，而是必须由两个配合工作的客户端组成 。书中用了一个很形象的“法院”比喻来解释两者的关系

-   **执行客户端 (Execution Client, EL)**：
    
    -   **角色**：像法院的**书记员**。
        

**职责**：负责“干活”。接收交易、在 EVM（虚拟机）里执行代码、计算余额变化、维护状态数据库。它只管算账，不管“该谁出块”

**常见软件**：Geth, Nethermind, Besu, Reth 等 。

-   **共识客户端 (Consensus Client, CL)**：
    
    -   **角色**：像法院的**法官**。
        
    -   **职责**：负责“决策”。它运行 PoS（权益证明）共识算法，决定哪个区块是合法的、谁来提议区块、给区块投票（Attestation）。它不直接执行交易，而是根据书记员（EL）的结果来做最终裁决。
        

**常见软件**：Lighthouse, Prysm, Teku, Nimbus 等 。

**Engine API**：两者之间的“专线电话” ，用于内部通信。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->








求职

1.背调清楚是否有拍照，如果是美国MSB拍照则没有进入合规范畴

2.深度聊有无做大陆客户，没有向大陆展业。

验证：不翻墙能否进入交易所官网，交易所app是否能够用大陆手机号邮箱注册

如果没有限制信息注册则依旧可以认定为向大陆展业

如果展业一定理清处工作内容是否支持到合约期权板块（高风险）

3.出金。合同如何签？

完全用海外主体，发生劳动争议难处理。

在国内注册公司或劳务派遣公司。

eg：工资法币表述，实际发虚拟币，离职后劳动仲裁，成功，项目方自身风险。

国内公司出事容易被牵连

新人入行：

到处都是风险，主要来自人心

工作出金

被人利用，得罪人

出金风险高

当地资源多，亲友群体老乡群体比较好，结合实际情况

出金遇到合规问题

有先例之后还有情况先找律师
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->









021学习以太坊第一章

\### **以太坊特点**

1.\*\*智能合约 Smart Contracts\*\*

存储在区块链上的程序，由网络节点执行，执行合约需支付 Gas

2.\*\*分布式应用程序 dApps\*\*

部署在区块链上，不依赖单一服务器

3.\*\*代币 Tokens\*\*

可替代（金币等）、不可替代（独特资产）

4.\*\*机制\*\*

早期的工作量证明 PoW Proof-of-Work 矿工通过算力竞争出块 硬件与电力成本

权益证明 PoS Proof-of-stake 节点需要质押一定数量ETH成为验证者，每个时隙由协议随机选出提议区块的验证者，并由其他验证者投票确定，恶意行为会导致验证者资产销毁或罚没，长时间离线也会罚没

5.\*\*Gas\*\*

base与priority

6.\*\*Proto-Danksharding与Dencun升级\*\*

它引入了一种名为“Blobs”（二进制大对象）的新数据结构。

Blobs 数据只会被以太坊节点保存约2 周，之后就会被丢弃。存储成本大幅降低。

Layer 2 网络不再像以前那样将交易数据作为昂贵的“calldata”永久存储在以太坊主链上，而是将数据放入临时的 Blobs 中挂载到区块上

7.\*\*分片与 Danksharding\*\*

分片把大系统拆成多个分区并行处理，提高吞吐量

Danksharding\*\*旨在把以太坊变成一个超级数据层，专门为 Layer 2 服务。

**Layer 2 (L2)** 指的是建立在现有区块链（Layer 1，如以太坊主网）之上的\*\*扩容解决方案\*\*，

链下执行，链上结算。交易的处理、计算都在 Layer 2 网络上进行。

Layer 2 将成百上千笔交易压缩成一个数据包发送回 Layer 1，Layer 1 只需要记录这个结果，并验证其有效性，而不需要处理具体的每一笔转账。

在 Dencun 升级（Proto-Danksharding）之前，L2 把数据存在 L1 的“昂贵区域”（Calldata）。升级后，L2 把数据存在了 L1 新开辟的“廉价临时区域”（\*\*Blob\*\*）。

Danksharding引入更多 blob 数据空间，加上数据可用性采样，让节点只需要随机抽样检查部分数据就能对整个大数据块有把握。

8、叔块 Ommer Block 在转为 PoS 后已停用 安慰奖

!\[\[Pasted image 20260113183048.png\]\]

\### ETH

既是支付 Gas 的燃料，又是质押安全的保证金，同时是 DeFi/NFT/Web3生态中最重要的抵押资产之一

**实际支付费用** = （Base Fee + Priority Fee ）× Gas Used

**变动因素**：网络拥堵、用户时差、交互复杂度

验证者收入 = 共识奖励（协议给的工资） + 执行奖励（用户给的消费） +某些协议给的补贴

惩罚 Slashing：proposer double 、double vote、surround vote

\### 以太坊

**Gobal**

Decentralized、Immutable、Secure & Transparent

**Programmable**

Smart Contracts 预设条件被满足时自动执行

Turing-complete 只要给足时间和资源，就能几乎任何可计算的逻辑

智能合约语言（Solidity、Vyper）在EVM上运行，使得以太坊是一台分布式通用计算机

因此可以构建 dApps 如 DeFi、NFT、DAO、供应链、数字身份、链上游戏、去中心化社交媒体等等

比特币是数字黄金，去中心化货币与长期价值储存 使用 Pow 供应有上限 确认速度慢10min 目标是成为全球性价值存储与自由货币，扩容方案发展 Ligtning Network 等支付通道型二层

以太坊是全球可编程计算机 使用 PoS 低通胀发行 确认速度12s Slot 扩展性强、协议执行环境复杂、交易费用低、目标是成为 Web3的基础设施

\### dApps

将链上的智能合约与链下的前端页面结合。后端代码运行在EVM中，前端可以用任意Web/App技术编写，既可以翻盖传统服务器上，也可以放在去中心化存储上

去中心化、确定性、图灵完备、隔离性

代价:维护困难、性能开销与扩展速度、网络拥堵与 Gas 成本、用户体验门槛高、再中心化倾向

\### 去中心化实现机制

1.\*\*共识（Pos等等）与出块 经济层、技术层\*\*

2.\*\*节点与网络 技术层\*\*

3.\*\*客户端多样性 实现层\*\*

4.\*\*MEV 与 PBS 市场结构层\*\*

5.\*\*Rollup-中心 路线与数据去中心化\*\*

6.\*\*治理 社会层面\*\* 公开讨论与社会共识推动协议演进

7.\*\*多个机制叠加出来的去中心化\*\*

至少有 32 ETH可以成为验证者

节点太少会中心化，太多会拖慢同步和共识

去中心化金融

Uniswap 最大去中心化交易所之一

Aave 借贷协议

MakerDAO / Sky + DAI稳定币

Lido、EigenLayer 等质押/再质押协议

RWA 现实世界资产上链
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->










\## 区块链基础概念

区块链是一种\*\*去中心化\*\*的\*\*分布式\*\*账本技术

特性：不可篡改、公开透明、匿名、快速交易

分布式网络：一个区块链网络中有非常多的节点（矿机）来记账，每个节点都会记录完整的、相同的区块链信息

因此保证了历史交易记录==不可篡改==，同时也实现了==去中心化==

\#### 一、BTC 基础概念

网络节点服务提供商可以得到代币奖励，不同提供商得到不同代币

特性：

1\. 有限供应量，可以自由转账→具备货币特性→成为加密货币

2\. 不会通胀、账户匿名、交易公开透明、不可篡改、快速交易

（如何实现）交易通过随机生成的钱包地址完成，与该地址相关的交易在网络上公开透明，他人无法得知该钱包与你有关联

缺点：

1\. 难以追踪和限制，容易被黑产利用

2\. 打包区块 10 min 影响交易实时性

3\. 每个区块存储数据有限

\#### 二、区块链的核心组成部分

1.\*\*去中心化的网络和区块链\*\*

区块链将会有一条链来记录全部的信息，这条链将存在对应的去中心化网络中。

2.\*\*维持网络运行的代币激励\*\*

去中心化的网络由无数节点提供服务来维持网络运行。

节点通过计算验证交易获得代币奖励。

运行步骤：

用户发起交易→交易广播→节点验证→打包成块→链接上链→奖励发放

\#### 三、公链、私链、联盟链

!\[\[Pasted image 20260112121654.png\]\]

| 区块链类型 | 节点加入方式 | 数据可见性 | 管理模式 | 适合场景 |

| ------- | ---------- | ------- | ----------- | --------- |

| **公链** | 任何人自由加入 | 所有人可见 | 去中心化（大家投票） | 加密货币、公共存证 |

| **联盟链** | 需联盟成员邀请/审批 | 仅联盟成员可见 | 多中心化（董事会决策） | 供应链、金融协作 |

| **私链** | 由老板严格审批 | 仅内部成员可见 | 中心化（老板说了算） | 企业内部管理、审计 |

\#### 四、web 3 web 3.0 web 2

| 维度 | Web 2 | Web 3.0 | Web 3 |

| -------- | ---------- | ------------- | ------------------- |

| **控制权** | 平台垄断 | 部分开放 | 用户自治 |

| **数据存储** | 中心服务器 | 混合存储 | 区块链 / IPFS |

| **支付系统** | 信用卡 / 支付宝 | 集成支付 | 加密货币 |

| **典型技术** | JavaScript | RDF / OWL | 智能合约 |

| **代表企业** | 腾讯 / 阿里 | W3C / DBpedia | Uniswap / ConsenSys |

Web 3.0 旨在通过标准化的数据格式（如 RDF），让计算机能够理解、连接和处理信息。知识图谱、语义搜索

Web3 旨在解决Web 2.0时代科技巨头（如 Google, Meta）垄断数据和利润的问题。Web3 通过区块链技术，把数据的所有权和价值归还给用户。

web 3

钱包（签名） →Dapp（调用）→ 智能合约 （读写）→区块链

Dapp：Decentralized Application 基于区块链的、自动化的、用户拥有所有权的 App

注意到如果连接钱包时，如果没钱去中心化交易所开户时可能会导致身份泄露，如果要保持隐私

1.混币器 tornado cash，但有冻结风险 2.隐私币中转 3.场外现金交易（容易受到诈骗）4.劳动赚取

5.跨链桥 并非完全隐私，只是加大追踪难度 6.设立隔离层钱包 交易所→钱包A（中转站）→钱包B（高风险项目测试）钱包A→钱包C（存放长期资产） 尽量避免频繁的法币与加密货币互换

\###### 分散资产，规划好钱包用途

\- 日常高频使用的热钱包存放少量资产，不同的钱包使用不同的助记词创建。

\- 设置冷钱包，用于储蓄和转账，减少交互和使用。

\- 周期性的创建新钱包进行资产转移。

很多资深人士的做法是将资产放入硬件钱包，每次需要对外交互的时候，都重新创建一个新钱包，用完即废弃。

\###### 警惕任何看到的消息

\- 学会正确的寻找官方网站、公告、项目等，不从第三方网站下载安装软件

\- 看到信息需要多加思考。即便是官方发布的消息，有时候也可能是因为官方账号被黑导致的

技术栈：

web 2：React + Node.js + MySQL

web 3：React + Ethers.js + Solidity + IPFS

web 3.0：Python + RDFLib + SPARQL

去中心化：

优势：安全（系统安全），用户自主管理，信任最小化，开放创新生态

挑战：效率与延迟、安全与治理（代码漏洞，治理失衡）、用户体验与成本，法律与合规

\--------------

\## 以太坊概览

\#### 一、以太坊介绍 智能合约和可编程性

以太坊（Ethereum）是一个开源的去中心化区块链平台，通过其原生加密货币以太币（Ether，简称 ETH）提供去中心化的以太虚拟机（EVM）来处理点对点合约。

以太坊的核心创新在于 ==智能合约（Smart Contracts）==

智能合约是存储在区块链上的可执行代码，能够在满足预设条件时自动执行操作，无需人工干预。

\#### 二、与bitcon区别

|维度|比特币（Bitcoin）|以太坊（Ethereum）|

|---|---|---|

|\*\*目标与定位\*\*|去中心化的数字货币，强调安全、稳定和稀缺性（总量 2100 万枚）|去中心化平台，支持智能合约和 Dapps，定位为“区块链 2.0”|

|\*\*编程能力\*\*|脚本语言有限，仅支持简单的交易验证逻辑|图灵完备的编程语言（如 Solidity），可开发复杂智能合约|

|\*\*共识机制\*\*|工作量证明（PoW），矿工通过算力竞争记账权|从 PoW 转向权益证明（PoS），通过 The Merge 实现能源效率优化|

|\*\*交易速度\*\*|每 10 分钟生成一个区块，交易确认较慢|区块时间约 12 秒，交易确认更快，适合高频应用|

|\*\*经济模型\*\*|总量固定，强调抗通胀属性|供应灵活，通过 EIP-1559 等机制可能呈现通缩趋势|

\#### 三、定位与演进

\==工作量证明（PoW）转向权益证明（PoS）==最关键

1\. **The Merge（2022 年完成）**：从高能耗 PoW → 低能耗 PoS

2\. **EIP-4844（2024 年完成）**：让 L2 更便宜，普通人用得起

3\. **数据分片（2025-2026 年）**：进一步降低 L2 成本，提升整体扩展性

\#### 四、核心机制

账户系统：由私钥控制的 ==\*\*外部账户（EOA）\*\*== 和由智能合约代码控制的 ==\*\*合约账户（CA）\*\*==

GAS模型：交易费用 =数量×单价 为激励矿工，防止资源滥用 基础费用+tip

EVM：是专门用来\*\*运行智能合约的虚拟计算机\*\*。

\#### 五、流程

\- **EOA 发起：** 你的钱包（EOA）签名并发起一笔交易，目标是 Uniswap 的合约（CA）。

\- **支付 Gas：** 你预付了一笔 ETH 作为 Gas（包含销毁的基础费 + 给矿工的小费）。

\- **EVM 启动：** 矿工接收任务，启动 EVM。

\- **代码执行：** EVM 读取 Uniswap 的合约代码（CA 的 CodeHash），执行“兑换逻辑”。

\- EVM 检查你的余额够不够。

\- EVM 修改数据：你的 ETH 减少，你的代币增加。

\- **状态更新：** 交易完成，剩余的 Gas 退给你。最新的余额状态被写入区块链的“状态树”（StorageRoot）。、

\---------

\## 行业赛道

\#### 一、DeFi

Decentralized Finance（去中心化金融）目标是提供不依赖传统银行或金融中介的服务

eg：

Uniswap 去中心化交易所DEX

x \* y=k

LP流动性池和流动性提供者 提供资金获取交易手续费

相比传统中心化交易所：交易方便快捷无需中介，无时间限制，大额交易更便捷

compound 去中心化借贷协议

流动性挖矿与利息收入

借贷模式与超额抵押

sky稳定币系统 USDS与美元挂钩的稳定币，用\*\*稳定费率\*\*调整系统中DAI的供需关系

\#### 二、NFT数字所有权

数字资产的唯一性和所有权，通过智能合约收税

\#### 三、DAO去中心化自治组织

ConstitutionDAO过于公开透明的结构让其他竞标者能够轻易了解你的出价情况

LXDAO Web3 公共物品的项目

Nouns DAO艺术和区块链的结合体

\#### 四、MEME：文化与投资热潮

**公平发射**（Fair Launch）、\*\*社区自治\*\*和\*\*实用性整合\*\*成为新趋势。

价格完全依赖市场情绪，极易遭遇暴跌风险。

需关注链上数据透明度：项目方是否公开代币分配、核心地址信息？如果代币高度集中，可能会被少数大户操控价格，导致投资者亏损。

分散投资，控制仓位：资金控制在总持仓10%以内

\#### 五、交叉创新领域

DeFi+NFT 数字资产金融化

MEME 币与 DAO 治理

ai+DeFi智能化金融服务

web3＋乡建
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
