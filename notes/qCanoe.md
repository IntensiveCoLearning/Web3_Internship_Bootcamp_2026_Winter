---
timezone: UTC+8
---

# CaNoe

**GitHub ID:** qCanoe

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->
今天主要进行了 Solidity 的应用学习（Applications），重点体验了以下功能的实现：

1\. Ether Wallet

2\. Multi-Sig Wallet

3\. Merkle Tree

4\. Iterable Mapping

5\. ERC20

然后重温了上一次 Assembly 从 Reveal 到 Loop、Error 的一些复杂的嵌套逻辑和错误。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->

1.23 补充

### 一、默认值与“看不见的状态”

Solidity 中所有状态变量在未显式赋值前，都具有**确定的默认值**：  
`uint` 为 0，`bool` 为 false，`address` 为 0x0，struct 中的字段也都会被递归初始化为默认值。

这一点在 mapping 中尤为重要。mapping 中“未写入”的 key 与“已写入但值为默认值”的 key **在读取结果上完全无法区分**。因此，凡是需要判断“是否存在”的逻辑，都必须额外设计标志位，而不能依赖数值本身。这是 Solidity 与传统语言 Map 语义的一个本质差异。

* * *

### 二、delete 的真实语义

`delete` 并不是“删除变量”，而是**将变量重置为默认值**。  
对于数组，`delete arr[i]` 只会清空该位置的值，不会改变数组长度；  
对于 struct，`delete user` 会将其所有字段清零；  
对于 mapping，`delete map[key]` 只是把该 key 映射回默认值。

这意味着：Solidity 中几乎不存在“释放存储”的概念，只有“覆盖”。理解这一点，对后续理解 gas refund、状态膨胀、链上存储不可逆增长非常重要。

* * *

### 三、require / revert / assert 的设计边界

Solidity 中有三种主要的失败机制，但语义并不相同：

-   `require`：用于**校验外部输入或调用前提条件**，失败是“预期内”的
    
-   `revert`：用于复杂逻辑中主动中断执行
    
-   `assert`：用于检查**永远不应被破坏的不变量**
    

在实际合约中，`assert` 的存在本身就意味着“如果失败，说明合约设计有 bug”，而不是用户操作错误。这个区分对安全审计和形式化验证非常关键。

* * *

### 四、事件（event）的真实作用

事件不是状态，也不能被合约读取，它们的本质是**写给链下世界看的日志**。  
事件的作用包括：

-   为前端、索引器、分析工具提供可追踪信息
    
-   替代昂贵的链上遍历
    
-   构建“可观察性”，而非“可计算性”
    

一个重要认知是：**事件是状态的投影，而不是状态本身**。你不能依赖事件来恢复合约真实状态，只能用它来“解释发生过什么”。

* * *

### 五、构造函数与部署期状态

构造函数只在合约部署时执行一次，用于初始化状态。部署阶段的 `msg.sender` 是**部署者地址**，而不是未来的调用者。

这一区别在权限设计中非常重要：  
一旦 owner 在构造函数中被写死，后续所有权限逻辑都会基于这一初始假设展开。因此，构造函数阶段的状态写入，往往是安全审计的第一检查点。

* * *

### 六、address(this) 与 msg.sender 的差异

-   `msg.sender`：当前调用者
    
-   `address(this)`：合约自身地址
    

合约既是代码，也是账户。  
这意味着合约可以持有 ETH，也可以作为“主体”参与其他合约交互。很多复杂系统（钱包、Agent、DeFi 协议）本质上都是在管理 **“合约作为主体” 的行为边界**。

* * *

### 七、fallback / receive 的边界认知

`receive()` 只在 **空 calldata 且携带 ETH** 时触发；  
`fallback()` 是兜底入口，在 calldata 不匹配任何函数时触发。

一个非常重要的设计原则是：  
**fallback 中不应包含复杂逻辑**。  
因为它可能在你并未预期的情况下被触发，是攻击面最敏感的位置之一。

* * *

### 八、Solidity 中“不可做”的事情

通过 solidity-by-example 的反复示例，其实也在不断强调 Solidity 的限制：

合约不能遍历 mapping  
合约不能主动访问链下信息  
合约不能真正删除存储  
合约不能假设调用顺序  
合约不能信任外部合约行为

这些“不能做”的事情，恰恰定义了 Solidity 的设计边界，也决定了系统设计必须依赖 **架构补偿**（事件、索引器、前端、off-chain agent 等）。
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->


**storage**：链上永久存储，读写成本高，生命周期与合约一致。

**memory**：函数执行期间的临时内存，成本较低，执行结束即释放。

**calldata**：只读输入数据，主要用于外部函数参数，gas 成本最低。

**mapping 的角色与设计限制**

mapping 是 Solidity 中最重要、也最容易被误解的数据结构之一。它本质上是一个**不可遍历的键值映射**，更接近链上的 KV 存储，而不是传统意义上的容器。

mapping 的核心特征包括：

-   只能通过 key 直接访问值
    
-   无法枚举所有 key
    
-   默认值始终存在（未写入的 key 也会返回默认值）
    

这一设计直接源于 EVM 的存储模型，也解释了为什么实际合约中经常需要“mapping + array”或“mapping + event”来实现可追踪的数据结构。

> 为什么已经有了 constant 不变量，还要有 immutable 这个修饰符去作为变量的不变修饰限定呢？

**使用场景不同：**

constant 适用于：

-   固定不变的常量（如最大供应量、固定地址）
    

-   值在编写代码时就已经知道
    

-   需要最省 gas 的场景
    

immutable 适用于：

-   部署时才能确定的值（如部署者地址、部署时间）
    

-   需要从构造函数参数传入的值
    

-   需要运行时值（如 block.timestamp、msg.sender）
    

**数组与删除陷阱示例**

```
contract ArrayDemo {
    uint[] public arr;
​
    function push(uint x) external {
        arr.push(x);
    }
​
    function pop() external {
        arr.pop();
    }
}
​
```

这个例子看似简单，但隐含了一个非常重要的设计点： Solidity 的动态数组删除是 **尾部删除才是 O(1)**，中间删除会导致元素移动、gas 激增。因此在设计任何“列表型状态”时，都需要先想清楚是否真的需要删除，还是用“标记失效”的方式替代。

**权限控制的最小示例**

```
contract Ownable {
    address public owner;
​
    constructor() {
        owner = msg.sender;
    }
​
    function withdraw() external {
        require(msg.sender == owner, "not owner");
    }
}
​
```

这个例子揭示了 Solidity 中最原始、也是最常用的权限模型：**基于 address 的显式检查**。没有角色系统、没有访问控制库，本质上所有权限逻辑都可以还原为这种判断。

> 合约永远围绕“状态是否存在链上”； mapping 用来查，不用来列； 数组操作要考虑 gas 复杂度； struct 是状态建模工具，不是对象； 权限永远是显式检查； payable 是价值流入的安全闸门。
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->



### **1.21**[**Solidity by Example | 0.8.26**](https://solidity-by-example.org/) **Basic 部分**

**一、Hello World 合约与基础结构**

学习了第一个最简单的智能合约 `HelloWorld`，核心代码示例如下：

```
pragma solidity ^0.8.26;
contract HelloWorld {
    string public greet = "Hello World!";
}
```

这个合约展示了 Solidity 合约最基础的组成部分：`pragma` 指定编译器版本、`contract` 定义合约、public 状态变量自动生成 getter。这个例子可以在 Remix 中直接编辑、编译、部署来看到输出效果。

这一步帮助理解合约内部结构和合约如何对外暴露状态。

**二、First Application（简单应用示例）**

`First Application` 是下一个简单示例，通常是一个计数器合约，实现对状态变量的增、减、获取等操作，比 Hello World 更进一步，让你实际写出可更改状态的函数。

这类示例重点在于：

学习如何声明状态变量（比如 `uint count`）、如何实现函数修改状态（增减 count），以及函数可见性（`external`, `public` 等）等。

**三、函数视图（View）与纯函数（Pure）**

一个重要的概念是 **View 与 Pure**：

-   **View 函数** 表声明不会改变状态，用于读取变量。
    
-   **Pure 函数** 表声明不会读写状态，只进行纯计算。
    

例如：

```
function getSum(uint a, uint b) external pure returns(uint) {
    return a + b;
}
```

这个例子说明了什么函数是只读、什么是只计算的语义区别，对于写安全、高效合约非常重要。

**四、Solidity 官网常见主题结构**

虽然 [solidity-by-example.org](http://solidity-by-example.org) 本身提供的是示例合约，但通过官网大纲可以看到它覆盖了很多 Solidity 核心主题：

包括 Primitive Data Types、Variables、Constants、Immutable、Reading and Writing to a State Variable、Ether and Wei、Operators、Control Flow（控制流）、映射（Mappings）、数组（Arrays）、结构体（Structs）等。

这些主题构成了智能合约开发的基本语法和数据组织方式，是写出实用合约的基础。

* * *

**今天学习的核心收获**

1.  **熟悉 Solidity 合约基础结构**：`pragma`, `contract`, 状态变量、函数签名。
    
2.  学会写最简单的 `HelloWorld` 合约，并理解状态变量自动生成 getter 的机制。
    
3.  学习简单应用示例，加深对状态可变函数、状态变量更改以及合约部署的理解。
    
4.  明确 **View / Pure 函数** 的区别，这在写成本更低、逻辑更清晰的合约中很关键。 5.了解 Solidity by Example 的整体内容布局，它不是单一例子，而是多个模块化讲解 Solidity 不同核心语法与合约范式。
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->




\### 1.20

**storage**

\- 永久写入链上状态

\- 昂贵（写入极贵，读取也不便宜）

\- 合约状态的“唯一真相来源”

\- 所有状态变量默认在 storage

**memory**

\- 只在当前调用中存在

\- 调用结束即销毁

\- 适合中间计算、临时变量

**calldata**

\- 只读

\- 不可修改

\- Gas 最便宜

\- 外部函数参数的首选位置

\`\`\`

external

\`\`\`

\- 只能被外部调用

\- 参数直接来自 calldata

\- Gas 更省

\- 推荐作为对外接口默认选择

\`\`\`

public

\`\`\`

\- 内外都可调用

\- 内部调用会复制参数到 memory

\`\`\`

internal

\`\`\`

\- 仅合约内部或继承合约可用

\- 不产生外部调用

\`\`\`

private

\`\`\`

\- 只在当前合约中可用

\- **不等于“链下不可见”**（代码依然公开）

\`\`\`

receive()

\`\`\`

\- 专门用于接收 ETH

\- calldata 为空时触发

\`\`\`

fallback()

\`\`\`

\- 函数不存在时触发

\- 或 calldata 非空但无匹配函数

\`\`\`

call

\`\`\`

\- 切换执行上下文

\- 修改的是被调用合约的 storage

\`\`\`

delegatecall

\`\`\`

\- 不切换 storage

\- **用对方代码，改自己的状态**

\- proxy / 升级机制的基础

\- 也是大量灾难性漏洞的根源

\`\`\`

staticcall

\`\`\`

\- 强制只读

\- 用于 view / 查询

\`\`\`

require

\`\`\`

\- 用于用户输入或外部条件校验

\- 失败会退回剩余 Gas

\`\`\`

revert

\`\`\`

\- 显式中断执行

\- 常用于复杂条件

\`\`\`

assert

\`\`\`

\- 表示“绝不应该发生的状态”

\- 失败会消耗所有 Gas

\- **用于内部不变量**

\#### 前端交互流程

1\. **初始化连接**：前端检测并连接 Web3 提供者

2\. **用户授权**：请求用户授权访问钱包账户

3\. **合约实例化**：使用 ABI 和合约地址创建合约实例

4\. **函数调用**：通过合约实例调用智能合约函数

5\. **交易签名**：钱包对交易进行数字签名

6\. **广播交易**：将签名交易发送到区块链网络

7\. **状态更新**：获取交易结果并更新前端界面

\[1.2 关键技术栈\]([https://web3intern.xyz/zh/smart-contract-development/#\_1-2-关键技术栈](https://web3intern.xyz/zh/smart-contract-development/#_1-2-关键技术栈))

\- **合约语言：** 掌握 Solidity 等相关合约开发语言

\- **Web3.js/Ethers.js：** JavaScript 库，提供区块链交互 API (当前 Web3.js/Ethers.js 库比较老旧，本技术只用来学习理解整体流程，可以使用 Viem、Wagmi 进行新项目开发)

\- **钱包连接器**：如 RainbowKit、ConnectKit、WalletConnect、Web3Modal 等

\- **状态管理**：React Context 等管理连接状态

\- **错误处理**：网络异常、用户拒绝、Gas 不足等场景处理

\#### \[高阶内容\]([https://web3intern.xyz/zh/smart-contract-development/#九、高阶内容](https://web3intern.xyz/zh/smart-contract-development/#九、高阶内容))

\##### \[1. Gas 优化\]([https://web3intern.xyz/zh/smart-contract-development/#\_1-gas-优化](https://web3intern.xyz/zh/smart-contract-development/#_1-gas-优化))

\##### \[2. 合约安全\]([https://web3intern.xyz/zh/smart-contract-development/#\_2-合约安全](https://web3intern.xyz/zh/smart-contract-development/#_2-合约安全))

\##### \[3. 智能合约审计\]([https://web3intern.xyz/zh/smart-contract-development/#\_3-智能合约审计](https://web3intern.xyz/zh/smart-contract-development/#_3-智能合约审计))

\##### \[4. **开发协作规范**\]([https://web3intern.xyz/zh/smart-contract-development/#\_4-开发协作规范](https://web3intern.xyz/zh/smart-contract-development/#_4-开发协作规范))
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->





### **1.19 Web3 实习手册**[**「智能合约开发」**](https://web3intern.xyz/zh/smart-contract-development/)**部分**

A Smart Contract (or cryptocontract) is a computer program that directly and automatically controls the transfer of digital assets between the parties under certain conditions. A smart contract works in the same way as a traditional contract while also automatically enforcing the contract. Smart contracts are programs that execute exactly as they are set up(coded, programmed) by their creators. Just like a traditional contract is enforceable by law, smart contracts are enforceable by code. 

![Smart Contracts in Blockchain - GeeksforGeeks](https://media.geeksforgeeks.org/wp-content/uploads/20220527093234/Howdoesasmartcontractwork1.jpg)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qCanoe/images/2026-01-19-1768834292532-image.png)

**1\. Dapp 与智能合约的整体框架**

去中心化应用（Dapp）与传统 Web 应用最大的不同在于其核心逻辑运行在区块链上，不由单一实体控制。一个完整的 Dapp 主要由四部分组成：前端界面、智能合约、数据检索层与区块链/去中心化存储系统。前端通过钱包（如 MetaMask）与 RPC 节点连接链上数据和交易，智能合约负责业务逻辑实现，而检索器将链上事件转换为可供前端查询的数据。

* * *

**2\. Dapp 的开发流程**

从需求到上线，一般分为以下阶段：

首先进行**需求分析与规划**，明确目标功能、选择合适链（如以太坊、Polygon 等），并设计用户体验。随后进入**智能合约开发阶段**，用 Solidity 编写业务逻辑。由于合约一旦部署就不可更改，因此在这一阶段要编写全面的测试代码和进行安全审计。之后开发数据**检索器**与前端，前端通过 Web3 库与链上合约交互，显示状态并触发交易。最后部署智能合约和前端，发布到测试网或主网并维护。

![Dapp 开发流程图](https://web3intern.xyz/assets/dapp_development-workflow_01-sGuU6DCd.jpg)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qCanoe/images/2026-01-19-1768834346013-image.png)

**3\. 智能合约开发核心要点**

讲到智能合约具体开发，重点理解以下几点：

-   **开发语言与环境**：以太坊生态中 Solidity 是最常用语言，要掌握其语法、生命周期管理和安全实践。合约编写完后需要由于编译器（如 solc、Hardhat/Foundry 工具链）生成 ABI 与 bytecode，供部署与前端调用使用。
    
-   **合约测试**：单元测试是确保逻辑正确的基础，通过框架如 Hardhat、Truffle 或 Foundry 写全面的单测和集成测试；还要考虑安全性测试（重入、溢出攻击等）。
    
-   **安全审计**：合约一旦部署不可更改，高风险逻辑需要仔细审查漏洞，使用社区审计合约库（如 OpenZeppelin）和 formal verification 等技术提升安全性。
    

* * *

**4\. 开发环境搭建**

在开始写合约之前，建议搭建完善的本地开发环境：

-   安装 Node.js 和包管理器（npm/yarn），这是绝大多数工具的基础。
    
-   选择开发框架：**Hardhat**（现代、插件丰富）或 **Foundry**（Rust 生态中本地构建/测试效率高）。这些工具能帮助编译、部署、测试合约。
    
-   本地链：可以直接用 Hardhat 内置节点或 Foundry 的 anvil 启动测试链；这样快速迭代合约逻辑。
    
-   常用工具：Remix IDE 适合快速实验，OpenZeppelin 提供安全、可复用合约库；前端则可用 Viem、Ethers.js、Wagmi 等现代库与链交互。
    

* * *

**5\. RPC 节点与链交互**

RPC 是 Dapp 与链通信的核心桥梁，通过 JSON-RPC 与节点交互读取数据、发送交易、监听事件等。开发中可以选择第三方 RPC 服务（如 Infura、Alchemy）或运行本地节点测试。理解基本 JSON-RPC 方法（如 `eth_call`、`eth_sendTransaction`）有助于调试与性能优化。

* * *

**6\. 常见智能合约模式与扩展**

理解合约常见模式对编写成熟 Dapp 很重要：

-   **事件（Event）**：合约通过事件广播状态变化，检索器可以实时捕获并存库供前端查询。
    
-   **代币标准**：如 ERC-20、ERC-721、ERC-1155 等，熟悉标准能提升可组合性。
    
-   **权限控制**：Ownable、AccessControl 等模式常用于管理合约操作权限。
    

* * *

**7\. 安全与调试实践总结**

智能合约一旦发布难以更改，因此安全至关重要。实践包括：代码审计、单测覆盖、使用开源安全库、利用静态分析工具（如 solc-verify）检查不变量，还可参考研究工具（如 eThor 等）进行深度形式验证和漏洞检测。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->






### **1.18 以太坊账户与节点机制的关键细节理解**

**一、执行客户端与共识客户端的真实分工**

在 The Merge 之后，一个“完整的以太坊节点”不再是单一程序，而是由执行客户端与共识客户端协同组成。执行客户端负责的核心任务是**交易执行与状态维护**：包括运行 EVM、更新账户余额与合约存储、维护状态树，并对外提供 JSON-RPC 接口。共识客户端则完全不关心 EVM 细节，它只负责**区块提议、验证投票、最终性与验证者管理**。 一个关键认知是：**共识层并不知道交易“执行得对不对”，它只关心执行层给出的执行结果是否被多数验证者一致确认**。这也解释了为什么执行与共识分离能降低实现耦合，却不会削弱安全性。

**二、EOA 地址的生成逻辑与设计取舍**

EOA 地址并不是随机字符串，而是由公钥经过 Keccak-256 哈希后截取后 20 字节得到。这种“截断式地址”并不是为了节省空间，而是一个工程取舍： 一方面，160 位地址在安全性上已经足够，暴力碰撞不可行；另一方面，统一的短地址能降低状态存储与网络传播成本。 需要注意的是：**地址本身不携带任何“账户类型”信息**，EOA 和合约账户在地址层面是完全一致的，这也是“合约像账户一样被调用”的基础。

**三、CREATE 与 CREATE2 的本质区别**

普通的 CREATE 指令中，合约地址由「部署者地址 + 部署时的 nonce」决定，因此只有在部署完成后才能知道地址。 CREATE2 则引入了 salt 与合约字节码哈希，使合约地址在部署前就可以被计算出来。 这项设计并不是为了“炫技”，而是为了解决非常实际的问题：**提前确定地址、支持工厂模式、降低 Gas、改善用户体验**。许多智能钱包、账户抽象方案和 Layer2 系统，都严重依赖 CREATE2 的可预测性。

**四、EOA nonce 与合约 nonce 的语义差异**

EOA 的 nonce 表示该账户已经发起过多少笔交易，是防止重放攻击的关键字段；任何 nonce 不匹配的交易都会被直接拒绝。 合约账户的 nonce 含义完全不同，它只在合约创建其他合约时增加，用于参与子合约地址的计算。 一个重要结论是：**你几乎永远不关心合约 nonce，但 EOA nonce 一旦出错，交易必失败**，这也是钱包在构造交易时必须精确管理 nonce 的原因。

**五、代币余额“并不在用户账户中”**

ERC-20 等代币的余额，本质上是存储在**代币合约的 storage mapping 中**，即 `mapping(address => uint256)`。 当你查询 `balanceOf(user)` 时，并不是在看 user 账户的状态，而是在读取代币合约的内部状态。 这直接导致一个重要安全结论：**授权（approve）不是“钱包行为”，而是“合约层面的权限变更”**，也是为什么授权风险在现实中远大于单次转账风险。

**六、轻节点如何“不保存状态却仍然可信”**

轻节点并不是“盲信全节点”，而是通过区块头与默克尔证明来验证数据真实性。 当轻节点查询某个账户余额时，全节点需要提供一条从状态根到目标账户的证明路径，轻节点通过验证哈希关系来确认数据确实属于某个已确认区块。 因此，轻节点信任的是**加密证明 + 共识结果**，而不是某个具体节点。

**七、Gossip 协议实际传播的对象**

以太坊的 Gossip 并不是“广播整个区块链状态”，而是传播**交易、区块、区块头、共识消息等离散对象**。 节点收到消息后会进行基本验证，再继续向其他节点扩散。这种多路径冗余传播牺牲效率，但极大增强了抗审查性和抗分区能力。

**八、为什么合约不能签名，却能验证签名**

合约账户没有私钥，因此不可能生成签名；但 EVM 提供了 `ecrecover` 等原语，使合约可以验证某个签名是否来自某个 EOA。 这正是多签钱包、智能钱包、Session Key 和账户抽象的技术基础。 从本质上看，**合约不是在“代替人签名”，而是在“定义哪些签名是有效的”**。

**九、账户状态在默克尔-帕特里夏树中的位置**

以太坊的状态并不是线性表，而是组织在默克尔-帕特里夏树中。每个账户对应一条路径，其存在性、余额和存储都可以被加密证明。 这也是为什么以太坊可以支持“可验证查询”，以及为什么状态增长会成为长期扩展性的核心问题。

**十、钱包、账户、地址、客户端的严格区分**

钱包是本地软件，用于管理私钥与签名； 账户是协议层对象，表示状态与权限； 地址是账户的索引标识； 客户端是协议的实现，用于验证与传播数据。 混淆这四者，几乎是所有新手错误与许多安全误判的根源。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->







### **1.17 021 学习以太坊第 1-3 章回顾**

**一、总体视角：从“系统是什么”到“谁在系统中行动”**

第一至第三章共同完成了一件事：**为以太坊建立一套可被工程化理解的世界观**。 第一章回答“以太坊是什么、为什么存在”；第二章解释“这套系统如何在现实世界中运行”；第三章则明确“谁能够在系统中发起行为、状态如何被表达”。三章合在一起，构成了理解后续 EVM、Gas、合约与安全问题的认知地基。

* * *

**二、以太坊的本质定位（第一章核心）**

以太坊并非单纯的数字货币系统，而是一个**去中心化、可编程的公共区块链平台**。其核心创新在于引入智能合约与 EVM，使区块链从“分布式账本”升级为“分布式状态机”。 在这一框架下，区块链不只是记录交易历史，而是维护一份全网共享、可验证、持续演进的系统状态。ETH 在其中既是资产，又是运行网络所必需的燃料和安全保证金。

以太坊被称为“全球可编程区块链”或“世界计算机”，并非因为其性能，而是因为它在去中心化前提下，实现了三点统一：全球可访问、逻辑可编程、执行结果可共识。这一定位决定了以太坊后续所有设计取舍。

* * *

**三、ETH 的系统性角色**

ETH 并不是附属于以太坊的“奖励代币”，而是系统运转的核心组成部分。 它承担了三重职能： 第一，作为 Gas 支付单位，对计算与存储资源进行定价，防止滥用； 第二，作为 PoS 机制中的质押资产，为网络安全提供经济约束； 第三，作为 DeFi、NFT 与 Web3 生态中的基础抵押品和结算资产，连接协议层与应用层。 EIP-1559 的引入，使 ETH 的供需与网络使用强度直接挂钩，也强化了其作为系统性资产的地位。

* * *

**四、以太坊如何“存在于现实中”（第二章核心）**

以太坊并不是抽象存在的协议，而是一张由大量节点构成的**点对点网络**。 网络中不存在中心服务器，所有节点通过 P2P 协议连接，并依靠 Gossip 机制传播区块和交易。这种设计牺牲了一定效率，但换来了抗审查性和高鲁棒性。

在 The Merge 之后，以太坊节点的实现被清晰拆分为执行客户端与共识客户端：前者负责交易执行与状态更新，后者负责区块提议、投票与最终性。这种模块化设计降低了系统性风险，也使协议演进更加灵活。

* * *

**五、节点类型与去中心化权衡**

以太坊节点根据存储和验证深度不同，分为全节点、轻节点和归档节点。 全节点是网络的中坚力量，能够独立验证规则；轻节点以牺牲部分独立性换取资源效率；归档节点则为数据分析和研究提供完整历史视角。 节点数量、分布和运行成本，直接决定了网络的去中心化程度，因此以太坊的扩容路线始终强调在性能提升与节点可运行性之间取得平衡。

* * *

**六、账户模型：谁在以太坊中行动（第三章核心）**

以太坊采用**账户模型**而非 UTXO 模型，系统维护的是一组全局账户状态。 账户是协议层中“行为与状态的基本单元”，所有交易和合约调用，本质上都是对账户状态的修改。

以太坊中只有两类账户： 外部拥有账户（EOA）由私钥控制，**唯一能够主动发起交易**； 合约账户由代码控制，只能被动执行逻辑，无法主动发起交易。 这种区分明确了“意图来源”与“逻辑执行者”的边界，是以太坊安全模型的基础。

* * *

**七、账户状态与统一地址空间**

无论是 EOA 还是合约账户，在协议层都由统一的地址空间表示，并包含余额、nonce、代码和存储等状态字段。这种统一抽象，使合约能够像账户一样被调用，从而实现高度可组合的系统结构。 代币并不“存放在用户账户中”，而是记录在合约账户的内部状态中，用户地址只是参与状态映射的标识。这一点对于理解授权、资产安全和钱包风险至关重要。

* * *

**八、钱包的真实角色**

钱包并不是区块链中的账户实体，而是**私钥与交易签名的管理工具**。 它负责构造交易、签名并提交给网络，但并不控制协议规则。理解这一点，有助于区分“私钥泄露”“合约漏洞”和“协议设计风险”等不同问题的责任边界。

**拓展目标：**

1.  弄清 **执行客户端 vs 共识客户端** 的最小职责边界： 哪些数据只存在于执行层，哪些只存在于共识层？
    
2.  搞明白 **EOA 地址是如何从公钥生成的**，以及为什么要截断成 20 字节，而不是更长或更短。
    
3.  对比 **CREATE 与 CREATE2**： 合约地址各自是如何计算的？CREATE2 解决的具体工程问题是什么？
    
4.  查清 **EOA nonce 和合约 nonce 的完整语义差异**，以及它们各自在哪些情况下会变化。
    
5.  明确 **“代币余额不在用户账户中”** 在协议层面的准确含义： ERC-20 合约的 `balanceOf` 本质上查的是什么？
    
6.  弄懂 **轻节点是如何在不保存状态的情况下“验证自己没被骗”** 的（用到的证明类型是什么）。
    
7.  理解 **Gossip 协议在以太坊里传播的具体对象**： 是交易？区块？还是状态？
    
8.  搞清 **为什么一个合约无法签名，但可以验证签名**，以及这在多签 / 智能钱包中的直接用途。
    
9.  看一眼 **账户状态在 MPT（默克尔-帕特里夏树）中的位置**： 账户是如何被组织和证明存在性的？
    
10.  分清 **钱包、账户、地址、客户端** 四者在系统中的角色，避免概念混用。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->








### **1.16 思考与扩展**

**一、从“一笔交易”重新理解以太坊系统的因果链**

如果把以太坊当作一个整体系统来看，一笔交易并不是“用户点确认 → 链上发生变化”这么简单，而是一条跨越钱包、账户、节点、共识和状态存储的完整因果链。交易的起点永远是 **EOA 表达意图**：钱包帮助用户构造交易、选择参数并完成签名，但钱包本身并不拥有执行权。签名之后，交易进入网络层，首先面对的是节点的本地判断——是否满足 nonce 顺序、Gas 是否合理、签名是否有效。

随后，交易并不是立刻“上链”，而是进入内存池，在不同节点之间通过 Gossip 传播。这个阶段本质上是一个去中心化的“意图广播市场”，矿工或验证者从中挑选交易并打包成区块。区块提议只是开始，真正决定交易是否生效的，是全网节点在 EVM 中对交易执行结果的**重复计算与一致性验证**。只有当状态转换被多数节点接受，并最终被共识机制确认，这笔交易才真正成为系统历史的一部分。

这一完整流程的关键意义在于：**以太坊不是在“相信某个执行者”，而是在相信一个可重复验证的执行过程**。后续你研究任何钱包安全、签名风险或执行前模拟，本质上都是在这个因果链的不同位置插入“额外的理解与约束”。

* * *

**二、从协议升级反推以太坊的“长期工程矛盾”**

以太坊的重要升级并不是零散功能叠加，而是围绕几个长期存在、无法一次性解决的结构性矛盾展开。最核心的一组矛盾是：**去中心化程度、系统安全性与可扩展性之间的张力**。

EIP-1559 试图解决的是“资源定价混乱与用户体验不确定性”的问题，它并不单纯是手续费机制的调整，而是在协议层引入了“拥堵信号”与“价值回收机制”；The Merge 从 PoW 转向 PoS，表面上是能耗与共识形式变化，实质上是降低安全成本、为后续扩展释放系统预算；EIP-4844 和 Rollup 路线则清晰地表明，以太坊不再追求“所有事情都在 L1 做”，而是选择成为安全与数据可用性的锚点。

从这个视角看，以太坊的演进哲学非常明确：**把不可替代的信任最小化能力留在 L1，把可规模化的执行压力下沉到 L2**。理解这一点，会直接影响你之后如何看待账户复用、多链钱包、跨执行域的安全假设，而不是把它们当作零散的新概念。

* * *

**三、节点与 RPC：理想去中心化与现实工程实践之间的断层**

在理论上，运行全节点是最“纯粹”的去中心化参与方式；但在现实中，大多数用户、前端甚至开发者，都高度依赖中心化 RPC 服务。这并不是因为“大家不懂去中心化”，而是节点运行成本、同步时间、运维复杂度与开发效率之间存在现实权衡。

这意味着一个重要事实：**大量用户看到的“链上世界”，其实是经由少数基础设施提供者中转和过滤过的视图**。这并不等同于作恶，但它确实在信任模型中引入了新的中介层。对于你来说，这个断层非常关键——钱包展示的余额、交易模拟结果、Gas 估算，往往并非直接来自共识层，而是来自某种“准可信服务”。

因此，当你之后讨论“钱包是否应该更安全”“是否应该做执行前分析”，你必须意识到：很多风险并不发生在链上执行阶段，而发生在**用户对链上行为的理解阶段**。这是钱包研究与合约安全研究之间最本质的分野。

* * *

**四、账户抽象：从“密钥控制”到“策略表达”的范式迁移**

传统 EOA 模型把几乎所有安全压力压缩到一件事上：私钥是否泄露。这种模型在密码学上是优雅的，但在真实世界中极其脆弱。账户抽象（AA）的真正意义，并不是“让账户更复杂”，而是让账户具备**表达安全策略的能力**。

当账户由合约定义时，签名不再等同于“不可逆授权”，而是策略输入的一部分。多签、限额、延迟执行、社交恢复、会话密钥，本质上都是在回答同一个问题：**哪些意图可以被接受，哪些需要额外验证，哪些应该被拒绝**。在这种模型下，钱包的角色也发生变化——它不再只是签名器，而是“策略交互界面”。

这一步转变，直接为你之后思考签名语义、钱包不变量和 Agent 钱包提供了技术与哲学基础：账户不再是被动的资产容器，而是一个主动执行约束的主体。

* * *

**五、L2 时代的账户体验：单一身份，多重执行域**

随着执行下沉到 L2，一个现实正在形成：**同一个账户地址，会在多个执行环境中同时存在**。用户的直觉仍然是“这是我的账户”，但底层却是不同 Rollup、不同状态根、不同最终性时间尺度。

这对钱包与账户设计提出了全新挑战。账户不再只需要“能不能做这笔交易”，还需要回答“这笔交易发生在哪个执行域”“安全性锚定在哪里”“跨域操作是否引入新的隐性风险”。从用户体验角度看，这种复杂性如果直接暴露，是不可接受的；但如果完全隐藏，又可能掩盖关键风险。

因此，未来的钱包与账户系统，本质上是在做一件事：**在多执行域世界中，重建一种用户可理解、可预测的安全直觉**
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->









### **1.13** [**021 学习以太坊第 3 章**](https://github.com/XiaoHai67890/021Ethereum/blob/main/%E3%80%8A021%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E3%80%8B%E5%BC%80%E6%BA%90%E6%95%99%E6%9D%90.pdf)

**一、章节目标与核心问题**

本章围绕以太坊最基础、也是最容易被忽视的抽象——**账户（Account）**展开，重点回答三个问题： 第一，以太坊中“参与者”在协议层是如何被表示的； 第二，谁能够主动发起交易、执行逻辑； 第三，账户状态如何在全网被记录与维护。 理解账户模型，是理解交易、Gas、智能合约调用以及安全边界的前提。

**二、以太坊的账户模型概述**

以太坊采用的是**基于账户（Account-based）**的模型，而非比特币的 UTXO 模型。 在该模型下，区块链维护的是一组全局账户状态，每个账户都有明确的余额和状态字段。所有交易和合约调用，本质上都是对这些账户状态的更新。这一设计更贴近传统“账户—余额—状态”的直觉，也为复杂合约逻辑提供了便利。

**三、两类核心账户：EOA 与合约账户**

以太坊中只存在两种账户类型：外部拥有账户（EOA）与合约账户，它们在权限与能力上存在根本差异。

EOA 由一对公私钥控制，其核心特征是**能够主动发起交易**。用户通过私钥对交易进行签名，网络节点在验证签名有效后，才会执行对应操作。常见的钱包（如 MetaMask）管理的正是 EOA，本质上是帮助用户安全地生成、存储和使用私钥。

合约账户则由代码控制，其地址通常由部署交易产生。合约账户**无法主动发起交易**，只能在接收到交易或被其他合约调用时被动执行。其行为完全由合约代码决定，不存在“私钥”这一概念。

**四、以太坊地址结构与生成逻辑**

无论是 EOA 还是合约账户，在链上都以 20 字节地址表示，通常以 “0x” 开头。 EOA 地址由公钥通过哈希计算得到，具有唯一性和不可预测性；合约地址则由部署者地址和其当时的 nonce 计算而来（或通过 CREATE2 规则预先计算）。 这一统一的地址空间，使得合约与普通账户在交互层面保持一致，从而实现“合约像账户一样被调用”的抽象。

**五、账户状态的组成**

每个以太坊账户在协议层都包含一组固定的状态字段，包括余额、nonce、代码（仅合约账户存在）以及存储根。 余额表示账户持有的 ETH 数量；nonce 用于防止重放攻击，并记录交易或合约创建次数；代码定义了合约账户的执行逻辑；存储则保存合约内部的持久化状态。 这些状态通过默克尔-帕特里夏树组织，并被全网节点共同维护与验证。

**六、交易发起与账户权限边界**

在以太坊中，**只有 EOA 能够发起交易**。无论是转账 ETH，还是调用合约函数，其起点都必须是一个 EOA。 合约账户虽然无法主动发起交易，但可以在执行过程中调用其他合约，形成复杂的调用链。这种设计清晰地区分了“意图的来源”（人或代理）与“逻辑的执行者”（合约），是以太坊安全模型的重要组成部分。

**七、EOA 与合约账户的交互机制**

EOA 可以向合约账户发送交易以触发其函数执行；合约账户在执行过程中，也可以调用其他合约或向 EOA 转账 ETH。 这种统一的调用语义，使得以太坊形成了高度可组合的系统结构：DeFi 协议、NFT 市场和 DAO 往往并非单一合约，而是多个合约相互调用、协同工作的结果。

**八、钱包在账户体系中的角色**

钱包并不是区块链上的实体，而是**管理 EOA 私钥与交易签名的工具**。 钱包负责构造交易、估算 Gas、展示账户余额和历史记录，但并不“托管”账户本身。理解这一点，有助于区分“钱包被盗”“私钥泄露”和“合约漏洞”等不同安全事件的本质差异。

**九、代币标准与合约账户**

ERC-20、ERC-721、ERC-1155 等代币标准，本质上都是**运行在合约账户中的状态机**。 代币余额并不存储在用户账户中，而是记录在代币合约的内部存储里。用户地址只是作为键参与合约状态映射，这一点对于理解代币授权、转账和安全风险尤为关键。

**十、合约的不可篡改性与升级问题**

合约一旦部署，其代码在默认情况下不可修改。这种不可篡改性是区块链可信性的来源之一，但也带来了升级困难。 为解决这一矛盾，开发者通常采用代理合约、逻辑合约分离等升级模式，在保持地址稳定的同时更新业务逻辑。这些模式在后续智能合约章节中将进一步展开。

**十一、本章小结**

第三章从账户模型出发，明确了以太坊中“谁能行动、谁在执行、状态如何保存”的基本规则。 以太坊通过区分 EOA 与合约账户，在安全性、可编程性与系统抽象之间取得平衡。这一账户体系，是理解交易流程、Gas 机制、合约安全与钱包设计的基础，也是后续深入学习 EVM 和智能合约不可或缺的认知前提。

> **EOA 的 nonce 和合约账户的 nonce，语义完全不同**。 EOA 的 nonce 表示“你发过多少笔交易”，主要用于防重放； 合约账户的 nonce 表示“这个合约创建过多少个合约”，它只在 CREATE / CREATE2 时才有意义。 所以你几乎从不关心合约账户的 nonce，但对 EOA 来说，nonce 出错会直接导致交易失败。

> **合约账户“不能签名”，但可以验证签名**。 合约没有私钥，因此不能生成签名； 但合约可以用 `ecrecover` 等机制**验证 EOA 的签名是否正确**。 这正是多签钱包、智能钱包、Session Key、Account Abstraction 的技术基础。 换句话说：
> 
> > 合约不是不能“控制账户”，而是不能“冒充人签名”。

EOA 负责表达意图（我想做什么）； 合约账户负责执行规则（这件事该不该、该怎么做）； EVM 负责保证所有人看到的执行结果一致。

**十一、未来方向**

**账户模型的演进：从“密钥账户”走向“策略账户”**。 传统以太坊以 EOA 为中心，安全性几乎完全压在“私钥是否安全”这一点上，这在真实世界里显得非常脆弱。未来的趋势非常明确：账户不再只是“一把私钥”，而是一个**由合约定义的安全与行为策略集合**。 账户抽象（AA）并不是为了“技术炫技”，而是为了让账户具备现实世界所需的能力，例如多重验证、社交恢复、限额控制、会话密钥和 Gas 代付。这意味着账户将逐渐从“身份 + 资产容器”升级为“可编程的安全主体”，钱包也会从签名工具演变为策略执行入口。

**账户模型的演进：从“密钥账户”走向“策略账户”**。 传统以太坊以 EOA 为中心，安全性几乎完全压在“私钥是否安全”这一点上，这在真实世界里显得非常脆弱。未来的趋势非常明确：账户不再只是“一把私钥”，而是一个**由合约定义的安全与行为策略集合**。 账户抽象（AA）并不是为了“技术炫技”，而是为了让账户具备现实世界所需的能力，例如多重验证、社交恢复、限额控制、会话密钥和 Gas 代付。这意味着账户将逐渐从“身份 + 资产容器”升级为“可编程的安全主体”，钱包也会从签名工具演变为策略执行入口。

**执行与验证成本持续下沉到 L2，但安全锚定在 L1**。 从账户视角看，未来绝大多数用户交易、账户交互、钱包操作都将发生在 Rollup 上。 这会直接改变账户使用习惯：

-   地址可能是“跨 L2 复用”的身份
    
-   同一个账户在不同执行环境中有不同表现
    
-   钱包需要处理“多执行域 + 单一安全根”的复杂模型 但与此同时，L1 仍然是账户最终安全性、状态有效性的锚点。这种“分层账户体验”将是未来以太坊生态的常态。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->










### **1.14** [**021 学习以太坊第 2 章**](https://github.com/XiaoHai67890/021Ethereum/blob/main/%E3%80%8A021%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E3%80%8B%E5%BC%80%E6%BA%90%E6%95%99%E6%9D%90.pdf)

**一、章节目标与整体视角**

本章围绕以太坊作为“全球去中心化计算机”的**网络基础设施**展开，系统阐述节点如何组成网络、节点之间如何通信、不同节点类型的职责差异，以及这些设计如何共同保障以太坊的安全性、去中心化程度与可持续运行能力。本章是理解后续共识机制、Gas 成本与性能边界的重要前提。

**二、以太坊网络的整体结构**

以太坊采用典型的**点对点（P2P）网络架构**，不存在中心化服务器或统一调度节点。网络中的每一个节点都是平等的参与者，既可以接收信息，也可以向其他节点传播信息。 节点之间通过节点发现机制建立连接，并利用 Gossip 协议扩散区块、交易与状态相关数据。这种通信方式虽然在效率上不如中心化架构，但在抗审查性、抗单点故障和容错性方面具有显著优势，是区块链系统去中心化特性的基础。

**三、节点与客户端的基本概念**

节点的本质是**运行以太坊客户端软件的实例**。客户端是对以太坊协议的具体实现，负责区块验证、交易执行、状态维护与网络通信。 在 The Merge 之后，以太坊客户端被明确拆分为两类： 执行客户端负责执行交易、维护 EVM 状态并处理智能合约逻辑；共识客户端负责区块提议、验证投票以及最终性判断。两者通过标准接口协同运行，共同完成一个完整节点的功能。这种分层设计提高了协议的模块化程度，也降低了单一实现的系统性风险。

**四、节点类型及其功能差异**

根据存储内容和验证深度的不同，以太坊节点主要分为三类。

全节点保存区块链的最新状态，并能够独立验证所有新区块和交易规则。它们不一定保存完整历史状态，但能够在不信任第三方的情况下确认当前链的正确性，是网络中的中坚力量。

轻节点只保存区块头，不维护完整状态。它们通过向全节点请求证明来验证特定数据，从而在资源消耗和安全性之间做出权衡。轻节点适合移动端或资源受限环境，但在信任模型上对全节点存在依赖。

归档节点保存区块链的全部历史状态，能够查询任意历史高度下的账户余额和合约存储。由于存储和维护成本极高，归档节点通常由研究机构、区块浏览器或数据分析服务运行，而非普通用户。

**五、运行全节点的意义**

本章强调，运行全节点不仅是“参与网络”的行为，更是一种**去中心化立场的体现**。通过运行全节点，用户或开发者可以自行验证链上规则，避免对中心化 RPC 服务的依赖，从而确保所获取数据的真实性与完整性。 对于开发者、基础设施提供方和高价值应用而言，全节点是进行调试、审计和安全分析的重要基础。

**六、节点间通信与数据传播机制**

以太坊节点通过一整套 P2P 协议进行通信。节点发现通常基于分布式哈希表（DHT）机制，确保节点能够在动态网络中快速找到彼此。 数据传播主要依赖 Gossip 协议，其核心思想是通过多路径、冗余传播确保信息最终覆盖整个网络。这种方式牺牲了一定效率，但显著提升了网络的鲁棒性和抗攻击能力。

**七、节点同步机制**

节点同步的目标并非重放所有历史交易，而是**尽快获得一份可验证的最新全局状态**。 以太坊支持多种同步模式，包括全同步、快照同步（Snap Sync）和轻同步。快照同步通过直接下载最新状态并校验区块头，大幅缩短了节点加入网络的时间，成为当前全节点的主流选择。这反映出以太坊在工程实践中对“安全性与可用性平衡”的重视。

**八、节点数量与去中心化保障**

网络中节点的数量、地理分布和运行门槛，直接影响以太坊的去中心化程度。节点越分散，网络越难被单一实体控制或审查。 因此，以太坊在设计升级方案时，始终需要在扩展性能与节点负担之间做权衡，例如通过 PoS、数据可用性优化和未来的 Verkle Tree 等方案，降低节点的存储和验证成本。

**安全与合规**

[https://web3intern.xyz/zh/security/](https://web3intern.xyz/zh/security/)

首先需要明确的是，在当前监管语境下，区块链技术与加密金融活动被严格区分。技术本身通常被视为中性工具，但一旦项目涉及代币发行、交易撮合、收益预期或资金募集，其性质便可能被认定为金融活动，从而进入高度监管甚至禁止的领域。因此，判断一个 Web3 项目是否存在风险，并不取决于其技术形式，而取决于其是否具备金融属性。

在具体风险类型上，代币发行与激励机制是最核心的高风险点。无论是 ICO、IEO、IDO，还是以链游、NFT、DAO 等形式包装的返利、分红、收益分享机制，只要存在“投入—回报”的结构，就可能被纳入非法集资、非法经营或传销的法律框架。尤其是多级返利、拉新奖励、充值抽取稀有资产等设计，在监管视角下极易被等同为赌博或传销模型。

一个重要但常被低估的风险在于参与主体的责任认定。法律责任并不只针对直接募集或管理资金的角色，参与项目核心逻辑设计、系统开发或合约部署的技术人员，同样可能被认定为共同实施行为。也就是说，技术工作并不天然构成免责理由，系统架构与经济模型本身可能被视为违法行为的重要组成部分。

从国际视角来看，全球主要司法辖区正在逐步建立加密资产的制度化监管框架，例如反洗钱与反恐融资要求、用户身份识别（KYC）、交易可追溯性以及稳定币监管等。这一趋势表明，合规正在从“事后规避风险”转变为“项目前置条件”，并逐渐成为项目可持续性的基础，而非单纯的限制因素。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->











### **1.13** [**021 学习以太坊第 1 章**](https://github.com/XiaoHai67890/021Ethereum/blob/main/%E3%80%8A021%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E3%80%8B%E5%BC%80%E6%BA%90%E6%95%99%E6%9D%90.pdf)

**一、学习目标与章节定位**

本章旨在从宏观层面理解以太坊的**起源、平台定位、核心机制与应用边界**，为后续关于节点、账户、智能合约与 EVM 的技术性内容建立统一认知框架。其重点不在“如何开发”，而在“以太坊是什么、能做什么、为何重要”。

**二、以太坊的起源与发展脉络**

以太坊由 Vitalik Buterin 于 2013 年提出，源于其对比特币脚本能力受限的反思。比特币更偏向安全、稳健的价值转移系统，而以太坊从一开始就被设想为一个**可运行通用程序的去中心化平台**。 以太坊主网于 2015 年上线（Frontier 阶段），随后经历 Homestead、Metropolis（Byzantium / Constantinople）等升级，并在 2022 年 The Merge 中完成从 PoW 向 PoS 的根本性转型。2024 年后的 Dencun、EIP-4844（Proto-Danksharding）标志着其发展重点转向 Rollup 支撑与数据可用性扩展，体现出“长期演进而非一次性设计”的工程哲学。

**三、以太坊的平台定位与核心特性**

以太坊是一个**去中心化、开源、支持智能合约的公共区块链平台**。其核心在于以太坊虚拟机（EVM），这是一个图灵完备的执行环境，使区块链从“分布式账本”升级为“分布式状态机”。 在该架构下，所有账户余额、合约状态与执行结果都被记录在一个全网共享的状态中，并通过共识机制确保一致性。这使得以太坊不仅能够转移资产，还能承载复杂逻辑和跨合约组合。

**四、ETH（以太币）的定义与系统职能**

ETH 是以太坊的原生资产，其设计目标并非单一的“货币”，而是兼具**功能性与资产性**。 首先，ETH 是网络运行的燃料，所有交易和合约执行都必须以 ETH 支付 Gas，用以计量计算和存储资源。EIP-1559 之后，Gas 费用由 Base Fee（销毁）与 Priority Fee（奖励验证者）构成，强化了 ETH 与网络使用度之间的内在联系。 其次，在 PoS 体系中，ETH 是质押资产，验证者通过锁定 ETH 参与共识并获得奖励，同时承担被 Slashing 的风险，从而为系统安全提供经济约束。 再次，ETH 也是 DeFi、NFT 与 Web3 生态中最重要的抵押资产和结算单位，构成整个应用层经济活动的“底层货币”。

**五、智能合约与可编程性**

智能合约是部署在区块链上的确定性程序，由全网节点在 EVM 中执行。它以“代码即规则”的方式替代传统的中心化执行者，使得协议行为无需依赖信任。 由于 EVM 是图灵完备的，以太坊能够表达几乎所有可计算逻辑，这一特性使其区别于比特币等以转账为核心的区块链系统，也奠定了 DeFi、DAO、NFT 等应用得以出现的技术基础。

**六、全球可编程区块链与“世界计算机”**

“全球可编程区块链”这一称谓可拆解为三层含义： 其一，区块链提供去中心化、不可篡改与公开可验证的信任基础； 其二，可编程性来自智能合约与 EVM，使逻辑不再受限于简单脚本； 其三，全球性意味着任何人只要接入网络，就可以在同一个共享状态机上部署和调用程序。 因此，以太坊常被描述为“世界计算机”：它不属于任何单一实体，但所有人都可以在其上执行逻辑并达成共识。

**七、以太坊与比特币的异同**

比特币与以太坊在去中心化、共识驱动和数字资产属性上高度相似，但在目标定位上存在根本差异。 比特币强调稀缺性、抗通胀与长期价值储存，协议设计极度克制；以太坊则强调通用性和应用承载能力，愿意通过升级换取功能与扩展性。这种差异并非优劣之分，而是服务于不同的系统目标。

**八、dApp 的概念与应用形态**

去中心化应用（dApp）通常由**链上智能合约（后端）与链下前端界面**构成。合约作为公开、不可篡改的逻辑层，前端则负责用户交互。 dApp 的优势在于抗审查、零停机和可验证性，但代价是性能受限、合约升级困难以及较高的设计与安全要求。当前 DeFi、NFT、DAO、链游等生态，正是这种架构在不同领域的具体体现。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->












## 1.12 Web3 实习手册[「入门导读」](https://web3intern.xyz/zh/blockchain-basic/)部分

## **一、区块链基础**

> [https://web3intern.xyz/zh/blockchain-basic/](https://web3intern.xyz/zh/blockchain-basic/)

-   去中心化、分布式账本
    
-   区块、链式结构、不可篡改
    
-   哈希函数、Merkle Tree
    
-   共识机制（PoW / PoS / DPoS）
    
-   区块确认、最终性（Finality）
    
-   公链 / 联盟链 / 私链
    
-   激励机制与节点（矿工 / 验证者）
    
-   经济安全性（Crypto-economic Security）
    
-   Web3 与 Web2 的区别
    
-   信任最小化、抗审查
    
-   可扩展性与性能瓶颈（不可能三角）
    
-   链上透明性 vs 隐私保护
    

* * *

## **二、以太坊概览**

> [https://web3intern.xyz/zh/overview-of-ethereum/](https://web3intern.xyz/zh/overview-of-ethereum/)

-   支持智能合约的公链
    
-   EVM（以太坊虚拟机）
    
-   Solidity 合约语言
    
-   ETH 与 Gas 机制
    
-   账户模型（EOA / 合约账户）
    
-   DApp 开发生态
    
-   DeFi / NFT / DAO 基础设施
    
-   PoW → PoS（The Merge）
    
-   质押（Staking）与验证者
    
-   可组合性（Composable / Money Lego）
    
-   Layer2 扩展需求
    
-   Rollup（Optimistic / ZK）
    

* * *

## **三、Web3 行业认知**

> [https://web3intern.xyz/zh/industry-knowledge/](https://web3intern.xyz/zh/industry-knowledge/)

-   技术岗 vs 非技术岗
    
-   智能合约开发
    
-   前端 / 后端 / 协议工程
    
-   产品、运营、社区
    
-   研究员、分析师、BD
    
-   DAO 与去中心化组织
    
-   Token 经济模型（Tokenomics）
    
-   基础设施赛道（L2、跨链、预言机）
    
-   钱包、节点、RPC 服务
    
-   开源与链上透明文化
    
-   快速迭代、高风险高波动
    
-   熊市 / 牛市周期影响
    

* * *

## **四、Web3 远程工作**

> [https://web3intern.xyz/zh/remote-work-guide/](https://web3intern.xyz/zh/remote-work-guide/)

-   全球化、远程优先
    
-   异步沟通为主
    
-   工具导向（Discord / GitHub / Notion）
    
-   文档驱动协作
    
-   公共讨论、透明决策
    
-   结果导向、弱层级
    
-   多时区协同
    
-   社区即入口
    
-   贡献即简历（PR / 提案 / 内容）
    
-   Token / 股权 / Grant 激励
    
-   自驱能力与自我管理
    
-   英语与跨文化沟通能力
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
