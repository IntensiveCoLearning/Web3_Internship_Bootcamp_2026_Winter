---
timezone: UTC+8
---

# zh0006xu

**GitHub ID:** zh0006xu

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
# Foundry & Hardhat初体验

今日完成 「入门技术任务」—— Foundry 和 Hardhat 教程跟练。

互动概念不复杂，但是 Hardhat 环境设置惹了很多麻烦。教程内容应该是按照 V2 — Ethers.js 编写的，但是没有明确，第一次创建的环境是 V3，虽然一路 debug 进行到了 Console 互动环节，但由于 ethers 和 viem 语法不同，我对2种框架都不熟悉，测试起来很麻烦，干脆退回重新设置环境。

第二次选择了 Hardhat V2 - ethers，但是安装依赖又出现了冲突，遂选择了minimal，之后用到哪个安哪个。最终完成全程。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

# **Solidity 学习**

今日完成 Solidity 101 中的最后2章：抽象合约和接口，异常。

笔记依旧记录在导图中。导图保存网盘：[https://bit.ly/49E72mP](https://bit.ly/49E72mP)。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-25-1769339996674-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-25-1769340016665-image.png)
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->


# **Tokenization 魔改**实践

基于昨天完成的 [Tokenization challenge](https://speedrunethereum.com/challenge/tokenization)，想让自己的毛孩子也上链，于是魔改代码，成功把使用项目预设图片改为支持用户上传图片：

-   用户上传图片 → 前端预览裁剪 → 后端图片处理背景移除 → 上传到IPFS → 自定义属性 → mint
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->



# Tokenization Challenge

今日完成[Tokenization挑战](https://speedrunethereum.com/challenge/tokenization)——内容和流程设计得非常清晰，惊觉原来跑通Dapp流程没有那么复杂。

除了了解了合约部署流程，最大收获是搞清楚了过程中涉及到的不同地址——初看到的时候觉得特别混乱。

下图是Dapp前端的Debug Contracts页面，显示了2个**不同的**地址：

1.  YourCollectible下边的地址：0xfdAe...F6Fd
    
2.  owner地址：0xC698...325f
    

而且他们都与我的钱包地址不同。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-23-1769165862635-image.png)

## 合约部署过程中的3个地址

调查后了解到合约部署过程中主要涉及了3个地址：

1.  部署者账户 (Deployer Account)
    
    -   发起部署交易的账户
        
    -   支付部署合约的 gas 费用
        
2.  合约地址（Contract Address）
    
    -   部署成功后，区块链为合约分配的唯一地址
        
    -   由部署者地址 + nonce 通过算法计算得出
        
3.  Owner地址（合约所有者）
    

-   普通合约中，与部署者账户一致
    

```
constructor() Ownable(msg.sender) {}
```

-   constructor可指定owner
    

```
constructor(address _owner) Ownable(_owner) {}  
```

-   工厂合约如果写 Ownable(msg.sender)，owner 是工厂合约；通常会显式传入用户地址
    

因此，YourCollectible下边的地址即为合约地址，owner地址即部署者的钱包地址。

那么第二个问题紧接着到来了：合约代码明明是 constructor() ERC721("YourCollectible", "YCB") Ownable(msg.sender) {}，那为什么作为部署者，Owner地址跟我的钱包地址又不同呢？

”答案就在题面上“：因为 yarn generate 在本地生成了一个部署地址，专门用于部署智能合约。私钥加密存储在项目的 .env 文件中。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-23-1769169346630-image.png)

这样做的几点好处：

-   安全性：部署私钥留在项目本地，不暴露你的主钱包私钥
    
-   自动化：部署脚本可以直接读取本地私钥，无需每次手动连接钱包
    
-   职责分离：部署者只负责部署，用户钱包负责交互
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->




# Solidity 学习

今日完成 Solidity 101 中的12和13章：事件，继承。

概念和逻辑跟Python相似。

导图中插入了自己查询后的扩展材料，也对之前涉及到的主题做了增补。

## 事件 Event

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-22-1769088426986-image.png)

## 继承 Inheritance

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-22-1769088606767-image.png)
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->





# **Solidity 学习**

今日完成 Solidity 101 中的7-11章。1-9章主要涵盖了 Solidity 数据类型，在此把零散和易混淆的知识点串起来，归纳总结了相关内容。

## Solidity 数据类型总结

### **一、值类型 vs 引用类型**

| 值类型 | 引用类型 |
| --- | --- |
| bool | string |
| uint / int | bytes（动态） |
| address | 数组（T[]） |
| bytes1 ~ bytes32 | struct |
| enum | mapping |

### **二、存储位置（仅引用类型需要）**

| 特性 | storage | memory | calldata |
| --- | --- | --- | --- |
| 位置 | 链上 | 内存 | 输入数据 |
| 生命周期 | 永久 | 函数执行期间 | 函数调用期间 |
| 可读写 | ✓ | ✓ | 只读 |
| 函数内创建 | ✗ （只能是引用） | ✓ | ✗ |
| 用于参数 | ✓ | ✓ | ✓（除 public 外） |
| gas 成本 | 最高 | 中等 | 最低 |

**示例：**

```solidity
contract MyContract {
    uint[] arr;  // 状态变量，自动 storage
    
    // calldata：只读，最省 gas
    function a(uint[] calldata input) external {}      // ✓
    function b(uint[] calldata input) internal {}      // ✓
    function c(uint[] calldata input) private {}       // ✓
    // function d(uint[] calldata input) public {}     // ✗ 错误
    
    // memory：可读写
    function e(uint[] memory input) public {}          // ✓
    
    function f() public {
        // 函数内创建 memory
        uint[] memory temp = new uint[](3);
        
        // 函数内引用 storage（不能创建新的）
        uint[] storage ref = arr;
        ref.push(1);  // arr 也会改变
    }
}
```

### **三、变量作用域**

| 类型 | 位置 | 特点 |
| --- | --- | --- |
| 状态变量 | 合约内函数外 | storage，永久存储 |
| 局部变量 | 函数内 | memory/stack，临时 |
| 全局变量 | Solidity 预留关键字，不用声明直接用 | EVM 提供，msg.sender, block.timestamp 等 |

### **四、constant 和 immutable**

|   | constant | immutable |
| --- | --- | --- |
| 赋值时机 | 声明时 | 声明时或构造函数 |
| 可用类型 | 值类型 + string + bytes | 值类型 |
| gas | 最省 | 省 |

**示例：**

```
contract MyContract {
    // constant：只能编译时确定
    uint constant A = 100;
    uint constant B = 50 + 50;  // 编译时计算
    // uint constant C = block.timestamp;  // 错误：不能用运行时值
    
    // immutable：可以编译时或部署时确定
    uint immutable X = 100;              // 编译时确定
    uint immutable Y;                    // 部署时确定
    uint immutable Z = block.timestamp;  // 运行时值
    
    constructor() {
        Y = msg.sender.balance;  // 部署时确定
    }
}
```

### **五、初始值**

| 类型 | 初始值 |
| --- | --- |
| bool | false |
| uint / int | 0 |
| address | 0x0000000000000000000000000000000000000000 或 address(0) |
| bytes32 | 0x0...0 （根据字节数而定） |
| string | "" |
| enum | 第一个成员 |
| mapping | 所有键返回默认值 |
| 数组 | 空数组 |
| struct | 所有成员默认值 |
| function | 空引用 |

### **六、数组操作**

| 方法 | 说明 | 返回值 | storage 动态 | storage 定长 | memory |
| --- | --- | --- | --- | --- | --- |
| length | 获取数组长度 | uint | ✓ | ✓ | ✓ |
| push() | 添加默认值元素 | 元素引用 | ✓ | ✗ | ✗ |
| push(x) | 添加指定值 | 无 | ✓ | ✗ | ✗ |
| pop() | 删除最后一个元素 | 无 | ✓ | ✗ | ✗ |

**示例：**

```
contract ArrayDemo {
    uint[] public dynamicArr;
    uint[3] public fixedArr;
    
    function testDynamic() public {
        // storage 动态数组：全部可用
        dynamicArr.push(1);       // [1]
        dynamicArr.push() = 3;    // [1, 3]
        dynamicArr.pop();         // [1]
        uint len = dynamicArr.length;  // 1
    }
    
    function testFixed() public view returns(uint) {
        // storage 定长数组：只能用 length
        return fixedArr.length;   // 3
        // fixedArr.push(1);      // 错误
        // fixedArr.pop();        // 错误
    }
    
    function testMemory() public pure returns(uint) {
        // memory 数组：只能用 length
        uint[] memory memArr = new uint[](3);
        memArr[0] = 1;
        memArr[1] = 2;
        memArr[2] = 3;
        return memArr.length;     // 3
        // memArr.push(4);        // 错误
        // memArr.pop();          // 错误
    }
}
```

### **七、mapping 限制**

| 特性 | 说明 |
| --- | --- |
| 键类型 | 只能是值类型 |
| 存储位置 | 只能 storage |
| 可否遍历 | 不能 |
| 作为参数/返回值 | 不能 |

### **八、函数可见性**

|   | 普通函数（定义时用，控制访问权限） | 函数类型变量（声明时用，指定调用方式） |
| --- | --- | --- |
| public | ✓ | ✗ |
| private | ✓ | ✗ |
| internal | ✓ | ✓ |
| external | ✓ | ✓ |

### **九、赋值行为**

| 赋值方式 | 结果 | 修改是否会互相影响 |
| --- | --- | --- |
| 值类型 | 复制 | ✗ |
| storage → storage | 引用 | ✓ |
| memory → memory | 引用 | ✓ |
| storage ↔ memory | 复制 | ✗ |
| calldata → memory / storage | 复制 | ✗ |
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->






# Solidity 学习

今日了解如何使用 Remix 各个模块，尤其是Debug。完成 Solidity 101 中的前6个章节，跟着案例边测试边学习，笔记较多，保存在学习导图中，截屏几个重要概念。

## 函数

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-20-1768915100964-image.png)

初次体验最大的感受就是函数结构很繁复，需要标明/定义很多内容。思考了背后的逻辑，大抵是考量了安全性和节省Gas费用导致的：

-   可见性限制：智能合约管理真金白银，必须严格限制访问权限
    
-   状态可见性：明确告诉 EVM 函数的行为，避免不必要的操作。eg. view 告诉 EVM：不写链，直接调用不收 gas；pure：纯牛马，不读不写，更省
    
-   可读性强（虽然写起来复杂）：函数声明本身就是文档，一目了然。eg.
    

```
function transfer(address to, uint amount) 
    external          // 只能外部调用
    payable           // 可以收 ETH
    onlyOwner         // 只有 owner 能调
    returns(bool)     // 返回布尔值
{ }
```

## 数据结构

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-20-1768915161963-image.png)

## 数据存储模式

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-20-1768915219015-image.png)

## 变量的作用域

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-20-1768915260881-image.png)
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->







# **智能合约开发 - 笔记**

第一章到第四章

## Dapp 架构和开发流程

Dapp（去中心化应用）与传统应用的核心区别：**数据和逻辑不由单一实体控制**，而是由区块链网络共同维护。

### Dapp 四大核心组件

| 组件 | 作用 | 技术栈 |
| --- | --- | --- |
| 前端 | 用户交互界面 | React/Vue + MetaMask |
| 智能合约 | 核心业务逻辑，部署在链上 | Solidity + EVM |
| 检索器（Indexer） | 捕获链上事件，存入传统数据库供查询 | Ponder/Subgraph + PostgreSQL |
| 去中心化存储 | 存储大文件（图片、文档） | IPFS/Arweave |

### 前端与区块链的交互方式

```
前端 ──→ 钱包（MetaMask）──→ RPC 节点 ──→ 区块链网络
         │                      │
         签名交易               广播/查询
```

**两种操作类型**：

-   **只读操作**（`eth_call`）：查询余额、读取状态，不消耗 Gas
    
-   **写入操作**（`eth_sendTransaction`）：修改链上状态，需签名 + 支付 Gas
    

### Dapp 开发六阶段流程

| 阶段 | 主要工作 |
| --- | --- |
| 1. 需求分析 | 确定功能、选择区块链平台（以太坊/Solana/Polygon）、设计 UX |
| 2. 智能合约开发 | 编写 Solidity 代码、单元测试、安全审计 |
| 3. 检索器开发 | 确定前端所需数据、编写事件监听代码、部署运维 |
| 4. 前端开发 | 选择框架、集成钱包、展示链上数据、处理交易签名 |
| 5. 链上交互 | 使用 Viem/Ethers.js/Wagmi 库实现读取和发送交易 |
| 6. 部署上线 | 合约部署到测试网/主网、前端部署到 IPFS/Vercel |

* * *

## 第二章：以太坊开发环境搭建

### 基础环境 & 本地开发链

### 常用工具汇总

| 工具 | 用途 |
| --- | --- |
| Remix IDE | 网页版 IDE，快速测试合约 |
| MetaMask | 浏览器钱包，开发必备 |
| OpenZeppelin | 标准合约库（ERC-20、ERC-721 等） |
| Viem/Wagmi | 现代前端交互库（推荐） |
| Ethers.js/Web3.js | 传统前端交互库 |

* * *

## 第三章：RPC 节点服务详解

### RPC & RPC 节点

**RPC（Remote Procedure Call）** = 前端与区块链通讯的桥梁

```
你的前端 ──HTTP/WebSocket──→ RPC 节点 ──P2P──→ 区块链网络
```

**类比**：RPC 节点 = 银行 ATM，区块链 = 银行核心系统

### RPC 四大职责

| 职责 | 说明 | 对应方法 |
| --- | --- | --- |
| 读取数据 | 查询余额、合约状态、区块信息 | eth_getBalance、eth_call |
| 发送交易 | 广播签名交易、估算 Gas | eth_sendTransaction、eth_estimateGas |
| 事件监听 | 监听合约 Events，实时推送 | eth_getLogs、WebSocket 订阅 |
| 网络管理 | 切换网络、获取链 ID | eth_chainId、net_version |

### 3.3 JSON-RPC 协议格式

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-19-1768818087984-image.png)

### 主流 RPC 服务商对比

| 服务商 | 免费额度 | 特点 | 适用场景 |
| --- | --- | --- | --- |
| Alchemy | 3 亿次/月 | 企业级稳定，文档完善 | 生产环境 |
| Infura | 10 万次/月 | 老牌，ConsenSys 旗下 | 开发测试 |
| QuickNode | 有限 | 高性能低延迟 | 高频交易 |
| Public Node | 无限制 | 完全免费 | 学习测试 |
| Ankr | 有限 | 多链支持 | 跨链项目 |

### 最佳实践

| 实践 | 说明 |
| --- | --- |
| 保护 API Key | 使用环境变量，不提交到 Git |
| 错误重试 | 实现重试机制，处理网络波动 |
| 速率限制 | 实现请求节流，避免超限 |
| 多节点备份 | 配置多个 RPC 端点，实现故障转移 |
| 本地开发优先 | 开发时用 Anvil/Hardhat Node，不受限制 |

### 自建 vs 第三方

| 对比项 | 自建全节点 | 第三方 RPC |
| --- | --- | --- |
| 控制权 | ✅ 完全 | ❌ 依赖外部 |
| 成本 | ❌ 高（TB 级存储） | ✅ 免费额度充足 |
| 维护 | ❌ 复杂 | ✅ 零维护 |
| 适用 | 交易所、企业级 | 大多数 Dapp |
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->








# AI 机器基础概念 - 讲座笔记

## 核心主题：让AI从"聊天机器人"变成"打工人"

_AI如何从只能对话进化为能够自主执行任务、赚钱的经济体。_

* * *

## 一、AI的演进：从LLM到Agentic AI

**2023年LLM的三个致命限制**：

-   **无状态**：每次对话从零开始，聊完就忘
    
-   **没有工具**：只能生成文本，不能执行代码或调用API
    
-   **没有身份**：不能代表任何人行动，不能签署协议或管理资产
    

**2026年Agentic AI的突破**：具备推理+记忆+工具使用能力，能自主执行任务

* * *

## 二、AI智能体的三大组件

**大脑（LLM）**：GPT-5.2、DeepSeek、Claude 4.5等，负责理解意图、制定计划、生成指令，但不执行操作。

**记忆（向量数据库）**：通过RAG流程实现私有记忆——数据采集→向量化（Embedding）→存储（Pinecone/Weaviate）→检索。让AI从"金鱼"进化成"大象"。

**工具（API/MCP）**：通过Function Call让AI能执行代码、查数据库、发指令，形成"思考-行动-观察"的React循环。

* * *

## 三、当前AI面临的信任危机

**身份欺诈**：HTTP协议无法验证请求者是人还是AI，任何人都可声称是某公司的AI Agent。

**不可审计**：AI决策是黑盒，日志存在企业本地可被篡改，出事后责任难追溯。

**影子AI**：59%的组织缺乏统一治理框架，大量AI以"游击队"方式在企业内部运行。

* * *

## 四、传统支付对AI的障碍

-   **身份认证**：验证码、KYC是为了证明你"不是机器人"，但AI恰恰就是机器人
    
-   **支付颗粒度**：信用卡手续费2-3%，无法支持0.001美元级别的微支付
    
-   **结算速度**：传统T+1到T+3，跨境可能一周；AI交互是毫秒级
    
-   **订阅模式错配**：固定月费与AI的动态工作模式不匹配
    

* * *

## 五、Web3解决方案：三层协议架构

**交易层 - x402协议**：

-   基于HTTP 402状态码实现原生机器支付
    
-   服务器返回402时，响应头包含支付地址、金额、代币类型
    
-   AI钱包自动签署交易，无需注册、登录、KYC
    
-   支持Pay-per-file、Pay-per-inference等微支付场景
    

**身份层 - ERC-8004标准**：

-   基于ERC-721为每个AI铸造唯一的链上护照NFT
    
-   **身份注册表**：存储AI类型、能力声明、运行模型哈希、所有者地址
    
-   **声誉注册表**：0-100分评分系统，只有链上有真实交易的地址才能评价，防止刷分
    
-   **验证机制**：支持TEE（可信执行环境）和zkML零知识证明
    

**应用层 - SpoonOS框架**：

-   连接Web2开发工具（Python、LangChain）与Web3基础设施的桥梁
    
-   开发者无需管理私钥或手写交易签名，调用SDK即可
    
-   四层架构：输入层→核心层（引擎+LLM API+智能体编排）→协议层→输出层
    

* * *

## 六、Q&A精华

**关于女巫攻击防护**：ERC-8004要求只有实际调用过该AI并产生交易哈希的钱包才能评价，攻击成本较高。

**关于AI DeFi交易**：AI的上限在于人的策略设计。建议先用小额资金（如100U）测试AI是否按预期执行，跑通后再增加资金。

**关于声誉系统设计**：目前声誉针对单个Agent而非Developer，确实存在开发者弃号重开的可能；评分目前是单维度的0-100分，未来会优化。

* * *

**Web3与AI结合不是情怀，是刚需**。未来经济主体将不仅是人类，而是数以亿计拥有自主钱包的AI智能体。区块链为AI提供了两样东西：一张不可伪造的身份证，和一个可编程的银行账户。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->









# 合规 — 讲座笔记

该主题笔记以图片形式上传，折叠敏感内容

![Screenshot 2026-01-17 at 11.32.38 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/zh0006xu/images/2026-01-17-1768663966392-Screenshot_2026-01-17_at_11.32.38_PM.png)
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->










# 合规和网络安全 - 笔记

## 一、Web3 合规性要求与常见法律风险

**中国监管现状**：自2017年起全面禁止ICO、虚拟货币交易所、挖矿活动。核心态度是"封堵金融属性，有限容忍技术创新"。

**核心法律风险**：

-   代币发行与交易可能构成非法吸收公众存款罪
    
-   链游中的"充值-抽奖-提现"模式可能触犯开设赌场罪
    
-   多级返利推广可能构成组织领导传销活动罪
    
-   场外交易涉及洗钱、非法经营外汇风险
    

**入职风险提示**：很多Web3项目境外注册、无法签正规劳动合同、无五险一金。薪酬中的Token或USDT部分存在法律和税务风险，出金时可能因收到涉诈资金导致银行卡被冻结。

## 二、常见网络安全风险与防护措施

**主要攻击类型**：

-   钓鱼攻击（伪造面试软件、假空投活动、假客服）
    
-   恶意软件/木马（剪贴板劫持、远程控制）
    
-   社会工程攻击（冒充HR、学长等）
    
-   供应链攻击（恶意浏览器插件、开源库后门）
    

**防护建议**：

-   只用官方会议软件
    
-   不轻信群内"官方人员"
    
-   转账前核对地址前后几位
    
-   助记词离线保存
    
-   启用2FA
    
-   使用密码管理器
    

## 三、骗局实际案例

-   恶意Word文档植入木马
    
-   Punycode域名欺骗（如将`trẹzor.com`伪装成`trezor.com`）
    
-   内部人员作恶等高级攻击手法
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->











# Web3安全与风险趋势 - 讲座笔记

## 2025年安全态势总览

-   2025年Web3领域发生超过1200起较严重的安全事件，总损失超过**35亿美元**。
    
-   攻击呈现"精准猎杀"与"广撒网"并行的特点。
    

1.  **精准猎杀（大额攻击）**：
    
    -   CeFi（中心化金融）成为主要的黑客取款机
        
        -   2025年单体损失超3000万美元的12起事件中占7起
            
        -   管理员私钥被盗、热钱包私钥被盗是最主要的原因
            
    -   DeFi漏洞越来越深入
        
        -   漏洞少了，但是危害越来越大
            
        -   攻击者利用AI技术挖掘智能合约漏洞的能力正在不断增强
            
    -   国家级黑客的“业绩”巅峰：2025年，朝鲜黑客组织（如Lazarus Group）盗取的资金创下朝鲜通过网络攻击获取资产的历史新高。朝鲜黑客的攻击模式在2025年完成了深度进化：
        
        -   社会工程
            
        -   精准猎杀
            
        -   洗钱工业化
            
2.  **广撒网攻击**——**Web3新手应多关注。**最高发的三种类型：
    

-   私钥窃取
    
-   钓鱼攻击
    
    -   随着 AI 技术的普及， 钓鱼攻击变得更加难以辨别
        
    -   钓鱼内容往往跟你近期关注的事情紧密相关
        
-   Rug Token骗局：类似资金盘，貔貅盘的欺诈项目
    
    -   呈现出职业化和团伙化的趋势
        

## 新型攻击手法

几种典型案例：

-   Bybit的多签前端篡改攻击
    
-   UXLINK的AI深伪社工攻击
    
-   Balancer的智能合约计算精度漏洞
    
-   EIP-7702新型钓鱼
    
-   软件供应链攻击
    
-   AI深伪社会工程等新技术骗局
    

## 安全建议

-   **对用户**：养成"不点、不签、不装、不转"的习惯，使用官方渠道下载App，安装安全插件，拒绝盲签，冷热钱包分离。
    
-   **对生态**：在开发阶段采用安全合约模板和AI审计工具，运行阶段集成安全API和透明化锁仓，建立快速应急响应机制。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->












# Web3 运行原理 — 讲座笔记

## 一、钱包、私钥和个人主权

### 核心概念

| 概念 | 说明 |
| --- | --- |
| 私钥 | 你的「终极签名印章」，谁拥有谁就能控制资产 |
| 助记词 | 私钥的可读备份；助记词 -> 私钥（1对多派生） |
| 公钥 | 通过私钥算出，公开身份证，用于验证签名；私钥 -> 公钥（1对1） |
| 地址 | 公钥截取后的字符串，公开收款号 |

### 安全原则（必须牢记）

-   助记词/私钥：**不截图、不网盘、不发人、不复制到不可信环境**
    
-   剪贴板是高风险区（恶意软件会读取）
    
-   私钥丢了 = 永远丢了，无法重置
    
-   大部分资产被盗不是链被攻破，而是**私钥泄露或授权被钓鱼**
    

### 社会学意义

> 任何人都可以随机创建私钥 → 立刻拥有一个**无需许可**的账户与资产权利

对比传统金融：开银行账户需要身份、审批、地域、制度。而私钥是密码学提供的「可验证的个人主权」。

* * *

## 二、交易与签名

### 交易的组成

```
交易 = 你要做的事 + 手续费 + 防重放序号
```

| 组成部分 | 作用 |
| --- | --- |
| 你要做的事 | 转账、调用合约、投票等 |
| 手续费Gas Fee | 为网络资源付费，激励验证者 |
| 防重放序号Nonce | 避免同一笔交易被重复执行 |

### 钱包做了什么

1.  组装交易内容
    
2.  用私钥签名（证明是你授权）
    
3.  广播到区块链网络
    

### 数字签名的核心

-   你用私钥签名一段消息
    
-   任何人都可以用你的地址验签
    
-   但任何人都**无法伪造**你的签名（除非拿到私钥）
    

### Gas Fee 的三层作用

1.  **防垃圾交易**：提高作恶成本
    
2.  **激励机制**：激励打包者/验证者提供算力
    
3.  **经济闭环**：资源使用者付费 → 网络可持续运转
    

* * *

## 三、区块链网络运行

### 交易的完整生命周期

```
Wallet（签名）→ RPC/Node（传播）→ Mempool（排队）→ Builder/Validator（挑选）→ Block（落盘）→ Explorer（可查）
```

### 为什么「不可篡改需要时间」

-   区块像账本新一页，会引用上一页的指纹（hash）
    
-   区块越往后叠，历史被推翻的成本越高
    
-   PoS 下存在「最终确认finality」：约 12-13 分钟达到稳定状态
    

### 共识机制对比

|   | PoW（工作量证明） | PoS（权益证明） |
| --- | --- | --- |
| 代表 | BTC | ETH |
| 原理 | 算力竞争写账 | 质押 + 随机选人写账 |
| 类比 | 解一道很难但答案好验的题 | 押保证金参加抽签当记账员 |
| 能耗 | 高 | 低 |
| 惩罚 | 浪费算力 | 罚没押金 |

### 钱包、RPC、节点的关系

```
钱包 → 连接 RPC（API）→ RPC 背后是节点 → 节点组成网络
```

⚠️ **RPC 往往是「中心化入口风险点」**

* * *

## 四、智能合约

### 本质

> 智能合约 = 区块链账本里的「可执行代码」

-   在 EVM（虚拟机）里运行
    
-   交易触发执行 → 改变链上状态
    
-   写进区块链：具备「难以篡改、可追溯」的特性
    

### 社会学意义：Code is Law

| 特点 | 说明 |
| --- | --- |
| 规则可验证、按代码执行 | 任何人都能检查规则与执行历史 |
| 部署后难以更改 | 减少“临时改规则”的空间 |
| 减少中介与摩擦 | 把「信任人/机构」压缩为「信任代码 + 共识 + 审计」 |

**例子（交换的最小模型）**：A 把 NFT 存入合约 → B 转账进合约 → 合约自动完成交换（按写死的规则执行）

* * *

## 五、区块链协议如何升级

### 以太坊的升级路径（EIP 流程）

```
讨论（Magicians 论坛）→ 形成文档（EIPs）→ 进入升级（每年 1-2 次硬分叉）
```

**关键点**：不是某公司拍板，是**社区协作推进**

### 节点客户端多样性

-   节点软件不止一种：执行层客户端 + 共识层客户端
    
-   多样性越高 → 越不怕单一软件 bug / 分叉风险
    
-   去中心化不仅是「节点多」，还包括「实现多样」
    
-   以太坊自上线以来，**从未宕机**
    

* * *

## 六、Web3 关键特性总结

| 特性 | 说明 |
| --- | --- |
| 去中心化 | 钱包创建高度去中心化；交易广播可能中心化（RPC 入口）；节点越分散越安全；客户端越多样越稳（减少单点软件风险） |
| 无许可 | 任何人都可以读/写网络（写入需要 gas） |
| 抗审查 | 节点全球分布，入口可替换（钱包/前端/RPC 都可换） |
| 开放开源 | 客户端开源，交易记录公开可查询 |
| 隐私 | 现状是公开账本 + 伪匿名；可通过关联分析追踪行为图谱；ZK 等隐私方案仍在发展 |

* * *

## 七、总结

### 技术层面一句话

> Web3 就是：用**私钥签名**证明你是谁，用**共识网络**保证账本可信，用**智能合约**让规则自动执行。

### 跨学科视角

| 学科 | Web3 中的体现 |
| --- | --- |
| 社会学 | 去中心化治理与共识形成 |
| 经济学 | 激励设计保证安全与可持续（Gas、质押、惩罚） |
| 密码学 | 签名、哈希、ZK 提供可信基础 |

### 技术之外的意义

**权力的重新分配**：

-   数字资产与权利自我控制
    
-   无许可
    
-   抗审查
    
-   公开可信
    
-   去中间商
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->













# **行业赛道全览笔记**

## 一、DeFi（去中心化金融）

基于区块链技术建立的金融体系，目标是提供不依赖传统银行或金融中介的服务，让每个人都可以自由参与。

### 1\. Uniswap - 去中心化交易所

-   使用 AMM（自动做市商）模式和恒定乘积公式 x × y = k
    
    -   交易前后，货币 x 和货币 y 的数量乘积保持固定不变
        
    -   流动性提供者（LP）通过向池子中存入 x 和 y 提供流动性，赚取交易手续费
        
-   思考和扩展查询
    
    -   Q1：池子中原始币对比例决定了相对价值，很重要，是由谁决定的？
        
        -   A1：第一个创建池子的人：任何人都可以创建新池子，创建时存入的两种代币数量就决定了初始价格。虽然技术上自由定价，经济上，错误定价=给套利者送钱，池子价格总是很快趋近于市场公允价格。
            
    -   Q2：k 保持常数的话，其他LP怎么存/取钱？是否按照当下比例存/取，然后更新 k 值？
        
        -   A2：交易时：x \* y = k（k 恒定，价格变化）。 存/取钱时：按比例存/取，k 变大/小。
            

-   Q3：每个币对只有一个池子么？还是有多个池子，用户自行选择汇率合适的进行交易？
    
    -   A3：Uniswap V2中，每个币对一个池子，手续费固定；Uniswap V3中，每个币对可以有多个池子，手续费4个档位。其他方面对比：
        
        |   | V2 | V3 |
        | --- | --- | --- |
        | 池子数量 | 每个币对 1 个池子 | 每个币对最多 4 个池子（按手续费区分） |
        | 手续费 | 固定 0.3% | 4 档可选：0.01%、0.05%、0.3%、1% |
        | 流动性分布 | 全价格范围（0 到 ∞） | LP 可自定义价格区间 |
        | 资金效率 | 低（大部分资金闲置） | 高（集中在活跃价格区间） |
        | 存入方式 | 必须按当前比例存入两种币 | 取决于区间：可能双币、可能单币 |
        | 收益分配 | 所有 LP 按份额均分 | 只有价格在区间内的 LP 获得手续费 |
        

### 2\. Compound - 借贷协议

-   存入资产获得 cToken，赚取利息
    
-   借款需要**超额抵押**
    
-   动态利率，根据市场供需调整
    
-   抵押物价值下跌过多会触发**强制清算**
    

### 3\. MakerDAO（现更名为 Sky）- 稳定币系统

-   超额抵押资产生成 DAI（与美元挂钩的稳定币）
    
-   通过稳定费率调节 DAI 供需
    
-   DAI 已升级为 USDS，MKR 升级为 SKY
    

* * *

## 二、NFT（非同质化代币）

-   通过区块链解决数字资产的**唯一性和所有权**问题
    
-   智能合约支持自动版税分成
    
-   **CryptoPunks**：NFT 先驱，10000 个像素头像
    
-   **OpenSea**：最大的 NFT 交易平台
    

* * *

## 三、DAO（去中心化自治组织）

-   通过智能合约和社区投票治理，无需管理层
    
-   **Nouns DAO**：每天拍卖一个 NFT，收益由持有者投票决定用途
    
-   **LXDAO**：支持 Web3 公共物品建设
    
-   **ConstitutionDAO**：众筹 4700 万美元竞拍美国宪法（失败但展示了 DAO 潜力）
    

* * *

## 四、MEME 币

-   基于网络文化的代币，缺乏技术价值，靠社区共识
    
-   **DOGE**：开山鼻祖，受马斯克推动
    
-   **PEPE**：社区驱动
    
-   **风险极高**，价格波动剧烈，需谨慎
    

* * *

## 五、交叉创新

| 领域 | 代表应用 |
| --- | --- |
| DeFi + NFT | NFT 抵押借贷（BendDAO） |
| DAO + MEME | 社区代币治理（FriendTech） |
| AI + DeFi | 智能投资策略（Yearn Finance） |
| Web3 + 乡建 | 南塘 DAO（中国乡村实践） |

* * *

## 六、2025 年新趋势

1.  **Intent-Based 交易**：用户表达目标，系统自动找最优路径
    
2.  **账户抽象（AA）**：无需 ETH 即可交易，支持社交恢复
    
3.  **模块化区块链**：执行、共识、数据可用性分离
    
4.  **AI + Web3 融合**：去中心化 AI 训练、AI 代理
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->














# 区块链基础概念笔记

## **区块链**组成部分及特点

1.  **去中心化的网络和区块链**
    
    -   区块链：一条依序串联起各个区块的链，每个区块包含交易记录等信息及上一个区块的摘要（哈希）
        
    -   分布式网络：一个区块链网络中有很多节点（矿机），通常分布在全球，共同记账。每个节点各自保存一份账本，内容完全一样
        
    -   特点：
        
        -   不可篡改：无法改变历史数据。公共账本，要改一块，后边的区块也都需要修改；其他节点的账本也要修改，而这些节点通常分布在全球各地，不现实
            
        -   公开透明、匿名：区块链上的信息全部公开透明。“顺藤摸瓜”可查询钱包余额，但不知晓主人身份
            
        -   快速交易：金额、物理位置不构成限制，远比传统跨国汇款快速便捷
            
        -   去中心化：点对点，不依赖第三方机构
            
2.  **维持网络运行的代币激励** <—为什么有人愿意提供服务
    
    -   节点可以得到奖励
        
        -   矿工获得代币作为“工资”
            
        -   不同网络节点服务提供商可得到不同的代币奖励（eg. BTC, ETH, SOL)
            
        -   交易、转账等活动均需支付代币
            
        -   若没有代币又想使用这个区块链网络服务，需进行代币间交换或法币交换
            
    -   比特币BTC
        
        -   价值来源
            
            -   货币属性：供应量有限，可自由转账
                
            -   区块链特性：账户匿名、交易公开透明、不可篡改、完全在虚拟网络中。交易便捷，尤其是跨境转账等场景
                
        -   缺点——新技术优化中
            
            -   难追踪、限制，常被黑产利用
                
            -   打包耗时长，影响交易实时性
                
            -   每个区块存储数据有限
                

## 区块链生态系统运行流程

用户发起交易 -> 交易广播 -> 节点验证 -> 打包成块 -> 上链 -> 奖励发放

## 公链 vs 私链 vs 联盟链

### 公链（Public Blockchain） = 公共公园

-   特点：
    
    -   自由进出，成为节点无审核
        
    -   数据、活动公开，所有人可见
        
    -   决策去中心化，由投票（共识）决定
        
-   缺点：
    
    -   决策效率低
        
    -   运维成本高
        

### 联盟链（Consortium Blockchain） = 多公司联合的董事会

-   特点：
    
    -   受邀/申请成为节点
        
    -   核心成员得以成为决策者—可读可写，普通成员为观察者—只读不写
        
    -   数据半公开，非联盟成员不可访问
        
    -   联合决策，由成员投票表决
        
-   优缺点：
    
    -   效率较公链高
        
    -   隐私比公链好
        
    -   治理和准入方面不如私链灵活
        

### 私链（Private Blockchain） = 私人俱乐部

-   特点：
    
    -   严格审批入会
        
    -   固定成员，权限由老板决定
        
    -   数据完全私有
        
    -   决策老板说了算
        
-   优缺点
    
    -   效率极高——人少
        
    -   隐私极强
        
    -   缺乏公链的透明性
        

## Web2 vs Web3

传统Web2：数据存储在中心化服务器，用户对自己的数据没有所有权

Web3：数据存储在去中心化网络，用户对自己的数据有所有权

# 以太坊概览笔记

## 以太坊对比比特币

### 比特币：

-   “区块链1.0”，去中心化**货币**——专注于货币属性，作为“数字黄金”存储价值
    
-   图灵不完备，只支持简单逻辑
    

### 以太坊：

-   “区块链2.0”，去中心化**平台**——“全球计算机”
    
-   图灵完备，可开发复杂的**智能合约**——生态
    

## 重要里程碑

### The Merge（2022年9月15日完成）

将以太坊PoW链（执行层：处理交易、智能合约、维护状态）与Beacon Chain（共识层：管理验证者、确定区块顺序）合并，然后转变成为ETH PoS链——共识机制从高能耗PoW转变为低能耗PoS。

### EIP-4844（2024 年完成）

让 L2 更便宜，普通人用得起。

### 数据分片（2025-2026 年）

进一步降低 L2 成本，提升整体扩展性。

## 多层架构

### Layer 1（L1）

1.  以太坊主网：执行层+共识层
    
    -   核心区块链，负责最终安全性与共识
        
2.  以太坊虚拟机EVM（Ethereum Virtual Machine）
    
    -   以太坊虚拟机，执行智能合约代码
        
3.  系统账户：外部账户（EOA）与合约账户（CA）共同构成网络基础
    

### Layer 2（L2）

-   建立在主网之上的扩容方案，把交易放到链下处理，最终把结果提交回主网。
    

### 侧链（Sidechains）

-   独立运行的链，有自己的共识机制和验证者，通过桥接与主网交互
    
    -   安全性与以太坊主网相互独立，但桥是个薄弱环节
        

## 生态分层架构

1.  **应用层（Application Layer）**：用户直接交互的应用和界面
    
2.  **协议层（Protocol Layer）**：以太坊的核心基础设施
    
3.  **扩展层（Scaling Layer）**：提升性能和降低成本的解决方案
    

## 核心机制

### 账户系统：你的数字身份

1.  私钥控制的 **外部账户（EOA）** ：由一对密钥生成
    
    -   私钥严格保密
        
    -   公钥通过加密算法生成唯一一个地址，可以分享给public进行转账等
        
2.  由智能合约代码控制的 **合约账户（CA）**
    
    -   不能主动发起交易，只能通过EOA触发
        

### Gas 模型：交易的燃料费

**存在目的：**

1.  激励矿工
    
2.  防止资源滥用
    

**计算模式：**

-   总费用 = Gas Price × Gas Limit
    
-   实际支付费用Transaction Fee = Gas Price x Gas Usage，剩余返还
    
-   Gas Price原本全部流向矿工，EIP-1559升级后，分为：
    
    -   基础费用（Base Fee）：每个区块都会有，自动计算。大部分被销毁（Burnt）来帮助 ETH 通缩
        
    -   小费（Tip）：额外加的钱鼓励矿工优先处理
        

### 以太坊虚拟机EVM（Ethereum Virtual Machine）：代码的执行引擎

-   专门用来**运行智能合约的虚拟计算机**
    
-   运行在每个节点上，确保整个网络在处理代码时，**结果都一致、可信任**
    
-   **EVM 的核心特点：**
    
    -   **图灵完备**：可以执行各种复杂逻辑
        
    -   **全球同步**：每个节点都会自己执行一遍合约代码，保证结果一样
        
    -   **隔离安全**：EVM 把合约“关”在一个小房间里运行，不允许它乱访问用户的数据和网络，保护隐私和安全
        

## 一般流程

1.  **用户通过 EOA 发起交易**
    
2.  **交易附带 Gas 参数**——矿工 / 验证者选择打包。
    
3.  **EVM 执行合约代码**——修改存储（如更新 NFT 归属）。
    
4.  **Gas 费用按 Gas Usage × Gas Price 扣除**——保障资源合理使用。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
