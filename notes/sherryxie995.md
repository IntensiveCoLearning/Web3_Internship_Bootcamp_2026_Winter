---
timezone: UTC+8
---

# NotFound404

**GitHub ID:** sherryxie995

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->
# **区块链的演变**

每个主要的区块链都代表了不同的工程决策和权衡，这些决策和权衡受我们所了解的基本约束所影响。

## **Bitcoin**

比特币并不是为了成为通用计算机而设计的；它的目标是解决一个特定的问题：创建一种无需银行或政府运作的数字货币。比特币的每一个设计决策都反映了这一单一目标。

### **共识**

比特币使用了中本聪设计的原始工作量证明（Proof of Work）实现。矿工们竞争寻找一个随机数（nonce），当与区块数据一起哈希时，会生成一个以特定数量的零开头的哈希值。

网络每隔 2,016 个区块（大约两周）会自动调整难度，以保持平均区块时间为 10 分钟。

这个时间设定并非随意。更快的区块会导致网络分裂，矿工在不同的区块链版本上工作。而更慢的区块会使交易变得非常缓慢。

### **UTXO 模型**

比特币不像银行那样追踪账户余额。相反，它通过 UTXO（未花费交易输出）来追踪单个“币”，其功能类似于实体现金。

想象一下，您的钱包里有三张 20 美元的钞票，您想买一件价值 35 美元的商品。您无法拆分一张 20 美元的钞票，因此您给收银员两张钞票（40 美元），并收到 5 美元的找零。比特币的运作方式完全相同：

假设 Alice 通过三笔独立的交易收到了比特币：

-   UTXO #1: 0.5 BTC（来自 Bob）
    
-   UTXO #2: 0.3 BTC（来自 Carol）
    
-   UTXO #3: 0.8 BTC（来自 Dave）
    

Alice 的 "余额" 是 1.6 BTC，但并没有一个单一账户存储这个数字。相反，区块链记录了 Alice 可以使用的三个独立的 UTXO。

当 Alice 想要发送 1.0 BTC 给 Eve 时，她需要：

-   选择总额至少为 1.0 BTC 的 UTXO（她选择了 UTXO #1 和 #3，总计 1.3 BTC）
    
-   创建一笔交易，将 1.0 BTC 发送给 Eve，并将 0.3 BTC 作为找零返回给自己
    
-   使用她的私钥签署交易，以证明她拥有输入的 UTXO
    

该交易消耗了 UTXO #1 和 #3（它们现在被 "花费" 了），并创建了两个新的 UTXO：一个给 Eve，另一个找零 UTXO 给 Alice。

这种模型实现了强大的功能：

-   并行处理：由于每个 UTXO 只能被花费一次，使用不同 UTXO 的交易不会发生冲突。矿工可以同时验证数千笔交易，只要每笔交易引用的 UTXO 不同，就无需担心双重花费。
    
-   隐私：没有一个全局账户会显示你的总余额。你的比特币分散在多个 UTXO 中，使观察者更难确定你的总财富。每个 UTXO 可能与不同的地址相关联，进一步模糊了所有权模式。
    
-   简单验证：每笔交易可以通过独立验证输入的 UTXO 是否存在且未被花费，以及数字签名是否有效来完成。你无需维护复杂的账户状态，也无需担心交易顺序对余额的影响。
    
-   原子操作：交易要么完全成功（消耗所有输入并创建所有输出），要么完全失败。不存在部分状态的风险，例如部分资金被扣除但未转移的情况。
    

## **Ethereum**

比特币解决了数字支付的问题，而 Vitalik Buterin 发现了一个更大的机会：如果区块链不仅能转账，还能运行任何程序会怎样？这一愿景促成了以太坊的诞生：第一个通用的区块链计算机。

比特币的 UTXO 模型在支付方面表现完美，但对于需要持久状态、复杂逻辑以及不同程序之间可组合性的复杂应用来说显得笨拙。

### **共识机制**

以太坊最初使用工作量证明（Proof of Work），但在 2022 年通过“合并”（The Merge）切换到了权益证明（Proof of Stake）。这一转变在保持安全性的同时带来了重要的优势：

-   数学终局性：大约 13 分钟后，交易变得数学上不可逆
    
-   能源效率：不再需要大量电力消耗
    
-   未来升级：权益证明支持分片技术，将网络分成并行链以提高吞吐量
    

### **账户模型**

以太坊用更为熟悉的基于账户的余额系统取代了比特币的 UTXO 系统，从而实现了：

-   智能合约：驻留在区块链上的程序，能够维护自己的状态
    
-   外部账户：类似于比特币地址的用户控制账户
    
-   合约间调用：智能合约可以无缝地相互交互
    

在以太坊中，有两种类型的账户：

-   外部拥有账户（EOA）：由用户通过私钥控制，类似于比特币地址。它们有余额并可以发送交易。
    
-   合约账户：由代码控制，而非私钥。它们既有余额，也存储可执行代码和持久数据。
    

因此，在以太坊上，智能合约是驻留在区块链上的自治程序，能够维护自己的状态，并可以被其他账户调用。

这种账户模型支持持久状态——跨交易存活的数据。智能合约可以记住先前交互的信息，维护复杂的数据结构，并随着时间推移而演变。

这使得像借贷协议、治理系统和复杂金融工具这样的应用成为可能。

所有这些都得益于以太坊虚拟机 (EVM)，它运行在每个节点上，使区块链具有可编程性。EVM 定义了可以运行的程序、它们的执行方式以及它们消耗的资源。

## **Solana**

以太坊证明了区块链可以支持通用计算，但这一成功也暴露了可扩展性限制。随着去中心化应用的普及，网络拥堵导致了高昂的交易费用和较慢的确认时间。

这些限制源于以太坊设计中的基本架构决策，而 Solana 试图通过从基础原则重新设计核心区块链组件的架构创新来解决这些问题。

### **共识机制**

Solana 使用权益证明 (Proof of Stake)，但增加了一项关键创新：历史证明 (Proof of History)。Solana 不需要等待事件发生时间的共识，而是创建了一个加密时钟，在共识之前为所有交易加上时间戳，使验证者能够并行处理交易，因为他们已经知道正确的顺序。

这种时间排序使得共识速度更快：Solana 每 400 毫秒生成一个区块，而以太坊需要 12 秒。

### **Solana 虚拟机**

EVM 按顺序处理交易，因为智能合约共享全局状态：当一个合约修改共享数据时，所有其他交易必须等待。这在网络使用量增长时会造成瓶颈。

Solana 从根本上重新思考了这一架构：

-   无状态程序：与以太坊智能合约内部存储数据不同，Solana 的程序是无状态的。所有数据存储在独立的账户中，程序从中读取和写入。这种分离使得并行处理成为可能，因为程序不需要争夺共享状态。
    
-   交易并行化：Solana 的交易必须提前声明将读取和修改哪些账户。运行时可以同时在多个 CPU 核心上执行不冲突的交易。如果交易 A 修改账户 X，而交易 B 修改账户 Y，它们可以并行运行。
    
-   优化执行：SVM 使用基于寄存器的架构，而不是 EVM 的基于堆栈的方式，从而减少了计算过程中数据移动的开销。程序编译为本地机器码，而不是字节码，消除了解释的开销。
    
-   可预测的成本：与以太坊多年前确定的固定 Gas 价格不同，Solana 使用动态费用市场，交易成本反映了实际的网络需求和消耗的计算资源。
    

Solana 的结果是能够处理每秒超过 5,000 笔交易（TPS），而以太坊仅为 15 TPS，同时保持亚秒级的最终确认时间和去中心化。这种性能得益于架构设计上的决策，优先采用并行执行，而非从单线程计算继承的顺序处理模型。

来源：[区块链的演变](https://learn.blueshift.gg/zh-CN/paths/solana-developer-foundations/courses/introduction-to-blockchain-and-solana/blockchain-evolution)
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->

## **共识机制**

计算机科学家实际上在 1980 年代通过数学方法解决了拜占庭将军问题，证明了要容忍 f 个叛徒，您至少需要 `3f+1` 个参与者。

考虑一个经典案例：四个将军中有一个叛徒。如果指挥将军是叛徒，他可能会告诉两个将军“进攻”，告诉另一个将军“撤退”。如果将军们仅仅遵循命令，计划将失败。解决方案需要额外一轮通信，在这一轮中，所有将军相互报告他们收到的命令。

这额外的通信轮次揭示了指挥官的欺骗行为。每个忠诚的将军都会看到“进攻”是多数命令（2 比 1），并据此行动。因为所有忠诚的将军得出了相同的结论，达成了共识，叛徒被击败。

背后的数学解决方案是可行的，但不实用：

-   您必须提前确切知道所有参与者是谁
    
-   每对参与者之间需要多轮消息传递
    
-   通信复杂性呈指数增长
    
-   在无许可系统中，攻击者可以创建无限的虚假身份
    

为了解决这个问题，区块链不再计算身份，而是计算难以伪造的东西：计算工作量或质押的资金。

### **工作量证明 (POW)**

在 POW 系统中，为了提议接下来应该发生什么，您必须证明您完成了昂贵的计算工作：

-   矿工将待处理的交易收集到一个“区块”中
    
-   矿工必须找到一个随机数（称为“随机数”），当与区块数据结合并进行哈希运算时，产生以多个零开头的结果
    
-   第一个找到该数字的矿工将其解决方案广播到网络
    
-   其他参与者可以立即验证解决方案的正确性并接受新区块
    

这是可行的，因为找到随机数可能需要数万亿次随机猜测，但验证解决方案只需几毫秒。

每个区块还引用了前一个区块的哈希值，从而形成了一条链。要篡改历史，攻击者需要重新完成所有后续的计算工作，而诚实的矿工会继续扩展真实的链。

安全假设是攻击的电力成本高于攻击者可能获得的收益。

### **权益证明（Proof of Stake）**

在 POS 系统中，与其消耗电力，参与者将自己的资金置于风险之中：

-   参与者将加密货币代币锁定作为抵押
    
-   协议根据其权益随机选择验证者提议区块
    
-   被选中的验证者提议区块，其他验证者投票接受或拒绝
    
-   诚实行为会获得奖励；不诚实行为会导致“削减”，即部分质押的代币被没收或罚没。具体的惩罚因网络和违规程度而异。
    

这是可行的，因为验证者有“利益相关”。攻击网络会破坏其质押代币的价值（通过削减）。此外，与工作量证明不同，权益证明可以提供经济终局性。一旦区块被绝大多数验证者最终确定，攻击者要想逆转它，就需要证明性地销毁大量资本，使得逆转成本高得无法承受。

### **区块链三难问题**

正如分布式系统面临 CAP 定理，区块链也面临自身的不可能权衡。区块链三难问题指出，区块链共识最多只能优化以下三个属性中的两个：

-   安全性：抵抗攻击和审查的能力
    
-   可扩展性：高交易吞吐量
    
-   去中心化：没有单一控制点
    

比特币选择了安全性和去中心化，而不是可扩展性。像 Visa 这样的传统支付系统选择了可扩展性和安全性，而不是去中心化。当前的挑战是找到同时实现这三者的方法。

## **Cryptographic Primitives**

共识机制解决了“谁来决定”的问题，但我们如何确保数据本身是可信的呢？

这就是密码学原语的作用所在：这些是经过数十年验证的数学工具。

区块链依赖于三种关键的密码学工具，它们协同工作以创建一个不可篡改且可验证的系统：

### **哈希函数**

想象一下，你需要验证一份庞大的文档没有被篡改，但你只能发送一小段信息来证明。这正是哈希函数所实现的功能。

哈希函数可以将任何输入（无论是“Hello”这个词、莎士比亚的全集，还是包含数千笔交易的区块）转换为固定大小的输出，这个输出是一个独特的数字指纹。

哈希函数具有三个关键属性：

-   **确定性：** 相同的输入总是会产生相同的输出。
    
-   **不可逆性：** 该函数在一个方向上易于计算，但在反方向上计算几乎不可能。给定一个哈希值，你无法轻易找到原始输入，除非通过暴力破解或查找表。
    
-   **雪崩效应：** 输入的微小变化（例如将一个字母大写）会导致完全不同的输出哈希值。虽然从任何输入计算哈希值是很简单的，但逆向过程在计算上是不可能的。给定一个哈希值，你无法推断出原始输入是什么，因为对于一个安全的哈希函数来说，这需要比宇宙的年龄还长的时间。
    
    在区块链中，哈希用于确保数据的完整性。每个区块都包含前一个区块的哈希值，从而形成一个不可破坏的链条。如果有人试图修改上周的一笔交易，他们会改变该区块的哈希值。由于下一个区块引用了旧的哈希值，这种修改会破坏链条。要修复这一点，他们需要重新计算每个后续区块的哈希值，同时网络还在不断添加新的区块，这几乎是一个不可能完成的追赶游戏。
    
    ### **数字签名**
    
    传统的身份验证依赖于共享的秘密信息（如密码），但区块链在没有可信机构或安全渠道来共享秘密信息的情况下运行。因此，它们使用数字签名，这种方法可以在不泄露任何秘密信息的情况下实现身份验证。
    
    数字签名使用非对称加密技术，这种技术依赖于一种数学关系：在一个方向上计算很容易，但几乎不可能反向计算。当您创建数字签名时，您会生成两个数学相关的数字，称为私钥和公钥；私钥必须保密，而公钥可以自由共享。
    
    -   私钥可用于为特定交易创建数字签名。
        
    -   签名是您私钥和确切交易内容的唯一组合。
        
    -   任何人都可以使用您的公钥验证签名只能由拥有相应私钥的人创建。
        
    
    没有您的私钥，即使拥有数百万个以前的签名，也无法计算出有效的签名。为了防止攻击者重放旧交易，每个签名必须包含一段唯一的数据，通常是一个简单的计数器，称为“随机数”（nonce），以确保每个签名都是唯一的。
    
    这就创造了“不可抵赖性”：一旦您签署了一笔交易，就无法声称您没有授权它。数学证明是无可辩驳的。
    
    在区块链中，这就是钱包的工作原理。您的“钱包”并不存储加密货币；这些币作为区块链上的条目存在。相反，钱包存储私钥，并帮助创建数字签名以证明您可以使用这些币。它们本质上是数字签名管理器。
    
    ### **默克尔树**
    
    如何在包含数千笔交易的区块中验证特定交易的存在，而无需下载整个区块？
    
    默克尔树以二叉树的形式组织数据，其中每个叶子代表一笔交易，每个父节点包含其两个子节点的哈希值。这种结构一直延续到树的顶部，最终形成一个代表整个数据集的根哈希值。
    
    因此，要证明树中存在任何交易，您只需要该交易和“默克尔路径”：用于重建根的兄弟节点哈希值。这意味着对于包含一百万笔交易的树，您只需要大约 20 个哈希值即可证明包含性。
    
    在区块链中，默克尔树使得仅凭几千字节的证明就能极其轻松地验证交易。安全性保证保持不变：如果默克尔路径验证正确，您可以在数学上确定该交易已包含在该区块中。
    
    ## **创建一个无需信任的系统**
    
    共识和加密原语共同作用，创建了一个“无需信任”的系统。历史上首次，信任被放在数学而非人身上：
    
    -   哈希函数确保任何对历史数据的篡改都会立即显现。
        
    -   数字签名在无需任何可信中介验证身份的情况下证明授权。
        
    -   默克尔树使得无需下载大量数据即可验证复杂声明成为可能。
        
    
    当结合共识机制时，这些工具创建了一个系统，每个参与者都可以仅使用自己的计算资源独立验证系统的整个历史记录。无需可信权威机构，无需共享秘密，也没有中心化的故障点。
    
    这就是区块链代表如此根本性变革的原因。传统系统通过控制访问和限制参与来实现安全性。而区块链通过使验证变得廉价且普遍，同时使欺诈变得昂贵且显而易见来实现安全性。
    
    理解这些基础要素至关重要，因为它们定义了区块链的能力和局限性。它们解释了为什么区块链交易是不可逆的（设计上使得逆转已完成交易的经济成本极高），为什么区块链系统可以在没有中心化权威的情况下运行（每个人都可以独立验证所有内容），以及为什么即使完全向公众开放参与，系统仍然保持安全。
    

来源：[区块链基础](https://learn.blueshift.gg/zh-CN/paths/solana-developer-foundations/courses/introduction-to-blockchain-and-solana/blockchain-fundamentals)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


区块链是一种去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据。每条链由一系列按照时间顺序相连的“区块”组成，每个区块内部包含了多笔交易数据及元数据，确保了数据记录的完整性与可追溯性。

### 分布式系统

大多数人认为，从一台计算机扩展到多台计算机只是“更多相同的事情”。这就像认为协调一个人和协调分布在不同时区、可能并不总是能联系上的一千人是一样的。

### CAP定理

1999 年，计算机科学家 Eric Brewer 提出了 CAP 定理，该定理指出任何分布式系统最多只能保证以下三个属性中的两个：

一致性 (C)：所有服务器始终显示相同的数据。当 Alice 的余额在服务器 A 上发生变化时，其他所有服务器会立即反映这一变化。

可用性 (A)：即使服务器崩溃，系统也能继续工作。如果服务器 A 宕机，用户仍然可以通过服务器 B 和 C 访问账户。

分区容错性 (P)：系统能够在网络故障将服务器分隔成孤立组时继续运行。

我们必须保证分区容错性，因为网络分区是不可避免的：电缆会被切断，路由器会失效，数据中心会断电。这使我们需要在一致性和可用性之间做出选择。

传统银行系统通常选择一致性 + 分区容错性（CP 系统）。它们宁愿关闭系统也不愿显示错误的账户余额。

社交媒体平台通常选择可用性 + 分区容错性（AP 系统）。它们宁愿让你发布内容（即使朋友无法立即看到）也不愿完全阻止你发布。

### **拜占庭将军问题**

除了 CAP 定理，大多数分布式系统假设参与者是诚实的：他们可能会失败或断开连接，但不会主动欺骗彼此。当参与者可能是恶意的时，这一假设就不成立了。

计算机科学家在 1982 年提出的拜占庭将军问题，说明了这一挑战：

你是一名拜占庭将军，计划攻打一座设防的城市。你有几位盟军将军分布在城市周围，每位将军指挥着自己的军队。为了成功，你必须协调同时发起攻击。如果有些人进攻而另一些人撤退，进攻的部队将被全歼。

你只能通过信使进行通信，而一些将军可能是叛徒，他们希望攻击失败。叛徒可能会：

-   向一些将军发送“进攻”消息，而向另一些将军发送“撤退”消息
    
-   修改忠诚将军传递的消息
    
-   与其他叛徒协调以最大化混乱
    

当你无法区分忠诚的将军和叛徒，也无法信任通信渠道时，如何就“进攻”或“撤退”达成共识？

这似乎是不可能的。几十年来，计算机科学家认为无法构建一个同时具备以下特性的系统：

-   拜占庭容错（即使有恶意参与者也能正常工作）
    
-   无许可（任何人都可以无需批准加入）
    
-   去中心化（没有中央权威）
    

然而在 2008 年，一个自称中本聪的人证明了他们是错的。

### **比特币：第一个区块链**

比特币是区块链技术的第一个实际应用。虽然其各个组成部分（如加密哈希、数字签名、点对点网络）在此之前已经存在，但中本聪是第一个将它们结合起来，解决数字货币双重支付问题的人。

区块链，或称为“区块链条”，正如其在最初的比特币[**白皮书**](https://bitcoin.org/bitcoin.pdf)中所描述的那样，最终创建了一个同时具备分布式、拜占庭容错和无许可特性的系统。

这一突破并不是试图确定谁值得信任，而是让撒谎在经济上比说真话更昂贵。工作量证明通过要求参与者消耗真实的计算能量来提出更改实现了这一点。攻击者需要在电力上花费的成本超过他们通过攻击所能获得的收益。

来源：[区块链介绍](https://learn.blueshift.gg/zh-CN/paths/solana-developer-foundations/courses/introduction-to-blockchain-and-solana/introduction)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
