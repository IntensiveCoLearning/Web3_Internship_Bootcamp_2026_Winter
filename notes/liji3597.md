---
timezone: UTC+8
---

# liji3597

**GitHub ID:** liji3597

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->
# **Day 2：EVM 指令集与 Gas 机制（学习笔记）**

## 1）把 EVM 当作“按指令计费 / 基于堆栈”的虚拟 CPU

**EVM 可以理解为一个堆栈机（stack machine）**：大多数运算都在栈顶完成（push / pop / op）。

Gas 机制可以理解为**“按指令与资源消耗计费”**：

\- 指令执行要花 Gas

\- 读写存储（storage）更贵

\- 超出 Gas 限额就会\*\*强制终止并回滚\*\*

\---

## **2）理论映射（嵌入式对照）**

\- **ARM Cortex-M：寄存器架构（register-based）**

\- **EVM：堆栈架构（stack-based）**

\> 嵌入式里你经常“螺蛳壳内做道场”，RAM 紧张`uint8_t` / `uint16_t` 用得多；

\> 但在 Solidity/EVM 里，很多时候更推荐直接用 EVM 原生字长`uint256`（对齐 EVM 256-bit word），避免不必要的类型转换成本和复杂度。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313068628-image.png)

\---

## 3）实践：触发第一个“看门狗复位”（Gas 耗尽）

**目标**：写一个“死循环”，亲眼看见 Gas 如何强行终止程序（类比 WDT Reset）。

\#### 合约代码

\`\`\`solidity

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract GasTest {

uint256 public counter = 0;

// 会触发“看门狗复位”（Gas耗尽）的函数

function foreverLoop() public {

// while(true) 的区块链版本

while (true) {

counter++;

}

}

// 正常函数：用于对比 Gas 消耗

function normalAdd() public {

counter++;

}

}

现象记录

-   `normalAdd()` 能正常给 `counter + 1`
    
-   `foreverLoop()` 调用后 `counter` **不会增加**
    
    -   我在调用 `foreverLoop()` 前后读取 `counter`，发现值完全一样
        
    -   说明：Gas 耗尽后交易失败，**状态被回滚**（increment 也“当没发生过”）
        

进一步观察

-   在 **Compile Details** 里查看 **BYTECODE**：在 opcodes 中能看到大量 `JUMP`
    
-   这个“死循环”本质就是靠 `JUMP` 不断跳转实现
    

* * *

### 4）反思复盘（工程经验固化）

4.1 忌讳无界循环（Unbounded Loop）

永远不要写这种逻辑：

```solidity
for (uint i = 0; i < users.length; i++) { ... }
```

因为一旦 `users.length` 变成 10,000，循环次数可能超过区块可承受的 Gas 上限，导致：

-   交易永远失败
    
-   函数逻辑等价于“永久卡死，再也跑不起来”
    

4.2 嵌入式类比：ISR 里做重活 = 直接把系统拖死

这就像你在中断服务函数（ISR）里塞了一个耗时 1 秒的操作：

-   主循环被打断
    
-   实时性崩掉
    
-   系统看起来“还活着”，其实已经不可用
    

4.3 Check-Effects-Interactions（CEI）与回滚直觉

-   由于以太坊的状态回滚机制：只要最终失败，前面做的状态修改都会撤销
    
-   所以我们不需要担心“改了一半”的脏状态残留问题
    
-   但仍然要坚持 CEI：
    
    -   **Check**：先校验前置条件
        
    -   **Effects**：再更新状态
        
    -   **Interactions**：最后做外部交互（防重入、防意外失败）
        

* * *

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313034569-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313053291-image.png)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->

# **Day 1 学习总结：我开始用“系统工程”理解以太坊**

今天我最大的收获是：

我不再把以太坊当成“转账网络”，而是把它当成一个**分布式状态机**。  
交易也不只是“转钱”，而是一次次**状态变更请求**：我们把请求广播出去，全网验证、排序、执行，然后把结果写进一个所有人都能复算的公共状态。很像做自动化/工作流——看流程怎么跑、日志怎么记、结果能不能重放，而不是某些公司，关键先生一言堂。

**区块链的核心也不只是账本**，更像一套“可验证的协作协议”：  
Web2 靠中心平台、权限和法律背书；Web3 把规则写进合约，用共识+密码学+可重放日志保证一致性。

信任没有消失，只是从“信机构”变成“信过程”，**信任被工程化了**。

**钱包不是存钱的，是控制权**：它本质是**密钥管理+签名器**。余额变化不是“钱包里多了钱”，而是链上状态变了。

我们真正拥有的不是账户，而是私钥这把钥匙。

**安全上我今天记住一句话**：危险的往往不是 value（转多少），而是 data（我们签了什么）。

很多事故不是转账，而是**授权/签名**把权限交出去了。

**Gas 可以理解为付费计算+反滥用**：gasUsed 是实际消耗，gasLimit 是预算上限，失败也会花费，因为执行发生了只是回滚。

最后，**Sepolia 测试网不是玩具**：对我来说最值钱的是端到端闭环和可观测性（hash/receipt/logs/nonce/revert）。

它是主网的预设项，只是币没价值、稳定性可能差一点。

总结一下就是：  
**以太坊=分布式状态机；区块链=可验证协作；钱包=控制权；交易=状态变更；Gas=付费计算；测试网=主网彩排。**

_小狐狸转账钱包的截图_

![屏幕截图 2026-01-12 193830.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232261149-_____2026-01-12_193830.png)

_简单看了老师们写的书（检视阅读），building的欲望越来越强烈了_

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232444538-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232417925-image.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
