---
timezone: UTC+8
---

# liji3597

**GitHub ID:** liji3597

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->
# 第三天 **：Solidity语法与核心数据结构**。

对于C 语言老手来说，学习 Solidity 的语法就像是换了一种方言，大体逻辑是通的，但有几个非常反直觉的“内存陷阱”需要特别注意。

今天的目标是：**编写一个工业级的“传感器数据上链”合约。**

## **理论映射：三大存储空间 (The Data Location)**

在 STM32 中，数据是放在 Flash（只读/持久化）、SRAM（读写/易失）还是寄存器里。 在 Solidity 中，必须**显式声明**变量存储在以下三个区域之一，否则编译器会报错。这是它和 Python/JS 最大的不同。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-14-1768405004145-image.png)

**嵌入式思维转换：**

-   **storage 就是写 Flash。** 它是状态变量的默认位置。永远不要为了临时计算而在 storage 里读写，那会让您的用户破产。
    
-   **memory 就是局部变量。** 在函数内部定义的复杂类型（如结构体、数组）需要加 memory 关键字。
    

## 核心数据结构：Mapping (映射) vs Array

我习惯用 SensorData logs\[100\]（数组）。 但在区块链上，数组非常危险（Gas 消耗随长度线性增加），所以改用为**mapping**。

-   **定义：** mapping(KeyType => ValueType)
    
-   **本质：** 一个巨大的**哈希表 (Hash Table)**。
    
-   **怪癖（与 C 的最大区别）：**
    
    1.  **没有长度： 无法获取 mapping.length。**
        
    2.  **无法遍历： 不能写 for (i in mapping)。必须知道 Key 才能拿到 Value。**
        
    3.  **全空间初始化： 它的逻辑空间包含所有可能的 Key。访问一个从未写入的 Key，不会报错，也不会读到垃圾值，而是返回 全0 (默认值)。**
        

## **代码实战：编写 SensorLogger 合约**

```
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

 

contract SensorLogger {

   

    // --- 1. 数据结构定义 (类似于 struct) ---

    struct SensorData {

        uint8 id;           // 传感器ID (uint8: 0-255)

        uint16 temperature; // 温度 (定点数: 2550 代表 25.50度)

                            // 注意: Solidity 没有 float/double 类型！必须用整数表示。

        uint32 timestamp;   // UNIX 时间戳

        bool isValid;       // 状态标志位

    }

 

    // --- 2. 永久存储区 (Flash / Storage) ---

    // 这是一个哈希表：设备ID (Key) -> 传感器数据 (Value)

    // 'public' 关键字会自动生成一个 getter 函数

    mapping(uint256 => SensorData) public sensors;

 

    // --- 3. 写入函数 (Flash Write) ---

    function updateData(uint256 deviceId, uint16 temp) public {

        // [Check] 简单的参数检查

        require(_deviceId > 0, "Invalid Device ID");

 

        // [Effects] 写入 Storage

        // block.timestamp 是当前区块的时间 (类似于 RTC 时间)

        sensors[_deviceId] = SensorData({

            id: uint8(_deviceId),

            temperature: _temp,

            timestamp: uint32(block.timestamp),

            isValid: true

        });

    }

 

    // --- 4. 读取函数 (Flash Read) ---

    // 'view' 表示只读，不修改状态。

    // 如果是外部(User)直接调用，不消耗 Gas。如果是合约内部调用，消耗极少 Gas。

    function getTemperature(uint256 _deviceId) public view returns (uint16) {

        // 从 Storage 读取数据到 Memory (RAM)

        SensorData memory data = sensors[_deviceId];

       

        // 检查数据是否有效 (类似于检查 Flash 里的 Magic Number)

        if (data.isValid) {

            return data.temperature;

        } else {

            return 0; // 或者抛出错误

        }

    }

}
```

## 部署与实验

**环境选择：** 依然使用 **Remix VM (Cancun)**，速度快。

1.  **Compile (编译): 确保绿色对勾。**
    
2.  **Deploy (部署): 点击橙色 Deploy 按钮。**
    
3.  **展开合约 进行交互：**
    

**实验 A：写入数据 (Update)**

-   找到 updateData 函数。
    
-   \_deviceId: 输入 101。
    
-   \_temp: 输入 2550 (代表 25.50 度)。
    
-   点击 **transact**。
    
-   _观察控制台：_ 只有写入操作才会消耗 Gas。
    

**实验 B：读取数据 (Read)**

-   找到 sensors 按钮（这是 public mapping 自动生成的）。
    
-   输入 101，点击 call。
    
    -   之后会看到返回的 tuple 数据：ID, temp, timestamp, true。
        
-   找到 getTemperature 按钮。
    
-   输入 101，点击 call。
    
    -   返回 2550。
        

**实验 C：访问未初始化的内存 (关键！)**

-   在 getTemperature 中输入 999 (一个从未写过的 ID)。
    
-   点击 call。
    
-   **问题：** 它返回了什么？是报错了，还是乱码，还是 0？
    

**思考题：** 这次写入大概消耗了多少 Gas？（通常是 **4万到5万** 左右）。 对比一下昨天那个简单的 `counter++`（约 2万多），为什么这次贵了这么多？

-   _提示：昨天只是修改了一个已经存在的整数，今天是_**_第一次_**_为一个新的 Key (_`101`_) 初始化结构体，相当于在 Flash 上开辟了一块新扇区，这是最贵的操作。_
    

回答：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-14-1768405228350-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-14-1768405200798-image.png)

### 困惑一：`call sensors` 的目的是什么？是生成 ID 吗？

**答案：不是生成，而是“直读内存”。**

-   **现象：** 您没有写 `function sensors()...` 这个函数，但 Remix 里却出现了一个蓝色的 `sensors` 按钮。
    
-   **原理（关键字** `public` **的魔法）：** 在代码第 18 行：`mapping(uint256 => SensorData) public sensors;` 当您给变量加上 `public` 关键字时，编译器（Solidity）会自动为您生成一个**同名的读取函数**。
    
-   **嵌入式类比：**
    
    -   `getTemperature` **(您写的函数):** 就像您封装的一个 API `float Sensor_GetVal(id)`。它里面有逻辑（比如判断 `isValid`，如果无效返回 0）。
        
    -   `sensors` **(自动生成的):** 就像通过 **JTAG/调试器** 直接查看内存地址 `0x20001000`。它不带任何逻辑，直接把那个存储槽（Slot）里的原始数据（ID, Temp, Timestamp, Bool）全部吐出来给您看。
        

**所以，它的目的是：** 让（开发者）方便地去“查账”，验证数据到底存进去没有。

### 困惑二：实验 C 返回 0，怎么判断 bool 值？

**答案：通过** `getTemperature` **函数您确实判断不了（因为它把 bool 丢弃了），但通过** `sensors` **可以看到。**

请看代码对比：

**场景：访问不存在的 ID (999)**

1.  **如果您调用** `getTemperature(999)`**：**
    
    -   **代码逻辑：** 函数签名是 `returns (uint16)`。内部逻辑是：如果 `isValid` 是 false，则 `return 0`。
        
    -   **结果：** 只拿到了 `0`。此时确实**无法区分**“这是真的 0 度”还是“数据不存在”。这正是这个函数的逻辑缺陷，也是为什么我们需要 Event 或 Revert
        
2.  **如果您调用** `sensors(999)` **(蓝色的那个按钮)：**
    
    -   **请现在尝试操作一下：** 在 `sensors` 按钮输入 999，点击 call。
        
    -   **预期结果：** 之后会看到类似这样的元组：
        
        Plaintext
        
        ```
        0: uint8: id 0
        1: uint16: temperature 0
        2: uint32: timestamp 0
        3: bool: isValid false   <-- 这里！
        ```
        
    -   **结论：** 在 Solidity 中，**所有未初始化的内存都是全 0**（bool 的 0 就是 false）。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->

# **Day 2：EVM 指令集与 Gas 机制（学习笔记）**

## 1）把 EVM 当作“按指令计费 / 基于堆栈”的虚拟 CPU

**EVM 可以理解为一个堆栈机（stack machine）**：大多数运算都在栈顶完成（push / pop / op）。

Gas 机制可以理解为**“按指令与资源消耗计费”**：

\- 指令执行要花 Gas

\- 读写存储（storage）更贵

\- 超出 Gas 限额就会\*\*强制终止并回滚\*\*

\---

## **2）理论映射（嵌入式对照）**

\- **ARM Cortex-M：寄存器架构（register-based）**

\- **EVM：堆栈架构（stack-based）**

\> 嵌入式里你经常“螺蛳壳内做道场”，RAM 紧张`uint8_t` / `uint16_t` 用得多；

\> 但在 Solidity/EVM 里，很多时候更推荐直接用 EVM 原生字长`uint256`（对齐 EVM 256-bit word），避免不必要的类型转换成本和复杂度。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313068628-image.png)

\---

## 3）实践：触发第一个“看门狗复位”（Gas 耗尽）

**目标**：写一个“死循环”，亲眼看见 Gas 如何强行终止程序（类比 WDT Reset）。

\#### 合约代码

\`\`\`solidity

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract GasTest {

uint256 public counter = 0;

// 会触发“看门狗复位”（Gas耗尽）的函数

function foreverLoop() public {

// while(true) 的区块链版本

while (true) {

counter++;

}

}

// 正常函数：用于对比 Gas 消耗

function normalAdd() public {

counter++;

}

}

现象记录

-   `normalAdd()` 能正常给 `counter + 1`
    
-   `foreverLoop()` 调用后 `counter` **不会增加**
    
    -   我在调用 `foreverLoop()` 前后读取 `counter`，发现值完全一样
        
    -   说明：Gas 耗尽后交易失败，**状态被回滚**（increment 也“当没发生过”）
        

进一步观察

-   在 **Compile Details** 里查看 **BYTECODE**：在 opcodes 中能看到大量 `JUMP`
    
-   这个“死循环”本质就是靠 `JUMP` 不断跳转实现
    

* * *

### 4）反思复盘（工程经验固化）

4.1 忌讳无界循环（Unbounded Loop）

永远不要写这种逻辑：

```solidity
for (uint i = 0; i < users.length; i++) { ... }
```

因为一旦 `users.length` 变成 10,000，循环次数可能超过区块可承受的 Gas 上限，导致：

-   交易永远失败
    
-   函数逻辑等价于“永久卡死，再也跑不起来”
    

4.2 嵌入式类比：ISR 里做重活 = 直接把系统拖死

这就像你在中断服务函数（ISR）里塞了一个耗时 1 秒的操作：

-   主循环被打断
    
-   实时性崩掉
    
-   系统看起来“还活着”，其实已经不可用
    

4.3 Check-Effects-Interactions（CEI）与回滚直觉

-   由于以太坊的状态回滚机制：只要最终失败，前面做的状态修改都会撤销
    
-   所以我们不需要担心“改了一半”的脏状态残留问题
    
-   但仍然要坚持 CEI：
    
    -   **Check**：先校验前置条件
        
    -   **Effects**：再更新状态
        
    -   **Interactions**：最后做外部交互（防重入、防意外失败）
        

* * *

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313034569-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313053291-image.png)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->


# **Day 1 学习总结：我开始用“系统工程”理解以太坊**

今天我最大的收获是：

我不再把以太坊当成“转账网络”，而是把它当成一个**分布式状态机**。  
交易也不只是“转钱”，而是一次次**状态变更请求**：我们把请求广播出去，全网验证、排序、执行，然后把结果写进一个所有人都能复算的公共状态。很像做自动化/工作流——看流程怎么跑、日志怎么记、结果能不能重放，而不是某些公司，关键先生一言堂。

**区块链的核心也不只是账本**，更像一套“可验证的协作协议”：  
Web2 靠中心平台、权限和法律背书；Web3 把规则写进合约，用共识+密码学+可重放日志保证一致性。

信任没有消失，只是从“信机构”变成“信过程”，**信任被工程化了**。

**钱包不是存钱的，是控制权**：它本质是**密钥管理+签名器**。余额变化不是“钱包里多了钱”，而是链上状态变了。

我们真正拥有的不是账户，而是私钥这把钥匙。

**安全上我今天记住一句话**：危险的往往不是 value（转多少），而是 data（我们签了什么）。

很多事故不是转账，而是**授权/签名**把权限交出去了。

**Gas 可以理解为付费计算+反滥用**：gasUsed 是实际消耗，gasLimit 是预算上限，失败也会花费，因为执行发生了只是回滚。

最后，**Sepolia 测试网不是玩具**：对我来说最值钱的是端到端闭环和可观测性（hash/receipt/logs/nonce/revert）。

它是主网的预设项，只是币没价值、稳定性可能差一点。

总结一下就是：  
**以太坊=分布式状态机；区块链=可验证协作；钱包=控制权；交易=状态变更；Gas=付费计算；测试网=主网彩排。**

_小狐狸转账钱包的截图_

![屏幕截图 2026-01-12 193830.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232261149-_____2026-01-12_193830.png)

_简单看了老师们写的书（检视阅读），building的欲望越来越强烈了_

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232444538-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232417925-image.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
