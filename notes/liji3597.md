---
timezone: UTC+8
---

# liji3597

**GitHub ID:** liji3597

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
# 第5天：事件日志 (Events) —— 区块链版的 `printf`

_（注：根据原本的计划，今天应该是讲“高级映射”，但我决定先把“事件”提上来，因为它是解决调试难题的神器，也是嵌入式工程师最熟悉的通信模式。）_

## 1\. 理论映射：串口打印与中断信号

在 STM32 开发中，当系统跑飞或者想知道当前温度是多少时，你会怎么做？

1.  **方法 A (Debug):** 暂停 CPU，用 J-Link 查看内存变量（这就像我们之前用的 `sensors` 按钮，读 Storage）。
    
2.  **方法 B (Log):** 在代码里写 `printf("Temp: %d\n", temp);`，通过串口（UART）把数据吐出来。
    
3.  **方法 C (Interrupt):** 某个引脚电平跳变，触发外部中断，通知主控。
    

在 Solidity 中，**Events (事件)** 同时扮演了 **方法 B** 和 **方法 C** 的角色。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-16-1768571631108-image.png)

核心概念：

智能合约是“哑巴”，它在链上默默运行。只有通过 emit 发射事件，它才能告诉链下的 Python/JS 脚本：“喂，刚才有人改了数据，ID是101，新温度是25度！”

* * *

## 2\. 语法实战

我们有两个关键字：

1.  `event`: 定义日志格式（类似于定义 `struct` 或报文协议头）。
    
2.  `emit`: 发送日志（类似于调用 `printf`）。
    

**任务：** 修改你的 `SensorLogger`，加上日志功能。

请在 Remix 中新建 `Day5_Events.sol`，输入以下代码（融合了之前的权限控制）：

Solidity

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract EventLogger {
    
    // 1. 定义事件 (协议头)
    // indexed 关键字：相当于建立索引，允许外部工具快速过滤搜索 (类似 Wireshark 的 Filter)
    event DataUpdated(uint256 indexed deviceId, uint256 temperature, address indexed operator);
    
    // 报警事件
    event HighTempAlert(uint256 indexed deviceId, uint256 temperature, string message);

    struct SensorData {
        uint16 temperature;
        bool isValid;
    }
    mapping(uint256 => SensorData) public sensors;
    address public owner;

    constructor() { owner = msg.sender; }

    function updateData(uint256 _id, uint16 _temp) public {
        require(msg.sender == owner, "Auth Fail");

        // [Effects] 修改状态
        sensors[_id] = SensorData(_temp, true);

        // [Interaction] 发射事件 (就像 printf)
        // 这条日志会永久记录在区块里，但不会修改 State (省钱)
        emit DataUpdated(_id, _temp, msg.sender);

        // 模拟简单的阈值报警
        if (_temp > 5000) { // 假设 50.00 度是阈值
            emit HighTempAlert(_id, _temp, "Warning: Overheat!");
        }
    }
}
```

* * *

## 3\. 实验操作：捕捉“串口数据”

### **步骤 1：部署合约**

1.  像往常一样部署 `EventLogger`。
    

### **步骤 2：触发事件**

1.  调用 `updateData`，输入 `101, 2550` (25.5度)。
    
2.  调用 `updateData`，输入 `101, 6000` (60.0度，**触发报警**)。
    

### 步骤 3：查看日志 (核心步骤)

这是很多初学者找不到的地方。

1.  在控制台（Terminal）找到刚刚成功的交易（绿色对勾）。
    
2.  点击展开交易详情。
    
3.  向下滚动，找到 **“Logs”** 字段。
    
    -   它是 JSON 格式的数组。
        
    -   你会看到 `DataUpdated` 和 `HighTempAlert` 的详细内容。
        
    -   注意看 `args` (参数) 里的数据，是不是和你输入的一样？
        

* * *

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-16-1768570899712-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-16-1768570919383-image.png)

## 4\. 深度思考：Indexed (索引) 的意义

在代码中，我给 `deviceId` 加了 `indexed` 关键字。

Solidity

```
event DataUpdated(uint256 indexed deviceId, ...);
```

这有什么用？

想象一下，你的合约里有 10,000 个传感器在不断上传数据。

-   **没有 indexed:** 如果你想找“ID 为 101 的所有历史记录”，前端脚本必须把 10,000 条日志全部下载下来，一条条遍历解析。效率极低。
    
-   **有 indexed:** 这里的 `deviceId` 被加入到了 **Bloom Filter (布隆过滤器)** 中。节点可以瞬间告诉你：“只给我 ID=101 的日志”，其他 9999 条直接忽略。
    

**这就像 SQL 里的** `WHERE deviceId = 101`**，或者 Wireshark 里的** `tcp.port == 80`**。**

* * *

### 今日作业

1.  **操作验证：** 运行代码，触发一次报警，截图控制台里的 **Logs** 部分给我看。
    
2.  **思考题：** 既然 `emit Event` 这么便宜（相比于 `SSTORE` 写状态），那为什么我不把所有历史数据（比如每秒的温度）都只用 `Event` 发出来，而根本不存到 `mapping` 里呢？
    
    -   _提示：智能合约自己能读到_ `Event` _吗？如果我想在合约里写一个功能“计算过去 10 次温度的平均值”，只用 Event 能实现吗？_
        

做完这个，我们就彻底打通了“链上（固件）”与“链下（监控软件）”的通信渠道！

### 思考题回答

答：**Event 和 Mapping 都是“SSD”**（它们的数据都会被永久记录在区块链的历史区块中，永远不会消失）。

**真正的区别在于“谁能读”：**

1.  **Mapping (**`SSTORE`**/**`SLOAD`**):**
    
    -   **可见性：** 合约**自己**能读，外部也能读。
        
    -   **嵌入式类比：** **内部 Flash/EEPROM**。CPU 可以读取这里的历史数据来做计算（比如：`if (last_temp > 50) { shutdown(); }`）。
        
    -   **成本：** 极贵。
        
2.  **Event (**`LOG` **opcode):**
    
    -   **可见性：** **合约自己读不到！** 只有链下的外部程序（前端/Python脚本）能读。
        
    -   **嵌入式类比：** **UART 串口打印 (**`printf`**)**。
        
    -   **关键点：** 你在代码里写了 `printf("Temp: 60");`，数据就从串口发走了。MCU（合约）能不能回头去读取刚才发出去的字符串来做加法运算？**不能！** 数据已经离开 CPU 进入了串口线（区块链日志区）。
        

**结论：** 如果你需要“根据历史数据做逻辑判断”**（比如计算平均值、判断是否连续三次报警），必须存 Mapping/Storage。 如果你只是为了**“存证”**或**“通知用户”，后续不再参与合约逻辑计算，那么用 **Event**，能省下 90% 的 Gas 费用 。
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->


昨天的合约虽然能跑，但在嵌入式领域，这相当于把调试串口（UART Debug Shell）直接暴露到了公网上，任何连上线的人都能发送 AT 指令修改系统参数。

今天要给这个系统加上 **“Root 权限”** 和 **“启动自检代码”**。

## 1\. 理论映射：启动代码与权限位

### **A. 构造函数 (constructor) = SystemInit()**

在 STM32 中，上电复位后，会先执行启动文件（Startup file）里的复位处理函数，初始化时钟、堆栈等。这段代码**只跑一次**。 在 Solidity 中，constructor 就是这段代码。它只在合约**部署（Deployment）** 的瞬间执行一次，之后永远无法再次调用。

通常在这里记录“谁是出厂管理员”。

### B. 全局变量 (msg.sender) = Current\_Task\_PID

在 RTOS 中，通过 osThreadGetId() 知道当前是谁在执行代码。 在 Solidity 中，msg.sender 是一个全局变量，代表**当前正在调用这个函数的地址**。

-   如果是你调用的，它就是你的钱包地址。
    
-   如果是黑客调用的，它就是黑客的地址。
    

### C. 修饰符 (modifier) = ASSERT 宏 / 中间件

这是 Solidity 最优雅的特性之一。它类似于 C 语言的预处理宏，或者是 AOP（面向切面编程）。 我们可以定义一个规则（比如“必须是管理员”），然后把这个标签贴在任何函数头上。函数执行前，会先跑这个规则。

## 2\. 代码实战：加上“防盗锁”

将修改 SensorLogger，增加一个管理员 owner，并且只允许 owner 写入数据。

**请在 Remix 中新建 Day4\_AccessControl.sol，输入以下代码：**

Solidity

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControlSensor {
    
    // 1. 定义管理员变量 (存在 Flash/Storage 中)
    address public owner;

    struct SensorData {
        uint16 temperature;
        bool isValid;
    }
    mapping(uint256 => SensorData) public sensors;

    // --- 启动代码 (Bootloader) ---
    // 仅在部署瞬间执行一次
    constructor() {
        // msg.sender 在这里代表“部署者” (也就是您)
        owner = msg.sender; 
    }

    // --- 定义修饰符 (宏检查) ---
    modifier onlyOwner() {
        // [Check] 检查当前调用者是不是管理员
        require(msg.sender == owner, "Error: You are not the admin!");
        
        // [Merge] 下划线代表“被修饰函数的代码体”
        // 也就是先执行上面的 require，通过后，再把原来的函数体填在这里执行
        _; 
    }

    // --- 写入函数 (加上了锁) ---
    // 注意头部多了 'onlyOwner' 关键字
    function updateData(uint256 _id, uint16 _temp) public onlyOwner {
        sensors[_id] = SensorData(_temp, true);
    }

    // --- 任何人都可以读取 ---
    function getTemp(uint256 _id) public view returns (uint16) {
        return sensors[_id].temperature;
    }
}
```

## 3\. 攻击模拟实验 (核心环节)

这次我们不能只点一下就完了，我们要模拟“身份切换”。Remix 提供了多个虚拟账户，非常适合做这个测试。

## 第一步：部署 (我是管理员)

1.  确保 **Account** 栏选中的是第一个地址（比如 0x5B3...）。
    
2.  点击 **Deploy**。
    
3.  展开合约，点击 owner 按钮。 确认显示的地址和上面 Account 栏里的地址一模一样。
    

## 第二步：正常写入 (授权操作)

1.  保持 Account 不变。
    
2.  在 updateData 输入 1, 2550。
    
3.  点击 transact。 **结果：** 交易成功（控制台绿色对勾）。
    

## 第三步：黑客攻击 (未授权操作)

1.  **切换账号：** 在左侧 **Account** 下拉菜单中，选择**第二个地址**（比如 0xAb8...）。 _此时您扮演了一个路人/黑客。_
    
2.  再次点击 updateData (输入 1, 9999)。 **结果：** 交易**失败**！控制台出现红色报错。
    
3.  **查看报错原因：** 在控制台报错信息中，寻找 Reason: Error: You are not the admin!。 这正是我们在 require 里写的报错字符串。
    

4\. 深度复盘

做完实验后，请思考这个 modifier 的执行流：

当黑客调用 updateData 时，实际发生的执行顺序是：

1.  进入 onlyOwner 修饰符。
    
2.  执行 require(msg.sender == owner)。 msg.sender 是黑客地址 (0xAb8...)。 owner 是管理员地址 (0x5B3...)。 **不相等 -> 抛出异常 -> 状态回滚。**
    
3.  **根本没有执行到** sensors\[\_id\] = ... 这一行。数据得到了完美保护。
    

![屏幕截图 2026-01-15 224301.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-15-1768489356926-_____2026-01-15_224301.png)![屏幕截图 2026-01-15 221308.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-15-1768489330308-_____2026-01-15_221308.png)

**今日作业：**如果您想把权限移交给别人（比如把设备卖给了客户），应该怎么写？ _试着添加一个 function changeOwner(address newOwner) 函数。_ _提示：这个函数本身也需要加 onlyOwner 吗？如果不加会发生什么？_

### 答：版本 A：直球版 (C 语言思维)

这是最直接的实现，类似于 C 语言中的指针重新赋值。

**⚠️ 这种写法的风险（嵌入式类比）：** 这就像通过串口发送一条指令修改波特率。如果手抖把波特率改成了乱码，由于通信已经断开，**再也无法**发指令改回去了。设备直接变砖。 同理，如果您把 `_newOwner` 输错了一位，或者输成了一个没人控制的地址，合约的管理员权限就**永久丢失**了。

**逻辑：**

1.  检查调用者是不是现任管理员 (`onlyOwner`)。
    
2.  检查新地址是不是“空指针” (`address(0)`)。
    
3.  直接覆盖 `owner` 变量。
    

```
// 在您的 AccessControlSensor 合约中添加：

function changeOwner(address _newOwner) public onlyOwner {
    // [Check] 防止手抖把权限转给 0x0000...0000 (空地址)
    require(_newOwner != address(0), "New owner is the zero address");

    // [Effect] 立即移交权限
    owner = _newOwner;
}
```

### 版本 B：两步验证法 (Web3 / Rust 安全思维)

这是您想要的“更好的建议”。在 Rust 中，所有权（Ownership）的转移是非常严谨的。在 Web3 智能合约中，为了防止“变砖”，我们采用 **"Offer - Accept" (提议-接受)** 模式。

**嵌入式类比：** 这就像 TCP 的 **三次握手**，或者 SPI 通信中的 **Master-Slave 握手**。

1.  **Master (现任管理员):** “我想把 Master 权限给从机 B。” (发送请求)
    
2.  **Slave B (新管理员):** “收到，我确认接管。” (发送 ACK)
    
3.  **系统:** “权限移交完成。”
    

如果 Slave B 没有响应（地址输错/私钥丢失），权限**仍然保留在 Master 手里**，系统不会挂掉。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeAccessControl {
    address public owner;
    address public pendingOwner; // 暂存的新管理员地址

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // --- 步骤 1: 现任管理员发起移交 ---
    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "Unsafe address");
        // 这里不直接改 owner，而是给 pendingOwner 赋值
        pendingOwner = _newOwner;
    }

    // --- 步骤 2: 新管理员确认接收 ---
    // 这个函数必须由 _newOwner 亲自调用
    function acceptOwnership() public {
        // [Check] 检查调用者是不是被指定的接班人
        require(msg.sender == pendingOwner, "You are not the pending owner");
        
        // [Effect] 正式移交
        owner = pendingOwner;
        pendingOwner = address(0); // 清空暂存区
    }
}
```

-   **部署** `SafeAccessControl` (使用账号 A)。
    
-   **发起移交 (transferOwnership):**
    
    -   使用账号 A。
        
    -   输入账号 B 的地址。
        
    -   点击 transact。
        
    -   _此时查看_ `owner`_，仍然是账号 A。_
        
-   **黑客尝试截胡 (模拟):**
    
    -   切换到账号 C。
        
    -   点击 `acceptOwnership`。
        
    -   _结果：报错 "You are not the pending owner"。_
        
-   **接受移交 (acceptOwnership):**
    
    -   切换到账号 B (必须是刚才指定的那个)。
        
    -   点击 `acceptOwnership`。
        
    -   _此时查看_ `owner`_，变成了账号 B。_
        

![屏幕截图 2026-01-15 224301.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-15-1768489534376-_____2026-01-15_224301.png)

### 为什么说这是 Rust 思维？

在 Rust 语言中，资源的所有权管理极其严格。你不能随便把一个变量的所有权“扔”给别人，必须确保作用域的安全性。 这种 **Two-Step Transfer** 模式体现了 Rust 的 **Explicit ensures Safety (显式即安全)** 哲学：

-   **不隐式发生：** 重要的状态变更必须有显式的“接受”动作。
    
-   **故障安全 (Fail-safe)：** 如果中间任何一步出错，系统回退到原有的安全状态（旧管理员依然拥有权限），而不是进入未定义的 Panic 状态。
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->



# 第三天 **：Solidity语法与核心数据结构**。

对于C 语言老手来说，学习 Solidity 的语法就像是换了一种方言，大体逻辑是通的，但有几个非常反直觉的“内存陷阱”需要特别注意。

今天的目标是：**编写一个工业级的“传感器数据上链”合约。**

## **理论映射：三大存储空间 (The Data Location)**

在 STM32 中，数据是放在 Flash（只读/持久化）、SRAM（读写/易失）还是寄存器里。 在 Solidity 中，必须**显式声明**变量存储在以下三个区域之一，否则编译器会报错。这是它和 Python/JS 最大的不同。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-14-1768405004145-image.png)

**嵌入式思维转换：**

-   **storage 就是写 Flash。** 它是状态变量的默认位置。永远不要为了临时计算而在 storage 里读写，那会让您的用户破产。
    
-   **memory 就是局部变量。** 在函数内部定义的复杂类型（如结构体、数组）需要加 memory 关键字。
    

## 核心数据结构：Mapping (映射) vs Array

我习惯用 SensorData logs\[100\]（数组）。 但在区块链上，数组非常危险（Gas 消耗随长度线性增加），所以改用为**mapping**。

-   **定义：** mapping(KeyType => ValueType)
    
-   **本质：** 一个巨大的**哈希表 (Hash Table)**。
    
-   **怪癖（与 C 的最大区别）：**
    
    1.  **没有长度： 无法获取 mapping.length。**
        
    2.  **无法遍历： 不能写 for (i in mapping)。必须知道 Key 才能拿到 Value。**
        
    3.  **全空间初始化： 它的逻辑空间包含所有可能的 Key。访问一个从未写入的 Key，不会报错，也不会读到垃圾值，而是返回 全0 (默认值)。**
        

## **代码实战：编写 SensorLogger 合约**

```
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

 

contract SensorLogger {

   

    // --- 1. 数据结构定义 (类似于 struct) ---

    struct SensorData {

        uint8 id;           // 传感器ID (uint8: 0-255)

        uint16 temperature; // 温度 (定点数: 2550 代表 25.50度)

                            // 注意: Solidity 没有 float/double 类型！必须用整数表示。

        uint32 timestamp;   // UNIX 时间戳

        bool isValid;       // 状态标志位

    }

 

    // --- 2. 永久存储区 (Flash / Storage) ---

    // 这是一个哈希表：设备ID (Key) -> 传感器数据 (Value)

    // 'public' 关键字会自动生成一个 getter 函数

    mapping(uint256 => SensorData) public sensors;

 

    // --- 3. 写入函数 (Flash Write) ---

    function updateData(uint256 deviceId, uint16 temp) public {

        // [Check] 简单的参数检查

        require(_deviceId > 0, "Invalid Device ID");

 

        // [Effects] 写入 Storage

        // block.timestamp 是当前区块的时间 (类似于 RTC 时间)

        sensors[_deviceId] = SensorData({

            id: uint8(_deviceId),

            temperature: _temp,

            timestamp: uint32(block.timestamp),

            isValid: true

        });

    }

 

    // --- 4. 读取函数 (Flash Read) ---

    // 'view' 表示只读，不修改状态。

    // 如果是外部(User)直接调用，不消耗 Gas。如果是合约内部调用，消耗极少 Gas。

    function getTemperature(uint256 _deviceId) public view returns (uint16) {

        // 从 Storage 读取数据到 Memory (RAM)

        SensorData memory data = sensors[_deviceId];

       

        // 检查数据是否有效 (类似于检查 Flash 里的 Magic Number)

        if (data.isValid) {

            return data.temperature;

        } else {

            return 0; // 或者抛出错误

        }

    }

}
```

## 部署与实验

**环境选择：** 依然使用 **Remix VM (Cancun)**，速度快。

1.  **Compile (编译): 确保绿色对勾。**
    
2.  **Deploy (部署): 点击橙色 Deploy 按钮。**
    
3.  **展开合约 进行交互：**
    

**实验 A：写入数据 (Update)**

-   找到 updateData 函数。
    
-   \_deviceId: 输入 101。
    
-   \_temp: 输入 2550 (代表 25.50 度)。
    
-   点击 **transact**。
    
-   _观察控制台：_ 只有写入操作才会消耗 Gas。
    

**实验 B：读取数据 (Read)**

-   找到 sensors 按钮（这是 public mapping 自动生成的）。
    
-   输入 101，点击 call。
    
    -   之后会看到返回的 tuple 数据：ID, temp, timestamp, true。
        
-   找到 getTemperature 按钮。
    
-   输入 101，点击 call。
    
    -   返回 2550。
        

**实验 C：访问未初始化的内存 (关键！)**

-   在 getTemperature 中输入 999 (一个从未写过的 ID)。
    
-   点击 call。
    
-   **问题：** 它返回了什么？是报错了，还是乱码，还是 0？
    

**思考题：** 这次写入大概消耗了多少 Gas？（通常是 **4万到5万** 左右）。 对比一下昨天那个简单的 `counter++`（约 2万多），为什么这次贵了这么多？

-   _提示：昨天只是修改了一个已经存在的整数，今天是_**_第一次_**_为一个新的 Key (_`101`_) 初始化结构体，相当于在 Flash 上开辟了一块新扇区，这是最贵的操作。_
    

回答：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-14-1768405228350-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-14-1768405200798-image.png)

### 困惑一：`call sensors` 的目的是什么？是生成 ID 吗？

**答案：不是生成，而是“直读内存”。**

-   **现象：** 您没有写 `function sensors()...` 这个函数，但 Remix 里却出现了一个蓝色的 `sensors` 按钮。
    
-   **原理（关键字** `public` **的魔法）：** 在代码第 18 行：`mapping(uint256 => SensorData) public sensors;` 当您给变量加上 `public` 关键字时，编译器（Solidity）会自动为您生成一个**同名的读取函数**。
    
-   **嵌入式类比：**
    
    -   `getTemperature` **(您写的函数):** 就像您封装的一个 API `float Sensor_GetVal(id)`。它里面有逻辑（比如判断 `isValid`，如果无效返回 0）。
        
    -   `sensors` **(自动生成的):** 就像通过 **JTAG/调试器** 直接查看内存地址 `0x20001000`。它不带任何逻辑，直接把那个存储槽（Slot）里的原始数据（ID, Temp, Timestamp, Bool）全部吐出来给您看。
        

**所以，它的目的是：** 让（开发者）方便地去“查账”，验证数据到底存进去没有。

### 困惑二：实验 C 返回 0，怎么判断 bool 值？

**答案：通过** `getTemperature` **函数您确实判断不了（因为它把 bool 丢弃了），但通过** `sensors` **可以看到。**

请看代码对比：

**场景：访问不存在的 ID (999)**

1.  **如果您调用** `getTemperature(999)`**：**
    
    -   **代码逻辑：** 函数签名是 `returns (uint16)`。内部逻辑是：如果 `isValid` 是 false，则 `return 0`。
        
    -   **结果：** 只拿到了 `0`。此时确实**无法区分**“这是真的 0 度”还是“数据不存在”。这正是这个函数的逻辑缺陷，也是为什么我们需要 Event 或 Revert
        
2.  **如果您调用** `sensors(999)` **(蓝色的那个按钮)：**
    
    -   **请现在尝试操作一下：** 在 `sensors` 按钮输入 999，点击 call。
        
    -   **预期结果：** 之后会看到类似这样的元组：
        
        Plaintext
        
        ```
        0: uint8: id 0
        1: uint16: temperature 0
        2: uint32: timestamp 0
        3: bool: isValid false   <-- 这里！
        ```
        
    -   **结论：** 在 Solidity 中，**所有未初始化的内存都是全 0**（bool 的 0 就是 false）。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->




# **Day 2：EVM 指令集与 Gas 机制（学习笔记）**

## 1）把 EVM 当作“按指令计费 / 基于堆栈”的虚拟 CPU

**EVM 可以理解为一个堆栈机（stack machine）**：大多数运算都在栈顶完成（push / pop / op）。

Gas 机制可以理解为**“按指令与资源消耗计费”**：

\- 指令执行要花 Gas

\- 读写存储（storage）更贵

\- 超出 Gas 限额就会\*\*强制终止并回滚\*\*

\---

## **2）理论映射（嵌入式对照）**

\- **ARM Cortex-M：寄存器架构（register-based）**

\- **EVM：堆栈架构（stack-based）**

\> 嵌入式里你经常“螺蛳壳内做道场”，RAM 紧张`uint8_t` / `uint16_t` 用得多；

\> 但在 Solidity/EVM 里，很多时候更推荐直接用 EVM 原生字长`uint256`（对齐 EVM 256-bit word），避免不必要的类型转换成本和复杂度。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313068628-image.png)

\---

## 3）实践：触发第一个“看门狗复位”（Gas 耗尽）

**目标**：写一个“死循环”，亲眼看见 Gas 如何强行终止程序（类比 WDT Reset）。

\#### 合约代码

\`\`\`solidity

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract GasTest {

uint256 public counter = 0;

// 会触发“看门狗复位”（Gas耗尽）的函数

function foreverLoop() public {

// while(true) 的区块链版本

while (true) {

counter++;

}

}

// 正常函数：用于对比 Gas 消耗

function normalAdd() public {

counter++;

}

}

现象记录

-   `normalAdd()` 能正常给 `counter + 1`
    
-   `foreverLoop()` 调用后 `counter` **不会增加**
    
    -   我在调用 `foreverLoop()` 前后读取 `counter`，发现值完全一样
        
    -   说明：Gas 耗尽后交易失败，**状态被回滚**（increment 也“当没发生过”）
        

进一步观察

-   在 **Compile Details** 里查看 **BYTECODE**：在 opcodes 中能看到大量 `JUMP`
    
-   这个“死循环”本质就是靠 `JUMP` 不断跳转实现
    

* * *

### 4）反思复盘（工程经验固化）

4.1 忌讳无界循环（Unbounded Loop）

永远不要写这种逻辑：

```solidity
for (uint i = 0; i < users.length; i++) { ... }
```

因为一旦 `users.length` 变成 10,000，循环次数可能超过区块可承受的 Gas 上限，导致：

-   交易永远失败
    
-   函数逻辑等价于“永久卡死，再也跑不起来”
    

4.2 嵌入式类比：ISR 里做重活 = 直接把系统拖死

这就像你在中断服务函数（ISR）里塞了一个耗时 1 秒的操作：

-   主循环被打断
    
-   实时性崩掉
    
-   系统看起来“还活着”，其实已经不可用
    

4.3 Check-Effects-Interactions（CEI）与回滚直觉

-   由于以太坊的状态回滚机制：只要最终失败，前面做的状态修改都会撤销
    
-   所以我们不需要担心“改了一半”的脏状态残留问题
    
-   但仍然要坚持 CEI：
    
    -   **Check**：先校验前置条件
        
    -   **Effects**：再更新状态
        
    -   **Interactions**：最后做外部交互（防重入、防意外失败）
        

* * *

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313034569-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-13-1768313053291-image.png)
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->





# **Day 1 学习总结：我开始用“系统工程”理解以太坊**

今天我最大的收获是：

我不再把以太坊当成“转账网络”，而是把它当成一个**分布式状态机**。  
交易也不只是“转钱”，而是一次次**状态变更请求**：我们把请求广播出去，全网验证、排序、执行，然后把结果写进一个所有人都能复算的公共状态。很像做自动化/工作流——看流程怎么跑、日志怎么记、结果能不能重放，而不是某些公司，关键先生一言堂。

**区块链的核心也不只是账本**，更像一套“可验证的协作协议”：  
Web2 靠中心平台、权限和法律背书；Web3 把规则写进合约，用共识+密码学+可重放日志保证一致性。

信任没有消失，只是从“信机构”变成“信过程”，**信任被工程化了**。

**钱包不是存钱的，是控制权**：它本质是**密钥管理+签名器**。余额变化不是“钱包里多了钱”，而是链上状态变了。

我们真正拥有的不是账户，而是私钥这把钥匙。

**安全上我今天记住一句话**：危险的往往不是 value（转多少），而是 data（我们签了什么）。

很多事故不是转账，而是**授权/签名**把权限交出去了。

**Gas 可以理解为付费计算+反滥用**：gasUsed 是实际消耗，gasLimit 是预算上限，失败也会花费，因为执行发生了只是回滚。

最后，**Sepolia 测试网不是玩具**：对我来说最值钱的是端到端闭环和可观测性（hash/receipt/logs/nonce/revert）。

它是主网的预设项，只是币没价值、稳定性可能差一点。

总结一下就是：  
**以太坊=分布式状态机；区块链=可验证协作；钱包=控制权；交易=状态变更；Gas=付费计算；测试网=主网彩排。**

_小狐狸转账钱包的截图_

![屏幕截图 2026-01-12 193830.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232261149-_____2026-01-12_193830.png)

_简单看了老师们写的书（检视阅读），building的欲望越来越强烈了_

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232444538-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/liji3597/images/2026-01-12-1768232417925-image.png)
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
