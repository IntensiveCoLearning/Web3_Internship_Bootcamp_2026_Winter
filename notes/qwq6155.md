---
timezone: UTC+8
---

# qwq6155

**GitHub ID:** qwq6155

**Telegram:** @qwq6155

## Self-introduction

学习web3相关知识

## Notes

<!-- Content_START -->
# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->
今天把eth基础案例学完了，顺便了解了一些汇编知识，明天整理知识点和进行练习

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-22-1769085453396-image.png)
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->

1.  [学习Solidity by Example | 0.8.26](https://solidity-by-example.org/) Basic 部分
    

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-21-1768992106059-image.png)
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->


**第四章**

一、智能合约的概念与功能

1\. 传统合约中的信任问题

2\. 智能合约能做什么？

2.1 数字自动售货机

2.2 自动执行：无需中介、无需等待

2.3 可预测的结果：相同输入 → 相同输出

2.4 公开记录与可审计性

2.5 “隐私”与假名制：不是完全匿名

2.6 条款可见与可审查

2.7 基本上你想到的逻辑，都能写成合约

二、Solidity 语言特性与优势

1\. 原生契合 EVM 架构

2\. 易学而强大

3\. 丰富生态与工具支持

4\. 这里给大家推荐一条学习的路线：

① 入门准备：

② 读官方文档 + 做例子：

③ 做交互式教程： 

④ 学习工具／测试／部署：

⑤ 安全／最佳实践：

⑥ 做一个小项目：

5\. 安全性与成熟度

6\. 图灵完备与功能丰富：

7\. 社区共识与兼容性

8\. 标准与库（少造轮子）

9\. 安全与审计支持

人们用 Solidity，不只是因为“它是以太坊的语言”，而是因为——EVM

原生 + 生态最强 + 工具 / 标准最成熟 + 多链兼容 + 安全经验最多。如

果你打算长期深耕以太坊 / EVM，Solidity 仍然是性价比最高的第一语言。

三、合约编译时产生的内容

1\. 智能合约编译产物：

1.1 字节码（Bytecode）

定义：这是智能合约的核心。它是以太坊虚拟机（EVM）可以理解和执行的

低级机器码。你可以把它想象成智能合约的“可执行文件”。

补充 1：创建字节码 vs 运行时字节码

补充 2：元数据哈希附加在字节码尾部

作用：当你部署智能合约时，实际上就是将这个字节码上传到区块链上。

EVM 会读取并执行这些字节码来运行你的合约逻辑。

类比：你在工厂里把零件 + 指令拼起来，生产出一个机器（部署）——创

建字节码就是整个工厂里的拼装图纸 + 材料；部署完机器装好后，不再包含那

些“拼装指令”（构造阶段逻辑），只留下成品逻辑（runtime）。

1.2 应用二进制接口（Application Binary Interface，ABI）

定义：ABI 是一个 JSON （ JavaScript Object Notation）格式的文件，它描述

了智能合约的公共接口。它包含了合约中所有公共函数和事件的详细信息，包括

它们的名称、参数类型、返回值类型以及它们的可见性（public、external）。

作用：

外部交互：

数据编码 / 解码

类比：像给你的合约写一个“菜单”，菜单上写了你能点什么菜（函数），

要什么材料（参数），会有什么反馈（返回值 / 事件）。

1.3 合约元数据（Contract Metadata）

定义：这是一个 JSON 文件，包含了关于合约的额外信息，例如：

编译器版本和设置

源代码路径或其 IPFS / Swarm 等去中心化存储的引用

ABI

NatSpec 文档（如果在代码里写了）

Solidity 编译器会默认生成这一文件，并且（默认）把它的 IPFS 哈希通过

CBOR 编码附加在运行时代码的尾部。

类比：像产品说明书 + 质检报告，写明这个机器什么厂制造、什么批次、

零件清单、配置如何，这样别人可以确认是不是正品或有没有被恶意篡改。

1.4 源映射 / Source Map / Storage Layout / AST（抽象语法树）

抽象语法树（AST，Abstract Syntax Tree）定义：AST 是源代码的结构化表示。编译器在编译过程中会生成它，用于分

析和优化代码。

类比：机器的内部结构图（电路图 / 内部机械结构图），你要维护 / 升级 /

修理时，这图很重要。

Source Map（源映射）：定义：编译器可以生成两类映射：

AST 节点对应的源码区间

字节码指令 ↔ 源码区间 的映射

1.5 Assembly（EVM Assembly）与 Yul IR

EVM Assembly：‘

定义：这是比字节码更高级一些的中间表示，但仍是低级的。它包含了 EVM操作码（opcode）和它们的操作数，更具可读性。

Yul / IR：

定义：Yul 是 Solidity 官方提供的中间语言，作为“IR-based codegen”的

核心，用于在多后端（EVM、eWASM 等）之间共享优化逻辑。

2\. 小结

• 部署与运行时字节码：真正上链执行的代码（附带 metadata 哈希）。

• ABI：前端、脚本和其他合约用来“看懂你合约接口”的说明书。

• Metadata JSON：记录编译器版本、源码、ABI、NatSpec 等，用于验证

与交互。

• AST / Source Map / IR / Assembly：供调试、审计、Gas 优化使用，多数

由工具在后台消费。

四、部署合约：地址与ABI获取

现在主流做法是：

本地编译 → 得到 bytecode + ABI + metadata

部署合约 → 得到链上的合约地址

在 Etherscan 或 Sourcify 上做源码验证（source verification） → 区块

浏览器会根据 metadata 解析出 ABI，并在网页上暴露“Read / Write

Contract”面板，供任何人交互。

总结一下：

• 部署后获得： 

o 合约地址（用于在区块链上找到并交互合约）

o 部署交易哈希（方便在区块浏览器追踪这次部署）

• 编译时生成： 

o ABI（用于链下应用程序理解和调用合约功能）

o bytecode（真正部署到链上的代码）

o metadata （记录编译器版本、源码哈希、ABI 等，用于验证和工具

集成）

1\. 智能合约常见组件有哪些？（变量、函数、事件等）

1.1 状态变量（State Variables）

定义：状态变量是存储在区块链上的数据，它们构成了合约的永久状态。一

旦部署，这些变量的值就会被记录在区块链上，并且在合约的生命周期内持续存

在（除非被合约的函数修改）。

特点：

持久性：

可见性：public：internal：private：

1.2 函数（Functions）

定义：函数是智能合约中执行操作的代码块。它们可以修改合约的状态变量，

也可以执行计算并返回结果。

特点：

可见性：

 public：可以从合约内部、继承合约或外部调用。

 external：只能从外部调用，不能从合约内部直接调用（但可以通过 this.functionName() 间接调用）。通常用于对外接口函数。

 internal：只能从合约内部或继承合约中调用。

 private：只能从当前合约内部调用。

状态可变性：

 pure：不读取也不修改合约状态的函数。

 view：读取合约状态但不修改状态的函数。

 payable：可以接收以太币的函数。

 默认（无修饰符）：可以修改合约状态的函数。

 receive()：专门处理“只带 ETH、不带 calldata”的转账；

 fallback()：处理“调用不存在的函数”或合约没有 receive() 时的 ETH 转账。

1.3 事件

定义：事件是智能合约向区块链日志中“广播”消息的方式。它们是轻量级

的、不可修改的，并且是智能合约与外部应用程序（如 DApp 前端、区块链浏览

器等）进行通信的主要机制。

特点：日志记录：可监听性：历史记录：

1.4 构造函数（Constructor）

定义：构造函数是一种特殊类型的函数，只在合约部署时执行一次。它通常

用于初始化合约的状态变量，例如设置合约的所有者、初始值或部署时的配置参

数。

特点：

一次性执行：

可选参数：

无名称：

1.5 修饰符（Modifiers）

定义：修饰符是用于修改函数行为的可重用代码块。它们可以在函数执行前

或执行后插入逻辑，常用于实现访问控制、条件检查等。

特点：

代码复用：

安全性：

1.6 结构体 / 枚举（Struct / Enum）与自定义错误（Custom Errors）

Struct / Enum:

• struct：定义复合数据结构，如订单、用户信息等；

• enum ：定义有限集合的枚举值，比如状态机中的

Pending/Active/Cancelled。

自定义错误（Custom Errors）:

error InsufficientBalance(uint requested, uint available);

function withdraw(uint amount) public {

if (amount > balances\[msg.sender\]) {

revert InsufficientBalance({

requested: amount,

available: balances\[msg.sender\]

});

}

// ...

}

2\. 小结

在智能合约开发中，字节码和 ABI 仍然是最重要的两个编译产物：  

字节码是你部署到区块链上的“程序本体”；

ABI 是告诉其他程序如何与你的合约“对话”的“说明书”。

五、合约部署的成本核算

部署智能合约，本质就是在链上“上传一段程序 + 初始化状态”，整件事

消耗的是 Gas，最后换算成 ETH 成本。

① 消耗了多少 Gas（Gas Used）？

② 每单位 Gas 要付多少价钱（Gas 价格 / Fee）？

1\. Gas 消耗量（Gas Used）——到底在为哪些操作付费？

• 基础交易成本（Base transaction cost）

• 合约创建开销（CREATE 成本） 

• 字节码存储成本（Code deposit） 

• 构造函数执行（Constructor 执行逻辑） 

• 初始存储写入（Storage 初始化）

小结：

代码越长、构造逻辑越复杂、初始化写入的状态越多，Gas Used 越高。

想省钱，第一位是：减少字节码体积 + 减少部署时的 storage 写入 +

精简 constructor。

2.  Gas 价格（现在不再是单一 GasPrice，而是 Base Fee +

Priority Fee）

Total Fee = Gas Used × (Base Fee + Priority Fee)

3\. 部署成本怎么计算？（公式 + 例子）

总成本（ETH） = Gas Used × (Base Fee + Priority Fee)

4\. 影响部署成本的关键因素（更新版）

① 合约复杂度 & 字节码体积

② 网络拥堵程度（Base Fee）

③ 你设置的小费（Priority Fee / maxPriorityFeePerGas）

④ 在哪条链部署：L1 与 L2 差异

在 L2 部署的成本结构：

总费用 ≈ L2 执行费（执行字节码） + L1 数据费（把批次数据提交回

以太坊）

现在由于 blob 数据的引入，L1 数据费占比大幅下降，L2 上部署合

约的成本对普通开发者更友好。

5\. 实战中如何“预估 & 控制”部署成本？

① 在本地 / 测试网先部署一遍

② 上线前看下实时 Gas 

③ 优化代码减少字节码和 storage 写入 

六、合约常见安全漏洞与防范措施

CEI 模式（Checks → Effects → Interactions）

使用 ReentrancyGuard 的 nonReentrant 修饰符（如 OpenZeppelin 提

供的实现），阻止同一函数在执行过程中被递归重入

采用 Pull-Payment 提现模式

1，ETH / 外部调用的安全性

(bool ok, ) = payable(to).call{value: amount}("");

require(ok, "ETH send failed");

2\. 整数溢出 / 下溢（Integer Overflow / Underflow）

3\. 访问控制错误 & 滥用 tx.origin

防范：

使用 Ownable / AccessControl（OpenZeppelin）来管理角色：如

onlyOwner、onlyRole(ADMIN\_ROLE) 等，关键操作建议叠加多签、

时间锁（Timelock）。

禁止使用 tx.origin 做权限判断，只用 msg.sender： tx.origin 在

跨合约调用场景中容易被钓鱼合约利用。‘

4\. 不可信外部调用（Unchecked External Calls）

防范：

所有低级调用都应显式检查 success 与返回数据，在失败时合理回退

或处理。

与 ERC-20 交互时，使用 OpenZeppelin 的 SafeERC20，兼容那些

“不按标准返回 bool”的代币（比如老 USDT），避免因返回值不规

范导致的漏洞。

5\. 预言机操控（Oracle Manipulation） / 闪电贷联动

防范：









使用 Chainlink 这样的多节点、去中心化价格预言机，避免单点喂价。

采用 时间加权平均价格（TWAP） 或滑动平均，避免使用单个区块

内的瞬时价格。

对关键交易加入 价差限制 / 最大滑点、最小回报（如 minAmountOut）

等保护。

高风险场景中考虑增加 延迟执行窗口 或多阶段确认，降低单块操纵

的攻击面。

6\. DoS 与 Gas 相关攻击

防范：

避免无上限的 for / while 循环，特别是其中包含外部调用的情况；需

要批处理时尽量拆分为多笔交易，或引入“分页处理”机制。

不要在循环中同时对多个用户“主动打钱”，改为 记录余额 + Pull

Payment 提现 模式。

对潜在失败的外部调用，明确设计失败策略 （忽略/跳过/记录）而不是

盲目 require(success)。

7\. 业务逻辑缺陷（Logic Errors）

防范：

编写覆盖边界条件的 单元测试，包括极端输入、边界值、错误路径。

使用 模糊测试（Fuzzing） 和 不变式测试（Invariant Testing） 来验

证“协议永远应成立的条件” （比如不会出现负余额、总供应不会凭

空增加等）。基于 Foundry / Echidna 的不变式测试已经逐渐成为主流

做法。

对高价值协议，引入第三方审计与（必要时）形式化验证。

8\. 随机数不安全（Insecure Randomness）

防范：

通过 Chainlink VRF 等可验证随机数服务获取随机数，确保随机源不

可被单方操控。

对“开奖类”活动考虑多轮承诺与揭示（commit–reveal）方案，避免

单区块内就能决定结果。

9\. 可升级 / 代理合约风险（Upgradeability）

防范：

使用成熟的 OpenZeppelin Upgradeable 模板，严格遵守存储布局规则；

在实现合约中使用 initializer / reinitializer 模式，并在实现合约构造函

数中调用 \_disableInitializers()，避免被“重复初始化”接管所有权。

升级入口函数（如 upgradeTo）必须只对多签 + 时间锁控制，且要有

完整的审核流程（包括新实现合约的安全审计）。

10\. delegatecall 到不受信目标

防范：

严格限制 delegatecall 目标为自家合约或白名单地址，绝不允许用户

可控地址被直接用于 delegatecall。

对所有涉及 delegatecall 的设计做好存储布局审计与测试，避免变量

“串位”。

11\. ERC-20 交互细节与陷阱



兼容“非标准”代币： 有些老代币（如早期 USDT）在 transfer /

transferFrom 上不返回 bool，或在失败时 revert 而不返回 false。直

接调用容易造成逻辑混乱。

→ 使用 SafeERC20，在内部帮你统一处理这些分支。

授权（approve）竞态：简单地从 X 改到 Y 可能被“抢在中途”利

用，形成无限花费授权。

→ 优先使用 increaseAllowance / decreaseAllowance，或先 approve(0) 再设

新值；支持的话可优先采用 EIP-2612 permit 减少授权交互。

12\. 工具与流程（结合当前主流实践）

静态分析：

模糊测试 / 不变式测试：

审计与竞争审计（Audit / Code Arena）

13\. 一页式防• 设计模式： 

o CEI（Checks-Effects-Interactions）；

o Pull-Payment（提现）；

o nonReentrant 防重入。

• 语言层： 

o Solidity ≥ 0.8，默认有算术溢出检查；

o 仅在证明安全场景下使用 unchecked。

• 访问控制： 

o Ownable / AccessControl + 多签 + 时间锁；

o 禁止使用 tx.origin 鉴权。

• 外部调用： 

o 使用 call + 检查返回值，不再依赖 transfer / send 的 2300 gas；

o ERC-20 使用 SafeERC20。

• 预言机： 

o 使用多源预言机（如 Chainlink）+ TWAP + 阈值 / 时延保护清单

• 随机数： 

o 使用 Chainlink VRF 或 commit–reveal，避免直接用区块属性。

• 可升级合约： 

o 遵循代理 + 实现合约的标准模式；

o 注意 Dencun/EIP-6780 后 SELFDESTRUCT 行为已改变，不再

依赖其“清空合约”。

• 测试与审计： 

o 单元/边界测试 + Fuzz + 不变式测试；

o 引入专业审计和（需要时）形式化验证。

七、合约部署工具：Remix、Hardhat等

1\. Remix IDE:

2\. Hardhat:

3\. Foundry:

4\. Truffle Suite（+ Ganache）:

5\. Tenderly:

6\. 小结：





刚入门 / 上课 Demo / 小实验

o Remix 一把锁。

正式项目开发（中大型）

o Hardhat （工程化 + 插件丰富） 或 Foundry （ 性 能 + 测试 / fuzz

/ 显式 gas 优化），很多团队两者混用。

需要命令行 + 高强度测试 / fuzz / invariant

o 强烈建议了解 Foundry，配合 anvil/mainnet fork 做真实场景测

试。

维护老项目 / 用到 Ganache / Truffle 老生态

o 继续用 Truffle + Ganache 也没问题，逐步向 Hardhat / Foundry

迁移。

想做高级调试 / 主网级模拟 / 运维监控

o 在上面任意本地工具之上加一层 Tenderly，体验会显著提升。

八、合约部署后的公开性与可审计性

1.合约的公开性

字节码公开：

交易历史公开：

状态变量半公开：

2\. 合约的可审计性

源码验证（Source Verification）：

重要性：

3\. 常见审计方式

3.1 人工审计（Manual Review）

3.2 自动化工具审计（Static / Symbolic Analysis）Slither：Mythril：

3.3 社区审计 / Bug Bounty：

4\. 小结

是的，合约一经部署即“公开”： 

o 字节码、交易历史、事件日志对所有人可见；

o 状态变量在链上明文存储，只是访问接口不同

是的，合约是审计且应当被审计： 

o 通过 Etherscan / Polygonscan / Sourcify 等进行源码验证；

o 结合人工审计 + 静态分析工具（Slither、Mythril 等）提升安

全性；

o 再辅以社区审计与漏洞赏金，形成多层防线。

九、合约逻辑的修改与升级模式

1.为什么不能直接改？

2\. 现实中是怎么“修改”的？

3\. 最直接的：简单替换（重新部署新合约）

适用：无状态 / 状态很少 / 状态可离线迁移的小合约。

做法：

写好新版本合约，部署一个新地址；

前端 / SDK / 其他合约 改成指向新地址；

需要的话，把旧合约里的重要数据（余额、配置等）通过脚本“迁移”

到新合约（往往需要用户参与或批处理脚本）。

优点：

实现简单、逻辑清晰；

没有额外的代理复杂度。

缺点：

地址变了：所有依赖该地址的外部系统都要更新；

状态迁移成本高、容易出错——尤其是有大批用户余额、投票记录、

LP 头寸时。

4\. 行业主流：代理模式（Proxy Pattern）

核心思想：把“地址 + 存储”锁死，把“逻辑”换着用。

4.1 基本结构

Proxy（代理合约） 

地址固定：用户只和它交互；

存储状态：所有状态变量都写在这里；

内部只做一件事：把调用用 delegatecall 转发到当前“实

现合约”。

Implementation / Logic 合约 

里面是真正的业务代码；

不直接被用户调用（正常不会对外暴露接口）；

被认为是“可丢弃”的：升级就是换一个新实现。

Proxy 像是一间办公室，存档案 + 收客人；Logic 像是外包来的业务团队，

来去可以换，但档案永远放在办公室里不搬家。

4.2 两种主流形态

① Transparent Proxy Pattern

② UUPS （ Universal Upgradeable Proxy Standard，基 于 EIP-1822 + ERC-1967）

4.3 升级过程长什么样？

① 部署 v1 实现合约（LogicV1）；

② 部署 Proxy，指向 LogicV1，初始化状态；

③ 运行一段时间后，发现需要升级： 

部署 LogicV2（保证存储布局兼容）；

由 Admin （往往是多签 + Timelock）调用升级函数，把实现地址改成

LogicV2；

用户继续用原来的 Proxy 地址交互，但底层逻辑已经是 V2 了。

4.4 最新实践小贴士

不要自己手写 proxy：直接用 OpenZeppelin Upgrades + Hardhat / Foundry 插

件

5\. 数据与逻辑分离 / 模块化（State-Logic Separation）

EIP-2535 Diamond Standard（钻石标准）：

优点：

单个模块可独立升级 / 替换；

逻辑拆分清晰，适合超大型项目。

缺点：

实现和审计复杂度都比普通 Proxy 高很多；

如果路由或存储布局搞错，事故会非常难排查。

总结：模块化 = Proxy 的更重型版本，适合“协议城市级”项目，小项目

没必要一上来就玩钻石。

6\. “销毁再重建”套路：在上海升级（EIP-6780）后基本退场

7\. 可插拔模块（Pluggable Modules）

一般会配合 接口白名单 + 角色权限，否则“模块热插拔”也可能成

为攻击入口；

复杂协议常把“风控逻辑”、“清算逻辑”、“费率模型”做成独立

模块，以实现： 

o 在线调参（换一个利率模型模块）；

o 按市场环境更换风控（比如上线新的抵押品策略）。

8\. 实战上应该怎么选？

给读者一个“考试型总结”：

① 小玩具 / 无资金 / Demo 



直接重部署新合约 + 前端指向新地址即可。

② 有资金、要长期运营的 DeFi / NFT / DAO 





默认用 Proxy（Transparent 或 UUPS）模式；

升级权限挂在多签 + 时间锁上。

③ 超大型、模块众多的协议 



考虑 Diamond / 模块化架构，但要做好额外审计和工具支持。

④ 永远不要： 



指望“以后用 selfdestruct 把合约删了重来”——EIP-6780 已经让

这条路基本失效；



自己随手写 proxy、随手改存储布局又不做检查——现在已经有成熟

工具帮你做 layout check，没必要拿主网资金练手。
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->



智能合约开发

Dapp 架构和开发流程

1.      Dapp 架构

1.      前端（User Interface）：HTML、CSS 和 JavaScript

2.      智能合约（Smart Contracts）：Solidity

3.      数据检索器（Indexer）：PostgreSQL 等传统数据库中

4.      区块链和去中心化存储（Blockchain & Decentralized Storage）：

2.      Dapp 开发流程

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814468811-image.png)

a需求分析与规划

确定功能需求

选择区块链平台

设计用户体验

b智能合约开发

编写智能合约

编写测试用例

审计和优化

c检索器开发

确定功能需要的数据内容

编写检索器程序

部署和运维

d前端开发

选择前端框架

连接钱包

显示区块链数据

处理交易签名与确认

e与区块链交互

读取数据

发送交易

f部署与上线

部署智能合约

前端部署

发布和维护

二、以太坊开发环境搭建

1\. 基础环境准备

Node.js（建议用 nvm 管理）

npm 或 yarn

Git

2以太坊本地开发链

方式一：Foundry（Rust 实现，极快）

方式二：Hardhat（推荐，现代以太坊开发框架）

3\. 以太坊钱包和前端交互

推荐使用 MetaMask 浏览器插件作为开发钱包。

前端推荐使用 Viem 和 Wagmi。

三、RPC 节点服务详解

1\. RPC 是什么？

想象 RPC 节点就像银行的 ATM 机：

ATM 机（RPC 节点）连接着银行的核心系统（区块链网络）

你通过 ATM 机（调用 RPC API）可以查询余额（读取链上数据）、转账（发送交易）

不同的 ATM 机可能由不同的银行或服务商提供（不同的 RPC 服务商）

2.RPC 在 Web3 开发中的作用

读取链上数据,发送交易, 事件监听, 网络管理

3.      JSON-RPC 协议

常用 JSON-RPC 方法：

方法名    功能       示例

eth\_getBalance      查询账户余额      eth\_getBalance(address, block)

eth\_blockNumber  获取最新区块号   eth\_blockNumber()

eth\_sendTransaction     发送交易       eth\_sendTransaction(txObject)

eth\_call   调用合约（只读）      eth\_call(callObject, block)

eth\_getTransactionReceipt   获取交易收据      eth\_getTransactionReceipt(txHash)

eth\_getLogs   查询事件日志      eth\_getLogs(filterObject)

4.      主流 RPC 服务商对比

5.      如何获取和使用 RPC 端点

5.1   获取 RPC URL

5.2   在代码中使用 RPC

使用 Viem（推荐）：

import { createPublicClient, http } from ‘viem’

import { mainnet } from ‘viem/chains’

const client = createPublicClient({

chain: mainnet,

transport: http(‘[https://eth-mainnet.g.alchemy.com/v2/YOUR\_API\_KEY](https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY)’)

})

// 查询余额

const balance = await client.getBalance({

address: ‘0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb’

})

5.3   在 Hardhat 中配置 RPC

6.      RPC 使用最佳实践

保护 API Key

错误处理和重试

速率限制管理

多节点备份

监控和日志

本地节点开发

7.      常见问题与解决方案

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814493649-image.png)

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814512224-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814521177-image.png)

四、Solidity 智能合约编程（简单介绍）

版本声明

pragma solidity ^0.8.0;

数据类型

基本数据类型

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814568199-image.png)

复合数据类型

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814539765-image.png)

函数修饰符

可见性修饰符表

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814559432-image.png)

状态修饰符表

开发范式

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814580182-image.png)

状态机模式

智能合约本质上是一个状态机，通过交易改变合约状态。

事件驱动编程

使用事件（Events）记录重要的状态变化，便于前端监听和日志记录。

模块化设计

通过继承和库（Library）实现代码复用和模块化。

**1.      合约结构详解**

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract MyContract {

// 状态变量

uint256 public myNumber;

// 构造函数

constructor() {

myNumber = 100;

}

// 函数

function setNumber(uint256 \_number) public {

myNumber = \_number;

}

}

**状态变量（State Variables）**

contract MyContract {

/\*

\* 可以通过内部与外部函数更改变量

\* public可以通过前端代码访问

\*/

uint256 public totalSupply;

mapping(address => uint256) private balances;

address public owner;

// 常量

uint256 public constant MAX\_SUPPLY = 1000000;

// 不可变量（构造函数中设置一次）

uint256 public immutable deploymentTime;

constructor() {

owner = msg.sender;

deploymentTime = block.timestamp;

totalSupply = 0;

}

}

**函数（Functions）**

function <函数名>(<参数列表>)

<可见性>

<状态可变性>

<修饰符列表>

<虚拟/重写关键字>

returns (<返回值列表>)

{

// 函数体

}

**函数可见性（Function Visibility**

contract VisibilityExample {

// 仅当前合约可访问

function privateFunc() private pure returns(uint256) { return 1; }

// 当前合约和继承合约可访问

function internalFunc() internal pure returns(uint256) { return 2; }

// 所有人可访问

function publicFunc() public pure returns(uint256) { return 3; }

// 仅外部调用

function externalFunc() external pure returns(uint256) { return 4; }

}

**函数状态修饰符（State Mutability Modifiers）**

contract StateModifiers {

uint256 public count = 0;

// view: 只读函数，不修改状态

function getCount() public view returns(uint256) {

return count;

}

// pure: 纯函数，不读取也不修改状态

function add(uint256 a, uint256 b) public pure returns(uint256) {

return a + b;

}

// payable: 可接收以太币

function deposit() public payable {

// msg.value 是发送的以太币数量

}

// 默认：可修改状态

function increment() public {

count++;

}

}

**函数参数和返回值**

// 多个返回值

function getPersonInfo() public pure returns(string memory name, uint256 age) {

name = “Alice”;

age = 25;

}

// 命名返回值

function calculate(uint256 a, uint256 b) public pure returns(uint256 sum, uint256 product) {

sum = a + b;

product = a \* b;

// 自动返回命名变量

}

// 调用带多返回值的函数

function callExample() public pure {

(string memory name, uint256 age) = getPersonInfo();

// 或者忽略某些返回值

(, uint256 productOnly) = calculate(5, 3);

}

**修饰符（Function Modifiers）**

contract ModifierExample {

address public owner;

bool public paused = false;

constructor() {

owner = msg.sender;

}

// 自定义修饰符

modifier onlyOwner() {

require(msg.sender == owner, “Not the owner”);

\_;  // 继续执行被修饰的函数

}

modifier whenNotPaused() {

require(!paused, “Contract is paused”);

\_;

}

function togglePause() public onlyOwner {

paused = !paused;

}

// 使用多个修饰符

function criticalFunction() public onlyOwner whenNotPaused {

// 函数逻辑

}

}

**继承与函数重写（Inheritance and Override）**

// 基础合约

contract Animal {

string public name;

constructor(string memory \_name) {

name = \_name;

}

function speak() public virtual returns(string memory) {

return “Some sound”;

}

}

// 继承合约

contract Dog is Animal {

constructor(string memory \_name) Animal(\_name) {}

// 重写父类函数

function speak() public pure override returns(string memory) {

return “Woof!”;

}

}

// 多重继承

contract Pet is Animal {

address public owner;

constructor(string memory _name, address_ owner) Animal(\_name) {

owner = \_owner;

}

}

contract Labrador is Dog, Pet {

constructor(string memory _name, address_ owner)

Dog(\_name)

Pet(\_name, \_owner) {}

}

**接口与抽象合约**

// 接口定义

interface IERC20 {

function transfer(address to, uint256 amount) external returns (bool);

function balanceOf(address account) external view returns (uint256);

}

// 抽象合约

abstract contract AbstractToken {

string public name;

// 没有函数体的抽象函数，必须被子类使用 override 关键词重载实现

function totalSupply() public virtual returns (uint256);

// 有函数体实现的抽象函数，子类可以不使用 override 关键词重载直接继承已有的实现，也可以选择使用 override 关键词重载实现

function decimals() public view virtual returns (uint8) {

return 18;

}

}

**事件机制（Events）**

contract EventExample {

// 定义事件

event Transfer(address indexed from, address indexed to, uint256 amount);

event Approval(address indexed owner, address indexed spender, uint256 amount);

mapping(address => uint256) public balances;

function transfer(address to, uint256 amount) public {

require(balances\[msg.sender\] >= amount, “Insufficient balance”);

balances\[msg.sender\] -= amount;

balances\[to\] += amount;

// 触发事件

// 可以在区块链浏览器查找到当前事件记录

emit Transfer(msg.sender, to, amount);

}

}

2.      安全实践

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814665475-image.png)

重入攻击（Reentrancy）防护

访问控制（Access Control）

整数溢出防护（Integer Overflow Protection）

五、智能合约实战项目

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract MessageBoard {

// 保存所有人的留言记录

mapping(address => string\[\]) public messages;

// 留言事件，便于检索器和区块链浏览器追踪

event NewMessage(address indexed sender, string message);

// 构造函数，在部署时留言一条欢迎词

constructor() {

string memory initMsg = “Hello ETH Pandas”;

messages\[msg.sender\].push(initMsg);

emit NewMessage(msg.sender, initMsg);

}

// 发送一条留言

function leaveMessage(string memory \_msg) public {

messages\[msg.sender\].push(\_msg);     // 添加到发言记录

emit NewMessage(msg.sender, \_msg);   // 发出事件

}

// 查询某人第 n 条留言（从 0 开始）

function getMessage(address user, uint256 index) public view returns (string memory) {

return messages\[user\]\[index\];

}

// 查询某人一共发了多少条

function getMessageCount(address user) public view returns (uint256) {

return messages\[user\].length;

}

}

六、以太坊技术基础

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814693538-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814709687-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814724733-image.png)

七、部署合约

测试链部署的意义

浏览器可见性

1.      测试网

名称  共识机制       状态       主要特点       适用场景

Sepolia     PoS (权益证明)     活跃       长期支持的主要测试网，与主网最相似，稳定性高。     最终部署前测试，生产环境模拟，Dapp 集成测试

Holesky    PoS (权益证明)     活跃       专为验证者测试设计，大型网络规模，质押功能完整。 验证者节点测试， 质押协议开发，大规模网络测试。

2.      领取 Sepolia 代币

3.      Remix 部署到 Sepolia

八、区块链前端整合

1\. 前端与合约交互工作流程概览

1.2 交互流程

初始化连接：前端检测并连接 Web3 提供者

用户授权：请求用户授权访问钱包账户

合约实例化：使用 ABI 和合约地址创建合约实例

函数调用：通过合约实例调用智能合约函数

交易签名：钱包对交易进行数字签名

广播交易：将签名交易发送到区块链网络

状态更新：获取交易结果并更新前端界面

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768814749447-image.png)

1.1   关键技术栈

合约语言： 掌握 Solidity 等相关合约开发语言

Web3.js/Ethers.js： JavaScript 库，提供区块链交互 API (当前 Web3.js/Ethers.js 库比较老旧，本技术只用来学习理解整体流程，可以使用 Viem、Wagmi 进行新项目开发)

钱包连接器：如 RainbowKit、ConnectKit、WalletConnect、Web3Modal 等

状态管理：React Context 等管理连接状态

错误处理：网络异常、用户拒绝、Gas 不足等场景处理

2\. 实例操作

2.1 关键代码

开发语言：HTML + JavaScript + CSS（单页面集成）

代码规模：约 650 行

核心依赖库：Web3.js —— 用于与以太坊区块链进行交互

连接钱包

合约 ABI 定义

合约实例化

合约方法调用

一、 高阶内容

1.      Gas 优化

常见优化技巧

减少存储操作（Storage Write）使用位压缩（Bit Packing）循环优化 函数可见性选择

2.      合约安全

重入攻击 Reentrancy预言机操纵 Oracle Manipulation整数溢出/下溢 权限控制缺失 未初始化代理 前置交易/三明治攻击

3.      智能合约审计

3.1   常见的合约审计工具

Slither, MythX, Foundry

3.2   审计标准流程

静态分析（Static Analysis）：使用工具如 Slither、Mythril 扫描代码缺陷

动态测试（Fuzzing/Property Testing）：模拟攻击行为和极限条件

人工审查（Manual Review）：由资深审计员检查业务逻辑漏洞

审计报告生成（Audit Report）：明确发现的问题及修复建议

3.3   知名审计机构比较

4.      开发协作规范

**分支策略：**

主分支 (main/master)：始终保持可部署状态，任何代码合并前必须经过测试与审查。

开发分支 (develop)：用于日常功能开发，作为 feature 分支的合并目标。

功能分支 (feature/xxx)：以 feature/功能描述 命名，完成后合并至 develop 分支。

修复分支 (fix/xxx)：针对 bug 的修复，以 fix/bug-name 命名，优先合并到 develop 或 main。

发布分支 (release/xxx)：用于发布前准备，如版本打包、测试等，合并后删除。

提交信息规范

**类型包括：**

feat: 新功能

fix: 修复问题

docs: 文档更新

refactor: 代码重构

test: 添加或修改测试

chore: 构建过程或辅助工具变动

**Pull Request（PR）流程**

2.2   Issue 管理

2.3   开源协作礼仪

3.      Layer 2 解决方案

5.1 Rollup 技术比较

5.2 主流 L2 平台概览

5.3 开发入门指南

实践

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768816402441-image.png)

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768816470296-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-19-1768816725165-image.png)
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->





对其他资料进行学习并练习

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-17-1768671446434-image.png)

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-17-1768671519520-image.png)
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->






* * *

# 第三章：账户类型与结构深度解析

## 核心前置知识：CREATE 与 CREATE2

在深入账户之前，先理解以太坊上“创造”事物的两种原语：

-   **CREATE (传统方式):** 地址取决于 `sender` + `nonce`。
    
-   **CREATE2 (EIP-1014):** 地址取决于 `init_code` + `salt`。
    
    -   **核心价值：** **可预测性 (Deterministic Deployment)**。你可以在合约还没部署前，就通过计算得出它未来的地址。这对 L2 充值地址、反事实合约（Counterfactual instantiation）至关重要。
        

* * *

## 一、EOA 的定义与控制方式

定义： EOA (Externally Owned Account) 是由私钥直接控制的账户。

本质： “人 + 银行卡”。它没有代码，只能被动接受指令（私钥签名）。

### 1.1 结构与特征

-   **控制权：** 私钥持有人 = 账户主人。
    
-   **成本：** 创建 EOA 是免费的（只需生成一对公私钥），只有发交易才需要 Gas。
    

### 1.2 我是怎么“控制”一个 EOA 的？

1.  **私钥签名：** 所有的控制权最终都体现为“对交易数据的数字签名”。
    
2.  **助记词 (BIP-39) & 路径 (BIP-44)：**
    
    -   **BIP-39:** 将随机数转化为 12/24 个单词（助记词）。
        
    -   **BIP-44:** 定义派生路径（如 `m/44'/60'/0'/0/0`），从一个种子生出无数个私钥。
        
3.  **Nonce (交易计数器)：**
    
    -   防止**重放攻击**。
        
    -   确保交易按顺序执行（Nonce 0 执行完，Nonce 1 才能进区块）。
        

### 1.3 实战视角：开发者 vs 普通用户

-   **对开发者：**
    
    -   前端看到的 `0x...` 地址只是公钥的哈希截取。
        
    -   `msg.sender` 是 EOA 时，代表这是交易的发起起点（User）。
        
-   **对普通用户：**
    
    -   **私钥即资产**。助记词一旦泄露，资产瞬间归零。
        
    -   网页端输入助记词 = 100% 诈骗。
        

* * *

## 二、合约账户的概念与创建流程

定义： 合约账户 (Contract Account) 是由代码 (Code) 控制的账户。

本质： “写死规则的自动售货机”。它没有私钥，无法主动发起交易，只能被动响应。

### 2.1 创建流程：从代码到地址

1.  **编写：** Solidity 代码 -> 编译为 EVM 字节码。
    
2.  **交易：** 发送一笔 `to` 为空（null/zero）的交易，`data` 字段放入 `init code`。
    
3.  **执行：**
    
    -   EVM 运行 `init code`（通常包含构造函数逻辑）。
        
    -   `init code` 运行结束，`RETURN` 一段新的字节码。
        
    -   这段 **Runtime Code** 才是最终被存储在链上的代码。
        

### 2.2 合约地址的计算公式 (必考点)

-   普通 CREATE:
    
    $$Address = \\text{keccak256}(\\text{RLP}(sender, nonce))\[12:\]$$
    
    -   _缺陷：_ 如果 `nonce` 管理乱了，地址就变了，很难跨链保持一致。
        
-   CREATE2 (EIP-1014):
    
    $$Address = \\text{keccak256}(0xff + sender + salt + \\text{keccak256}(init\\\_code))\[12:\]$$
    
    -   **sender:** 部署工厂合约的地址。
        
    -   **salt:** 开发者自定义的随机数。
        
    -   **init\_code:** 合约的初始化代码。
        
    -   _优势：_ 只要参数不变，**无论在那条链、什么时候部署，地址永远一样**。
        

### 2.3 能力与限制

-   **能力：** 存储代码、持有资产、由代码逻辑控制转账。
    
-   **限制：** **无法主动发起交易**（必须由 EOA 踢第一脚），部署需要昂贵的 Gas。
    

* * *

## 三、以太坊地址“0x”开头的由来

-   **本体：** 160-bit (20字节) 的二进制数据。
    
-   **0x 前缀：** 编程界（C语言/Hex）的标准前缀，表示后面跟的是十六进制数。
    
-   **EIP-55 (Checksum)：**
    
    -   以太坊地址不区分大小写，但 EIP-55 利用大小写混写来做**校验和**。
        
    -   例如：`0x5aAeb6...`。如果你输错了一位，钱包会因为校验和不对而报错，防止转错账。
        

* * *

## 四、EOA 与合约账户的控制方式对比

| 特性 | EOA (个人账户) | 合约账户 (智能合约) |
| 控制核心 | 私钥 (Private Key) | 代码逻辑 (Code) |
| 生成成本 | 免费 (链下生成) | 昂贵 (需支付 Gas 上链) |
| 发起交易 | 可以 (一切交易的起点) | 不可以 (只能被调用) |
| 跨链一致 | 天然一致 (私钥在哪都一样) | 需用 CREATE2 技巧实现 |

### 4.1 进阶控制模型

1.  **多签 (Multisig):**
    
    -   **Gnosis Safe:** 一个合约账户，设定规则“必须集齐 3 个指定的 EOA 签名才能执行操作”。
        
    -   _优势：_ 消除单点故障，适合团队资金管理。
        
2.  **时间锁 (Timelock):**
    
    -   合约规定：操作发起后，必须等待 24 小时才能执行。
        
    -   _场景：_ 防止项目方恶意修改代码跑路，给社区预留撤资时间。
        

* * *

## 五、可主动发起交易的账户类型

**物理定律：** 链上的每一笔交易，起点**必须**是某个 EOA 的签名。合约不能自己“醒来”发交易。

### 5.1 为什么感觉合约有时候在“自动运行”？

-   **ERC-4337 (账户抽象):**
    
    -   **UserOperation:** 用户签一个“意图单”，不是标准交易。
        
    -   **Bundler:** 有个链下的“打工仔”（EOA），帮你收集意图单，并由他垫付 Gas 发起交易去调用合约。
        
    -   _本质：_ 还是有 EOA 在发交易，只是那个 EOA 不是你，而是 Bundler。
        
-   **Automation (Keeper):**
    
    -   Chainlink Keepers 等服务在链下轮询，一旦条件满足，机器人的 EOA 就会发起交易调用你的合约。
        
-   **EIP-7702 (Pectra 升级):**
    
    -   允许 EOA 在一笔交易中**临时**变身为智能合约账户，拥有批量处理、代付 Gas 等能力，交易结束后恢复原状。
        

* * *

## 六、合约账户的余额与状态存储

在以太坊的世界状态 (World State) 中，每个账户都由 4 个字段组成：

$$Account = (nonce, balance, storageRoot, codeHash)$$

1.  **nonce:**
    
    -   EOA: 发出的交易数量。
        
    -   Contract: 创建过的合约数量。
        
2.  **balance:** 余额 (Wei)。
    
3.  **storageRoot (仅合约有效):**
    
    -   指向一棵 Merkle Patricia Trie 的根节点。
        
    -   这里存着合约里所有的变量（Mapping, Array, uint 等）。
        
4.  **codeHash (仅合约有效):**
    
    -   合约字节码的哈希值。
        
    -   **EOA 的 codeHash 为空字符串哈希**，这是区分 EOA 和合约的最底层方法。
        

* * *

## 七、EOA 与合约账户的互相调用机制

-   **调用链：** `EOA (起点) -> 合约 A -> 合约 B -> 合约 C`。
    
-   **Msg.sender 变化：**
    
    -   在合约 A 中，sender 是 EOA。
        
    -   在合约 B 中，sender 是合约 A。
        
-   **Tx.origin：** 永远指向起点的那个 EOA（安全最佳实践：尽量少用 `tx.origin` 做鉴权，易受钓鱼攻击）。
    

* * *

## 八、MetaMask 钱包对 EOA 的管理

-   **核心逻辑：**
    
    -   **本地存储：** 私钥加密保存在浏览器本地存储 (Local Storage) 中，**绝不上传服务器**。
        
    -   **本地签名：** 当你需要发交易时，MetaMask 弹出窗口，解锁私钥，在本地对交易哈希进行签名。
        
    -   **广播：** 将签好名的二进制数据通过 RPC (如 Infura) 发送到区块链网络。
        
-   **账户抽象支持：** MetaMask 正通过 Snaps 和 EIP-7702 支持智能账户功能，让用户体验接近 Web2（如社交恢复、无感 Gas）。
    

* * *

## 九、ERC20 / ERC721 代币与合约账户的关系

这是一个常见的误区。

-   **误区：** “我的钱包里有 100 个 USDT。”
    
-   **真相：** 你的钱包里什么都没有，只有一把钥匙。
    
    -   USDT 是一个**智能合约**。
        
    -   合约里有一张巨大的 Excel 表格（Mapping）：
        
        -   `Alice: 100`
            
        -   `Bob: 20`
            
    -   **转账：** 你调用 USDT 合约的 `transfer` 函数，合约把表格里你的数字减 10，给别人加 10。
        

* * *

## 十、合约部署后的不可篡改性与销毁 (重要更新)

传统认知： 合约不可篡改，但可用 SELFDESTRUCT 销毁。

Dencun (Cancun) 升级后的新认知 (EIP-6780)：

1.  **代码不可更改：** 部署后，Runtime Code 永远固定。
    
2.  **SELFDESTRUCT 被废了：**
    
    -   为了适应 Verkle Tree 的状态管理，EIP-6780 改变了 `SELFDESTRUCT` 操作码的行为。
        
    -   **现在的行为：** 只有在**合约创建的同一笔交易中**调用 `SELFDESTRUCT`，才能真正删除代码和存储（主要用于临时性的 Gas 套利合约）。
        
    -   **后果：** 以前部署的合约，如果现在调用销毁函数，**只会转出余额，但代码和存储状态保留，合约依然存在**。
        
3.  **如何实现“升级”？—— 代理模式 (Proxy Pattern)**
    
    -   **Proxy 合约：** 存数据，地址不变。
        
    -   **Implementation 合约：** 存逻辑。
        
    -   **升级：** 修改 Proxy 指向一个新的 Implementation 合约地址。用户无感，数据保留。
        

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-17-1768631257163-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-17-1768631268896-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-17-1768631278375-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-17-1768631287533-image.png)
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->







今天学习web3的基础数据与合法合规基础，使用ai整理如下

* * *

# 简章：Web3 基础概念与合法合规指南

## 一、区块链基础概念：从技术到范式

### 1\. 区块链是什么？

-   **定义：** 一个去中心化、不可篡改、公开透明的**分布式账本数据库**。
    
-   **本质：** “信任机器”。它在没有第三方中介（如银行、支付宝）的情况下，通过数学和密码学解决了人与人之间的信任问题。
    

### 2\. 比特币 (BTC)：区块链的第一个杀手级应用

-   **定义：** 点对点的电子现金系统。
    
-   **价值来源：**
    
    -   **稀缺性：** 总量恒定 2100 万，被称为“数字黄金”，具有价值存储属性。
        
    -   **共识：** 全球算力保障网络安全，无需许可即可参与。
        
-   **公开透明 vs. 隐私：**
    
    -   **伪匿名性：** 你的名字是地址（一串乱码），但你的每一笔交易在链上所有人可见。
        
-   **缺点：** TPS（每秒交易量）低，转账慢，能耗高（PoW），脚本语言简单（非图灵完备，做不了复杂应用）。
    

### 3\. 区块链的核心组成部分

-   **P2P 网络：** 节点之间点对点通信。
    
-   **密码学：** 哈希函数（防篡改）、非对称加密（公私钥控制资产）。
    
-   **共识机制：** PoW（工作量证明）、PoS（权益证明），解决“谁来记账”的问题。
    
-   **智能合约（以太坊引入）：** 自动执行的代码。
    

### 4\. 公链、私链与联盟链（由开放程度划分）

| 类型 | 形象比喻 | 读写权限 | 特点 | 代表项目 |
| 公链 (Public) | 公共花园 | 任何人可读、可写 | 即使开发者跑路，链还在；完全去中心化，效率低。 | BTC, ETH |
| 联盟链 (Consortium) | 公司董事会 | 指定成员可读写 | 多个机构共同维护；部分去中心化，效率较高。 | Hyperledger Fabric |
| 私链 (Private) | 私人俱乐部 | 单个组织控制 | 中心化管理，只是用了区块链的数据结构；效率极高。 | 某些企业内部数据库 |

### 5\. Web 发展史：Web1 -> Web2 -> Web3

| 阶段 | 核心特征 | 行为模式 | 数据归属 | 代表 |
| Web1.0 | 只读 (Read Only) | 获取信息 | 平台 | 新浪, Yahoo (门户网站) |
| Web2.0 | 可读+可写 (Read + Write) | 交互、创造内容 | 平台垄断 (大数据杀熟) | 微信, 抖音, Twitter |
| Web3.0 | 可读+可写+拥有 (Read+Write+Own) | 拥有资产与数据 | 用户自己 | 以太坊, ENS, MetaMask |

### 6\. 去中心化的挑战（不可能三角）

-   **优势：**
    
    -   **信任最小化：** 代码即法律 (Code is Law)。
        
    -   **抗审查：** 只要有私钥，没人能冻结你的资产。
        
    -   **高弹性：** 全球节点分布，无单点故障。
        
-   **挑战：**
    
    -   **扩展性瓶颈：** 节点越多，达成共识越慢（TPS 问题）。
        
    -   **安全与治理：** 智能合约漏洞（被黑客盗取）无法回滚；DAO 治理效率低。
        
    -   **用户体验 (UX)：** 助记词难记，Gas 费波动大。
        

* * *

## 二、以太坊概览：世界计算机

### 1\. 以太坊 (Ethereum) 的定位

不仅是货币，更是一个**去中心化的应用平台**。如果说比特币是计算器，以太坊就是智能手机。

### 2\. 演进路线

-   **3.1 PoW 阶段 (过去)：** 依靠显卡挖矿，高能耗。
    
-   **3.2 The Merge (合并)：** PoW 转为 **PoS (权益证明)**，节能 99.9%，矿工变为验证者。
    
-   **3.3 未来升级 (The Roadmap)：**
    
    -   **Dencun 升级 (EIP-4844)：** 引入 **Blob** 数据包，专门给 Layer 2 (如 Arbitrum) 降低 Gas 费，被称为“L2 的省钱神器”。
        
    -   **分片 (Sharding)：** 从“执行分片”转向“数据分片 (Danksharding)”，专注于让以太坊成为通过 L2 扩展的数据可用性层。
        
    -   **Verkle Trees：** 优化存储，让轻节点也能验证数据。
        

### 3\. 以太坊生态分层架构

这是技术人员必须理解的架构：

-   **L1 (Layer 1 - 主网)：** 安全层，负责最终结算和数据可用性。贵，慢，但最安全。
    
-   **L2 (Layer 2 - 扩容层)：**
    
    -   **Rollups (主流)：** 在链下打包几百笔交易，压缩后传回 L1。
        
        -   **Optimistic Rollup:** (Arbitrum, Optimism) 默认交易有效，有欺诈证明窗口。
            
        -   **ZK-Rollup:** (zkSync, Starknet) 利用零知识证明，数学上保证有效，更快更难。
            
-   **侧链 (Sidechains)：** (Polygon PoS) 有自己独立的共识机制，安全性不如 L2，但便宜。
    

### 4\. 核心机制 (技术视角)

-   **账户系统：**
    
    -   **EOA (外部账户)：** 用户控制，有私钥。
        
    -   **CA (合约账户)：** 代码控制，无私钥，由 EOA 触发。
        
-   **Gas 模型：**
    
    -   公式：`Fee = Gas Used * Gas Price`。
        
    -   作用：防止死循环攻击，为网络计算资源定价。
        
-   **EVM (虚拟机)：** 准图灵完备的堆栈机，所有节点运行完全相同的代码。
    

* * *

## 三、行业赛道全览

### 1\. DeFi (去中心化金融) —— 华尔街的替代方案

-   **DEX (Uniswap):**
    
    -   **核心：** AMM (自动做市商) 机制。
        
    -   **公式：** `x * y = k` (恒定乘积)。无需挂单，人与合约交易。
        
-   **Lending (Aave/Compound):**
    
    -   **逻辑：** 超额抵押。抵押 100 美元的 ETH，借出 70 美元的 USDT。
        
-   **Stablecoin (MakerDAO):**
    
    -   **DAI：** 通过抵押加密资产生成的美元稳定币，去中心化发行。
        

### 2\. NFT (非同质化代币)

-   **本质：** 以前区块链记的是“钱”，NFT 记的是“物”或“所有权”。
    
-   **基础设施：** OpenSea (交易市场), Blur (聚合器)。
    

### 3\. DAO (去中心化自治组织)

-   把公司章程写进代码里。没有 CEO，只有提案 (Proposal) 和 投票 (Voting)。
    
-   **工具：** Snapshot (链下签名投票，省 Gas)。
    

### 4\. MEME (模因币)

-   **代表：** Doge, Pepe。
    
-   **逻辑：** 纯粹的情绪与注意力经济，高风险高回报的博彩性质。
    

### 5\. 新趋势 (技术前沿)

-   **账户抽象 (AA)：** 智能钱包。可以社交恢复私钥，可以用 USDT 支付 Gas，极大降低用户门槛。
    
-   **AI + Web3：** 使用区块链验证 AI 生成内容的真实性，或者去中心化算力网络。
    

* * *

## 四、安全与合规 (从业者必读)

**特别提示：** 无论技术如何创新，必须严守法律底线。**技术中立，但使用技术的人不中立。**

### 1\. 核心法律风险梳理 (尤其是中国大陆背景)

-   **发币风险：** 在中国大陆，ICO (代币发行融资) 被定性为**非法公开融资**。
    
-   **交易所风险：** 境内禁止开设交易所，涉及**非法经营罪**。
    
-   **OTC (场外交易) 风险：** 个人买卖币最容易遇到“黑钱”，导致银行卡冻结（冻卡），严重者涉及**帮信罪**（帮助信息网络犯罪活动罪）或**掩饰隐瞒犯罪所得罪**。
    

### 2\. 全球监管框架

-   **美国：** SEC (证券监管) 强势，判定很多代币是证券；CFTC 管商品。
    
-   **香港：** 拥抱 Web3，推行 VASP 牌照制度，允许散户交易大蓝筹 (BTC/ETH)。
    
-   **欧盟 (MiCA 法案)：** 目前全球最完善的加密资产监管框架。
    

### 3\. 入职与职业风险防范 (Web3 求职指南)

-   **薪酬合规：**
    
    -   很多 Web3 公司发 **USDT**。
        
    -   **风险：** 不交社保公积金；自行变现 USDT 时容易收到黑钱被冻卡；劳动合同主体往往在海外，国内维权难。
        
-   **项目审查：**
    
    -   **红线：** 涉赌 (博彩类游戏)、涉传 (拉人头、多级分销)、涉洗钱 (混币器)。
        
    -   **技术人员责任：** 在某些案件中，明知项目违法仍提供核心技术支持（如编写资金盘合约），技术人员会被作为**共犯**处理。
        

### 4\. 网络安全风险 (个人防护)

-   **钓鱼攻击 (Phishing)：** 假的 MetaMask 弹窗，假的官网链接。**永远不要在网页里输入助记词！**
    
-   **剪贴板劫持：** 复制地址后，粘贴出来的是黑客的地址。**转账前务必核对后四位。**
    
-   **社交工程：** 电报群里的“热心客服”私聊你，100% 是骗子。
    

* * *

### 重要概念图

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560765284-image.png)

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560776662-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560786295-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560796567-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560805591-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560816051-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-16-1768560826819-image.png)
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->








学习以太坊第二章

通过ai整理如下

* * *

# 第二章：以太坊节点与基础设施深度解析

本章核心：理解以太坊“肉身”是如何构成的。从合并后的双层架构，到节点间的 P2P 通信，再到不同类型节点的实际应用场景。

* * *

## 一、以太坊节点的双层架构 (The Merge 之后)

在“合并”之后，以太坊节点不再是单一软件，而是必须由**执行层**和**共识层**两个客户端配合运行。

### 1\. 核心组件拆解

| 组件名称 | 角色比喻 | 核心职责 | 常见软件 |
| 执行客户端 (Execution Client, EL) | 干活的工人 | 算账 + 状态：1. 维护内存池 (Mempool) 和世界状态 (State)。2. 执行 EVM 智能合约。3. 提供 JSON-RPC 接口 (给 dApp 用)。 | Geth (Go)Nethermind (C#)Erigon (Go) |
| 共识客户端 (Consensus Client, CL) | 法官 | 选块 + 投票：1. 运行 PoS 算法 (Casper FFG)。2. 追踪链头 (Head) 和最终性 (Finality)。3. 管理信标链 (Beacon Chain)。 | Prysm (Go)Lighthouse (Rust)Teku (Java) |
| 验证者客户端 (Validator Client) | 陪审团代表 | (可选组件)：只有质押了 32 ETH 的节点才需要。负责保管私钥，对区块进行签名。 | 通常包含在 CL 软件报里 |

### 2\. 内部通信：Engine API

-   **定义：** 执行层和共识层之间的“专线电话”（通常监听端口 `8551`）。
    
-   **安全机制：** 通过 **JWT Token** (JSON Web Token) 进行身份验证，确保只有你的 CL 能指挥你的 EL。
    
-   **交互流程 (Engine API 关键指令)：**
    
    -   `engine_newPayload`：CL 收到新块，扔给 EL 说“你算算这一块对不对”。
        
    -   `engine_forkchoiceUpdated`：CL 告诉 EL “现在的最新链头是这个，你把状态更新过去；或者，准备好打包下一个块”。
        
    -   `engine_getPayload`：CL 自己要出块时，找 EL 要打包好的交易数据。
        

> 📝 背诵版总结：
> 
> 以太坊节点 = 一台电脑 + 执行客户端 (EL) + 共识客户端 (CL) + Engine API (JWT 认证)。

* * *

## 二、P2P 网络与通信机制 (如何传八卦)

以太坊没有中央服务器，依靠 P2P 网络实现全球同步。这个过程分为三步：**发现、连接、传播**。

### 1\. 发现阶段 (Discovery) —— 找邻居

-   **协议：** 基于 **UDP** 的 Node Discovery Protocol (v5)。
    
-   **算法：** **Kademlia (DHT)**。
    
    -   _类比：_ 快递分拨中心。节点通过计算 ID 的“距离”，只保留逻辑距离最近的节点信息。
        
-   **动作：** `Ping` / `Pong` (确认在线) -> `FindNode` / `Neighbors` (交换通讯录)。
    
-   **目的：** 只为了获得对方的 IP 和端口，**不传输区块链数据**。
    

### 2\. 连接阶段 (Connection) —— 建管道

-   **协议：** 基于 **TCP** 的 RLPx / DevP2P。
    
-   **动作：** 在选中的邻居之间建立加密的 TCP 连接（默认端口 `30303`）。
    
-   **多路复用：** 在这一条 TCP 管道里，同时跑多种子协议（eth 协议传区块，snap 协议传快照）。
    

### 3\. 传播阶段 (Propagation) —— 传八卦

-   **核心机制：Gossip 协议 (八卦协议)**。
    
    -   _类比：_ 办公室谣言。你告诉 8 个人，这 8 个人再各自告诉 8 个人，消息瞬间指数级扩散。
        
    -   _优势：_ **高容错**（挂掉几个节点无所谓）、**快而不炸**（通过 Message ID 缓存去重，防止消息风暴）。
        
-   **数据类型：**
    
    -   **Gossip (广播)：** 新交易、新区块、PoS 投票。
        
    -   **Request/Response (点对点)：** “我要 100 号区块的数据” -> “给你”。用于历史数据同步。
        

* * *

## 三、节点类型与数据存储 (图书馆比喻)

根据存储数据的多少，节点分为三类。

### 1\. 全节点 (Full Node) —— “公共图书馆”

-   **存储：** 保存所有区块头和区块体，但**修剪**了旧的状态数据。
    
-   **能力：** 验证所有新交易，查询最新状态（现在谁有多少钱）。
    
-   **同步模式：Snap Sync (快照同步)**。
    
    -   _原理：_ 不从第 0 块开始跑，而是下载网络中最近的“状态快照”，然后从那里开始同步。这是目前最推荐的模式。
        

### 2\. 归档节点 (Archive Node) —— “国家档案馆”

-   **存储：** 保存所有区块，以及**创世以来所有历史时刻的状态**。
    
-   **能力：** **时间机器**。
    
    -   _场景：_ “查询 2018 年 5 月 1 日，Uniswap 某个池子的储备量是多少？”
        
    -   _代价：_ 存储极其昂贵（目前需 12TB+ SSD）。
        
-   **谁需要：** 区块浏览器 (Etherscan)、专业数据分析 (Dune, Nansen)、审计公司、调试历史 Bug 的开发者。
    

### 3\. 轻节点 (Light Client) —— “目录索引”

-   **存储：** 仅下载区块头。
    
-   **能力：** 依赖全节点获取数据，自己只验证 Merkle Root (目录) 是否正确。
    
-   **场景：** 手机钱包、嵌入式设备。
    

* * *

## 四、实战：运行与维护 (DevOps 视角)

### 1\. 为什么要自己跑节点？

开发者和机构运行全节点，是为了拿回三件东西：

1.  **隐私与安全：** 你的钱包不需要告诉 Infura 你的 IP 和你要查的地址。
    
2.  **抗审查：** 没人能切断你的 RPC 服务。
    
3.  **极速数据：** 本地 RPC (Localhost) 延迟极低，适合套利机器人。
    

### 2\. 硬件参考配置 (主网全节点)

-   **CPU:** 4 核+ (建议高性能单核主频，利于 EVM 执行)。
    
-   **RAM:** 16 GB+ (32 GB 更佳，防止 OOM)。
    
-   **Disk:** **2 TB NVMe SSD** (必须是 NVMe，SATA SSD 的 IOPS 撑不住以太坊的读写压力)。
    
-   **Bandwidth:** 25 Mbit/s+ 上行。
    

### 3\. 运维关键点

-   **同步模式选择：**
    
    -   执行层 (EL): 使用 **Snap Sync** (Geth 默认) 或 Path-based storage (Geth 新特性/Reth)。
        
    -   共识层 (CL): 使用 **Checkpoint Sync** (从一个可信节点秒级同步最新的信标链头，不需要从头同步)。
        
-   **监控：** 暴露 Metrics 端口，使用 Prometheus + Grafana 监控区块高度、内存占用和 Peer 数量。
    

* * *

## 五、拓展：不跑节点的数据分析方案

如果你只是做数据分析，不一定要自己维护服务器。

| 方案 | 工具/平台 | 优点 | 缺点 | 适用人群 |
| SQL 分析平台 | Dune, Flipside | 零运维，直接写 SQL 画图，数据已清洗 | 有延迟，查不到未打包交易 (Mempool) | 分析师、研报作者 |
| 数据仓库 | Google BigQuery | 企业级数仓，可结合 AI/ML 工具 | 数据更新有延迟，按查询量付费 | 熟悉 GCP 的数据团队 |
| RPC 服务商 | Infura, Alchemy | 简单，类似本地节点体验 | 有速率限制 (Rate Limit)，也是中心化的 | dApp 前端开发、轻量脚本 |
| 区块浏览器 API | Etherscan | 只有简单的 HTTP 请求 | 功能受限，适合查余额和交易记录 | 简单的 Python 爬虫 |

* * *

### 重要图片：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-15-1768464669878-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-15-1768464691221-image.png)
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->









今天开始学习eth入门，认真学习第一章3个小节之后摘取关键词构成大纲如下

以太坊常见概念

1以太坊的起源与发展，

2以太坊的定位与特性：智能合约，dpps，tokens，pos，pow，gas，EIP-4844与 Dencun 升级，分片与 Danksharding，叔块。

3eth定义与职能

1gas的交易与计算

交易公式

Gas费的波动

2\. 参与网络共识与安全

质押（Staking）资产

获得奖励（Rewards）

提供经济安全（Security / “保证金”）

3\. 奖惩机制：为什么验证者会被奖励或被 Slashing？

奖励：验证者的收益构成

惩罚：什么是 Slashing？为什么要这么狠？

4\. 价值储存和交换媒介

数字货币与投资资产

DeFi 生态的抵押品与流动性基石

NFT 与数字经济的基石货币

5\. NFT 与同质化 / 非同质化代币

什么是 NFT

常见 NFT 标准

那什么是“同质化代币”四、以太坊为何被誉“全球可编程区块链”

1. 区块链（Blockchain）——信任的基石

2\. 可编程（Programmable）——让以太坊脱颖而出的关键

3\. 什么是智能合约？

4\. 图灵完备（Turing-complete）

5\. 全球性（Global）——“世界计算机”的愿景

五、以太坊与比特币的异同对比

1. 相似点

2\. 不同点

3\. 为什么比特币被称为“数字黄金”？

六、以太坊 dApps 的概念与应用

1. dApp 的几个核心技术特征

2\. dApp 开发的好处

3\. dApp 能做些什么？

4\. dApp 开发的缺点 / 代价

七、以太坊的去中心化实现机制

1. 共识与出块（技术 / 经济层）

2\. 节点与网络（技术层）

3\. 客户端多样性（实现层）

4\. MEV 与 PBS（市场结构层）

5\. 「Rollup-中心」路线与数据去中心化（扩容 / 职责分离）

6\. 治理（社会层）

7\. 多个机制叠加出来的「去中心化」

8\. 做个补充：什么是 P2P 网络？

八、网络结构的开放性与参与机制

1. 节点越来越多，会带来什么问题？

2\. 节点多了，共识会不会变慢？——共识效率

3\. 那以太坊是怎么“又要人多、又要跑得快”的？

4\. 总结一句话：以太坊到底能不能“无限制参与”？

九、行业应用案例：金融、游戏与社交

1. 去中心化金融（DeFi、稳定币、RWA）

2\. 游戏、虚拟世界与 NFT

3\. 社交、内容创作与 DAO / 公共物品

十、生态系统创新：DeFi、NFT与DAO

1. 去中心化金融（DeFi）：重塑全球金融“操作系统”

2\. 非同质化代币（NFT）： 从 “所有权证明”到“链上身份与权

限系统”

3\. 去中心化自治组织（DAO）： 把 “组织结构图”写进代码

十一、社区与开发生态扮演的角色

1. 社区之中

2\. 开发生态系统

使用ai整理扩充如下：

* * *

# 以太坊 (Ethereum) 深度学习笔记

## 第一部分：起源、定位与核心架构

### 1\. 起源与发展

-   **起源：** 2013 年由 Vitalik Buterin 发布白皮书，旨在创建一个“下一代智能合约和去中心化应用平台”。2015 年主网（Frontier）上线。
    
-   **关键转折 (The Merge)：** 2022 年，以太坊从工作量证明 (PoW) 转换为权益证明 (PoS)，标志着能源消耗降低 99.9%，并改变了代币发行模型。
    

### 2\. 定位与特性

以太坊不仅是加密货币，更是\*\*“世界计算机” (World Computer)\*\*。

-   **智能合约 (Smart Contracts)：** 存储在链上的自动执行程序（通常用 Solidity 编写）。一旦部署，无法篡改。
    
-   **dApps (去中心化应用)：** 前端（Web/App）+ 后端（智能合约）的架构。
    
-   **EVM (以太坊虚拟机)：** 执行智能合约代码的运行时环境。
    
-   **叔块 (Uncle Blocks)：**
    
    -   _PoW 时代：_ 指那些合法但未成为主链一部分的区块（因为传播延迟）。以太坊曾奖励叔块以提高网络安全性。
        
    -   _PoS 时代：_ 概念已淡化，主要由 Slot（时隙）和 Epoch（周期）机制替代，重组（Reorg）概率大大降低。
        

### 3\. 核心升级与扩展性 (Scaling)

这是目前以太坊最前沿的技术方向，主要为了解决“贵”和“慢”的问题。

-   **分片 (Sharding) vs. Danksharding：**
    
    -   _旧路线 (Sharding)：_ 原计划将以太坊分成 64 条链并行处理交易（执行分片）。
        
    -   _新路线 (Danksharding)：_ 放弃执行分片，专注于**数据可用性 (Data Availability)**。即以太坊主网主要充当 Layer 2 (L2) 的安全数据层，计算交给 L2 做。
        
-   **EIP-4844 (Proto-Danksharding) 与 Dencun 升级：**
    
    -   **核心：** 引入了一种新的交易类型，携带 **Blob (Binary Large Object)** 数据。
        
    -   **作用：** Blob 就像一个外挂的“临时存储包”，专门给 L2 (如 Optimism, Arbitrum) 存数据用。Blob 数据在大约 18 天后会自动过期删除，不像普通 Call Data 那样永久存储，因此费用极低。
        
    -   **结果：** L2 的 Gas 费大幅降低（降幅可达 90% 以上）。
        

* * *

## 第二部分：ETH 的定义与职能

ETH 是以太坊网络的原生资产，兼具**燃料**、**保证金**和**货币**三重属性。

### 1\. Gas：交易与计算的燃料

Gas 是为了防止死循环和滥用网络资源而设计的计费单位。

**Gas 费计算公式 (EIP-1559 标准)**

在伦敦升级后，交易费不再是简单的竞价，而是分为两部分：

$$\\text{Total Fee} = (\\text{Base Fee} + \\text{Priority Fee}) \\times \\text{Gas Used}$$

-   **Base Fee (基础费)：** 由协议根据上一区块的拥堵情况自动调整。**这部分 ETH 会被直接销毁 (Burn)，导致 ETH 通缩。**
    
-   **Priority Fee (小费/Tip)：** 用户付给验证者的额外费用，以求优先打包。
    
-   **Gas Used：** 实际操作消耗的计算量（例如：普通转账是 21,000 Gas，复杂的 DeFi 交互可能几十万）。
    

**Gas 费的波动**

-   **供需关系：** 当大量用户抢着发交易（如热门 NFT 发售），区块空间供不应求，Base Fee 飙升。
    

### 2\. 共识与安全：权益证明 (PoS)

用户通过质押 ETH 成为验证者 (Validator)，维护网络安全。

-   **质押 (Staking)：** 需要锁定 **32 ETH** 才能激活一个验证者节点。
    
-   **职责：**
    
    1.  **Attesting (证明)：** 对其他验证者的区块进行投票签名，确认其有效性。
        
    2.  **Proposing (提议)：** 被随机选中时，打包并广播新区块。
        

### 3\. 奖惩机制 (Carrot and Stick)

**奖励 (为什么要做验证者？)**

验证者的收益来源主要有三部分：

1.  **共识奖励 (Issuance)：** 协议增发的 ETH，奖励给完成 Attesting 和 Proposing 的节点。
    
2.  **Priority Fees (小费)：** 用户交易中的小费部分。
    
3.  **MEV (最大可提取价值)：** 验证者通过重新排序交易（例如夹子攻击、套利）获得的额外收益。
    

**惩罚 (Slashing & Inactivity)**

为了防止验证者作恶，系统设计了严厉的惩罚：

-   **Inactivity Leak (怠工扣除)：** 如果节点离线，只是慢慢扣除少量余额。
    
-   **Slashing (罚没)：** **针对恶意行为的重罚**。
    
    -   _触发条件：_ \* **Double Signing (双签)：** 在同一高度签署了两个不同的区块。
        
        -   **Surround Vote：** 违反投票规则，试图分叉链。
            
    -   _后果：_ 立即扣除一部分 ETH（如 1 ETH），并将验证者强制驱逐出网络。且在驱逐期间，如果有很多其他人也被 Slash，扣除金额会指数级上升（反共谋机制）。
        
    -   _为什么这么狠？_ 为了解决 PoS 的“无利害关系 (Nothing at Stake)”问题，增加攻击成本，确保区块链的不可篡改性（Finality）。
        

### 4\. 价值储存与交换媒介

-   **数字石油：** 任何使用以太坊网络的人都必须消耗 ETH。
    
-   **DeFi 基石：** 在 MakerDAO、Aave 等协议中，ETH 是主要的抵押品 (Collateral)，用于生成稳定币或借贷。
    
-   **计价单位：** NFT 市场通常以 ETH 计价。
    

* * *

## 第三部分：代币标准 (Tokens & NFT)

在以太坊上，“代币”本质上只是一个智能合约账本。

### 1\. 同质化代币 (Fungible Tokens)

-   **定义：** 每一个代币都是完全一样的，可互换，可分割。例如：你手里的 1 USDC 和我手里的 1 USDC 没有任何区别。
    
-   **标准：ERC-20**
    
    -   定义了转账 (`transfer`)、授权 (`approve`)、余额查询 (`balanceOf`) 等标准接口，使得钱包和交易所能通用处理。
        

### 2\. 非同质化代币 (NFT)

-   **定义：** 每一个代币都是独一无二的，拥有唯一的 **Token ID**。
    
-   **特性：**
    
    -   **唯一性：** 通过 `Contract Address + Token ID` 确权。
        
    -   **不可分割：** 通常只能整个交易（但在碎片化协议中可拆分）。
        
    -   **Metadata (元数据)：** 链接到图片、属性描述等文件。
        
-   **常见标准：**
    
    -   **ERC-721：** 最基础的 NFT 标准（一个 ID 代表一个资产）。
        
    -   **ERC-1155：** 多重代币标准。在一个合约里可以同时包含同质化（如游戏金币）和非同质化（如游戏道具）代币，Gas 费更低，适合链游。
        

这是为您整理扩充的以太坊进阶学习笔记（第四至第十一章）。

这部分内容从**技术原理**深入到了**网络架构**、**生态应用**以及**社会治理**层面，不仅回答了“以太坊是什么”，更解释了它“为什么这么设计”以及“它能改变什么”。

* * *

# 四、以太坊为何被誉“全球可编程区块链”

以太坊的核心创新在于将区块链从单一的“记账本”升级为了“操作系统”。

### 1\. 区块链（Blockchain）——信任的基石

-   **本质：** 一个去中心化的、不可篡改的分布式账本。
    
-   **作用：** 解决了“双花问题”（Double Spending）和拜占庭将军问题，在没有第三方中介的情况下建立了信任。
    

### 2\. 可编程（Programmable）——关键差异

-   **对比：** 比特币主要是为了记录“谁给谁转了多少钱”（脚本语言非常有限）。
    
-   **以太坊：** 允许开发者部署**任意逻辑**的代码。你可以写一个条件：“如果明天不下雨，且 A 给 B 转了 10 ETH，那么 C 就自动获得一张门票”。这种灵活性使得以太坊不仅是货币，更是平台。
    

### 3\. 什么是智能合约 (Smart Contract)？

-   **定义：** 运行在以太坊区块链上的计算机程序。
    
-   **比喻：** **自动售货机**。你投入资金，按下按钮（调用函数），机器自动执行预定逻辑（出货），无需售货员（中介）干预。
    
-   **特性：** 代码即法律（Code is Law）。一旦部署，无法被任何人（包括开发者）单方面修改或停止（除非预留了升级接口）。
    

### 4\. 图灵完备（Turing-complete）

-   **含义：** 理论上，以太坊虚拟机 (EVM) 可以执行任何可计算的算法（包括循环）。
    
-   **代价：** 图灵完备意味着可能出现“死循环”。为了防止死循环卡死全网节点，引入了 **Gas 限制**机制——程序跑多少步就收多少费，钱花完了程序就会强制停止。
    

### 5\. 全球性（Global）——“世界计算机”

-   **单例状态机：** 全球成千上万个节点维护着**同一个**状态（State）。
    
-   **永不停机：** 只要世界上还有一个节点在运行，这台“计算机”就不会关机，且任何人都无法被审查或禁止使用。
    

* * *

# 五、以太坊与比特币的异同对比

### 1\. 相似点

-   **底层技术：** 都基于 P2P 网络、密码学哈希、公私钥体系。
    
-   **去中心化：** 都没有中心化服务器，依靠社区维护。
    
-   **价值属性：** 都有原生代币（BTC, ETH）作为激励。
    

### 2\. 不同点 (关键)

| 特性 | 比特币 (Bitcoin) | 以太坊 (Ethereum) |
| 核心定位 | 数字黄金，货币支付系统 | 世界计算机，dApp 平台 |
| 账户模型 | UTXO (未花费交易输出) | Account Model (账户/余额模型) |
| 出块时间 | 约 10 分钟 | 约 12 秒 (每个 Slot) |
| 编程语言 | Script (堆栈语言，非图灵完备) | Solidity, Vyper (图灵完备) |
| 货币发行 | 总量恒定 2100 万 | 无硬顶，但通过 EIP-1559 销毁实现动态通缩 |
| 共识机制 | PoW (工作量证明) | PoS (权益证明) |

### 3\. 为什么比特币被称为“数字黄金”？

-   **稀缺性：** 2100 万枚的硬性上限，使其具有极强的抗通胀属性。
    
-   **稳定性：** 代码极少变动，追求极致的安全和简单，适合作为价值储存 (Store of Value)。
    

* * *

# 六、以太坊 dApps 的概念与应用

### 1\. dApp 的核心技术特征

-   **后端：** 智能合约（运行在链上）。
    
-   **前端：** 网页或 App（通过 Ethers.js/Web3.js 与链交互）。
    
-   **数据：** 存储在区块链上，公开透明。
    
-   **身份：** 使用钱包地址（如 MetaMask）登录，无需注册账号密码。
    

### 2\. dApp 开发的好处

-   **零停机时间：** 没有中心化服务器可以被攻击瘫痪。
    
-   **抗审查：** 开发者也无法封禁特定用户。
    
-   **可组合性 (Composability)：** “货币乐高”。一个 dApp 可以直接调用另一个 dApp 的合约（例如：在 Uniswap 换币，立刻放入 Aave 借贷），无需申请 API 权限。
    

### 3\. dApp 能做些什么？

-   **金融 (DeFi)：** 借贷、交易、保险。
    
-   **游戏 (GameFi)：** 玩家真正拥有装备（NFT）。
    
-   **社交：** 内容所有权归用户，而非平台。
    

### 4\. dApp 开发的缺点 / 代价

-   **不可篡改的风险：** 代码一旦有 Bug（如资金被盗），很难回滚，通常只能重新部署。
    
-   **用户门槛：** 需要用户安装钱包、购买 ETH 支付 Gas 费。
    
-   **性能瓶颈：** 链上交互速度受限于区块确认时间。
    

* * *

# 七、以太坊的去中心化实现机制

以太坊的去中心化不是单一维度的，而是多层叠加的结果。

1.  **共识与出块（技术/经济层）：** PoS 机制降低了参与门槛（不需要买矿机），只需要 32 ETH（或通过 Lido 少量参与），让更多人能维护网络。
    
2.  **节点与网络（技术层）：** 任何普通电脑都可以运行“节点”来验证账本，不依赖大机构的数据。
    
3.  **客户端多样性（实现层）：** 以太坊有多种客户端软件（Geth, Nethermind, Prysm, Lighthouse 等）。如果一种软件出了 Bug，其他软件还能正常运行，防止全网瘫痪。（这点非常重要，区别于大多数公链）。
    
4.  **MEV 与 PBS（市场结构层）：**
    
    -   **问题：** 打包区块能赚很多钱（MEV），导致只有专业大户能做。
        
    -   **解决：** **PBS (提议者-构建者分离)**。让专业的“构建者”去拼装最赚钱的区块，然后卖给普通的“提议者”去广播。这样普通验证者也能分享收益，避免算力集中。
        
5.  **「Rollup-中心」路线（扩容）：** L1（主网）只负责最核心的安全和数据，L2（Rollup）负责跑得快。职责分离，保证主网足够轻、足够去中心化。
    
6.  **治理（社会层）：** EIP (以太坊改进提案) 流程。没有 CEO，依靠社区讨论、开发者编写代码、节点自愿升级来达成共识。
    
7.  **P2P 网络 (补充)：** 点对点网络。所有计算机地位平等，没有“中央服务器”。你既是客户端，也是服务器。
    

* * *

# 八、网络结构的开放性与参与机制

### 1\. 节点越来越多，会带来什么问题？

-   **网络延迟：** 消息在几万个节点间传播需要时间。
    
-   **状态膨胀：** 硬盘存储压力越来越大，导致普通人跑不动节点。
    

### 2\. 节点多了，共识会不会变慢？

-   **会。** 以前几千人投票很快，现在几十万人投票（Attestation），收集签名的开销巨大。
    

### 3\. 以太坊如何“又要人多、又要跑得快”？

-   **BLS 聚合签名：** 一种密码学技术，可以将成千上万个签名压缩成一个很小的签名，极大地减轻了验证负担。
    
-   **委员会机制 (Committees)：** 不需要每轮都让几十万验证者投票，而是每轮随机选出一组人（委员会）代表大家投票。
    

### 4\. 总结：能“无限制参与”吗？

-   **准入无限制（Permissionless）：** 任何人只要有 ETH 和电脑就能加入。
    
-   **技术有物理上限：** 带宽、计算和存储能力限制了区块不能无限大（这也是为什么要有 Gas Limit）。
    

* * *

# 九 & 十、行业应用与生态创新 (DeFi, NFT, DAO)

这部分是**智能合约**的具体表现形式。

### 1\. DeFi (去中心化金融)：重塑“金融操作系统”

-   **核心：** 用代码代替银行和交易所。
    
-   **三大支柱：**
    
    -   **DEX (如 Uniswap)：** 自动做市商 (AMM) 机制，不需要挂单撮合，人与合约交易。
        
    -   **Lending (如 Aave)：** 超额抵押借贷。抵押 ETH，借出 USDT。
        
    -   **Stablecoins (如 DAI/USDT)：** 链上的法币桥梁。
        
-   **RWA (现实资产代币化)：** 将国债、房地产映射到链上（目前的超级热点）。
    

### 2\. NFT (非同质化代币)：链上身份与权限

-   **不仅是小图片：** 它是**数字所有权证书**。
    
-   **应用演进：**
    
    -   1.0：艺术品、头像 (PFP)。
        
    -   2.0：游戏道具、土地。
        
    -   3.0：**SBT (灵魂绑定代币)** —— 你的链上学历证书、信用评分、会员资格（不可转让）。
        

### 3\. DAO (去中心化自治组织)：代码化的公司

-   **定义：** 规则写在智能合约里的组织。
    
-   **决策：** 持有代币 = 拥有投票权。
    
-   **案例：**
    
    -   **ConstitutionDAO：** 几万人集资竞拍美国宪法副本。
        
    -   **MakerDAO：** 管理 DAI 稳定币的参数和金库。
        

* * *

# 十一、社区与开发生态

以太坊最强大的护城河不是技术，而是**人**。

### 1\. 社区之中

-   **Layer 0 (社会层)：** 拥有加密领域最庞大、最活跃的开发者社区。
    
-   **价值观：** 崇尚开源、去中心化、公共物品 (Public Goods) 建设。
    

### 2\. 开发生态系统

作为开发者（你现在的角色），这是你的工具箱：

-   **开发框架：** Hardhat, Foundry (Solidity 开发利器).
    
-   **客户端库：** **Ethers.js** (你的重点), Web3.js, Viem.
    
-   **基础设施：** Infura/Alchemy (节点服务), The Graph (数据索引), Chainlink (预言机).
    
-   **黑客松：** ETHGlobal 等活动不断诞生新的独角兽项目。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->











今天使用小狐狸钱包在谷歌测试网领取了测试eth，并在Unphishable上完成了常见的一些web3钓鱼骗局，使用ai总结如下

### 1\. 授权钓鱼 (Approval Phishing)

这是目前 DeFi 领域最普遍的攻击方式之一。

-   **原理**：骗子诱导用户在虚假网站上点击按钮（通常伪装成“领取空投”、“验证钱包”或“低价Mint”），实际上是让用户签署一个 `approve`（授权）交易。
    
-   **后果**：一旦签署，攻击者就获得了你钱包中特定代币（如 USDT、USDC）的**无限转账权限**。即使你不泄露私钥，攻击者也能随时转走你授权的资产。
    
-   **进阶版**：**Permit2 签名钓鱼**。这是利用 Uniswap 的 Permit2 协议进行的更隐蔽的授权攻击，通过离线签名即可授权代币转移，用户往往难以察觉。
    

### 2\. 助记词/私钥骗局 (Seed Phrase Scams)

这是最古老但依然有效的手段。

-   **原理**：
    
    -   **虚假客服**：在 Discord 或 Telegram 上冒充官方人员，声称你需要“同步钱包”或“修复故障”，并发给你一个伪造的网页，要求输入助记词。
        
    -   **虚假工具**：伪装成钱包插件或空投查询工具，在“连接钱包”时直接弹窗要求输入 12 到 24 个助记词。
        
-   **后果**：助记词一旦泄露，攻击者拥有你钱包的完全控制权，资产会被瞬间洗劫一空。
    

### 3\. 空投骗局 (Airdrop Scams)

利用用户的贪婪心理（FOMO）进行的诈骗。

-   **原理**：攻击者在链上向你的钱包发送一种毫无价值的诱饵代币（Token），或者在社交媒体上大肆宣扬某个知名项目的“官方空投”。
    
-   **手段**：当你试图去某个网站兑换（Swap）这些代币，或领取空投时，该网站会诱导你进行上述的“授权钓鱼”或“签名钓鱼”。
    
-   **危险信号**：钱包里莫名其妙出现的大额“空投币”通常都是陷阱。
    

### 4\. 零元购/签名钓鱼 (Eth\_sign / Blind Signing)

-   **原理**：利用 `eth_sign` 等底层签名方法，让用户签署一段无法读懂的十六进制数据（盲签）。
    
-   **后果**：这段数据实际上可能是一个授权交易甚至是私钥相关的操作指令。
    
-   **Unphishable 演示**：平台会演示这种看起来像是一串乱码的签名请求有多危险，现在主流钱包（如 MetaMask）通常会对这类签名发出红色警报。
    

### 5\. 地址投毒 (Address Poisoning)

针对用户“复制粘贴”习惯的攻击。

-   **原理**：攻击者利用脚本监控你的链上活动，生成一个与你常用转账地址**首尾字符完全相同**（例如前4位和后4位一致）的虚假地址。
    
-   **手段**：攻击者向你的钱包发送一笔小额交易（0 USDT 或 0.01 美元），让这个假地址出现在你的交易记录中。
    
-   **后果**：当你下次通过“历史记录”复制地址进行转账时，如果不仔细核对中间的字符，很容易误将资金转给黑客。
    

### 6\. 剪贴板劫持 (Clipboard Hijacking)

-   **原理**：通过植入在电脑或手机中的恶意软件（通常是在下载假冒的钱包应用或破解软件时感染），监控你的剪贴板。
    
-   **手段**：当你复制一个加密货币地址时，恶意软件会瞬间将其替换为黑客的地址。
    
-   **后果**：如果你在粘贴后不复查地址，资金将直接转入黑客手中。
    

### 7\. Punycode 域名攻击

-   **原理**：注册一个看起来和正规域名极度相似的域名。例如，用西里尔字母的 `а` 代替英文字母的 `a`。
    
-   **手段**：在浏览器地址栏中，它看起来几乎和官方网站一模一样（如 `opensea.io` 实际上可能是伪造的字符），诱导用户登录并进行操作。
    

核心教育理念可以归纳为以下几点防御策略：

1.  **所见即所签**：永远不要签署你看不懂的签名请求（尤其是红色警告的盲签）。
    
2.  **核对地址**：转账时务必核对地址的完整字符，而不仅仅是首尾。
    
3.  **甚至不信“自己”**：不要盲目信任交易历史中的地址，也不要盲目信任剪贴板。
    
4.  **物理隔离**：绝不在任何网页输入助记词，助记词只应存放在物理介质（纸、钢板）或硬件钱包中。
    

通过学习可以提高自己对使用链上工具的敏感性，保护自己的资产。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-13-1768302246710-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-13-1768302279782-image.png)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/qwq6155/images/2026-01-13-1768302296903-image.png)
<!-- DAILY_CHECKIN_2026-01-13_END -->
<!-- Content_END -->
