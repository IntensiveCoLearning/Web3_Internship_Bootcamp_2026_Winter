---
timezone: UTC+8
---

# bruce237

**GitHub ID:** bruce237

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
web3 投研

研究项目基本面 研究项目背景 研究经济模型

包括项目的技术，团队，社区等。了解行业，赛道和竞争格局。分析代币供应，分配，效用和治理。

投研，是通过对项目的深入分析，来判断其投资价值的过程

投研的本质

主流币不需要投研，投研只针对山寨币以下的资产——流动性外溢效应

在海量的信息与资产中，精准发现被低估的真正价值，并在合适的时机行动，最终收获价值回归的红利。

深度挖掘

穿透表象，洞察项目核心价值。

精准评估

量化风险收益，判断真实价格。

时机把握

等待市场错配，果断执行决策。

为什么不行？

为什么会出现这种情况呢？核心原因在于流动性不足。

主流资产市场

BTC/ETH等主流币种

资金是否溢出 → （是）→ 山寨币市场

中小市值币种

资金流动 → “资金从主流向山寨转移”

（否）

结论：流动性是资产价值的基石，缺乏有效流动将导致价值无法实现。
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

学习solidity基本语法

玩良心杀

public关键字相当于自动生成了一个外部调用的函数（也叫getter函数）返回这个变量的值，没有这个关键字，外部合约无法访问此变量的值，对于mapping也是如此，不同的是mapping函数是带有参数的 `function minter() external view returns (address) { return minter; }`

function balances(address account) public view returns (uint256) { return balances\[account\]; }

所以我们调用合约的变量时，可以这样await contract.password()调用这个合约的password属性

6.复合数据类型mapping

映射可以看作哈希表，其初始状态为所有可能的键都存在，并且映射到一个字节表示全为零的值。然而，既无法获取映射中所有键的列表，也无法获取所有值的列表。因此，请记录您添加到映射中的内容，或者将其用于不需要这种记录的上下文中。或者，更好的做法是，维护一个列表，或者使用更合适的数据类型。

所以不需要创建键，因为所有的key都存在，只需要直接赋值就可以了，没有赋值的key对应的value都是0，同时无法获取key和value的列表，mapping不维护，也无法获取插入了多少条数据
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->


修饰符

修饰符允许在函数执行前插入额外逻辑，常用于权限控制与前置检查：

modifier onlyOwner() { require(msg.sender == owner, "Not the owner"); \_; // 继续执行被修饰的函数 }

function criticalFunction() public onlyOwner whenNotPaused { // 函数逻辑 }

如果一个函数被多个modifier修饰，执行顺序按从左到右，像上面先执行onlyOwner再执行whenNotPaused

receive() external payable { require(msg.value > 0 && contributions\[msg.sender\] > 0); owner = msg.sender; }

receive() 是 Solidity 内置的、专门用于接收 ETH 的特殊函数。
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->



solidity

基本数据类型 uint256

复合数据类型 mapping（k⇒v) mapping(address⇒uint256) balances

event事件 看起来是应用程序和区块链的接口一类的

构造函数

合约可以调用的函数

require函数 调用定义了条件，如果条件不满足，则所有更改都会被撤销，包含有3个重载版本

结构体语法

struct Packed { uint128 a; uint128 b; }

function test() public { data = Packed({a: 1, b: 2}); }

msg.sender表示调用这个函数的钱包地址 msg.value本次交易附带了多少eth

Solidity 的状态包括：

-   storage（状态变量）
    
-   balance（合约余额变化）
    
-   event（不会回滚日志）
    

外部调用后的结果（会回滚）
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->




ave-v4

风险引擎与清算机制

外部清算人偿还债务，ave依赖外部套利者维持系统健康，而非中心化干预

v3高级风控原语

隔离模式和高效模式

允许列出高风险资产，但不危及整个协议，限制：仅能借出特定的稳定币

限制：设有严格的债务上限

高效模式：

针对价格高度相关的资产对

优势：允许极高的ltv 逻辑：资产間价格脱锚风险极低，资本效率最大化

v4核心架构：Hub-and-Spoke

liquidity Hub：汇聚全协议存款，极大提升资本效率

spokes：独立的时长或功能模块，拥有独立的风险配置（ltv，liquidation Logic）

code structure:src/hub & src/spoke

开发和测试工作流：gas snapshots（重要）v4极其重视gas效率，每次提交代码前，对比gas消耗变化

总结：终极流动性层

unified（统一）hub汇聚所有资本，消除流动性孤岛

modular（模块化）spoke架构支持无限的业务场景扩展

efficient（高效）优化的gas消耗与精确的风险定价

foutry

anvil 游戏服务器 forge 造物主工具 cast 游戏手柄
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->





学习 Uniswap 的底层原理，我理解到它本质上是用自动化做市商（AMM）机制，用一个简单但强约束的数学公式 x\*y=k 来维持流动性池内两种资产的价格平衡，不依赖传统订单簿。用户每次交换代币时都会改变池子的资产比例，而交易价格也随比例自动调整，因此价格是由池子状态实时决定的。流动性提供者往池子里按比例存入两种资产，获得 LP 份额，交易者支付的手续费会按份额分配，这解决了交易撮合困难、没有足够对手盘的问题。v2 的核心是恒定乘积公式 + 每笔交易 0.3% 手续费，而 v3 在此基础上引入集中流动性概念，让 LP 在指定价格区间提供资金，提高资金利用效率但需要更主动管理。整个机制的关键是：AMM 自动根据资产比例给出隐含价格；套利者负责把 AMM 价格拉回市场价格；流动性池负责维持深度；手续费激励 LP 提供资金；而无常损失则是 LP 需要理解的核心风险。学习下来我意识到 Uniswap 的“去中心化交易”并不是用复杂逻辑，而是用简单数学和市场力量组合出稳定交易体验，加上链上透明与开放接口
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->






公共物品：不是道德问题，是设计问题

web3中的公共物品 开源代码，协议，开发者工具/文档

带来的问题：公地悲剧，谁来为植物浇水？高使用量！=高收入

我们需要新的机制确保有价值的东西能够长期存在

机制一：委员会制 优点：简单，快速 缺点：权力集中，偏好固化与偏见

机制二：二次方资助 放大社区共识，由贡献者的数量决定

机制三：回溯性资助，先创造价值，后获得奖励

需要有一个得到激励继续工作的机制

思考：贡献者网络，每个人的贡献自动记录和评分，形成可继承声誉，可跨dao使用
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->







Twitter Space 的完整运营流程主要包括前期准备、执行和复盘三个阶段。前期准备中，最关键的是提前 2～3 天完成宣传，包括在推特和各类社群发布海报与文案，并在活动当天或前一天再次提醒听众，以确保他们能记住并预留时间。创建 Space 本身操作简单，只需设置主题和时间并确认时区，但真正重要的是建立一个专属群聊，将嘉宾、主持人和运营人员拉在一起，用于同步嘉宾信息、海报、文案和问题库等物料，所有对外内容在发布前都要经老师确认。为了让嘉宾充分准备，需要提前提供一份完整的问题库，而不是只给简单概述，这能让整个访谈更加顺畅。

执行阶段中，主持人需要先完成项目方的品牌介绍，再引导嘉宾自我介绍，并按照问题库推进讨论；当嘉宾一次回答多个问题时，主持人需现场调整问法或过渡，以保持节奏。若有观众提问环节则可加入，但不是必须。活动结束后进入复盘，重点观察三个指标：推文浏览量用于评估前期宣发效果，实时在线人数是衡量 Space 热度的最关键指标，而累计参与人数因可能被刷不完全可靠。此外，还可以通过参与者头像显示情况判断是否存在“买粉”。复盘时应记录执行过程中的不足，以便判断主题、宣发或流程哪个环节需要改进。

从收集信息、确认物料、制作海报、宣发、主持到复盘，这是一套完整的小型活动策划流程。
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->








背景  
现有账户模型缺乏对“模块能做什么”的统一规范，导致钱包安全性难以评估。ERC-7962 的提出，就是为了解决模块扩展与安全之间的矛盾，让模块化钱包具备可控、可审计的权限体系。

核心思想  
ERC-7962 的核心是能力模型（Capability Model）。每个模块只能声明并使用明确的能力，不允许拥有隐式或无限制权限。钱包在执行模块操作前必须验证模块声明的能力是否经过授权。我的理解是，模块是应用，能力是权限，钱包核心是内核，通过清晰的权限边界避免越权行为。

主要内容  
模块必须公开声明它拥有哪些能力，不能隐藏行为，便于用户、钱包 UI 和审核工具理解模块的权限范围。  
钱包在执行模块调用时需要检查模块声明、用户授权以及参数范围，确保调用在授权之内。  
模块之间必须职责分明，不得直接操作核心逻辑，所有敏感行为都应通过能力模型完成。  
模块升级后需要重新进行能力验证，不允许借升级扩展未授权权限。此举减少了账户升级引入新风险的可能。

  
我觉得 ERC-7962 的创新点在于，它把智能钱包的安全设计提升到了“权限系统”层面，而不是传统的函数级别限制。能力模型让模块变成可控、可审计的组件，有助于构建像“插件商店”那样的生态。未来账户抽象钱包会更加系统化、标准化，安全逻辑不再依赖开发者自觉，而是由协议层面强制约束。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->









关于 Fork 后的仓库维护

一旦在 GitHub 上完成了对目标仓库的 Fork 并在本地进行了 Clone，后续进行修改时，完全不需要再次重复 Fork 和 Clone 的步骤。

Fork 本质上是在自己的账户下创建了一个“代码快照”。如果原作者的仓库（上游仓库）有了更新，我们应该通过配置远程仓库地址（Remote），使用 `git fetch` 或 `git pull` 来同步更新，而不是重新克隆。

本地分支创建的先决条件

在本地环境中使用 `git clone` 下载仓库后，如果想要创建新分支（Branch），必须先进入仓库所属的目录。

Git 命令的执行依赖于当前目录下的 `.git` 隐藏文件夹。只有进入该目录，Git 才能识别出这是一个受管理的仓库，从而执行分支创建等版本控制指令。

GitHub 用户 ID 的确认方式

如果需要查看自己的 GitHub ID，可以通过个人主页（Profile）或者在设置（Settings）的个人资料页面中找到。
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->










例会

web3牛马新人学习效果的最大化方法

构建掌控感 把直播内容喂给ai生成一个思维导图，逻辑链条更明确，顺着其中的一个链条把其中的逻辑理清楚，又不会丢失全局的掌握，不会遗漏大局的知识，避免发散性思维太过发散

掌握感作为主观的感受难以和真实的世界同步，掌握的程度并没有想象的那么高，社交平台账号输出整理自己的学习成果类似于考试默写了，内化为自己的知识，确实是一个好方法对于理论层面的，如果是动手方面的知识的话，我会倾向于多做几个类似的玩具跑通自己的逻辑，或者多看几个视频也行的hhh

尽快跑通输入，思考，总结，输出，反馈的正循环
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->











ai+web3 分享会

LLM 无状态 无工具 无身份

26年的agent 持久记忆 工具调用能力 资产管理，拥有一个持久化的记忆和执行身份

LLM的大脑 +vector db做为记忆+工具 api接口连接外部世界

设施缺口

传统网络带来身份与信任的危机

身份欺诈，无法验证操作者是人还是机器，在授权操作会存在风险

不可审计，缺乏不可篡改的日志

影子ai

web3带来的解决方案

不可篡改的审计日志

所有推理，交易，验证记录永久存证

满足最严格的监管升级要求

erc804的新升级

身份注册表提供唯一，可转移的链上id

声誉系统记录不可篡改的反馈评分，防止垃圾信息

验证机制，zkml证明解决可信执行机制

展望，web3和ai结合是必然的，作为技术选型的必然，可以承载高频，低频交易的基础设施

web3给ai合规带来的价值

开发者使用ai

spoonos框架连接web2 ai与web3设施
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->












新手需要关注

私钥和助记词危险

钓鱼高频

同名恶意token

热钱包防止被盗，私钥泄露

要有独立自主验证的习惯很重要，不点击未知链接，要通过官方链接下载软件等等，搜索引擎的结果可能是假的，插件等等

代币核对合约地址，可能有同名恶意token

大陆合规方面中

ico公开融资 单纯发币ok，打击公开融资

虚拟货币交易所 永续合约当做赌博 技术中立没用 打击交易所实现财政盈利

虚拟货币挖矿 披着 ai算力超算中心的皮，实现合规

中国特色合规要素 跟当局建立比较好的关系

个人经常出入金 香港出入金也没用，回到大陆税务局会联系报税 不知道上游接收到赃款，第一次的话记录就没什么事 ，多次的话建议先找律师谈谈

入金攻击 上游的洗钱成本太高升级了 收到大笔资产要警惕甚至主动备案，保护好自己的钱包地址，查找合约地址和交易记录，不要立马转u，可能是蜜罐或者貔貅

u商 大陆 u卡反洗钱kyc，kyk b端客户 车队人员盯上，海外资金盘拿到的赃款兑换法币，漂白 使用u卡发卡方是否合规，资金丢失风险，发卡方和万事达在这个机构下把开卡者当做员工，自己组的u卡发行公司，钱包地址 ，要进行一定的合规动作

项目方

线索奖励 工作人员在大陆的，项目是海外项目，募集资金，非法经营，传销

涉及到合约，期权的板块风险较高，岗位需要注意
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->














web3基础讲解

私钥不能截图，全文粘贴，私钥是根

gas费是区块链的激励机制，操作越复杂，gas费越高，网络拥堵时gas费也会水涨船高

钱包不直接连区块链，它连rpc，有中心化的风险，是抽象化了区块链底层的逻辑，帮助我们节省了很多操作，并不存储资产，组装交易内容，私钥进行签名，广播到区块链网络等等

比特币使用pow，以太坊使用的pos质押押金，随机选择出块，作恶的话会被罚没押金，依赖资金量，和pow各有优缺点

利用web3的技术为一些现实问题提供新的解决方案，而不是打造一个web3的社会，web2和web3共存
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->















我注册了一个钱包，并且进行了测试币转账，学到了在区块链中矿工会验证交易的合法性，并且得到代币奖励，链会把交易支付的gas fee分配给矿工，我以为这是通过智能合约做的，问了chatgpt才知道这是协议层做的，接着又了解了以太坊的分层，

应用层：defi，钱包，nft

协议层：核心协议

扩展层：evm，gas机制

后面参加了岗位概览的会议，没想到岗位竞争这么激烈，450:1，但我相信web3会发展壮大的，忍耐，坚持

备考期末，明天接着学习
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
