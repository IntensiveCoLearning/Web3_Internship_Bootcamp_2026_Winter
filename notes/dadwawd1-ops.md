---
timezone: UTC+8
---

# dadwawd1-ops

**GitHub ID:** dadwawd1-ops

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->
zk-snarks (零知识简洁非交互式知识论证) 是建立在一条精密数学流水线上的协议。这条流水线将计算机程序的逻辑正确性，一步步转化为多项式的几何特性，并最终压缩为椭圆曲线上的密码学验证。本文将从“算术化”这一关键步骤开始，深度拆解这一技术堆栈。

一、算术化：将代码抽象为矩阵的形式

计算机程序充斥着 if/else 跳转、循环和变量赋值，这些不确定的逻辑流无法直接用于数学证明。zk-SNARKs 的第一步，是必须将这些逻辑强行转化为静态的代数方程，这一过程称为算术化。

1\. 扁平化操作：

复杂的方程式或程序操作被分解为A + B = C或AB = C 形式的简单操作。 (A + B) _B_ C 如何表示为简单的基本操作：GATE 1（加法门）、GATE 2（乘法法门）和 GATE 3（乘法门）。

例如，一个复杂的运算 (a + b)  _b_  c 会被拆解为3个约束门：

加法门（通过乘法模拟）：p:(a + b) \* 1 = s1

乘法门：q:b \* c= s2

乘法门：s1 \* s2 = s3

|   | A | B | C |
| p | q | r | p | q | r | p | q | r |
| 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| A | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| B | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| C | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
| S1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |
| S2 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |
| S3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

图解：

在A中矩阵P对应的1为A+B，在B矩阵中p对应的是1，C中的P为S1

          所以为p:(a + b) \* 1 = s1

### 同理可推导列 q 和列 r。

### 2\. 构建一阶约束系统 (R1CS)

扁平化操作将复杂的逻辑拆解为独立的门（Gate），而 R1CS 则是将这些分散的门组装成一个统一的代数骨架。它由三个系数矩阵A, B, C 和一个核心的见证向量 (Witness Vector, s) 组成。见证向量s：上帝视角的数据全集见证向量 s 是一个包含电路中所有数值的列表。它不仅包含输入变量，还包含所有的中间变量和输出结果，甚至包含常数项 1（用于加法模拟）。基于上面的例子，向量 s 的结构为：s = \[1, a, b, c, s1, s2, s3\]

向量内积约束：用数学“镊子”提取数据

对于电路中的每一个逻辑门（例如门 p），R1CS 利用向量内积 (Dot Product) 作为“选择器”。它通过在矩阵行中填入权重（通常是 0 或 1），从庞大的向量 s 中精准提取出当前步骤所需的数值，并强制它们满足以下核心方程：

(s _Ai)_ (s _Bi) - (s_ Ci) = 0

| 向量分量 | 1 | a | b | c | s1 | s2 | s3 | 作用 |
| 矩阵 A (行 p) | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 提取a+b |
| 矩阵 B (行 p) | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 提取 1 |
| 矩阵 C (行 p) | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 提取 s1 |

运算过程：

左输入 (s _Ap)：(1_ 0) + (a _1) + (b_ 1) + ... = (a + b)

右输入 (s _Bp)：(1_ 1) + (a \* 0) + ... = 1

输出结果 (s _Cp)：(s1_ 1) + ... = s1

将结果代入 R1CS 核心方程：

(a + b) _1 - s1 = 0 =>  (a + b)_ 1 = s1

通过这种方式，R1CS 成功地将动态的代码执行流（程序逻辑），固化为一组静态的、线性代数层面的矩阵约束。无论输入数据如何变化，只要这组矩阵方程成立，就证明了原程序的逻辑被正确执行。

二、多项式压缩（QAP）：

R1CS 虽然成功实现了算术化，但验证效率依然低下。如果电路包含 100 万个门，验证者就需要逐一验证 100 万个矩阵方程。为了实现“简洁性”，我们需要将这些离散的方程打包成一个数学对象。这就要提到我们的二次算术规划 (QAP) 技术

1\. 拉格朗日插值：从列向量到多项式

利用拉格朗日插值法，我们将 R1CS 矩阵中的每一列（代表不同门的约束系数），拟合成一条连续平滑的多项式曲线。

变换逻辑：

矩阵 A 的每一列  转化为多项式 A(x)

矩阵 B 的每一列  转化为多项式 B(x)

矩阵 C 的每一列  转化为多项式 C(x)

物理意义：之前的约束是“第 1 步检查行 1，第 2 步检查行 2……”，现在的约束变成了“检查曲线 A(x)、B(x)、C(x) 在几何上的整体关系”。

目标多项式与整除性，此时，成千上万个独立的 R1CS 约束方程被压缩为一个核心多项式方程：

A(x) _B(x) - C(x) = H(x)_ Z(x)

目标多项式 Z(x)：这是一个预定义的“标尺”，其根为所有逻辑门的索引（如 x=1, 2, 3）。这意味着在每一個逻辑步骤点上，Z(x) 的值都为 0。

整除性验证：问题被转化——只要计算出的组合多项式 A(x) \* B(x) - C(x) 能够被 Z(x) 整除（即没有余数），就在数学上证明了原电路在每一个逻辑步骤上都是正确的。

三、概率性验证：施瓦茨-齐佩尔引理与O(1)效率

1\. 施瓦茨-齐佩尔引理 该数学引理指出：两个不相等的最高阶多项式，在极大的取值范围内随机取点，其函数值相等的概率接近于零。

这意味着，验证者不需要下载整条曲线进行比对，只需要在任意一个秘密随机点 t0 上比对一次：

A(t0)\* B(t0) - C(t0) = H(t0)\* Z(t0)

2\. 简洁性  无论原始计算有多复杂（哪怕是验证整个以太坊区块的交易），验证者的工作量都被压缩为一次常数级 O(1) 的乘法检查。这是 zk-SNARKs 能够用于区块链扩容（zk-Rollup）的根本原因——验证成本与计算量解耦。

四、椭圆曲线与信任

算术化与多项式压缩虽然将逻辑转化为了数学验证，但直接处理多项式数值依然面临隐私裸露与伪造证明的双重风险。为了解决这一问题，zk-SNARKs 构建了一套精密的密码学防御体系，我们可以通过一个“制药公司的新药验证”场景来深刻理解这一过程。

首先是解决数据的隐私问题。在数学层面，系统引入了椭圆曲线密码学（ECC）来构建“同态隐藏”机制。这一步骤可以类比于一家制药公司必须向监管机构证明其新药的有效性，但绝不能泄露其核心商业机密——秘密配方。该公司并非直接提交实际的秘密成分（即见证数据 A、B）及其最终化合物（C），而是将每种成分溶解在一种特殊的“加密溶剂”中。这种溶剂（椭圆曲线生成元）能够完美隐藏成分的分子结构，使得监管机构只能看到混合后的溶液，而无法逆向还原出原始的化学成分。这在数学上对应了离散对数难题的单向性，从物理层面保证了没有任何人能暴力破解出原始数据。

然而，一旦成分被溶解，监管机构便无法直接通过化学反应来验证其有效性。为了突破这一困境，系统利用了双线性配对技术。这相当于监管机构拥有一台名为“关系分析仪”的高科技设备。监管机构并不需要直接分析那些被隐藏的成分，而是将装有三种溶液的容器放入分析仪。该设备会检查这三种溶液的“能量波长关系”是否满足特定的数学公式（即验证 A \* B = C）。通过这种方式，监管机构无需了解药物的具体秘密成分，即可确信“配方公式”是正确无误的。这便实现了逻辑验证与信息泄露的完美解耦。

最后，为了确保整个验证体系的根基不被动摇，必须解决信任源头的问题。整个验证过程的可信度，完全取决于那台“关系分析仪”本身是否是公平构建的。

在 zk-SNARKs 中，这对应着“可信设置”环节。这台设备必须由可信的第三方机构（如国际标准组织）制造，以防止被篡改。而制造过程中使用的“初始蓝图”（即系统初始化时的随机点 t0）绝不能泄露。一旦该蓝图泄露，任何人都可以根据蓝图制造出能够欺骗系统的“假冒分析仪”（即伪造证明）。因此，该蓝图被视为“有毒废物”。在设备制造完成并提取出公共参数后，必须在所有利益相关者面前彻底销毁这份蓝图，以建立“无人能够操纵系统”的绝对信任。

总之，zk-SNARKs 是一种将信息转换为多项式形式的数学系统，它能够在单点进行高效验证，并对整个过程进行加密。凭借这种结构，zk-SNARKs 在保证计算正确性的同时，完美避免了信息泄露，从而兼具了高效性（Succinctness）和隐私性（Privacy），并已成为现代零知识证明技术的核心基础。

    看到这里，你一定会产生一个疑问：为什么我们要大费周章，把直观的代码逻辑简化成这种仅包含加法和乘法的“算术电路”？这就考虑到了zk-SNARKs的底层设计哲学，也取决于后端的工具偏好，有限域 zk-SNARKs 的后端并不是在普通的整数或二进制上运行的，而是在有限域上运行的。你可以把有限域想象成一个巨大的、循环的数字时钟。 在这个“时钟”世界里，加法 (+) 和 乘法 (\*) 是最高效、最自然的运算。所有的现代密码学原语（如椭圆曲线）都是基于这两个运算构建的。算术电路恰好只包含加乘，因此它是连接代码逻辑与底层密码学的最佳通用语。效率的降维打击

如果我们使用计算机熟悉的布尔电路（与门、或门、异或门）：

计算一个 256 位大整数的乘法（A \* B），可能需要成千上万个逻辑门（因为要处理每一位的进位）。

而在算术电路中，这只是 1 个乘法门 (A\* B = C)。

3\. 为多项式（QAP）铺路

别忘了我们的下一步是将电路转化为多项式。多项式 P(x) 本质上就是变量的加权和与乘积。算术电路（加/乘）与多项式结构存在天然的 1:1 映射。

所以选择算术电路，是因为它是将“计算代价”压缩到最小的唯一数学路径。它就像是把复杂的自然语言（代码）翻译成了最精简的莫尔斯电码（加乘），以便后续的数学机器能以光速处理。

zk-SNARKs 的局限性：可信设置 (Trusted Setup) 的阴影

zk-SNARKs 具有强大的性能和效率，但最终会面临被称为可信设置的结构性限制。如果恶意方获取了设置过程中使用的密钥，他们就可以生成无限多个看似有效的证明，而这些证明实际上并不成立——从而彻底破坏系统的信任。

因此，可信设置的存在本身就引入了集中式单点故障的漏洞。如果设置过程由单个实体或小组执行，则存在他们可能恶意行事或遭受外部攻击的风险，从而导致密钥泄露。最终，系统安全依赖于“一个完全可信的仪式”，这本身就具有讽刺意味。

因此，可信设置被认为是零知识证明SNARK系统中最关键的攻击途径之一。为了缓解这一问题，实现方案通常采用多方计算（MPC）进行设置，或者采用完全不需要可信设置的新型零知识证明系统。

今日solidity学习：ERC165 & ERC721：

ERC165标准接口检测，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了 ERC721，ERC1155的接口。

ERC721处理非同质化代币标准（NFT）
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->

今天看了很有趣的文章，让我在零知识证明的方面了解到了在初期对与隐私的保护，解决了我之前对信息泄露方面的疑惑，现在对于今日知识进行一个总结和理解：零知识证明的概念最早是由 Goldwasser, Micali 和 Rackoff 在 1985年 的论文中提出的。当时的状况： 全是复杂的数学公式，非常晦涩，普通人（甚至很多计算机专家）都很难理解“如何能证明一件事却不告诉你是怎么证明的”，在此之后有了两个经典的故事：

阿里巴巴洞穴 (1989年)： 这是最早期的解释。就在 ZKP 发明仅仅 4 年后，密码学家 Jean-Jacques Quisquater 发表了一篇著名的论文《如何向你的孩子解释零知识协议》。他创造了“阿里巴巴洞穴”这个故事，专门用来向非专业人士解释 ZKP 的核心逻辑（交互式证明）。所以，这是真正的元老级例子。我来简单的阐述一下这个故事的内容：在一个有a,b出口的洞穴里，要讲出密令才能找到出口并出去，但是只有2知道密令是什么，但他不想告诉验证者1，只想证明2知道这个密令，这时候1就要去证实2，过程：1在洞穴外让2按照他的命令从a出或者从b出（不能仅执行几次，会有概率疑惑产生），重复多次，2都可以通过密令从指定的洞口出来，这就验证了2知道这个秘令，但是不知道这个密令是什么，保证了隐私。

第二个故事时”寻找沃尔多”准备工作：佩吉用一张大纸盖住原图。这张纸遮住了整幅画，但可以剪出一个刚好和沃尔多大小一样的小洞。维克多先检查一下纸是否完全盖住了画。

证据制作：在维克多的视线之外，佩吉在床单上沃尔多所在的位置剪了一个洞。

展示证据：佩吉只向维克多展示了剪开的一小块区域，而照片的其余部分仍然被遮盖着。

验证：透过小孔，维克多可以清楚地看到沃尔多的标志性特征（红色条纹衬衫、眼镜等）。

重复：由于一次事件可能是运气或欺骗，维克多可能会用另一张照片重复此操作，并再次要求提供证据。附图：

![G-s4UNMa0AAQ8fk.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-15-1768485815888-G-s4UNMa0AAQ8fk.jpg)

X402协议：一种开放的，互联网原生的支付方式（极低边际成本、接近零的单笔支付摩擦），且根据浏览器的HTTP协议不用额外的通信，有五个特性，零协议费用（但要支付少量的支付网络费用），零等待（速度和互联网一样快），零摩擦（不用提供账户和个人信息），去中心化，零限制（不用特定的网络），对比传统的方式讲：要新的api创建账户，添加支付方式，买积分订阅管理密钥很满且麻烦，402通过用ai代理发送HTTP请求并收到402错误：（需要支付），然后ai代理用稳定币去（即时）付款，已授予API访问权限（不用去管理API密钥风险）
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->


今日学习：

以太坊上有两种账户类型：EOA（Externally Owned Account，外部拥有账户） 和 合约账户（Contract Account）。它们是整个以太坊生态的基础，所有交易、转账、dApp交互都围绕这两种账户展开：

| 项目 | EOA（外部拥有账户） | 合约账户（Contract Account） |
| 控制方式 | 由私钥（外部拥有）控制，用户通过钱包签名交易 | 由部署的智能合约代码控制，无私钥 |
| 地址生成方式 | 由公钥通过Keccak-256哈希生成（0x开头） | 由部署者地址 + nonce哈希生成（也0x开头） |
| 是否有代码 | 无代码（codeHash为空） | 有字节码（bytecode）和存储状态 |
| 能否主动发起交易 | 可以（外部交易，external transaction） | 不能主动发起，只能被调用后执行内部交易 |
| 余额 | 可以持有ETH、代币 | 可以持有ETH、代币（合约可编程控制） |
| 典型例子 | 你的MetaMask钱包地址 | Uniswap、Aave、ERC20代币合约地址 |
| nonce | 交易计数器（防止重放攻击） | 交易计数器 + 合约创建计数器 |
| 存储（storage） | 无（或极少） | 有（合约变量、映射等持久化数据） |

二叉默克尔树（适用于BTC） vs. 默克尔-帕特里夏树 (MPT)（又称世界状态树）

|   | 标准二叉默克尔树 (Binary Merkle Tree) | 默克尔-帕特里夏树 (Merkle Patricia Trie, MPT) |
| 典型应用 | Bitcoin (比特币) 交易树 | Ethereum (以太坊) 状态树、交易树、收据树 |
| 数据结构基础 | 纯粹的 二叉树 (Binary Tree) | 基数树 (Radix Trie) + 默克尔树的结合体 |
| 分支数量 (Arity) | 2 (每个节点最多2个子节点) | 16 (十六进制前缀树，Hexary Trie) |
| 主要目的 | 验证数据的存在性 (Inclusion Proof) | 高效管理键值对 (Key-Value) 状态 及其更新 |
| 数据动态性 | 静态优化：一旦生成（如区块打包后），通常不再修改。修改一个数据需要重构树的大部分。 | 动态优化：专为频繁的插入、更新、删除设计。每次状态变更只需重新计算受影响路径的哈希。 |
| 键值映射 (Key Mapping) | 无特定键值路径逻辑，通常按列表顺序排列。 | 确定性路径：数据的 Key (如地址的哈希) 决定了数据在树中的位置。 |
| 存储效率 | 较高，结构简单，仅存储哈希。 | 较低，结构复杂，需引入空节点、扩展节点(Extension)、分支节点(Branch)和叶子节点(Leaf)来压缩路径。 |
| 查询复杂度 | $O(\log_2 n)$ | $O(\log_{16} n)$ (由于分支多，树高通常更低，查询步数更少) |
| 抗碰撞性 | 依赖哈希函数的抗碰撞性。 | 同样依赖哈希，但路径本身作为 Key 提供了额外的索引确定性。 |

比特币 (二叉树)：比特币的区块就像一本账本的一页。一旦这页写好了（区块被挖出），里面的交易顺序和内容就是固定的。因此，使用简单的二叉树将所有交易哈希两两合并，生成一个 Root Hash 即可。它不需要支持“快速修改”。

以太坊 (MPT)：以太坊是一个“世界状态机”。账户余额、Nonce、智能合约存储（Storage）在每个区块之间都会发生变化。如果使用二叉树，每次有人转账，你都需要重新排列整个树来计算新的 Root，效率极低。MPT 结合了前缀树（Trie）的特性，使得修改某个账户的余额时，只需要更新该账户对应的路径分支，而无需重算整棵树。

2\. 路径确定性： (Determinism)二叉树：数据的顺序很重要。交易 A 在左边，交易 B 在右边，生成的 Root 是 $H(A+B)$。如果交换顺序，Root 就会改变。MPT：位置由 Key 决定。例如，无论你以什么顺序插入数据，只要 Key（例如钱包地址）相同，它在树中的位置就是固定的。这对于验证以太坊这种去中心化的全局状态至关重要——所有节点必须对“状态树”的结构达成绝对一致。

3\. 节点类型的复杂性：

二叉树：只有一种节点逻辑（左哈希 + 右哈希 = 父哈希）。

MPT：为了解决“稀疏性”问题（即地址空间很大，但实际使用的地址很少），MPT 引入了复杂的节点类型来压缩路径：

Leaf Node (叶子节点)：存储真正的数据（Value）。

Branch Node (分支节点)：也就是路口，有16个分支指向下一层。

Extension Node (扩展节点)：用于“跳过”没有任何分支的长路径，优化存储效率。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->



今日基础知识学习记录：

了解了以太坊节点是如何构成网络的，官方知识点：节点node是任何一台运行以太坊客户端软件并连接到其他节点的电脑，就是一个以太坊节点，客户端是对以太坊协议的具体体现，会按照协议规则验证数据，同步区块状态，帮助网络保持完全，在（The Merge）之后，节点由执行客户端和共识客户端两个核心客户端组成外加一个接口（Engine API）这个是基于JSON-RPC的本地接口。下面是在内部网络的流程：

1,交易进场,执行客户端 (EL)(如 Geth),收到用户的转账请求，验证格式后存入内存池，并广播给其他节点。,MempoolExecution P2P

2,区块进场,共识客户端 (CL)(如 Prysm),从外部网络收到一个新的区块提议（里面包含打包好的交易）。,Block ProposalConsensus P2P

3,请求验证,CL → EL(经理呼叫会计),共识客户端通过接口把交易数据扔给执行客户端：“跑一遍数据，看合不合法？”,Engine APIengine\_newPayload

4,执行计算,执行客户端 (EL)(如 Geth),实际运行 EVM，查询状态数据库（检查余额、Nonce、签名）。,EVMStateDB

5,返回结果,EL → CL(会计回复经理),执行客户端反馈验证结果：有效 (VALID) 或 无效 (INVALID)。,"JSON-RPC Response{status: ""VALID""}"

6,确认共识,共识客户端 (CL)(如 Prysm),收到“有效”确认后，将该区块设为最新的链头，并广播投票。,Fork ChoiceAttestation

Solidity学习：今日研究多签名钱包，它是整个在Web3组织治理和资金安全的基石，充当于一个钥匙的作用，预防丢失提升安全性，他主要体现以下场景中：

1、DAO（去中心化自治组织）的管理，多签钱包应用最为广泛的场景，在一个组织通过筹集得来的资金，由选出的几位社区核心贡献者作为owners，想要取走资金必须得到这几位owners的签名才可通过（例如有7位，则最小通过4位即可），社区成员不需要信任某一个具体的人只需要信任整个代码规则即可

2、项目方的”Admin Key”管理，是DeFi协议的最关键的安全防线，在 Uniswap 或 Aave 这样的协议，通常有一些特权操作，比如“升级合约代码”、“修改手续费率”或者“紧急暂停协议”，多签解决方案：协议的 Owner 被设置为一个多签钱包合约地址任何对协议参数的修改，本质上都是一次 submitTransaction（提交提案）必须由项目方的多位核心开发者、甚至外部的安全审计机构共同签名（Confirm），修改才能生效（Execute）。

以下是这个函数的构造：定义状态变量owners(合伙人)，isOwner(映射合伙人状态)，numConfirmationsRequired（最小验证需求数量），Transaction（结构体储存对应数据信息（to,value,data,execute,numConfirmtions））,isConfirmed(映射，几号=>合伙人=>验证状态),transactions(存储结构体信息)，里面主要有四个主函数submitTransaction（（提议）把这一笔待处理的交易详情，永久地记录在区块链的“账本”上），

confirmTransaction（认证），executeTransaction（通过认证执行），revokeConfirmation（回撤），同时他们的函数加上了modifier修饰符，为了给函数加入控制权限。而在目前Gnosis Safe 就是一套“完全免费签字、最后一次性打包寄出的企业级银行系统”。它在逻辑上把你代码中的多次链上交互（Confirm）变成了链下无Gas签名，只有最后一步执行时才上链付费，极大地节省了成本；同时它采用了“模具+克隆”（代理模式）的安全架构，让你的资金由一套经过千亿资产验证的公共逻辑库守护，还能像手机装APP一样通过“模块（Modules）”随意扩展功能（比如设置每日限额或自动理财），因此它成为了 Web3 世界管理公款的最高标准。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->




基础知识梳理：

以太坊：以太坊是一个去中心化的区块链网络，也是个软件开发平台，用以太币（ETH）作为燃料。它支持成千上万的加密货币，还有各种应用，比如去中心化金融（DeFi）、非同质化代币（NFT）、游戏、社交媒体和稳定币。以太坊是开源的，由Vitalik Buterin和几个联合创始人在2015年7月推出。核心想法是通过智能合约这种开源程序，让任何人创建数字资产和全球24/7运行的去中心化应用（dApp）

以太坊的核心概念：

区块链：由区块和链构成公共去中心化链，其特性为：不可篡改；公开透明；快速交易的特性。

智能合约：开源程序，就是一段代码，部署完成后具有不可篡改的特性，在之前需要严格审查安全问题

ETH： ETH 就是这台计算机的gas 你想在这台计算机上做任何事（比如转账、运行上面的智能合约、发个 NFT），都需要消耗计算资源，而 ETH 就是你付给验证者的小费。当然，它本身也是钱，可以用来储值。gas=Base Fee+Tip

去中心化：没中央控制，也没人能随意修改你的数据，抗审查、安全可靠。

pow和pos之间的区别：

|   | PoW (工作量证明) | PoS (权益证明) |
| 运作机制 | 算力竞赛谁的电脑算得快，谁就有权记账。 | 随机抽签谁质押的钱(ETH)多，被选中记账的概率就大。 |
| 记账人 | 矿工 | 验证者 |
| 门槛 (Sybil Resistance) | 硬件 + 电力需要购买显卡/矿机，消耗巨额电费。 | 32 ETH需要将 ETH 锁定在智能合约中。 |
| 奖机制 | 只有奖励，很难惩罚矿工干坏事只能拒绝其区块，无法没收他的矿机。 | 奖励 + 罚没验证者作恶（如双重签名），质押的 ETH 会被直接销毁。 |
| 能源消耗 | 极高相当于一个中等国家的耗电量。 | 极低减少了 99.95%，只需普通服务器即可运行。 |
| 抗攻击门槛 | 51% 算力攻击需要拥有全网一半以上的计算能力。 | 51% 资金攻击需要控制全网一半以上的质押 ETH（数千亿美元）。 |
| 经济模型 | 通胀必须大量印钱给矿工付电费，抛压大。 | 通缩印钱少 + 燃烧机制 (EIP-1559)。 |
| 确定性 | 概率性需要等十个区块确认才算安全。 | 确定性经过两个 Epoch (约12.8分钟) 后，交易绝对不可逆。 |

以太坊网络（抗审查，高度安全，持久而可靠）L1和L2的区别：

|   | Layer 1 (L1) | Layer 2 (L2) | Layer 3 （拓展） |
| 层级定义 | 结算层 (Settlement) | 通用扩容层 (Scaling) | 应用定制层 (Application) |
| 代表项目 | Ethereum Mainnet | Arbitrum One, Optimism, Base | Arbitrum Orbit, OP Stack L3, Xai |
| 核心职责 | 最终裁决与安全保证账本不可篡改，提供去中心化信任。 | 通用计算与压缩处理绝大多数交易，打包压缩后发给 L1。 | 极致定制与体验为特定APP（如链游、高频DeFi）设计的专用链。 |
| 通俗类比 | 中央银行 / 最高法院 | 商业银行 / 地方法院 | 支付宝 / 专属会员俱乐部 |
| Gas 费用 | 极贵 ($5 - $50) | 便宜 ($0.01 - $0.1) | 几近于零 (甚至可由项目方代付) |
| 速度 (TPS) | 极慢 (15 TPS) | 快 (2,000+ TPS) | 极速 (10,000+ TPS, 瞬间确认) |
| 安全性来源 | 依靠全球几十万个验证节点 (PoS)。 | 继承 L1 的安全性 (数据最终在 L1)。 | 继承 L2 的安全性 (数据最终在 L2)。 |

钱包：我们使用MetaMask创建了一个新的钱包，生成了一个由12个单词组成的助记词。这个助记词最重要，请勿泄露！MetaMask 使用助记词默认生成了一个钱包。一个助记词创建可以无限个钱包，每个钱包将包含一个钱包地址（公钥）和一个私钥。钱包地址可以是公开的，但是私钥是可以不公开的，永远用 [etherscan.io](http://etherscan.io) 双重确认交易，别只信MetaMask界面。

根据椭圆曲线的知识简单了解了一下私钥的形成：

![a932fdfe3de80da9df02f1e08d6cb0e.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-12-1768209705329-a932fdfe3de80da9df02f1e08d6cb0e.jpg)

对于安全预防（目前早上答题情况总结出来的钓鱼信息）：

网络钓鱼的迹象包括：域名，预填收款人的地址，合约地址，UI差异，使用 DeFi 应用时，务必核实域名、合约地址和收款人地址。任何一个错误都可能导致资金的不可挽回损失。

Uniswap V3 多重调用钓鱼攻击原理：攻击者利用合法的 Uniswap V3 Multicall 合约创建交易。它们使用聚合函数将多个调用捆绑在一起。这包括授权呼叫（使用您的签名）和转接呼叫。捆绑交易允许他们在一次交易中完成代币的授权和转移。

书签攻击的工作原理：书签攻击是指诱骗用户将恶意 JavaScript 代码添加到浏览器书签中。当用户在 Discord 上点击这些书签时，这些书签会执行有害代码，窃取敏感信息或控制用户帐户。

预防：务必仔细核实签名请求，尤其是对于捆绑交易。要警惕类似 aggregate 或 multicall 这样的函数，它们可能隐藏恶意操作。检查实际执行的调用数据，而不仅仅是合约地址。使用具备高级交易模拟功能的钱包。分散资产，规划钱包用途。就像你的银行卡一样，禁止账户减少操作，只作存储和转账不操作和使用。日常高频使用账户只放少量资产。在刷空投或者参与新项目时，最好咨询有经验的朋友或者查看合约代码等以确保没有问题再进行操作。

今日solidity学习：今天学习了ERC20代币标准，ERC-20本质： 它不是代码，它是一份像是接口规范文档。它规定了一个代币合约必须拥有哪几个函数（比如查余额、转账），名字必须一模一样。在代码中我们可以发现有两个文件一个是IERC20用于接口的文件（IERC20主要用于定标准），里面包含着balance(address)(查看余额)，totalSupply()(总币)，transfer(to, amount)(转账)，transferFrom(from, to, amount)(DeFi的核心思想，操作别人的钱给你)，approve(spender, amount)(用于授权，准许别人动用多少钱)，allowance(owner,spender)(检查授权余额)这六重要函数，ERC20来实现代码逻辑，发新币。定义接口是为了方便调用和gas优化，并且同时理解了在IERC20中和ERC20中external和public的区别和用法：在ERC20标准中，接口（IERC20）定义为 external 是确立了“外部必须能调用”的最小范围，而实现（ERC20）改为 public 是为了赋予合约内部复用及子合约重写的灵活性（例如在 transfer 中嵌入额外逻辑）；相比之下，external 强制直接从 calldata 读取数据，避免了复制到内存的开销，因此在处理复杂参数时更省 Gas，且能清晰表达“仅限外部入口”的语义。一句话原则：如果函数需要被内部或其他合约继承调用，必须用 public；如果仅作为外部入口（如 mint/burn），首选 external 以明确意图并优化性能。顺便补充一下internal和private的区别，两者都是不可以被外部合约调用，前者可以被继承调用后者不可以，private 只有在你非常确定不希望子合约修改、访问或破坏这段逻辑时才使用。它更多是一种安全防护或避免命名冲突的手段。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
