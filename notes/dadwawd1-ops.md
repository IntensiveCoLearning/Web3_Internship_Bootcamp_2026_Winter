---
timezone: UTC+8
---

# dadwawd1-ops

**GitHub ID:** dadwawd1-ops

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-26
<!-- DAILY_CHECKIN_2026-01-26_START -->
![微信图片_20260126191522.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-26-1769426222333-_____20260126191522.jpg)![微信图片_20260126191509.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-26-1769426236758-_____20260126191509.jpg)![微信图片_20260126191535.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-26-1769426252531-_____20260126191535.jpg)
<!-- DAILY_CHECKIN_2026-01-26_END -->

# 2026-01-25
<!-- DAILY_CHECKIN_2026-01-25_START -->

起来补笔记
<!-- DAILY_CHECKIN_2026-01-25_END -->

# 2026-01-24
<!-- DAILY_CHECKIN_2026-01-24_START -->


参加了LXDAO的周例会

完成第一次审计实例
<!-- DAILY_CHECKIN_2026-01-24_END -->

# 2026-01-23
<!-- DAILY_CHECKIN_2026-01-23_START -->



审计：模糊测试：是一种通过向智能合约输入大量随机、非预期或无效的数据，试图诱发合约异常、崩溃或违反安全规则的自动化测试技术，模糊测试分为无状态模糊测试和有状态模糊测试，无状态模糊测试：每次测试都是独立的。Fuzzer 生成一组参数调用一个函数，检查结果，然后重置状态，但是无法发现无法发现由于多次交互导致的状态累积错误（例如：先存钱，再转账，最后取钱时的漏洞）。**有状态模糊测试**：Fuzzer 生成一个交易序列。它会随机调用合约中的不同函数，并且保留合约的状态。这是 Web3 审计的核心。大多数高危漏洞（如重入攻击、记账错误）只有在特定的操作顺序下才会暴露（很重要）
<!-- DAILY_CHECKIN_2026-01-23_END -->

# 2026-01-22
<!-- DAILY_CHECKIN_2026-01-22_START -->




特性      Aave V3              Aave V4

流动性结构 分割的池子 (Siloed Pools) 统一流动性层 (Unified Hub)

跨链互通 Portal (需桥接配合)     CCLL (全自动跨链调拨)

利率模型 统一借款利率         基于抵押品风险的差异化利率

账户管理 单一账户 (风险混同)     智能账户 (多子账户/风险隔离)

清算体验 二元硬清算             平滑软清算 (集成GHO)

利率调整 需治理投票修改曲线     模糊逻辑控制 (自动根据供需调整)
<!-- DAILY_CHECKIN_2026-01-22_END -->

# 2026-01-21
<!-- DAILY_CHECKIN_2026-01-21_START -->





foundry核心概念：

在深入命令之前，先理解 Foundry 的三大支柱：

Forge: 核心工具。用于编译、测试、部署合约。（类似 Hardhat/Truffle）

Cast: 交互工具。用于与链进行 RPC 交互、数据解码、通过命令行发送交易。（类似 Ethers.js 的 CLI 版）

Anvil: 本地节点。启动一个快速的本地测试网。（类似 Ganache/Hardhat Network）

2\. 安装与环境配置

Foundry 的安装非常简洁，使用官方提供的安装器 foundryup。

Linux / macOS / Windows (WSL 或 Git Bash)

Linux / macOS / Windows（WSL 或 Git Bash）

打开终端，运行以下命令下载安装器： 

curl -L [https://foundry.paradigm.xyz](https://foundry.paradigm.xyz) | bash

执行完毕后，重新加载终端配置（或重启终端），然后运行安装命令来下载具体的二进制文件：

foundryup

foundryup 会自动安装 forge, cast, anvil, 和 chisel。如果日后想更新到最新版本，只需再次运行 foundryup。

3\. 项目初始化

新建项目：

forge init my\_project\_name

cd my\_project\_name

项目结构解析

src/: 存放智能合约源文件 (.sol)。

test/: 存放测试文件（也是 .sol 文件，这是 Foundry 的精髓）。

script/: 存放部署和交互脚本。

foundry.toml: 配置文件（类似 hardhat.config.js，配置编译器版本、优化次数、RPC URL 等）。

lib/: 存放依赖库（Foundry 使用 git submodules 管理依赖）。

4\. 核心组件运用：Forge (开发与测试)

依赖管理

Foundry 不使用 npm，而是直接拉取 GitHub 仓库。

安装 OpenZeppelin:：  

forge install OpenZeppelin/openzeppelin-contracts

重映射: Foundry 会自动生成 remappings.txt，让你在代码中可以简写引入路径。

引入示例: import "openzeppelin-contracts/token/ERC20/ERC20.sol";

编译

forge build

测试 (Testing) —— 核心亮点

Foundry 的测试是用 Solidity 编写的。

基本运行: forge test

查看详细日志 (Traces): 这是 Foundry 最强大的功能。

\-vv: 显示 console.log 输出。

\-vvv: 显示失败测试的调用栈。

\-vvvv: 显示所有测试的详细调用栈（调试神技）。

forge test -vvvv

测试特定函数:

forge test --match-test testTransfer

在 Solidity 测试中，你可以控制区块链的状态（时间、区块号、发送者等）。需要通过 vm 实例调用。

vm.prank(address): 伪造下一个调用的发送者（msg.sender）。

[vm.deal](http://vm.deal)(address, uint256): 给某个地址设置余额。

vm.warp(uint256): 修改当前区块时间（测试锁仓逻辑时非常有用）。

vm.expectRevert(): 预期下一行代码会报错（测试异常情况）。

5\. 核心组件运用：Cast (链上交互)

Cast 是一个瑞士军刀式的命令行工具，不需要写脚本即可快速查询数据。

查询数据

获取 ETH 余额:

cast balance 0x...地址... --rpc-url <YOUR\_RPC\_URL>

调用合约视图函数 (Call):

比如查询 USDT 余额

cast call 0xdAC17F958D2ee523a2206206994597C13D831ec7 "balanceOf(address)(uint256)" 0x...你的地址... --rpc-url mainnet

数据转换 (Conversion)

将十六进制转为十进制:

cast --to-dec 0x3e8  # 输出 1000

将字符串转为 bytes32:

cast --format-bytes32-string "hello"

6\. 核心组件运用：Anvil (本地测试网)

启动一个极速的本地节点（类似 Ganache）：

Anvil：

默认监听 127.0.0.1:8545。

提供 10 个预充值了 10,000 ETH 的私钥供测试使用。

分叉主网 (Forking): 在本地模拟主网环境（非常适合测试 DeFi 组合性）：

anvil --fork-url <YOUR\_MAINNET\_RPC\_URL>

7\. 进阶：模糊测试 (Fuzz Testing)

Foundry 原生支持模糊测试。你不需要配置复杂的参数，只需给测试函数添加参数，Foundry 就会自动随机生成各种输入来轰炸你的合约。

普通测试: function testWithdraw() public { ... }

模糊测试: function testWithdraw(uint256 amount) public { ... }

Foundry 会自动尝试 0, MAX\_INT, 随机数等边界情况。

技巧: 使用 vm.assume(amount > 0) 来过滤无效的随机输入。

8\. 部署合约 (Deployment)  8. 部署合约（Deployment）

Foundry 推荐使用 Solidity 脚本 (script/) 进行部署，这样部署逻辑也是可测试的。

编写脚本 (script/Deploy.s.sol):

Solidity  

contract DeployScript is Script {

    function run() external {

        uint256 deployerPrivateKey = vm.envUint("PRIVATE\_KEY");

        vm.startBroadcast(deployerPrivateKey); // 开始广播交易

        new MyContract();

        vm.stopBroadcast();

    }

}

执行部署:

forge script script/Deploy.s.sol --rpc-url
<!-- DAILY_CHECKIN_2026-01-21_END -->

# 2026-01-20
<!-- DAILY_CHECKIN_2026-01-20_START -->






目前所接触到的优化Gas的方法：

函数的可见修饰符用external比public省gas，只有外部调用的函数设为 external 而不是 public（如果该函数内部不被调用），因为 external 函数可以直接从 calldata 读取参数

使用calldata代替memory，对于外部只读引用类型参数，强制使用calldata，直接从输入读取，不复制到内存

使用 unchecked 代码块： Solidity 0.8+ 默认检查溢出，这会消耗 Gas。如果你确定某个运算（如循环计数器 i++）绝对不会溢出。

自定义错误时Error最省gas，因为require存储字符串很贵

不要再网络拥堵的时候交易，会增加gas费

将多个变量压缩到一个uint256中可以节省存储空间

智能合约攻击类型以及预防：

重入攻击：他会利用代码的转账漏洞逻辑将钱一点一点的转走，预防策略再转账函数里一定要遵循检查->扣款->发送;

整数溢出：在0.8.0在 Solidity 0.8.0 之前，如果一个 uint8 (最大值 255) 加上 1，它会变成 0。虽然 0.8.x 版本已经自动处理了这个问题，但在使用 unchecked 代码块或阅读旧代码时，这依然是巨大的隐患

伪随机数攻击，利用block.timestamp或 blockhash 来生成随机数，但这非常不安全攻击者编写一个恶意合约。恶意合约会先用同样的逻辑计算结果

还有tx.origin钓鱼，攻击者诱骗 owner 访问一个恶意钓鱼网站或调用一个恶意合约。

owner 点击了按钮，向恶意合约发送了一笔交易。

恶意合约在收到调用后，立刻调用 SmartWallet.withdrawAll(攻击者地址)。

此时：msg.sender 是恶意合约。tx.origin 依然是受害者 owner。require(tx.origin == owner) 通过检查，钱被转走。所以一定要检查好代码逻辑，做好安全审计

 无gas费转移（Gasless Token Transfer）：ERC2612它的核心理念是利用 ERC-20 Permit (EIP-2612) 标准，让持有代币的用户（Sender）在不需要拥有 ETH（或其他原生代币）支付 Gas 费的情况下，也能完成代币转账。用户只需对交易进行“离线签名”，而实际的 Gas 费由这一笔交易的提交者（Relayer/中继者）垫付，作为回报，Relayer 会从用户的代币中抽取一部分作为手续费代币兼容性：并非所有 ERC20 代币都支持 permit。只有实现了 EIP-2612 的代币（如 USDC, DAI, UNI 等）才能使用此合约。像标准的 USDT（泰达币）目前并不支持 permit，因此无法直接通过此合约进行无 Gas 转账（除非使用封装过的版本）。

由谁调用：任何人都可以调用 send 函数，只要他们拿到了有效的签名。通常这是由专业的“中继器网络”或钱包后端完成的。安全性：deadline 检查防止了过期的签名被执行。EIP-2612 内置了 nonce 机制，防止同一个签名被重复使用（重放攻击）
<!-- DAILY_CHECKIN_2026-01-20_END -->

# 2026-01-19
<!-- DAILY_CHECKIN_2026-01-19_START -->







再网站上去做了关于智能合约被攻击的案例（[https://ethernaut.openzeppelin.com/），](https://ethernaut.openzeppelin.com/），)   了解了智能合约在部署前阶段要做好安全审查，避免遭受到更严重的损失，在这里面我学习到了四个知识点，第一个是整除溢出，在之前的版本会出现整数溢出的情况，如果用小数字减去大数字会得到一个无穷大的数，这就是会整数溢出，第二个tx.origin (交易发起者)：永远是交易链条最顶端的那个人（你的钱包地址）。不管中间经过多少个合约，它永远是你。msg.sender (消息发送者)：是直接调用该函数的那个地址（可以是人，也可以是上一个合约）。第三个是delegatecall和call之间的区别，普通 Call: A 调用 B。B 在 B 的地盘上运行代码，修改 B 的数据。DelegateCall: A 委托 B。B 的代码被拿过来，在 A 的地盘上运行，修改的是 A 的数据。一定要区别好这个情况（2017年，著名的 Parity 多重签名钱包 被黑客攻击，导致 3000万美金（约15万 ETH） 被盗。 原理和这一关几乎一模一样：所有用户的钱包都 delegatecall 到一个共享的“库合约”。库合约里有个初始化函数 initWallet（类似这关的 pwn），可以设置 Owner。黑客直接调用了这个函数，因为库合约本身的疏忽，黑客变成了库合约的 Owner。然后黑客自毁了库合约，导致所有依赖它的用户钱包全部瘫痪（这是第二次攻击，锁死了数亿美金）。）机制上：selfdestruct 是 EVM 层面最霸道的指令，它不经过目标合约的允许，也不触发目标合约的任何代码（包括 receive 或 fallback），直接修改目标地址的余额。安全上：作为开发者，永远不要假设你的合约余额完全由你控制。在写逻辑时，尽量用 >= 代替 ==，或者单独用一个变量（比如 totalDeposited）来记录存入金额，而不要直接读取 address(this).balance；所以我们要尽量避免这样的事情出现，别让我们的资金无缘无故丢失锁死，在部署智能合约之前，一定要做安全审计。

今天完成了Challenge#0的挑战，并且成功的部署了我的第一个NFT，在这里有一些代码的细节，这里面运用了ERC721标准来实现NFT的铸造和转发，然后通过hardhat部署到测试网络。

通过“My First ZKVote”完善了我对零知识证明基础的理解，零知识证明通常用两个角色来描述：

1.证明者（Prover）：掌握某个秘密信息，希望向他人证明自己「确实知道」这个秘密；

2.验证者（Verifier）：希望确认某个断言是真的，但不想（或不允许）知道该秘密本身。

这个概念有两个很好的故事去理解“阿里巴巴洞穴”“寻找沃尔多”都去阐释了零知识证明的理念，就是要隐私和扩展，体现出他的三个特性（完备性，可靠性，零知识性）在投票系统中：完备性保证「合法选民的合法投票不会被无故拒绝」；可靠性保证「非选民或者试图一人多投的人无法通过验证」；零知识性保证「验证者无法从证明中推断出你是谁、投了什么票」；ZK投票的流程（除了proof和公开输入剩下的都是隐私）生成identitySecret-> 计算identityCommitment->生成proof+nullifier->verify(proof)->检查nullifier未使用

zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）（前端：R1CS，后端：椭圆曲线）

1.Succinct：证明大小很小，验证开销与原始计算规模无关或几乎无关；

2.Non-Interactive：证明是单向的，不需要多轮交互；

3.已被广泛用于隐私交易、zk-Rollup 等场景。

zk-STARK（Zero-Knowledge Scalable Transparent Argument of Knowledge）（前端：AIR（包括 APR、ALI）后端：FRI）

1.不依赖可信初始化；

2.更适合大规模、复杂计算的场景，但证明大小通常更大。

学习了Rust基础，变量，宏，整型和字符；mut关键字用于定义变量，println!()输出（不了解为什么叫宏）整形（i（有符号），u（无符号））char定义字符，for r in （1.6）从一到5的循环不取最后一个数字。

Solidity：荷兰拍卖，基于ERC721的Transferfrom的基础上进行交易，为什么 Web3/NFT 喜欢用荷兰拍？，

荷兰拍有几个巨大的优势：

1.无需后端介入 (完全去中心化)：

正如你的代码所示，getPrice() 函数完全基于 block.timestamp 计算。不需要拍卖师在中间喊价，智能合约自己就能算出当前价格。

2.价格发现 (Price Discovery)：

对于一个新的 NFT 项目，很难确定它到底值多少钱。荷兰拍让市场自己决定：如果起拍价太贵没人买，它会自动降价，直到找到市场认可的价格。

3.防止 Gas War (部分有效)：

如果起拍价设得足够高（以此来冷却早期的抢购热情），可以分散买家的购买时间，避免所有人都在同一秒钟挤爆网络。

4\. 心理博弈 (博弈论)

荷兰拍最有趣的地方在于买家的心理纠结，这是一种 贪婪 vs. 恐惧 的平衡：

贪婪：“现在是 5 ETH，如果我再等一小时，它就会变成 4 ETH，能省好多钱！”

恐惧 (FOMO)：“但是如果我等那一小时，可能就被别人先买走了！那时候我就什么都得不到了。”
<!-- DAILY_CHECKIN_2026-01-19_END -->

# 2026-01-18
<!-- DAILY_CHECKIN_2026-01-18_START -->








| 特性 | Uniswap V1 | Uniswap V2 | Uniswap V3 |
| 发布时间 | 2018 年 11 月 | 2020 年 5 月 | 2021 年 5 月 |
| 核心定位 | 概念验证 (Proof of Concept) | 通用化 DEX (General Purpose) | 资本效率最大化 (Capital Efficiency) |
| 交易对支持 | 仅支持 ETH <=> ERC20 (ERC20 互换需经过 ETH 中转) | 支持任意 ERC20 <=> ERC20 (无需 ETH 作为路由中介) | 支持任意 ERC20 <=> ERC20 (同 V2，但底层算法不同) |
| 流动性机制 | 全范围流动性 (资金均匀分布在 $0-\infty$ 价格区间) | 全范围流动性 (同 V1，资金利用率低) | 集中流动性 (Concentrated Liquidity) (LP 可自定义价格区间提供流动性) |
| 资本效率 | 低 | 低 | 极高 (最高可达 V2 的 4000x) |
| 交易手续费 | 固定 0.3% | 固定 0.3% (增加了协议收费开关，可分流 0.05%) | 多级费率 (0.01%, 0.05%, 0.3%, 1% 等，适应不同波动率资产) |
| LP 代币类型 | ERC-20 代币 | ERC-20 代币 | ERC-721 (NFT) (因为每个 LP 的价格区间不同，是非同质化的) |
| 价格预言机 | 无原生预言机 (依赖瞬时价格，易被操控) | TWAP (算术平均) (时间加权平均价格，抗操纵性强) | TWAP (几何平均) (更易于计算和集成，支持长周期数据) |
| 闪电贷 | 不支持 | 引入 Flash Swaps (允许无抵押借贷交易) | 支持 (机制优化) |
| 滑点与深度 | 较高 (尤其是非热门币种) | 较高 (同 V1) | 极低 (在做市区间内流动性深度极佳) |
| 许可证 | GPL (完全开源) | GPL (完全开源) | BSL (商业源码保护，后转为 GPL) |

区块链桥：众所周知桥是连接两方地理位置的东西，再区块链中，桥是连接两个区块链生态系统，传输了信息和资产，促进了区块链之间的通信，为什么要有链桥呢：跨越传输资产和信息，使去中心化应用程序可以利用各种区块链的优势从而增强功能，能够访问新平台并利用不同链的优势，使来自不同区块链生态系统的开发人员相互协作并为用户构建新平台；桥梁的用例降低交易费，其他区块链上的去中心化应用程序，探索区块链生态系统，拥有原生加密资产

| 需信任桥梁 | 去信任桥梁 |
| 需信任桥梁依赖于中心实体或系统的运作。 | 去信任桥梁使用智能合约和算法运行。 |
| 他们对资金的保管和桥梁的安全性有信任假设。 用户大多依赖桥梁运营商的声誉。 | 这种桥梁免于信任，即桥梁的安全性与底层区块链的安全性相同。 |
| 用户需要放弃对其加密资产的控制。 | 借助智能合约，去信任链桥使用户能够始终控制他们的资金。 |

使用桥梁的风险：智能合约风险，代码错误可能导致资金风险丢失；

技术风险-软件故障；审查风险；保险风险：桥梁运营商可以串通盗取用户资金

EIP-5164：本规范定义了基于EVM的区块链的跨链执行接口。本规范的实现将允许一条链上的合约通过发送跨链消息来调用另一条链上的合约。

该规范定义了两个组件：“消息分发器”和“消息执行器”。消息分发器位于调用端，消息执行器位于接收端。当发送消息时，消息分发器会将消息通过传输层传递到消息执行器，并在执行器中执行消息。该规范的实现必须同时实现这两个组件。许多以太坊协议需要协调多个基于以太坊虚拟机（EVM）的区块链之间的状态变更。这些链通常拥有原生或第三方桥接器，允许以太坊合约执行代码。然而，由于桥接器的API各不相同，因此桥接器的集成往往是定制的。每个桥接器都提供不同的特性，在安全性、速度和控制方面各有差异。定义一个简单通用的规范将提高代码复用率，并允许我们使用通用的桥接器实现。
<!-- DAILY_CHECKIN_2026-01-18_END -->

# 2026-01-17
<!-- DAILY_CHECKIN_2026-01-17_START -->









# zk-STARK 的数学原理

zk-STARK（可扩展透明零知识论证）是一种透明（无需可信设置）、抗量子、可扩展的零知识证明体系。与 zk-SNARK 不同，zk-STARK 不依赖椭圆曲线配对等深度数学工具，而是基于哈希函数和多项式论证。具体来说，STARK 使用代数中间表示（AIR）、代数布局与布线（APR）、代数链接交互式证明（ALI）以及快速 Reed–Solomon 接近性证明（FRI）来构造证明。其特点包括：**无需可信设置**（所有随机性公开可验证）、**后量子安全**（依赖抗量子安全哈希）、以及**多项式的低度测试**等。然而，这种透明性和可扩展性带来代价：STARK 证明体积比 SNARK 大得多（通常是几十到几百 KB 而非 SNARK 的百字节级别），因此验证耗时和通信成本较高。

## AIR

AIR 是将原始计算（如程序执行）转换为多项式约束问题的第一步。首先，证明者根据计算过程生成一个**执行轨迹表**：表格的每行代表一个计算步骤（时钟周期），每列代表一个状态变量（寄存器、内存单元等），其表格大小为 _N_×_w_，_N_ 为步数，_w_ 为寄存器数。每个状态值在有限域上表示，整个轨迹可以看成多项式在求值域上的离散采样。证明者也定义一组**约束条件**：其中**边界约束**规定初始/结束状态（如初始寄存器值、最终输出正确性等），**转换约束**规定相邻行状态间的合法转换（如下一个状态 = 当前状态经计算转移得出）。例如，一个简单 CPU 运算的转换约束可以写成 Trace\[t,1\]+Trace\[t,2\]−Trace\[t+1,3\]=0\\text{Trace}\[t,1\] + \\text{Trace}\[t,2\] - \\text{Trace}\[t+1,3\] = 0Trace\[t,1\]+Trace\[t,2\]−Trace\[t+1,3\]=0  
。当且仅当整个执行轨迹满足所有这些多项式约束时，原始计算才被认为是正确执行的。因此，将计算正确性的陈述归结为多个多项式恒等式——这就是 AIR 的核心思想。

## APR

在构造完执行轨迹和约束后，APR 阶段将这些约束整合并转化为**低度多项式测试**问题。具体步骤包括：首先将轨迹表的每一列插值为一个低度多项式 $f\_i(x)$，这些多项式在某个（扩展）域中插值后代表各列的取值。然后将 AIR 中定义的所有边界约束和转换约束应用到这些列多项式上，构造出一个**组合约束多项式** $\\Psi(x)$，其分子表达必须为零的多项式表达式，分母则是对应的“零点多项式”（zerofier），表示约束适用的域。将 $\\Psi(x)$ 除以分母 $V(x)$（对应的零点多项式）得到商多项式 $Q(x)=\\Psi(x)/V(x)$。如果执行轨迹诚实无误，则分母整除分子且 $Q(x)$ 的次数很低；如果执行轨迹有错误，则 $Q(x)$ 要么无法以整多项式形式存在，要么次数非常高。因此，验证执行轨迹的正确性就转化为**检测 $Q(x)$ 是否为低度多项式**的问题。

为了高效处理所有约束，APR 同时进行以下工作：首先调整所有独立约束多项式的整体最高次数，将它们统一到同一最高次数 $D$，然后引入随机系数将各个约束线性叠加成一个“组合多项式” $H(x)$。这样做的目的是，只需对单个组合多项式进行一次低度测试即可涵盖所有约束条件；如果所有原始约束都被满足，则随机线性组合后的 $H(x)$ 仍然是低度的；若其中有约束被破坏，则 $H(x)$ 以极高概率会成为高次多项式。

## ALI

在 APR 之后，证明系统得到多个商多项式 $Q\_1(x),Q\_2(x),\\dots$（每个约束或约束组合对应一个）。直接验证每个 $Q\_i(x)$ 的低度性会很低效，因此 ALI 阶段引入了随机线性组合技术：验证者从公共随机源中生成一组随机权重 $a\_1,a\_2,\\dots$，证明者将各 $Q\_i(x)$ 按权重合并成一个**复合多项式** $C(x)=a\_1Q\_1(x)+a\_2Q\_2(x)+\\dots$。如果所有 $Q\_i(x)$ 都是低度多项式，则线性组合 $C(x)$ 依然保持低度；而如果哪怕一个 $Q\_i(x)$ 的次数不受约束，则由于权重随机性，$C(x)$ 很大概率成为高次多项式。这样，原来需要多次测试的问题简化为只测试 $C(x)$ 是否低度。因此，到 ALI 阶段结束时，原计算正确性的判定已转换为**判断单个复合多项式 $C(x)$ 是否为低度多项式**的问题。接下来进入最后的 FRI 阶段。

## FRI

FRI（Fast Reed–Solomon IOP of Proximity）协议在后端用以证明复合多项式 $C(x)$ 确实具有承诺的低次数。其核心思路是：证明者多次对 $C(x)$ 取值（在一个较大域上），并构造出这些取值的 Merkle 树，向验证者公开根哈希以作为承诺。接着通过交互式（或非交互式 Fiat–Shamir 方式模拟交互）地“反复折叠”多项式，逐层降低多项式次数，直到简化到常数多项式。验证者则通过随机抽样和查询折叠过程中的取值及 Merkle 证明链条，检测每一步操作是否正确。整个 FRI 协议包括**承诺阶段**和**查询阶段**：

-   **承诺阶段**：证明者先将初始多项式 $p\_0(x)=C(x)$ 表示为两个较低次多项式的拼合形式 $p\_0(x)=g\_0(x^2)+x,h\_0(x^2)$。然后验证者抽取随机值 $\\alpha\_0$，要求证明者承诺合并后的多项式 $p\_1(x)=g\_0(x)+\\alpha\_0 h\_0(x)$（其次数为原来的一半）。证明者不断重复此过程：将 $p\_k$ 拆分为 $g\_k,h\_k$，随机抽样 $\\alpha\_k$，承诺次一级多项式 $p\_{k+1}(x)=g\_k(x)+\\alpha\_k h\_k(x)$，直到次数降为 0（常数多项式）。每一层的多项式取值都通过 Merkle 树承诺给验证者。
    
-   **查询阶段**：验证者为了检查证明者没有作弊，会在第一层多项式中抽取随机点 $z$ 并查询 $p\_0(z)$ 和 $p\_0(-z)$。利用这两个值，验证者可以解算出 $g\_0(z^2)$ 和 $h\_0(z^2)$ 的值（因为 $p\_0(z)=g\_0(z^2)+z,h\_0(z^2)$，$p\_0(-z)=g\_0(z^2)-z,h\_0(z^2)$），进而计算 $p\_1(z^2)=g\_0(z^2)+\\alpha\_0h\_0(z^2)$。然后验证者查询 $p\_1(z^2)$ 并检验其与此前计算结果是否一致，来证明 $p\_1$ 的承诺是正确的。验证者依此类推，依次查询 $p\_1(-z^2)$、并求解 $p\_2(z^4)$、$p\_2(-z^4)$……直到查询到最后的常数多项式的值，并检查其与承诺值是否相符。同时，每一次查询还附带所需的 Merkle 验证路径，以证明取值的正确性。由于每层的多项式度数折半，被证明的低度多项式性质等价于原证明目标。所有随机查询和折叠都基于公开可验证的随机数（通过哈希链方式生成），因此整个协议无需任何秘密或可信设置。
    

通过上述步骤，zk-STARK 的透明证明体系得以构建：证明者提供所有环节的参与信息和 Merkle 证明，验证者仅用公开随机数对其中少量点进行抽查，即可高度置信地判定 $C(x)$ 是否为低度多项式，从而验证原始计算的正确性。**在此过程中无需任何可信设置**，所有随机性公开可验证。然而，由于哈希承诺和多轮折叠的开销，最终生成的 STARK 证明比 SNARK 证明大得多。例如，一位开发者指出：“我们不得不在百字节级的 SNARK 证明和百千字节级的 STARK 证明之间做权衡，后者巨大许多，使得在我们项目中难以应用”。

## 大规模审计示例：会计账簿案例

为了直观理解上述机制，可以用一个审计公司**会计账簿**的例子来类比 zk-STARK 的证明过程。假设公司财务总监（证明者）对首席执行官（验证者）声称：“我已经正确处理了包含 100 万行的会计账簿”。CEO 没有时间逐行检查账目，但希望快速验证这项声明的真实性。利用 zk-STARK 的思想，这个过程可以如下展开：

1.  **构建执行轨迹和约束（AIR 阶段）**：CFO 编写账簿的执行轨迹表，每行代表一笔交易，每列代表状态变量（例如当前余额、交易金额等）。例如，每行最后一列可以记录当前账户余额；每笔交易后，余额应当等于上一笔的余额加上当前交易额。CFO 还定义边界约束：起始余额为 0，最终余额应与实际账户余额相符（例如 500 万美元）。这些约束以多项式形式表示，只有当整个账簿正确时所有约束才成立。
    
2.  **转换为多项式验证问题（APR/ALI 阶段）**：CFO 将账目和约束编码为一个数学图表——可以想象成多变量多项式在 100 万个点上的取值。若账簿无误，该图表在所有点的输出均为“0”；若某行被篡改，对应点则输出非零。从而“账簿是否正确”被转化为“这个多项式图是否恒零（平坦）”的问题。因存在许多约束，需要合成它们：CEO 要求 CFO 使用公开的随机系数，将所有这些多项式随机线性组合成一个**合成多项式**。验证者只需检查合成后的图表是否恒零，而不用单独验证每个原始约束。
    
3.  **多轮承诺和查询（FRI 阶段）**：CFO 将合成多项式的值在多个点上计算出来，并将这些值的 Merkle 根提交给 CEO 作为承诺（无需任何秘密参数）。接下来，CEO 要求 CFO 进一步“简化”这一多项式：模拟 FRI 协议的折叠过程，CFO 在每一步使用公开的随机数生成下一级多项式的承诺并提交，直至最后得到常数多项式。这个过程类似验证者在“玩二十问”：每轮 CEO 可以随机抽查合成多项式在某些点的值和对应的 Merkle 证明，然后 CFO 给出折叠后多项式的相应取值和 Merkle 证明。整个证明过程通过哈希链保证随机性，验证者无需任何秘密信息即可确认流程正确。
    
4.  **验证**：最终，CEO 只得到一份 zk-STARK 证明，便能通过随机抽查少数点来核实。例如，可以验证从第三步合成多项式到第四步合成多项式的一致性转换是否符合预期。在所有抽查都通过的情况下，CEO 高度信任账簿被正确处理，无需亲自检查 100 万行明细。
    

通过这个比喻，我们看到 zk-STARK 证明就像是 CFO 提供的一份“审核日志”，通过分层承诺和随机抽查使 CEO 能够高效审计，而不必逐项检查所有账目。这种方法充分体现了零知识证明中“概率抽样”与“哈希承诺”相结合的原理：只要验证通过，CEO 即可相信账本真实可靠，而无需暴露敏感数据或检查所有细节。

| 标准 | 角色 | 核心问题 | 典型对话 | 关键代码特征 |
| ERC165 | 安检员 / 翻译官 | "你是谁？" | Q: "你会处理 NFT 吗?" A: "会 (True)。"  A: "会（True）。" | supportsInterface(id) |
| ERC20 | 货币 (现金) | "你有多少钱？" | "转给张三 100 块。" | balanceOf (只有余额) |
| ERC721 | 古董 (收藏品) | "这个东西归谁？" | "把 ID 为 #88 的画转给李四。" | Mapping |
| ERC1155 | 集装箱 (杂货) | "你有多少个这种货？" | "给王五发 100 个金币 + 1 把剑。" | balanceOf (人+ID 查余额) |
<!-- DAILY_CHECKIN_2026-01-17_END -->

# 2026-01-16
<!-- DAILY_CHECKIN_2026-01-16_START -->










zk-snarks (零知识简洁非交互式知识论证) 是建立在一条精密数学流水线上的协议。这条流水线将计算机程序的逻辑正确性，一步步转化为多项式的几何特性，并最终压缩为椭圆曲线上的密码学验证。本文将从“算术化”这一关键步骤开始，深度拆解这一技术堆栈。

一、算术化：将代码抽象为矩阵的形式

计算机程序充斥着 if/else 跳转、循环和变量赋值，这些不确定的逻辑流无法直接用于数学证明。zk-SNARKs 的第一步，是必须将这些逻辑强行转化为静态的代数方程，这一过程称为算术化。

1\. 扁平化操作：

复杂的方程式或程序操作被分解为A + B = C或AB = C 形式的简单操作。 (A + B) _B_ C 如何表示为简单的基本操作：GATE 1（加法门）、GATE 2（乘法法门）和 GATE 3（乘法门）。

例如，一个复杂的运算 (a + b)  _b_  c 会被拆解为3个约束门：

加法门（通过乘法模拟）：p:(a + b) \* 1 = s1

乘法门：q:b \* c= s2

乘法门：s1 \* s2 = s3

|   | A | B | C |
| p | q | r | p | q | r | p | q | r |
| 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| A | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| B | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| C | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
| S1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |
| S2 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |
| S3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

图解：

在A中矩阵P对应的1为A+B，在B矩阵中p对应的是1，C中的P为S1

          所以为p:(a + b) \* 1 = s1

### 同理可推导列 q 和列 r。

### 2\. 构建一阶约束系统 (R1CS)

扁平化操作将复杂的逻辑拆解为独立的门（Gate），而 R1CS 则是将这些分散的门组装成一个统一的代数骨架。它由三个系数矩阵A, B, C 和一个核心的见证向量 (Witness Vector, s) 组成。见证向量s：上帝视角的数据全集见证向量 s 是一个包含电路中所有数值的列表。它不仅包含输入变量，还包含所有的中间变量和输出结果，甚至包含常数项 1（用于加法模拟）。基于上面的例子，向量 s 的结构为：s = \[1, a, b, c, s1, s2, s3\]

向量内积约束：用数学“镊子”提取数据

对于电路中的每一个逻辑门（例如门 p），R1CS 利用向量内积 (Dot Product) 作为“选择器”。它通过在矩阵行中填入权重（通常是 0 或 1），从庞大的向量 s 中精准提取出当前步骤所需的数值，并强制它们满足以下核心方程：

(s _Ai)_ (s _Bi) - (s_ Ci) = 0

| 向量分量 | 1 | a | b | c | s1 | s2 | s3 | 作用 |
| 矩阵 A (行 p) | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 提取a+b |
| 矩阵 B (行 p) | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 提取 1 |
| 矩阵 C (行 p) | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 提取 s1 |

运算过程：

左输入 (s _Ap)：(1_ 0) + (a _1) + (b_ 1) + ... = (a + b)

右输入 (s _Bp)：(1_ 1) + (a \* 0) + ... = 1

输出结果 (s _Cp)：(s1_ 1) + ... = s1

将结果代入 R1CS 核心方程：

(a + b) _1 - s1 = 0 =>  (a + b)_ 1 = s1

通过这种方式，R1CS 成功地将动态的代码执行流（程序逻辑），固化为一组静态的、线性代数层面的矩阵约束。无论输入数据如何变化，只要这组矩阵方程成立，就证明了原程序的逻辑被正确执行。

二、多项式压缩（QAP）：

R1CS 虽然成功实现了算术化，但验证效率依然低下。如果电路包含 100 万个门，验证者就需要逐一验证 100 万个矩阵方程。为了实现“简洁性”，我们需要将这些离散的方程打包成一个数学对象。这就要提到我们的二次算术规划 (QAP) 技术

1\. 拉格朗日插值：从列向量到多项式

利用拉格朗日插值法，我们将 R1CS 矩阵中的每一列（代表不同门的约束系数），拟合成一条连续平滑的多项式曲线。

变换逻辑：

矩阵 A 的每一列  转化为多项式 A(x)

矩阵 B 的每一列  转化为多项式 B(x)

矩阵 C 的每一列  转化为多项式 C(x)

物理意义：之前的约束是“第 1 步检查行 1，第 2 步检查行 2……”，现在的约束变成了“检查曲线 A(x)、B(x)、C(x) 在几何上的整体关系”。

目标多项式与整除性，此时，成千上万个独立的 R1CS 约束方程被压缩为一个核心多项式方程：

A(x) _B(x) - C(x) = H(x)_ Z(x)

目标多项式 Z(x)：这是一个预定义的“标尺”，其根为所有逻辑门的索引（如 x=1, 2, 3）。这意味着在每一個逻辑步骤点上，Z(x) 的值都为 0。

整除性验证：问题被转化——只要计算出的组合多项式 A(x) \* B(x) - C(x) 能够被 Z(x) 整除（即没有余数），就在数学上证明了原电路在每一个逻辑步骤上都是正确的。

三、概率性验证：施瓦茨-齐佩尔引理与O(1)效率

1\. 施瓦茨-齐佩尔引理 该数学引理指出：两个不相等的最高阶多项式，在极大的取值范围内随机取点，其函数值相等的概率接近于零。

这意味着，验证者不需要下载整条曲线进行比对，只需要在任意一个秘密随机点 t0 上比对一次：

A(t0)\* B(t0) - C(t0) = H(t0)\* Z(t0)

2\. 简洁性  无论原始计算有多复杂（哪怕是验证整个以太坊区块的交易），验证者的工作量都被压缩为一次常数级 O(1) 的乘法检查。这是 zk-SNARKs 能够用于区块链扩容（zk-Rollup）的根本原因——验证成本与计算量解耦。

四、椭圆曲线与信任

算术化与多项式压缩虽然将逻辑转化为了数学验证，但直接处理多项式数值依然面临隐私裸露与伪造证明的双重风险。为了解决这一问题，zk-SNARKs 构建了一套精密的密码学防御体系，我们可以通过一个“制药公司的新药验证”场景来深刻理解这一过程。

首先是解决数据的隐私问题。在数学层面，系统引入了椭圆曲线密码学（ECC）来构建“同态隐藏”机制。这一步骤可以类比于一家制药公司必须向监管机构证明其新药的有效性，但绝不能泄露其核心商业机密——秘密配方。该公司并非直接提交实际的秘密成分（即见证数据 A、B）及其最终化合物（C），而是将每种成分溶解在一种特殊的“加密溶剂”中。这种溶剂（椭圆曲线生成元）能够完美隐藏成分的分子结构，使得监管机构只能看到混合后的溶液，而无法逆向还原出原始的化学成分。这在数学上对应了离散对数难题的单向性，从物理层面保证了没有任何人能暴力破解出原始数据。

然而，一旦成分被溶解，监管机构便无法直接通过化学反应来验证其有效性。为了突破这一困境，系统利用了双线性配对技术。这相当于监管机构拥有一台名为“关系分析仪”的高科技设备。监管机构并不需要直接分析那些被隐藏的成分，而是将装有三种溶液的容器放入分析仪。该设备会检查这三种溶液的“能量波长关系”是否满足特定的数学公式（即验证 A \* B = C）。通过这种方式，监管机构无需了解药物的具体秘密成分，即可确信“配方公式”是正确无误的。这便实现了逻辑验证与信息泄露的完美解耦。

最后，为了确保整个验证体系的根基不被动摇，必须解决信任源头的问题。整个验证过程的可信度，完全取决于那台“关系分析仪”本身是否是公平构建的。

在 zk-SNARKs 中，这对应着“可信设置”环节。这台设备必须由可信的第三方机构（如国际标准组织）制造，以防止被篡改。而制造过程中使用的“初始蓝图”（即系统初始化时的随机点 t0）绝不能泄露。一旦该蓝图泄露，任何人都可以根据蓝图制造出能够欺骗系统的“假冒分析仪”（即伪造证明）。因此，该蓝图被视为“有毒废物”。在设备制造完成并提取出公共参数后，必须在所有利益相关者面前彻底销毁这份蓝图，以建立“无人能够操纵系统”的绝对信任。

总之，zk-SNARKs 是一种将信息转换为多项式形式的数学系统，它能够在单点进行高效验证，并对整个过程进行加密。凭借这种结构，zk-SNARKs 在保证计算正确性的同时，完美避免了信息泄露，从而兼具了高效性（Succinctness）和隐私性（Privacy），并已成为现代零知识证明技术的核心基础。

    看到这里，你一定会产生一个疑问：为什么我们要大费周章，把直观的代码逻辑简化成这种仅包含加法和乘法的“算术电路”？这就考虑到了zk-SNARKs的底层设计哲学，也取决于后端的工具偏好，有限域 zk-SNARKs 的后端并不是在普通的整数或二进制上运行的，而是在有限域上运行的。你可以把有限域想象成一个巨大的、循环的数字时钟。 在这个“时钟”世界里，加法 (+) 和 乘法 (\*) 是最高效、最自然的运算。所有的现代密码学原语（如椭圆曲线）都是基于这两个运算构建的。算术电路恰好只包含加乘，因此它是连接代码逻辑与底层密码学的最佳通用语。效率的降维打击

如果我们使用计算机熟悉的布尔电路（与门、或门、异或门）：

计算一个 256 位大整数的乘法（A \* B），可能需要成千上万个逻辑门（因为要处理每一位的进位）。

而在算术电路中，这只是 1 个乘法门 (A\* B = C)。

3\. 为多项式（QAP）铺路

别忘了我们的下一步是将电路转化为多项式。多项式 P(x) 本质上就是变量的加权和与乘积。算术电路（加/乘）与多项式结构存在天然的 1:1 映射。

所以选择算术电路，是因为它是将“计算代价”压缩到最小的唯一数学路径。它就像是把复杂的自然语言（代码）翻译成了最精简的莫尔斯电码（加乘），以便后续的数学机器能以光速处理。

zk-SNARKs 的局限性：可信设置 (Trusted Setup) 的阴影

zk-SNARKs 具有强大的性能和效率，但最终会面临被称为可信设置的结构性限制。如果恶意方获取了设置过程中使用的密钥，他们就可以生成无限多个看似有效的证明，而这些证明实际上并不成立——从而彻底破坏系统的信任。

因此，可信设置的存在本身就引入了集中式单点故障的漏洞。如果设置过程由单个实体或小组执行，则存在他们可能恶意行事或遭受外部攻击的风险，从而导致密钥泄露。最终，系统安全依赖于“一个完全可信的仪式”，这本身就具有讽刺意味。

因此，可信设置被认为是零知识证明SNARK系统中最关键的攻击途径之一。为了缓解这一问题，实现方案通常采用多方计算（MPC）进行设置，或者采用完全不需要可信设置的新型零知识证明系统。

今日solidity学习：ERC165 & ERC721：

ERC165标准接口检测，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了 ERC721，ERC1155的接口。

ERC721处理非同质化代币标准（NFT）
<!-- DAILY_CHECKIN_2026-01-16_END -->

# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->











今天看了很有趣的文章，让我在零知识证明的方面了解到了在初期对与隐私的保护，解决了我之前对信息泄露方面的疑惑，现在对于今日知识进行一个总结和理解：零知识证明的概念最早是由 Goldwasser, Micali 和 Rackoff 在 1985年 的论文中提出的。当时的状况： 全是复杂的数学公式，非常晦涩，普通人（甚至很多计算机专家）都很难理解“如何能证明一件事却不告诉你是怎么证明的”，在此之后有了两个经典的故事：

阿里巴巴洞穴 (1989年)： 这是最早期的解释。就在 ZKP 发明仅仅 4 年后，密码学家 Jean-Jacques Quisquater 发表了一篇著名的论文《如何向你的孩子解释零知识协议》。他创造了“阿里巴巴洞穴”这个故事，专门用来向非专业人士解释 ZKP 的核心逻辑（交互式证明）。所以，这是真正的元老级例子。我来简单的阐述一下这个故事的内容：在一个有a,b出口的洞穴里，要讲出密令才能找到出口并出去，但是只有2知道密令是什么，但他不想告诉验证者1，只想证明2知道这个密令，这时候1就要去证实2，过程：1在洞穴外让2按照他的命令从a出或者从b出（不能仅执行几次，会有概率疑惑产生），重复多次，2都可以通过密令从指定的洞口出来，这就验证了2知道这个秘令，但是不知道这个密令是什么，保证了隐私。

第二个故事时”寻找沃尔多”准备工作：佩吉用一张大纸盖住原图。这张纸遮住了整幅画，但可以剪出一个刚好和沃尔多大小一样的小洞。维克多先检查一下纸是否完全盖住了画。

证据制作：在维克多的视线之外，佩吉在床单上沃尔多所在的位置剪了一个洞。

展示证据：佩吉只向维克多展示了剪开的一小块区域，而照片的其余部分仍然被遮盖着。

验证：透过小孔，维克多可以清楚地看到沃尔多的标志性特征（红色条纹衬衫、眼镜等）。

重复：由于一次事件可能是运气或欺骗，维克多可能会用另一张照片重复此操作，并再次要求提供证据。附图：

![G-s4UNMa0AAQ8fk.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-15-1768485815888-G-s4UNMa0AAQ8fk.jpg)

X402协议：一种开放的，互联网原生的支付方式（极低边际成本、接近零的单笔支付摩擦），且根据浏览器的HTTP协议不用额外的通信，有五个特性，零协议费用（但要支付少量的支付网络费用），零等待（速度和互联网一样快），零摩擦（不用提供账户和个人信息），去中心化，零限制（不用特定的网络），对比传统的方式讲：要新的api创建账户，添加支付方式，买积分订阅管理密钥很满且麻烦，402通过用ai代理发送HTTP请求并收到402错误：（需要支付），然后ai代理用稳定币去（即时）付款，已授予API访问权限（不用去管理API密钥风险）
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->












今日学习：

以太坊上有两种账户类型：EOA（Externally Owned Account，外部拥有账户） 和 合约账户（Contract Account）。它们是整个以太坊生态的基础，所有交易、转账、dApp交互都围绕这两种账户展开：

| 项目 | EOA（外部拥有账户） | 合约账户（Contract Account） |
| 控制方式 | 由私钥（外部拥有）控制，用户通过钱包签名交易 | 由部署的智能合约代码控制，无私钥 |
| 地址生成方式 | 由公钥通过Keccak-256哈希生成（0x开头） | 由部署者地址 + nonce哈希生成（也0x开头） |
| 是否有代码 | 无代码（codeHash为空） | 有字节码（bytecode）和存储状态 |
| 能否主动发起交易 | 可以（外部交易，external transaction） | 不能主动发起，只能被调用后执行内部交易 |
| 余额 | 可以持有ETH、代币 | 可以持有ETH、代币（合约可编程控制） |
| 典型例子 | 你的MetaMask钱包地址 | Uniswap、Aave、ERC20代币合约地址 |
| nonce | 交易计数器（防止重放攻击） | 交易计数器 + 合约创建计数器 |
| 存储（storage） | 无（或极少） | 有（合约变量、映射等持久化数据） |

二叉默克尔树（适用于BTC） vs. 默克尔-帕特里夏树 (MPT)（又称世界状态树）

|   | 标准二叉默克尔树 (Binary Merkle Tree) | 默克尔-帕特里夏树 (Merkle Patricia Trie, MPT) |
| 典型应用 | Bitcoin (比特币) 交易树 | Ethereum (以太坊) 状态树、交易树、收据树 |
| 数据结构基础 | 纯粹的 二叉树 (Binary Tree) | 基数树 (Radix Trie) + 默克尔树的结合体 |
| 分支数量 (Arity) | 2 (每个节点最多2个子节点) | 16 (十六进制前缀树，Hexary Trie) |
| 主要目的 | 验证数据的存在性 (Inclusion Proof) | 高效管理键值对 (Key-Value) 状态 及其更新 |
| 数据动态性 | 静态优化：一旦生成（如区块打包后），通常不再修改。修改一个数据需要重构树的大部分。 | 动态优化：专为频繁的插入、更新、删除设计。每次状态变更只需重新计算受影响路径的哈希。 |
| 键值映射 (Key Mapping) | 无特定键值路径逻辑，通常按列表顺序排列。 | 确定性路径：数据的 Key (如地址的哈希) 决定了数据在树中的位置。 |
| 存储效率 | 较高，结构简单，仅存储哈希。 | 较低，结构复杂，需引入空节点、扩展节点(Extension)、分支节点(Branch)和叶子节点(Leaf)来压缩路径。 |
| 查询复杂度 | $O(\log_2 n)$ | $O(\log_{16} n)$ (由于分支多，树高通常更低，查询步数更少) |
| 抗碰撞性 | 依赖哈希函数的抗碰撞性。 | 同样依赖哈希，但路径本身作为 Key 提供了额外的索引确定性。 |

比特币 (二叉树)：比特币的区块就像一本账本的一页。一旦这页写好了（区块被挖出），里面的交易顺序和内容就是固定的。因此，使用简单的二叉树将所有交易哈希两两合并，生成一个 Root Hash 即可。它不需要支持“快速修改”。

以太坊 (MPT)：以太坊是一个“世界状态机”。账户余额、Nonce、智能合约存储（Storage）在每个区块之间都会发生变化。如果使用二叉树，每次有人转账，你都需要重新排列整个树来计算新的 Root，效率极低。MPT 结合了前缀树（Trie）的特性，使得修改某个账户的余额时，只需要更新该账户对应的路径分支，而无需重算整棵树。

2\. 路径确定性： (Determinism)二叉树：数据的顺序很重要。交易 A 在左边，交易 B 在右边，生成的 Root 是 $H(A+B)$。如果交换顺序，Root 就会改变。MPT：位置由 Key 决定。例如，无论你以什么顺序插入数据，只要 Key（例如钱包地址）相同，它在树中的位置就是固定的。这对于验证以太坊这种去中心化的全局状态至关重要——所有节点必须对“状态树”的结构达成绝对一致。

3\. 节点类型的复杂性：

二叉树：只有一种节点逻辑（左哈希 + 右哈希 = 父哈希）。

MPT：为了解决“稀疏性”问题（即地址空间很大，但实际使用的地址很少），MPT 引入了复杂的节点类型来压缩路径：

Leaf Node (叶子节点)：存储真正的数据（Value）。

Branch Node (分支节点)：也就是路口，有16个分支指向下一层。

Extension Node (扩展节点)：用于“跳过”没有任何分支的长路径，优化存储效率。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->













今日基础知识学习记录：

了解了以太坊节点是如何构成网络的，官方知识点：节点node是任何一台运行以太坊客户端软件并连接到其他节点的电脑，就是一个以太坊节点，客户端是对以太坊协议的具体体现，会按照协议规则验证数据，同步区块状态，帮助网络保持完全，在（The Merge）之后，节点由执行客户端和共识客户端两个核心客户端组成外加一个接口（Engine API）这个是基于JSON-RPC的本地接口。下面是在内部网络的流程：

1,交易进场,执行客户端 (EL)(如 Geth),收到用户的转账请求，验证格式后存入内存池，并广播给其他节点。,MempoolExecution P2P

2,区块进场,共识客户端 (CL)(如 Prysm),从外部网络收到一个新的区块提议（里面包含打包好的交易）。,Block ProposalConsensus P2P

3,请求验证,CL → EL(经理呼叫会计),共识客户端通过接口把交易数据扔给执行客户端：“跑一遍数据，看合不合法？”,Engine APIengine\_newPayload

4,执行计算,执行客户端 (EL)(如 Geth),实际运行 EVM，查询状态数据库（检查余额、Nonce、签名）。,EVMStateDB

5,返回结果,EL → CL(会计回复经理),执行客户端反馈验证结果：有效 (VALID) 或 无效 (INVALID)。,"JSON-RPC Response{status: ""VALID""}"

6,确认共识,共识客户端 (CL)(如 Prysm),收到“有效”确认后，将该区块设为最新的链头，并广播投票。,Fork ChoiceAttestation

Solidity学习：今日研究多签名钱包，它是整个在Web3组织治理和资金安全的基石，充当于一个钥匙的作用，预防丢失提升安全性，他主要体现以下场景中：

1、DAO（去中心化自治组织）的管理，多签钱包应用最为广泛的场景，在一个组织通过筹集得来的资金，由选出的几位社区核心贡献者作为owners，想要取走资金必须得到这几位owners的签名才可通过（例如有7位，则最小通过4位即可），社区成员不需要信任某一个具体的人只需要信任整个代码规则即可

2、项目方的”Admin Key”管理，是DeFi协议的最关键的安全防线，在 Uniswap 或 Aave 这样的协议，通常有一些特权操作，比如“升级合约代码”、“修改手续费率”或者“紧急暂停协议”，多签解决方案：协议的 Owner 被设置为一个多签钱包合约地址任何对协议参数的修改，本质上都是一次 submitTransaction（提交提案）必须由项目方的多位核心开发者、甚至外部的安全审计机构共同签名（Confirm），修改才能生效（Execute）。

以下是这个函数的构造：定义状态变量owners(合伙人)，isOwner(映射合伙人状态)，numConfirmationsRequired（最小验证需求数量），Transaction（结构体储存对应数据信息（to,value,data,execute,numConfirmtions））,isConfirmed(映射，几号=>合伙人=>验证状态),transactions(存储结构体信息)，里面主要有四个主函数submitTransaction（（提议）把这一笔待处理的交易详情，永久地记录在区块链的“账本”上），

confirmTransaction（认证），executeTransaction（通过认证执行），revokeConfirmation（回撤），同时他们的函数加上了modifier修饰符，为了给函数加入控制权限。而在目前Gnosis Safe 就是一套“完全免费签字、最后一次性打包寄出的企业级银行系统”。它在逻辑上把你代码中的多次链上交互（Confirm）变成了链下无Gas签名，只有最后一步执行时才上链付费，极大地节省了成本；同时它采用了“模具+克隆”（代理模式）的安全架构，让你的资金由一套经过千亿资产验证的公共逻辑库守护，还能像手机装APP一样通过“模块（Modules）”随意扩展功能（比如设置每日限额或自动理财），因此它成为了 Web3 世界管理公款的最高标准。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->














基础知识梳理：

以太坊：以太坊是一个去中心化的区块链网络，也是个软件开发平台，用以太币（ETH）作为燃料。它支持成千上万的加密货币，还有各种应用，比如去中心化金融（DeFi）、非同质化代币（NFT）、游戏、社交媒体和稳定币。以太坊是开源的，由Vitalik Buterin和几个联合创始人在2015年7月推出。核心想法是通过智能合约这种开源程序，让任何人创建数字资产和全球24/7运行的去中心化应用（dApp）

以太坊的核心概念：

区块链：由区块和链构成公共去中心化链，其特性为：不可篡改；公开透明；快速交易的特性。

智能合约：开源程序，就是一段代码，部署完成后具有不可篡改的特性，在之前需要严格审查安全问题

ETH： ETH 就是这台计算机的gas 你想在这台计算机上做任何事（比如转账、运行上面的智能合约、发个 NFT），都需要消耗计算资源，而 ETH 就是你付给验证者的小费。当然，它本身也是钱，可以用来储值。gas=Base Fee+Tip

去中心化：没中央控制，也没人能随意修改你的数据，抗审查、安全可靠。

pow和pos之间的区别：

|   | PoW (工作量证明) | PoS (权益证明) |
| 运作机制 | 算力竞赛谁的电脑算得快，谁就有权记账。 | 随机抽签谁质押的钱(ETH)多，被选中记账的概率就大。 |
| 记账人 | 矿工 | 验证者 |
| 门槛 (Sybil Resistance) | 硬件 + 电力需要购买显卡/矿机，消耗巨额电费。 | 32 ETH需要将 ETH 锁定在智能合约中。 |
| 奖机制 | 只有奖励，很难惩罚矿工干坏事只能拒绝其区块，无法没收他的矿机。 | 奖励 + 罚没验证者作恶（如双重签名），质押的 ETH 会被直接销毁。 |
| 能源消耗 | 极高相当于一个中等国家的耗电量。 | 极低减少了 99.95%，只需普通服务器即可运行。 |
| 抗攻击门槛 | 51% 算力攻击需要拥有全网一半以上的计算能力。 | 51% 资金攻击需要控制全网一半以上的质押 ETH（数千亿美元）。 |
| 经济模型 | 通胀必须大量印钱给矿工付电费，抛压大。 | 通缩印钱少 + 燃烧机制 (EIP-1559)。 |
| 确定性 | 概率性需要等十个区块确认才算安全。 | 确定性经过两个 Epoch (约12.8分钟) 后，交易绝对不可逆。 |

以太坊网络（抗审查，高度安全，持久而可靠）L1和L2的区别：

|   | Layer 1 (L1) | Layer 2 (L2) | Layer 3 （拓展） |
| 层级定义 | 结算层 (Settlement) | 通用扩容层 (Scaling) | 应用定制层 (Application) |
| 代表项目 | Ethereum Mainnet | Arbitrum One, Optimism, Base | Arbitrum Orbit, OP Stack L3, Xai |
| 核心职责 | 最终裁决与安全保证账本不可篡改，提供去中心化信任。 | 通用计算与压缩处理绝大多数交易，打包压缩后发给 L1。 | 极致定制与体验为特定APP（如链游、高频DeFi）设计的专用链。 |
| 通俗类比 | 中央银行 / 最高法院 | 商业银行 / 地方法院 | 支付宝 / 专属会员俱乐部 |
| Gas 费用 | 极贵 ($5 - $50) | 便宜 ($0.01 - $0.1) | 几近于零 (甚至可由项目方代付) |
| 速度 (TPS) | 极慢 (15 TPS) | 快 (2,000+ TPS) | 极速 (10,000+ TPS, 瞬间确认) |
| 安全性来源 | 依靠全球几十万个验证节点 (PoS)。 | 继承 L1 的安全性 (数据最终在 L1)。 | 继承 L2 的安全性 (数据最终在 L2)。 |

钱包：我们使用MetaMask创建了一个新的钱包，生成了一个由12个单词组成的助记词。这个助记词最重要，请勿泄露！MetaMask 使用助记词默认生成了一个钱包。一个助记词创建可以无限个钱包，每个钱包将包含一个钱包地址（公钥）和一个私钥。钱包地址可以是公开的，但是私钥是可以不公开的，永远用 [etherscan.io](http://etherscan.io) 双重确认交易，别只信MetaMask界面。

根据椭圆曲线的知识简单了解了一下私钥的形成：

![a932fdfe3de80da9df02f1e08d6cb0e.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-12-1768209705329-a932fdfe3de80da9df02f1e08d6cb0e.jpg)

对于安全预防（目前早上答题情况总结出来的钓鱼信息）：

网络钓鱼的迹象包括：域名，预填收款人的地址，合约地址，UI差异，使用 DeFi 应用时，务必核实域名、合约地址和收款人地址。任何一个错误都可能导致资金的不可挽回损失。

Uniswap V3 多重调用钓鱼攻击原理：攻击者利用合法的 Uniswap V3 Multicall 合约创建交易。它们使用聚合函数将多个调用捆绑在一起。这包括授权呼叫（使用您的签名）和转接呼叫。捆绑交易允许他们在一次交易中完成代币的授权和转移。

书签攻击的工作原理：书签攻击是指诱骗用户将恶意 JavaScript 代码添加到浏览器书签中。当用户在 Discord 上点击这些书签时，这些书签会执行有害代码，窃取敏感信息或控制用户帐户。

预防：务必仔细核实签名请求，尤其是对于捆绑交易。要警惕类似 aggregate 或 multicall 这样的函数，它们可能隐藏恶意操作。检查实际执行的调用数据，而不仅仅是合约地址。使用具备高级交易模拟功能的钱包。分散资产，规划钱包用途。就像你的银行卡一样，禁止账户减少操作，只作存储和转账不操作和使用。日常高频使用账户只放少量资产。在刷空投或者参与新项目时，最好咨询有经验的朋友或者查看合约代码等以确保没有问题再进行操作。

今日solidity学习：今天学习了ERC20代币标准，ERC-20本质： 它不是代码，它是一份像是接口规范文档。它规定了一个代币合约必须拥有哪几个函数（比如查余额、转账），名字必须一模一样。在代码中我们可以发现有两个文件一个是IERC20用于接口的文件（IERC20主要用于定标准），里面包含着balance(address)(查看余额)，totalSupply()(总币)，transfer(to, amount)(转账)，transferFrom(from, to, amount)(DeFi的核心思想，操作别人的钱给你)，approve(spender, amount)(用于授权，准许别人动用多少钱)，allowance(owner,spender)(检查授权余额)这六重要函数，ERC20来实现代码逻辑，发新币。定义接口是为了方便调用和gas优化，并且同时理解了在IERC20中和ERC20中external和public的区别和用法：在ERC20标准中，接口（IERC20）定义为 external 是确立了“外部必须能调用”的最小范围，而实现（ERC20）改为 public 是为了赋予合约内部复用及子合约重写的灵活性（例如在 transfer 中嵌入额外逻辑）；相比之下，external 强制直接从 calldata 读取数据，避免了复制到内存的开销，因此在处理复杂参数时更省 Gas，且能清晰表达“仅限外部入口”的语义。一句话原则：如果函数需要被内部或其他合约继承调用，必须用 public；如果仅作为外部入口（如 mint/burn），首选 external 以明确意图并优化性能。顺便补充一下internal和private的区别，两者都是不可以被外部合约调用，前者可以被继承调用后者不可以，private 只有在你非常确定不希望子合约修改、访问或破坏这段逻辑时才使用。它更多是一种安全防护或避免命名冲突的手段。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
