---
timezone: UTC+8
---

# dadwawd1-ops

**GitHub ID:** dadwawd1-ops

**Telegram:** 

## Self-introduction

Web3 实习计划 2025 冬季实习生

## Notes

<!-- Content_START -->
# 2026-01-15
<!-- DAILY_CHECKIN_2026-01-15_START -->
今天看了很有趣的文章，让我在零知识证明的方面了解到了在初期对与隐私的保护，解决了我之前对信息泄露方面的疑惑，现在对于今日知识进行一个总结和理解：零知识证明的概念最早是由 Goldwasser, Micali 和 Rackoff 在 1985年 的论文中提出的。当时的状况： 全是复杂的数学公式，非常晦涩，普通人（甚至很多计算机专家）都很难理解“如何能证明一件事却不告诉你是怎么证明的”，在此之后有了两个经典的故事：

阿里巴巴洞穴 (1989年)： 这是最早期的解释。就在 ZKP 发明仅仅 4 年后，密码学家 Jean-Jacques Quisquater 发表了一篇著名的论文《如何向你的孩子解释零知识协议》。他创造了“阿里巴巴洞穴”这个故事，专门用来向非专业人士解释 ZKP 的核心逻辑（交互式证明）。所以，这是真正的元老级例子。我来简单的阐述一下这个故事的内容：在一个有a,b出口的洞穴里，要讲出密令才能找到出口并出去，但是只有2知道密令是什么，但他不想告诉验证者1，只想证明2知道这个密令，这时候1就要去证实2，过程：1在洞穴外让2按照他的命令从a出或者从b出（不能仅执行几次，会有概率疑惑产生），重复多次，2都可以通过密令从指定的洞口出来，这就验证了2知道这个秘令，但是不知道这个密令是什么，保证了隐私。

第二个故事时”寻找沃尔多”准备工作：佩吉用一张大纸盖住原图。这张纸遮住了整幅画，但可以剪出一个刚好和沃尔多大小一样的小洞。维克多先检查一下纸是否完全盖住了画。

证据制作：在维克多的视线之外，佩吉在床单上沃尔多所在的位置剪了一个洞。

展示证据：佩吉只向维克多展示了剪开的一小块区域，而照片的其余部分仍然被遮盖着。

验证：透过小孔，维克多可以清楚地看到沃尔多的标志性特征（红色条纹衬衫、眼镜等）。

重复：由于一次事件可能是运气或欺骗，维克多可能会用另一张照片重复此操作，并再次要求提供证据。附图：

![G-s4UNMa0AAQ8fk.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-15-1768485815888-G-s4UNMa0AAQ8fk.jpg)

X402协议：一种开放的，互联网原生的支付方式（极低边际成本、接近零的单笔支付摩擦），且根据浏览器的HTTP协议不用额外的通信，有五个特性，零协议费用（但要支付少量的支付网络费用），零等待（速度和互联网一样快），零摩擦（不用提供账户和个人信息），去中心化，零限制（不用特定的网络），对比传统的方式讲：要新的api创建账户，添加支付方式，买积分订阅管理密钥很满且麻烦，402通过用ai代理发送HTTP请求并收到402错误：（需要支付），然后ai代理用稳定币去（即时）付款，已授予API访问权限（不用去管理API密钥风险）
<!-- DAILY_CHECKIN_2026-01-15_END -->

# 2026-01-14
<!-- DAILY_CHECKIN_2026-01-14_START -->

今日学习：

以太坊上有两种账户类型：EOA（Externally Owned Account，外部拥有账户） 和 合约账户（Contract Account）。它们是整个以太坊生态的基础，所有交易、转账、dApp交互都围绕这两种账户展开：

| 项目 | EOA（外部拥有账户） | 合约账户（Contract Account） |
| 控制方式 | 由私钥（外部拥有）控制，用户通过钱包签名交易 | 由部署的智能合约代码控制，无私钥 |
| 地址生成方式 | 由公钥通过Keccak-256哈希生成（0x开头） | 由部署者地址 + nonce哈希生成（也0x开头） |
| 是否有代码 | 无代码（codeHash为空） | 有字节码（bytecode）和存储状态 |
| 能否主动发起交易 | 可以（外部交易，external transaction） | 不能主动发起，只能被调用后执行内部交易 |
| 余额 | 可以持有ETH、代币 | 可以持有ETH、代币（合约可编程控制） |
| 典型例子 | 你的MetaMask钱包地址 | Uniswap、Aave、ERC20代币合约地址 |
| nonce | 交易计数器（防止重放攻击） | 交易计数器 + 合约创建计数器 |
| 存储（storage） | 无（或极少） | 有（合约变量、映射等持久化数据） |

二叉默克尔树（适用于BTC） vs. 默克尔-帕特里夏树 (MPT)（又称世界状态树）

|   | 标准二叉默克尔树 (Binary Merkle Tree) | 默克尔-帕特里夏树 (Merkle Patricia Trie, MPT) |
| 典型应用 | Bitcoin (比特币) 交易树 | Ethereum (以太坊) 状态树、交易树、收据树 |
| 数据结构基础 | 纯粹的 二叉树 (Binary Tree) | 基数树 (Radix Trie) + 默克尔树的结合体 |
| 分支数量 (Arity) | 2 (每个节点最多2个子节点) | 16 (十六进制前缀树，Hexary Trie) |
| 主要目的 | 验证数据的存在性 (Inclusion Proof) | 高效管理键值对 (Key-Value) 状态 及其更新 |
| 数据动态性 | 静态优化：一旦生成（如区块打包后），通常不再修改。修改一个数据需要重构树的大部分。 | 动态优化：专为频繁的插入、更新、删除设计。每次状态变更只需重新计算受影响路径的哈希。 |
| 键值映射 (Key Mapping) | 无特定键值路径逻辑，通常按列表顺序排列。 | 确定性路径：数据的 Key (如地址的哈希) 决定了数据在树中的位置。 |
| 存储效率 | 较高，结构简单，仅存储哈希。 | 较低，结构复杂，需引入空节点、扩展节点(Extension)、分支节点(Branch)和叶子节点(Leaf)来压缩路径。 |
| 查询复杂度 | $O(\log_2 n)$ | $O(\log_{16} n)$ (由于分支多，树高通常更低，查询步数更少) |
| 抗碰撞性 | 依赖哈希函数的抗碰撞性。 | 同样依赖哈希，但路径本身作为 Key 提供了额外的索引确定性。 |

比特币 (二叉树)：比特币的区块就像一本账本的一页。一旦这页写好了（区块被挖出），里面的交易顺序和内容就是固定的。因此，使用简单的二叉树将所有交易哈希两两合并，生成一个 Root Hash 即可。它不需要支持“快速修改”。

以太坊 (MPT)：以太坊是一个“世界状态机”。账户余额、Nonce、智能合约存储（Storage）在每个区块之间都会发生变化。如果使用二叉树，每次有人转账，你都需要重新排列整个树来计算新的 Root，效率极低。MPT 结合了前缀树（Trie）的特性，使得修改某个账户的余额时，只需要更新该账户对应的路径分支，而无需重算整棵树。

2\. 路径确定性： (Determinism)二叉树：数据的顺序很重要。交易 A 在左边，交易 B 在右边，生成的 Root 是 $H(A+B)$。如果交换顺序，Root 就会改变。MPT：位置由 Key 决定。例如，无论你以什么顺序插入数据，只要 Key（例如钱包地址）相同，它在树中的位置就是固定的。这对于验证以太坊这种去中心化的全局状态至关重要——所有节点必须对“状态树”的结构达成绝对一致。

3\. 节点类型的复杂性：

二叉树：只有一种节点逻辑（左哈希 + 右哈希 = 父哈希）。

MPT：为了解决“稀疏性”问题（即地址空间很大，但实际使用的地址很少），MPT 引入了复杂的节点类型来压缩路径：

Leaf Node (叶子节点)：存储真正的数据（Value）。

Branch Node (分支节点)：也就是路口，有16个分支指向下一层。

Extension Node (扩展节点)：用于“跳过”没有任何分支的长路径，优化存储效率。
<!-- DAILY_CHECKIN_2026-01-14_END -->

# 2026-01-13
<!-- DAILY_CHECKIN_2026-01-13_START -->


今日基础知识学习记录：

了解了以太坊节点是如何构成网络的，官方知识点：节点node是任何一台运行以太坊客户端软件并连接到其他节点的电脑，就是一个以太坊节点，客户端是对以太坊协议的具体体现，会按照协议规则验证数据，同步区块状态，帮助网络保持完全，在（The Merge）之后，节点由执行客户端和共识客户端两个核心客户端组成外加一个接口（Engine API）这个是基于JSON-RPC的本地接口。下面是在内部网络的流程：

1,交易进场,执行客户端 (EL)(如 Geth),收到用户的转账请求，验证格式后存入内存池，并广播给其他节点。,MempoolExecution P2P

2,区块进场,共识客户端 (CL)(如 Prysm),从外部网络收到一个新的区块提议（里面包含打包好的交易）。,Block ProposalConsensus P2P

3,请求验证,CL → EL(经理呼叫会计),共识客户端通过接口把交易数据扔给执行客户端：“跑一遍数据，看合不合法？”,Engine APIengine\_newPayload

4,执行计算,执行客户端 (EL)(如 Geth),实际运行 EVM，查询状态数据库（检查余额、Nonce、签名）。,EVMStateDB

5,返回结果,EL → CL(会计回复经理),执行客户端反馈验证结果：有效 (VALID) 或 无效 (INVALID)。,"JSON-RPC Response{status: ""VALID""}"

6,确认共识,共识客户端 (CL)(如 Prysm),收到“有效”确认后，将该区块设为最新的链头，并广播投票。,Fork ChoiceAttestation

Solidity学习：今日研究多签名钱包，它是整个在Web3组织治理和资金安全的基石，充当于一个钥匙的作用，预防丢失提升安全性，他主要体现以下场景中：

1、DAO（去中心化自治组织）的管理，多签钱包应用最为广泛的场景，在一个组织通过筹集得来的资金，由选出的几位社区核心贡献者作为owners，想要取走资金必须得到这几位owners的签名才可通过（例如有7位，则最小通过4位即可），社区成员不需要信任某一个具体的人只需要信任整个代码规则即可

2、项目方的”Admin Key”管理，是DeFi协议的最关键的安全防线，在 Uniswap 或 Aave 这样的协议，通常有一些特权操作，比如“升级合约代码”、“修改手续费率”或者“紧急暂停协议”，多签解决方案：协议的 Owner 被设置为一个多签钱包合约地址任何对协议参数的修改，本质上都是一次 submitTransaction（提交提案）必须由项目方的多位核心开发者、甚至外部的安全审计机构共同签名（Confirm），修改才能生效（Execute）。

以下是这个函数的构造：定义状态变量owners(合伙人)，isOwner(映射合伙人状态)，numConfirmationsRequired（最小验证需求数量），Transaction（结构体储存对应数据信息（to,value,data,execute,numConfirmtions））,isConfirmed(映射，几号=>合伙人=>验证状态),transactions(存储结构体信息)，里面主要有四个主函数submitTransaction（（提议）把这一笔待处理的交易详情，永久地记录在区块链的“账本”上），

confirmTransaction（认证），executeTransaction（通过认证执行），revokeConfirmation（回撤），同时他们的函数加上了modifier修饰符，为了给函数加入控制权限。而在目前Gnosis Safe 就是一套“完全免费签字、最后一次性打包寄出的企业级银行系统”。它在逻辑上把你代码中的多次链上交互（Confirm）变成了链下无Gas签名，只有最后一步执行时才上链付费，极大地节省了成本；同时它采用了“模具+克隆”（代理模式）的安全架构，让你的资金由一套经过千亿资产验证的公共逻辑库守护，还能像手机装APP一样通过“模块（Modules）”随意扩展功能（比如设置每日限额或自动理财），因此它成为了 Web3 世界管理公款的最高标准。
<!-- DAILY_CHECKIN_2026-01-13_END -->

# 2026-01-12
<!-- DAILY_CHECKIN_2026-01-12_START -->



基础知识梳理：

以太坊：以太坊是一个去中心化的区块链网络，也是个软件开发平台，用以太币（ETH）作为燃料。它支持成千上万的加密货币，还有各种应用，比如去中心化金融（DeFi）、非同质化代币（NFT）、游戏、社交媒体和稳定币。以太坊是开源的，由Vitalik Buterin和几个联合创始人在2015年7月推出。核心想法是通过智能合约这种开源程序，让任何人创建数字资产和全球24/7运行的去中心化应用（dApp）

以太坊的核心概念：

区块链：由区块和链构成公共去中心化链，其特性为：不可篡改；公开透明；快速交易的特性。

智能合约：开源程序，就是一段代码，部署完成后具有不可篡改的特性，在之前需要严格审查安全问题

ETH： ETH 就是这台计算机的gas 你想在这台计算机上做任何事（比如转账、运行上面的智能合约、发个 NFT），都需要消耗计算资源，而 ETH 就是你付给验证者的小费。当然，它本身也是钱，可以用来储值。gas=Base Fee+Tip

去中心化：没中央控制，也没人能随意修改你的数据，抗审查、安全可靠。

pow和pos之间的区别：

|   | PoW (工作量证明) | PoS (权益证明) |
| 运作机制 | 算力竞赛谁的电脑算得快，谁就有权记账。 | 随机抽签谁质押的钱(ETH)多，被选中记账的概率就大。 |
| 记账人 | 矿工 | 验证者 |
| 门槛 (Sybil Resistance) | 硬件 + 电力需要购买显卡/矿机，消耗巨额电费。 | 32 ETH需要将 ETH 锁定在智能合约中。 |
| 奖机制 | 只有奖励，很难惩罚矿工干坏事只能拒绝其区块，无法没收他的矿机。 | 奖励 + 罚没验证者作恶（如双重签名），质押的 ETH 会被直接销毁。 |
| 能源消耗 | 极高相当于一个中等国家的耗电量。 | 极低减少了 99.95%，只需普通服务器即可运行。 |
| 抗攻击门槛 | 51% 算力攻击需要拥有全网一半以上的计算能力。 | 51% 资金攻击需要控制全网一半以上的质押 ETH（数千亿美元）。 |
| 经济模型 | 通胀必须大量印钱给矿工付电费，抛压大。 | 通缩印钱少 + 燃烧机制 (EIP-1559)。 |
| 确定性 | 概率性需要等十个区块确认才算安全。 | 确定性经过两个 Epoch (约12.8分钟) 后，交易绝对不可逆。 |

以太坊网络（抗审查，高度安全，持久而可靠）L1和L2的区别：

|   | Layer 1 (L1) | Layer 2 (L2) | Layer 3 （拓展） |
| 层级定义 | 结算层 (Settlement) | 通用扩容层 (Scaling) | 应用定制层 (Application) |
| 代表项目 | Ethereum Mainnet | Arbitrum One, Optimism, Base | Arbitrum Orbit, OP Stack L3, Xai |
| 核心职责 | 最终裁决与安全保证账本不可篡改，提供去中心化信任。 | 通用计算与压缩处理绝大多数交易，打包压缩后发给 L1。 | 极致定制与体验为特定APP（如链游、高频DeFi）设计的专用链。 |
| 通俗类比 | 中央银行 / 最高法院 | 商业银行 / 地方法院 | 支付宝 / 专属会员俱乐部 |
| Gas 费用 | 极贵 ($5 - $50) | 便宜 ($0.01 - $0.1) | 几近于零 (甚至可由项目方代付) |
| 速度 (TPS) | 极慢 (15 TPS) | 快 (2,000+ TPS) | 极速 (10,000+ TPS, 瞬间确认) |
| 安全性来源 | 依靠全球几十万个验证节点 (PoS)。 | 继承 L1 的安全性 (数据最终在 L1)。 | 继承 L2 的安全性 (数据最终在 L2)。 |

钱包：我们使用MetaMask创建了一个新的钱包，生成了一个由12个单词组成的助记词。这个助记词最重要，请勿泄露！MetaMask 使用助记词默认生成了一个钱包。一个助记词创建可以无限个钱包，每个钱包将包含一个钱包地址（公钥）和一个私钥。钱包地址可以是公开的，但是私钥是可以不公开的，永远用 [etherscan.io](http://etherscan.io) 双重确认交易，别只信MetaMask界面。

根据椭圆曲线的知识简单了解了一下私钥的形成：

![a932fdfe3de80da9df02f1e08d6cb0e.jpg](https://raw.githubusercontent.com/IntensiveCoLearning/Web3_Internship_Bootcamp_2026_Winter/main/assets/dadwawd1-ops/images/2026-01-12-1768209705329-a932fdfe3de80da9df02f1e08d6cb0e.jpg)

对于安全预防（目前早上答题情况总结出来的钓鱼信息）：

网络钓鱼的迹象包括：域名，预填收款人的地址，合约地址，UI差异，使用 DeFi 应用时，务必核实域名、合约地址和收款人地址。任何一个错误都可能导致资金的不可挽回损失。

Uniswap V3 多重调用钓鱼攻击原理：攻击者利用合法的 Uniswap V3 Multicall 合约创建交易。它们使用聚合函数将多个调用捆绑在一起。这包括授权呼叫（使用您的签名）和转接呼叫。捆绑交易允许他们在一次交易中完成代币的授权和转移。

书签攻击的工作原理：书签攻击是指诱骗用户将恶意 JavaScript 代码添加到浏览器书签中。当用户在 Discord 上点击这些书签时，这些书签会执行有害代码，窃取敏感信息或控制用户帐户。

预防：务必仔细核实签名请求，尤其是对于捆绑交易。要警惕类似 aggregate 或 multicall 这样的函数，它们可能隐藏恶意操作。检查实际执行的调用数据，而不仅仅是合约地址。使用具备高级交易模拟功能的钱包。分散资产，规划钱包用途。就像你的银行卡一样，禁止账户减少操作，只作存储和转账不操作和使用。日常高频使用账户只放少量资产。在刷空投或者参与新项目时，最好咨询有经验的朋友或者查看合约代码等以确保没有问题再进行操作。

今日solidity学习：今天学习了ERC20代币标准，ERC-20本质： 它不是代码，它是一份像是接口规范文档。它规定了一个代币合约必须拥有哪几个函数（比如查余额、转账），名字必须一模一样。在代码中我们可以发现有两个文件一个是IERC20用于接口的文件（IERC20主要用于定标准），里面包含着balance(address)(查看余额)，totalSupply()(总币)，transfer(to, amount)(转账)，transferFrom(from, to, amount)(DeFi的核心思想，操作别人的钱给你)，approve(spender, amount)(用于授权，准许别人动用多少钱)，allowance(owner,spender)(检查授权余额)这六重要函数，ERC20来实现代码逻辑，发新币。定义接口是为了方便调用和gas优化，并且同时理解了在IERC20中和ERC20中external和public的区别和用法：在ERC20标准中，接口（IERC20）定义为 external 是确立了“外部必须能调用”的最小范围，而实现（ERC20）改为 public 是为了赋予合约内部复用及子合约重写的灵活性（例如在 transfer 中嵌入额外逻辑）；相比之下，external 强制直接从 calldata 读取数据，避免了复制到内存的开销，因此在处理复杂参数时更省 Gas，且能清晰表达“仅限外部入口”的语义。一句话原则：如果函数需要被内部或其他合约继承调用，必须用 public；如果仅作为外部入口（如 mint/burn），首选 external 以明确意图并优化性能。顺便补充一下internal和private的区别，两者都是不可以被外部合约调用，前者可以被继承调用后者不可以，private 只有在你非常确定不希望子合约修改、访问或破坏这段逻辑时才使用。它更多是一种安全防护或避免命名冲突的手段。
<!-- DAILY_CHECKIN_2026-01-12_END -->
<!-- Content_END -->
